<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › ixgbe › ixgbe_common.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>ixgbe_common.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel 10 Gigabit PCI Express Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>

<span class="cp">#include &quot;ixgbe.h&quot;</span>
<span class="cp">#include &quot;ixgbe_common.h&quot;</span>
<span class="cp">#include &quot;ixgbe_phy.h&quot;</span>

<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_acquire_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_get_eeprom_semaphore</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgbe_release_eeprom_semaphore</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_ready_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgbe_standby_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgbe_shift_out_eeprom_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">,</span>
                                        <span class="n">u16</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">ixgbe_shift_in_eeprom_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgbe_raise_eeprom_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eec</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgbe_lower_eeprom_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eec</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgbe_release_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_mta_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mc_addr</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_poll_eerd_eewr_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ee_reg</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_read_eeprom_buffer_bit_bang</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
					     <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_write_eeprom_buffer_bit_bang</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
					     <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_detect_eeprom_page_size_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
						 <span class="n">u16</span> <span class="n">offset</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_disable_pcie_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_device_supports_autoneg_fc - Check if phy supports autoneg flow</span>
<span class="cm"> *  control</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  There are several phys that do not support autoneg flow control. This</span>
<span class="cm"> *  function check the device id to see if the associated phy supports</span>
<span class="cm"> *  autoneg flow control.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_device_supports_autoneg_fc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_X540T</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_T3_LOM</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_FC_NOT_SUPPORTED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_setup_fc - Set up flow control</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Called at init time to set up flow control.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_setup_fc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reg_bp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reg_cu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate the requested mode.  Strict IEEE mode does not allow</span>
<span class="cm">	 * ixgbe_fc_rx_pause because it will cause us to fail at UNH.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">strict_ieee</span> <span class="o">&amp;&amp;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">requested_mode</span> <span class="o">==</span> <span class="n">ixgbe_fc_rx_pause</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;ixgbe_fc_rx_pause not valid in strict IEEE mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_INVALID_LINK_SETTINGS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * 10gig parts do not have a word in the EEPROM to determine the</span>
<span class="cm">	 * default flow control setting, so we explicitly set it to full.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">requested_mode</span> <span class="o">==</span> <span class="n">ixgbe_fc_default</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">requested_mode</span> <span class="o">=</span> <span class="n">ixgbe_fc_full</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the 1G and 10G flow control advertisement registers so the</span>
<span class="cm">	 * HW will be able to do fc autoneg once the cable is plugged in.  If</span>
<span class="cm">	 * we link at 10G, the 1G advertisement is harmless and vice versa.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_media_type_fiber</span>:
	<span class="k">case</span> <span class="n">ixgbe_media_type_backplane</span>:
		<span class="n">reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PCS1GANA</span><span class="p">);</span>
		<span class="n">reg_bp</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_media_type_copper</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MDIO_AN_ADVERTISE</span><span class="p">,</span>
					<span class="n">MDIO_MMD_AN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_cu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The possible values of fc.requested_mode are:</span>
<span class="cm">	 * 0: Flow control is completely disabled</span>
<span class="cm">	 * 1: Rx flow control is enabled (we can receive pause frames,</span>
<span class="cm">	 *    but not send pause frames).</span>
<span class="cm">	 * 2: Tx flow control is enabled (we can send pause frames but</span>
<span class="cm">	 *    we do not support receiving pause frames).</span>
<span class="cm">	 * 3: Both Rx and Tx flow control (symmetric) are enabled.</span>
<span class="cm">	 * other: Invalid.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">requested_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_fc_none</span>:
		<span class="cm">/* Flow control completely disabled by software override. */</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_PCS1GANA_SYM_PAUSE</span> <span class="o">|</span> <span class="n">IXGBE_PCS1GANA_ASM_PAUSE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">ixgbe_media_type_backplane</span><span class="p">)</span>
			<span class="n">reg_bp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_AUTOC_SYM_PAUSE</span> <span class="o">|</span>
				    <span class="n">IXGBE_AUTOC_ASM_PAUSE</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">ixgbe_media_type_copper</span><span class="p">)</span>
			<span class="n">reg_cu</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_TAF_SYM_PAUSE</span> <span class="o">|</span> <span class="n">IXGBE_TAF_ASM_PAUSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_fc_tx_pause</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Tx Flow control is enabled, and Rx Flow control is</span>
<span class="cm">		 * disabled by software override.</span>
<span class="cm">		 */</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">IXGBE_PCS1GANA_ASM_PAUSE</span><span class="p">;</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_PCS1GANA_SYM_PAUSE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">ixgbe_media_type_backplane</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reg_bp</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_ASM_PAUSE</span><span class="p">;</span>
			<span class="n">reg_bp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_AUTOC_SYM_PAUSE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">ixgbe_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reg_cu</span> <span class="o">|=</span> <span class="n">IXGBE_TAF_ASM_PAUSE</span><span class="p">;</span>
			<span class="n">reg_cu</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_TAF_SYM_PAUSE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_fc_rx_pause</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Rx Flow control is enabled and Tx Flow control is</span>
<span class="cm">		 * disabled by software override. Since there really</span>
<span class="cm">		 * isn&#39;t a way to advertise that we are capable of RX</span>
<span class="cm">		 * Pause ONLY, we will advertise that we support both</span>
<span class="cm">		 * symmetric and asymmetric Rx PAUSE, as such we fall</span>
<span class="cm">		 * through to the fc_full statement.  Later, we will</span>
<span class="cm">		 * disable the adapter&#39;s ability to send PAUSE frames.</span>
<span class="cm">		 */</span>
	<span class="k">case</span> <span class="n">ixgbe_fc_full</span>:
		<span class="cm">/* Flow control (both Rx and Tx) is enabled by SW override. */</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">IXGBE_PCS1GANA_SYM_PAUSE</span> <span class="o">|</span> <span class="n">IXGBE_PCS1GANA_ASM_PAUSE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">ixgbe_media_type_backplane</span><span class="p">)</span>
			<span class="n">reg_bp</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_SYM_PAUSE</span> <span class="o">|</span>
				  <span class="n">IXGBE_AUTOC_ASM_PAUSE</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">ixgbe_media_type_copper</span><span class="p">)</span>
			<span class="n">reg_cu</span> <span class="o">|=</span> <span class="n">IXGBE_TAF_SYM_PAUSE</span> <span class="o">|</span> <span class="n">IXGBE_TAF_ASM_PAUSE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Flow control param set incorrectly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_CONFIG</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ixgbe_mac_X540</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Enable auto-negotiation between the MAC &amp; PHY;</span>
<span class="cm">		 * the MAC will advertise clause 37 flow control.</span>
<span class="cm">		 */</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PCS1GANA</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PCS1GLCTL</span><span class="p">);</span>

		<span class="cm">/* Disable AN timeout */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">strict_ieee</span><span class="p">)</span>
			<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_PCS1GLCTL_AN_1G_TIMEOUT_EN</span><span class="p">;</span>

		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PCS1GLCTL</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Set up FC; PCS1GLCTL = 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * AUTOC restart handles negotiation of 1G and 10G on backplane</span>
<span class="cm">	 * and copper. There is no need to set the PCS1GCTL register.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">ixgbe_media_type_backplane</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_bp</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_AN_RESTART</span><span class="p">;</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">,</span> <span class="n">reg_bp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">ixgbe_media_type_copper</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ixgbe_device_supports_autoneg_fc</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MDIO_AN_ADVERTISE</span><span class="p">,</span>
				      <span class="n">MDIO_MMD_AN</span><span class="p">,</span> <span class="n">reg_cu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Set up FC; IXGBE_AUTOC = 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_start_hw_generic - Prepare hardware for Tx/Rx</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Starts the hardware by filling the bus info structure and media type, clears</span>
<span class="cm"> *  all on chip counters, initializes receive address registers, multicast</span>
<span class="cm"> *  table, VLAN filter table, calls routine to set up link and flow control</span>
<span class="cm"> *  settings, and leaves transmit and receive units disabled and uninitialized</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_start_hw_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">;</span>

	<span class="cm">/* Set the media type */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_media_type</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Identify the PHY */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">identify</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Clear the VLAN filter table */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">clear_vfta</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Clear statistics registers */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">clear_hw_cntrs</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Set No Snoop Disable */</span>
	<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CTRL_EXT</span><span class="p">);</span>
	<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">IXGBE_CTRL_EXT_NS_DIS</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Setup flow control */</span>
	<span class="n">ixgbe_setup_fc</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Clear adapter stopped flag */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">adapter_stopped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_start_hw_gen2 - Init sequence for common device family</span>
<span class="cm"> *  @hw: pointer to hw structure</span>
<span class="cm"> *</span>
<span class="cm"> * Performs the init sequence common to the second generation</span>
<span class="cm"> * of 10 GbE devices.</span>
<span class="cm"> * Devices in the second generation:</span>
<span class="cm"> *     82599</span>
<span class="cm"> *     X540</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_start_hw_gen2</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">regval</span><span class="p">;</span>

	<span class="cm">/* Clear the rate limiters */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">max_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RTTDQSEL</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RTTBCNRC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Disable relaxed ordering */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">max_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regval</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_DCA_TXCTRL_82599</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">regval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_DCA_TXCTRL_DESC_WRO_EN</span><span class="p">;</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_DCA_TXCTRL_82599</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">regval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">max_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regval</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_DCA_RXCTRL</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">regval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_DCA_RXCTRL_DATA_WRO_EN</span> <span class="o">|</span>
			    <span class="n">IXGBE_DCA_RXCTRL_HEAD_WRO_EN</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_DCA_RXCTRL</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">regval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_init_hw_generic - Generic hardware initialization</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Initialize the hardware by resetting the hardware, filling the bus info</span>
<span class="cm"> *  structure and media type, clears all on chip counters, initializes receive</span>
<span class="cm"> *  address registers, multicast table, VLAN filter table, calls routine to set</span>
<span class="cm"> *  up link and flow control settings, and leaves transmit and receive units</span>
<span class="cm"> *  disabled and uninitialized</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_init_hw_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Reset the hardware */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">reset_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Start the HW */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">start_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_clear_hw_cntrs_generic - Generic clear hardware counters</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Clears all hardware statistics counters by reading them from the hardware</span>
<span class="cm"> *  Statistics counters are clear on read.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_clear_hw_cntrs_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CRCERRS</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ILLERRC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ERRBC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MSPDC</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MLFC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MRFC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RLEC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LXONTXC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LXOFFTXC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">ixgbe_mac_82599EB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LXONRXCNT</span><span class="p">);</span>
		<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LXOFFRXCNT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LXONRXC</span><span class="p">);</span>
		<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LXOFFRXC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PXONTXC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PXOFFTXC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">ixgbe_mac_82599EB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PXONRXCNT</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PXOFFRXCNT</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PXONRXC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PXOFFRXC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">ixgbe_mac_82599EB</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PXON2OFFCNT</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PRC64</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PRC127</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PRC255</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PRC511</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PRC1023</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PRC1522</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GPRC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_BPRC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPRC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GPTC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GORCL</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GORCH</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GOTCL</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GOTCH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_mac_82598EB</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RNBC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RUC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RFC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ROC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RJC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MNGPRC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MNGPDC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MNGPTC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TORL</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TORH</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TPR</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TPT</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PTC64</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PTC127</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PTC255</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PTC511</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PTC1023</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PTC1522</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPTC</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_BPTC</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_QPRC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_QPTC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">ixgbe_mac_82599EB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_QBRC_L</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_QBRC_H</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_QBTC_L</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_QBTC_H</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_QPRDC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_QBRC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_QBTC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_mac_X540</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">identify</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PCRC8ECL</span><span class="p">,</span> <span class="n">MDIO_MMD_PCS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PCRC8ECH</span><span class="p">,</span> <span class="n">MDIO_MMD_PCS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LDPCECL</span><span class="p">,</span> <span class="n">MDIO_MMD_PCS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LDPCECH</span><span class="p">,</span> <span class="n">MDIO_MMD_PCS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_read_pba_string_generic - Reads part number string from EEPROM</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @pba_num: stores the part number string from the EEPROM</span>
<span class="cm"> *  @pba_num_size: part number string buffer length</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the part number string from the EEPROM.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_read_pba_string_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">pba_num</span><span class="p">,</span>
                                  <span class="n">u32</span> <span class="n">pba_num_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pba_ptr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pba_num</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;PBA string buffer was null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_INVALID_ARGUMENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PBANUM0_PTR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;NVM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PBANUM1_PTR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pba_ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;NVM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if data is not ptr guard the PBA must be in legacy format which</span>
<span class="cm">	 * means pba_ptr is actually our second data word for the PBA number</span>
<span class="cm">	 * and we can decode it into an ascii string</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="n">IXGBE_PBANUM_PTR_GUARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;NVM PBA number is not stored as string</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* we will need 11 characters to store the PBA */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pba_num_size</span> <span class="o">&lt;</span> <span class="mi">11</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;PBA string buffer too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IXGBE_ERR_NO_SPACE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* extract hex string from data and pba_ptr */</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pba_ptr</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pba_ptr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pba_ptr</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">pba_ptr</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>

		<span class="cm">/* put a null character on the end of our string */</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

		<span class="cm">/* switch all the data but the &#39;-&#39; to hex char */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mh">0xA</span><span class="p">)</span>
				<span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">+=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">)</span>
				<span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">+=</span> <span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="mh">0xA</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">pba_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;NVM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mh">0xFFFF</span> <span class="o">||</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;NVM PBA number section invalid length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_PBA_SECTION</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check if pba_num buffer is big enough */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pba_num_size</span>  <span class="o">&lt;</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">length</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;PBA string buffer too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_NO_SPACE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* trim pba length from start of string */</span>
	<span class="n">pba_ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">length</span><span class="o">--</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">pba_ptr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;NVM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">pba_num</span><span class="p">[(</span><span class="n">offset</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_mac_addr_generic - Generic get MAC address</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @mac_addr: Adapter MAC address</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the adapter&#39;s MAC address from first Receive Address Register (RAR0)</span>
<span class="cm"> *  A reset of the adapter must be performed prior to calling this function</span>
<span class="cm"> *  in order for the MAC address to have been loaded from the EEPROM into RAR0</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_get_mac_addr_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rar_high</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rar_low</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rar_high</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RAH</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">rar_low</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RAL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">rar_low</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">rar_high</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_bus_info_generic - Generic set PCI bus info</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Sets the PCI bus info (speed, width, type) within the ixgbe_hw structure</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_get_bus_info_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ixgbe_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">link_status</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ixgbe_bus_type_pci_express</span><span class="p">;</span>

	<span class="cm">/* Get the negotiated link width and speed from PCI config space */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IXGBE_PCI_LINK_STATUS</span><span class="p">,</span>
	                     <span class="o">&amp;</span><span class="n">link_status</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">link_status</span> <span class="o">&amp;</span> <span class="n">IXGBE_PCI_LINK_WIDTH</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IXGBE_PCI_LINK_WIDTH_1</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">ixgbe_bus_width_pcie_x1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_PCI_LINK_WIDTH_2</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">ixgbe_bus_width_pcie_x2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_PCI_LINK_WIDTH_4</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">ixgbe_bus_width_pcie_x4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_PCI_LINK_WIDTH_8</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">ixgbe_bus_width_pcie_x8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">ixgbe_bus_width_unknown</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">link_status</span> <span class="o">&amp;</span> <span class="n">IXGBE_PCI_LINK_SPEED</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IXGBE_PCI_LINK_SPEED_2500</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">ixgbe_bus_speed_2500</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_PCI_LINK_SPEED_5000</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">ixgbe_bus_speed_5000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">ixgbe_bus_speed_unknown</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">set_lan_id</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_set_lan_id_multi_port_pcie - Set LAN id for PCIe multiple port devices</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Determines the LAN function id by reading memory-mapped registers</span>
<span class="cm"> *  and swaps the port value if requested.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">ixgbe_set_lan_id_multi_port_pcie</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_bus_info</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_STATUS</span><span class="p">);</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_STATUS_LAN_ID</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">IXGBE_STATUS_LAN_ID_SHIFT</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">lan_id</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>

	<span class="cm">/* check for a port swap */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FACTPS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_FACTPS_LFS</span><span class="p">)</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">^=</span> <span class="mh">0x1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_stop_adapter_generic - Generic stop Tx/Rx units</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Sets the adapter_stopped flag within ixgbe_hw struct. Clears interrupts,</span>
<span class="cm"> *  disables transmit and receive units. The adapter_stopped flag is used by</span>
<span class="cm"> *  the shared code and drivers to determine if the adapter is in a stopped</span>
<span class="cm"> *  state and should not touch the hardware.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_stop_adapter_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the adapter_stopped flag so other driver functions stop touching</span>
<span class="cm">	 * the hardware</span>
<span class="cm">	 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">adapter_stopped</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Disable the receive unit */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXCTRL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Clear interrupt mask to stop interrupts from being generated */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EIMC</span><span class="p">,</span> <span class="n">IXGBE_IRQ_CLEAR_MASK</span><span class="p">);</span>

	<span class="cm">/* Clear any pending interrupts, flush previous writes */</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EICR</span><span class="p">);</span>

	<span class="cm">/* Disable the transmit unit.  Each queue must be disabled. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">max_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TXDCTL</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">IXGBE_TXDCTL_SWFLSH</span><span class="p">);</span>

	<span class="cm">/* Disable the receive unit by stopping each queue */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">max_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_val</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXDCTL</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">reg_val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_RXDCTL_ENABLE</span><span class="p">;</span>
		<span class="n">reg_val</span> <span class="o">|=</span> <span class="n">IXGBE_RXDCTL_SWFLSH</span><span class="p">;</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXDCTL</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">reg_val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* flush all queues disables */</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent the PCI-E bus from from hanging by disabling PCI-E master</span>
<span class="cm">	 * access and verify no pending requests</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ixgbe_disable_pcie_master</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_led_on_generic - Turns on the software controllable LEDs.</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @index: led number to turn on</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_led_on_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">led_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LEDCTL</span><span class="p">);</span>

	<span class="cm">/* To turn on the LED, set mode to ON. */</span>
	<span class="n">led_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_LED_MODE_MASK</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">led_reg</span> <span class="o">|=</span> <span class="n">IXGBE_LED_ON</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_LED_MODE_SHIFT</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LEDCTL</span><span class="p">,</span> <span class="n">led_reg</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_led_off_generic - Turns off the software controllable LEDs.</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @index: led number to turn off</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_led_off_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">led_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LEDCTL</span><span class="p">);</span>

	<span class="cm">/* To turn off the LED, set mode to OFF. */</span>
	<span class="n">led_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_LED_MODE_MASK</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">led_reg</span> <span class="o">|=</span> <span class="n">IXGBE_LED_OFF</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_LED_MODE_SHIFT</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LEDCTL</span><span class="p">,</span> <span class="n">led_reg</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_init_eeprom_params_generic - Initialize EEPROM params</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Initializes the EEPROM parameters ixgbe_eeprom_info within the</span>
<span class="cm"> *  ixgbe_hw struct in order to set up EEPROM access.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_init_eeprom_params_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_eeprom_info</span> <span class="o">*</span><span class="n">eeprom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eec</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_eeprom_uninitialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ixgbe_eeprom_none</span><span class="p">;</span>
		<span class="cm">/* Set default semaphore delay to 10ms which is a well</span>
<span class="cm">		 * tested value */</span>
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">semaphore_delay</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* Clear EEPROM page size, it will be initialized as needed */</span>
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_page_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check for EEPROM present first.</span>
<span class="cm">		 * If not present leave as none</span>
<span class="cm">		 */</span>
		<span class="n">eec</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eec</span> <span class="o">&amp;</span> <span class="n">IXGBE_EEC_PRES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ixgbe_eeprom_spi</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * SPI EEPROM is assumed here.  This code would need to</span>
<span class="cm">			 * change if a future EEPROM is not SPI.</span>
<span class="cm">			 */</span>
			<span class="n">eeprom_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">eec</span> <span class="o">&amp;</span> <span class="n">IXGBE_EEC_SIZE</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
					    <span class="n">IXGBE_EEC_SIZE_SHIFT</span><span class="p">);</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">eeprom_size</span> <span class="o">+</span>
						  <span class="n">IXGBE_EEPROM_WORD_SIZE_SHIFT</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">eec</span> <span class="o">&amp;</span> <span class="n">IXGBE_EEC_ADDR_SIZE</span><span class="p">)</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Eeprom params: type = %d, size = %d, address bits: &quot;</span>
			  <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">,</span>
			  <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_write_eeprom_buffer_bit_bang_generic - Write EEPROM using bit-bang</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset within the EEPROM to write</span>
<span class="cm"> *  @words: number of words</span>
<span class="cm"> *  @data: 16 bit word(s) to write to EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads 16 bit word(s) from EEPROM through bit-bang method</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_write_eeprom_buffer_bit_bang_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
					       <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_params</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">words</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_INVALID_ARGUMENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">words</span> <span class="o">&gt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The EEPROM page size cannot be queried from the chip. We do lazy</span>
<span class="cm">	 * initialization. It is worth to do that when we write large buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_page_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">words</span> <span class="o">&gt;</span> <span class="n">IXGBE_EEPROM_PAGE_SIZE_MAX</span><span class="p">))</span>
		<span class="n">ixgbe_detect_eeprom_page_size_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We cannot hold synchronization semaphores for too long</span>
<span class="cm">	 * to avoid other entity starvation. However it is more efficient</span>
<span class="cm">	 * to read in bursts than synchronizing access for each word.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">IXGBE_EEPROM_RD_BUFFER_MAX_COUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">words</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">IXGBE_EEPROM_RD_BUFFER_MAX_COUNT</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span>
			 <span class="n">IXGBE_EEPROM_RD_BUFFER_MAX_COUNT</span> <span class="o">:</span> <span class="p">(</span><span class="n">words</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_write_eeprom_buffer_bit_bang</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
							    <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_write_eeprom_buffer_bit_bang - Writes 16 bit word(s) to EEPROM</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset within the EEPROM to be written to</span>
<span class="cm"> *  @words: number of word(s)</span>
<span class="cm"> *  @data: 16 bit word(s) to be written to the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  If ixgbe_eeprom_update_checksum is not called after this function, the</span>
<span class="cm"> *  EEPROM will most likely contain an invalid checksum.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_write_eeprom_buffer_bit_bang</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
					      <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">word</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">page_size</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">write_opcode</span> <span class="o">=</span> <span class="n">IXGBE_EEPROM_WRITE_OPCODE_SPI</span><span class="p">;</span>

	<span class="cm">/* Prepare the EEPROM for writing  */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_acquire_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_ready_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ixgbe_release_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ixgbe_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

			<span class="cm">/*  Send the WRITE ENABLE command (8 bit opcode )  */</span>
			<span class="n">ixgbe_shift_out_eeprom_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						  <span class="n">IXGBE_EEPROM_WREN_OPCODE_SPI</span><span class="p">,</span>
						  <span class="n">IXGBE_EEPROM_OPCODE_BITS</span><span class="p">);</span>

			<span class="n">ixgbe_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Some SPI eeproms use the 8th address bit embedded</span>
<span class="cm">			 * in the opcode</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">address_bits</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">))</span>
				<span class="n">write_opcode</span> <span class="o">|=</span> <span class="n">IXGBE_EEPROM_A8_OPCODE_SPI</span><span class="p">;</span>

			<span class="cm">/* Send the Write command (8-bit opcode + addr) */</span>
			<span class="n">ixgbe_shift_out_eeprom_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">write_opcode</span><span class="p">,</span>
						    <span class="n">IXGBE_EEPROM_OPCODE_BITS</span><span class="p">);</span>
			<span class="n">ixgbe_shift_out_eeprom_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
						    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">address_bits</span><span class="p">);</span>

			<span class="n">page_size</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_page_size</span><span class="p">;</span>

			<span class="cm">/* Send the data in burst via SPI*/</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">word</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
				<span class="n">ixgbe_shift_out_eeprom_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">page_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="cm">/* do not wrap around page */</span>
				<span class="k">if</span> <span class="p">(((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">page_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span>
				    <span class="p">(</span><span class="n">page_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">);</span>

			<span class="n">ixgbe_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">usleep_range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Done with writing - release the EEPROM */</span>
		<span class="n">ixgbe_release_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_write_eeprom_generic - Writes 16 bit value to EEPROM</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset within the EEPROM to be written to</span>
<span class="cm"> *  @data: 16 bit word to be written to the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  If ixgbe_eeprom_update_checksum is not called after this function, the</span>
<span class="cm"> *  EEPROM will most likely contain an invalid checksum.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_write_eeprom_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_params</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_write_eeprom_buffer_bit_bang</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_read_eeprom_buffer_bit_bang_generic - Read EEPROM using bit-bang</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset within the EEPROM to be read</span>
<span class="cm"> *  @words: number of word(s)</span>
<span class="cm"> *  @data: read 16 bit words(s) from EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads 16 bit word(s) from EEPROM through bit-bang method</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_read_eeprom_buffer_bit_bang_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
					      <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_params</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">words</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_INVALID_ARGUMENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">words</span> <span class="o">&gt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We cannot hold synchronization semaphores for too long</span>
<span class="cm">	 * to avoid other entity starvation. However it is more efficient</span>
<span class="cm">	 * to read in bursts than synchronizing access for each word.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">IXGBE_EEPROM_RD_BUFFER_MAX_COUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">words</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">IXGBE_EEPROM_RD_BUFFER_MAX_COUNT</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span>
			 <span class="n">IXGBE_EEPROM_RD_BUFFER_MAX_COUNT</span> <span class="o">:</span> <span class="p">(</span><span class="n">words</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_read_eeprom_buffer_bit_bang</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
							   <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_read_eeprom_buffer_bit_bang - Read EEPROM using bit-bang</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset within the EEPROM to be read</span>
<span class="cm"> *  @words: number of word(s)</span>
<span class="cm"> *  @data: read 16 bit word(s) from EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads 16 bit word(s) from EEPROM through bit-bang method</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_read_eeprom_buffer_bit_bang</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
					     <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">word_in</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">read_opcode</span> <span class="o">=</span> <span class="n">IXGBE_EEPROM_READ_OPCODE_SPI</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Prepare the EEPROM for reading  */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_acquire_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_ready_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ixgbe_release_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ixgbe_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Some SPI eeproms use the 8th address bit embedded</span>
<span class="cm">			 * in the opcode</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">address_bits</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">))</span>
				<span class="n">read_opcode</span> <span class="o">|=</span> <span class="n">IXGBE_EEPROM_A8_OPCODE_SPI</span><span class="p">;</span>

			<span class="cm">/* Send the READ command (opcode + addr) */</span>
			<span class="n">ixgbe_shift_out_eeprom_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">read_opcode</span><span class="p">,</span>
						    <span class="n">IXGBE_EEPROM_OPCODE_BITS</span><span class="p">);</span>
			<span class="n">ixgbe_shift_out_eeprom_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
						    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">address_bits</span><span class="p">);</span>

			<span class="cm">/* Read the data. */</span>
			<span class="n">word_in</span> <span class="o">=</span> <span class="n">ixgbe_shift_in_eeprom_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">word_in</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">word_in</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* End this read operation */</span>
		<span class="n">ixgbe_release_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_read_eeprom_bit_bang_generic - Read EEPROM word using bit-bang</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset within the EEPROM to be read</span>
<span class="cm"> *  @data: read 16 bit value from EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads 16 bit value from EEPROM through bit-bang method</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_read_eeprom_bit_bang_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
				       <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_params</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_read_eeprom_buffer_bit_bang</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_read_eerd_buffer_generic - Read EEPROM word(s) using EERD</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset of word in the EEPROM to read</span>
<span class="cm"> *  @words: number of word(s)</span>
<span class="cm"> *  @data: 16 bit word(s) from the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads a 16 bit word(s) from the EEPROM using the EERD register.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_read_eerd_buffer_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
				   <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eerd</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_params</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">words</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_INVALID_ARGUMENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eerd</span> <span class="o">=</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_EEPROM_RW_ADDR_SHIFT</span><span class="p">)</span> <span class="o">+</span>
		       <span class="n">IXGBE_EEPROM_RW_REG_START</span><span class="p">;</span>

		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EERD</span><span class="p">,</span> <span class="n">eerd</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_poll_eerd_eewr_done</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_NVM_POLL_READ</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EERD</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				   <span class="n">IXGBE_EEPROM_RW_REG_DATA</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Eeprom read timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_detect_eeprom_page_size_generic - Detect EEPROM page size</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset within the EEPROM to be used as a scratch pad</span>
<span class="cm"> *</span>
<span class="cm"> *  Discover EEPROM page size by writing marching data at given offset.</span>
<span class="cm"> *  This function is called only when we are writing a new large buffer</span>
<span class="cm"> *  at given offset so the data would be overwritten anyway.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_detect_eeprom_page_size_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
						 <span class="n">u16</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">[</span><span class="n">IXGBE_EEPROM_PAGE_SIZE_MAX</span><span class="p">];</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_EEPROM_PAGE_SIZE_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_page_size</span> <span class="o">=</span> <span class="n">IXGBE_EEPROM_PAGE_SIZE_MAX</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_write_eeprom_buffer_bit_bang</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					     <span class="n">IXGBE_EEPROM_PAGE_SIZE_MAX</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_page_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_read_eeprom_buffer_bit_bang</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When writing in burst more than the actual page size</span>
<span class="cm">	 * EEPROM address wraps around current page.</span>
<span class="cm">	 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_page_size</span> <span class="o">=</span> <span class="n">IXGBE_EEPROM_PAGE_SIZE_MAX</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Detected EEPROM page size = %d words.&quot;</span><span class="p">,</span>
	       <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_page_size</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_read_eerd_generic - Read EEPROM word using EERD</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset of  word in the EEPROM to read</span>
<span class="cm"> *  @data: word read from the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads a 16 bit word from the EEPROM using the EERD register.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_read_eerd_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ixgbe_read_eerd_buffer_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_write_eewr_buffer_generic - Write EEPROM word(s) using EEWR</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset of  word in the EEPROM to write</span>
<span class="cm"> *  @words: number of words</span>
<span class="cm"> *  @data: word(s) write to the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Write a 16 bit word(s) to the EEPROM using the EEWR register.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_write_eewr_buffer_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
				    <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eewr</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_params</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">words</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_INVALID_ARGUMENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">word_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eewr</span> <span class="o">=</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_EEPROM_RW_ADDR_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		       <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_EEPROM_RW_REG_DATA</span><span class="p">)</span> <span class="o">|</span>
		       <span class="n">IXGBE_EEPROM_RW_REG_START</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_poll_eerd_eewr_done</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_NVM_POLL_WRITE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Eeprom write EEWR timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEWR</span><span class="p">,</span> <span class="n">eewr</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_poll_eerd_eewr_done</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_NVM_POLL_WRITE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Eeprom write EEWR timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_write_eewr_generic - Write EEPROM word using EEWR</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset of  word in the EEPROM to write</span>
<span class="cm"> *  @data: word write to the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Write a 16 bit word to the EEPROM using the EEWR register.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_write_eewr_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ixgbe_write_eewr_buffer_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_poll_eerd_eewr_done - Poll EERD read or EEWR write status</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @ee_reg: EEPROM flag for polling</span>
<span class="cm"> *</span>
<span class="cm"> *  Polls the status bit (bit 1) of the EERD or EEWR to determine when the</span>
<span class="cm"> *  read or write is done respectively.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_poll_eerd_eewr_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ee_reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_EERD_EEWR_ATTEMPTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ee_reg</span> <span class="o">==</span> <span class="n">IXGBE_NVM_POLL_READ</span><span class="p">)</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EERD</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEWR</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_EEPROM_RW_REG_DONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_acquire_eeprom - Acquire EEPROM using bit-bang</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Prepares EEPROM for access using bit-bang method. This function should</span>
<span class="cm"> *  be called before issuing a command to the EEPROM.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_acquire_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire_swfw_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GSSR_EEP_SM</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_SWFW_SYNC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eec</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">);</span>

		<span class="cm">/* Request EEPROM Access */</span>
		<span class="n">eec</span> <span class="o">|=</span> <span class="n">IXGBE_EEC_REQ</span><span class="p">;</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">,</span> <span class="n">eec</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_EEPROM_GRANT_ATTEMPTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eec</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eec</span> <span class="o">&amp;</span> <span class="n">IXGBE_EEC_GNT</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Release if grant not acquired */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">eec</span> <span class="o">&amp;</span> <span class="n">IXGBE_EEC_GNT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">eec</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_EEC_REQ</span><span class="p">;</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">,</span> <span class="n">eec</span><span class="p">);</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Could not acquire EEPROM grant</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release_swfw_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GSSR_EEP_SM</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Setup EEPROM for Read/Write */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Clear CS and SK */</span>
			<span class="n">eec</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_EEC_CS</span> <span class="o">|</span> <span class="n">IXGBE_EEC_SK</span><span class="p">);</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">,</span> <span class="n">eec</span><span class="p">);</span>
			<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_eeprom_semaphore - Get hardware semaphore</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Sets the hardware semaphores so EEPROM access can occur for bit-bang method</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_get_eeprom_semaphore</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">swsm</span><span class="p">;</span>

	<span class="cm">/* Get SMBI software semaphore between device drivers first */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">timeout</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the SMBI bit is 0 when we read it, then the bit will be</span>
<span class="cm">		 * set and we have the semaphore</span>
<span class="cm">		 */</span>
		<span class="n">swsm</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SWSM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">swsm</span> <span class="o">&amp;</span> <span class="n">IXGBE_SWSM_SMBI</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Driver can&#39;t access the Eeprom - SMBI Semaphore &quot;</span>
		       <span class="s">&quot;not granted.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * this release is particularly important because our attempts</span>
<span class="cm">		 * above to get the semaphore may have succeeded, and if there</span>
<span class="cm">		 * was a timeout, we should unconditionally clear the semaphore</span>
<span class="cm">		 * bits to free the driver to make progress</span>
<span class="cm">		 */</span>
		<span class="n">ixgbe_release_eeprom_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * one last try</span>
<span class="cm">		 * If the SMBI bit is 0 when we read it, then the bit will be</span>
<span class="cm">		 * set and we have the semaphore</span>
<span class="cm">		 */</span>
		<span class="n">swsm</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SWSM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">swsm</span> <span class="o">&amp;</span> <span class="n">IXGBE_SWSM_SMBI</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now get the semaphore between SW/FW through the SWESMBI bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">timeout</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">swsm</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SWSM</span><span class="p">);</span>

			<span class="cm">/* Set the SW EEPROM semaphore bit to request access */</span>
			<span class="n">swsm</span> <span class="o">|=</span> <span class="n">IXGBE_SWSM_SWESMBI</span><span class="p">;</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SWSM</span><span class="p">,</span> <span class="n">swsm</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we set the bit successfully then we got the</span>
<span class="cm">			 * semaphore.</span>
<span class="cm">			 */</span>
			<span class="n">swsm</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SWSM</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">swsm</span> <span class="o">&amp;</span> <span class="n">IXGBE_SWSM_SWESMBI</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Release semaphores and return error if SW EEPROM semaphore</span>
<span class="cm">		 * was not granted because we don&#39;t have access to the EEPROM</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;SWESMBI Software EEPROM semaphore &quot;</span>
			       <span class="s">&quot;not granted.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ixgbe_release_eeprom_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Software semaphore SMBI between device drivers &quot;</span>
		       <span class="s">&quot;not granted.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_release_eeprom_semaphore - Release hardware semaphore</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  This function clears hardware semaphore bits.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_release_eeprom_semaphore</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">swsm</span><span class="p">;</span>

	<span class="n">swsm</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SWSM</span><span class="p">);</span>

	<span class="cm">/* Release both semaphores by writing 0 to the bits SWESMBI and SMBI */</span>
	<span class="n">swsm</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_SWSM_SWESMBI</span> <span class="o">|</span> <span class="n">IXGBE_SWSM_SMBI</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SWSM</span><span class="p">,</span> <span class="n">swsm</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_ready_eeprom - Polls for EEPROM ready</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_ready_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">spi_stat_reg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read &quot;Status Register&quot; repeatedly until the LSB is cleared.  The</span>
<span class="cm">	 * EEPROM will signal that the command has been completed by clearing</span>
<span class="cm">	 * bit 0 of the internal status register.  If it&#39;s not cleared within</span>
<span class="cm">	 * 5 milliseconds, then error out.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_EEPROM_MAX_RETRY_SPI</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ixgbe_shift_out_eeprom_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEPROM_RDSR_OPCODE_SPI</span><span class="p">,</span>
		                            <span class="n">IXGBE_EEPROM_OPCODE_BITS</span><span class="p">);</span>
		<span class="n">spi_stat_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">ixgbe_shift_in_eeprom_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spi_stat_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_EEPROM_STATUS_RDY_SPI</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">ixgbe_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * On some parts, SPI write time could vary from 0-20mSec on 3.3V</span>
<span class="cm">	 * devices (and only 0-5mSec on 5V devices)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">IXGBE_EEPROM_MAX_RETRY_SPI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;SPI EEPROM Status error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_standby_eeprom - Returns EEPROM to a &quot;standby&quot; state</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_standby_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eec</span><span class="p">;</span>

	<span class="n">eec</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">);</span>

	<span class="cm">/* Toggle CS to flush commands */</span>
	<span class="n">eec</span> <span class="o">|=</span> <span class="n">IXGBE_EEC_CS</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">,</span> <span class="n">eec</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">eec</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_EEC_CS</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">,</span> <span class="n">eec</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_shift_out_eeprom_bits - Shift data bits out to the EEPROM.</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @data: data to send to the EEPROM</span>
<span class="cm"> *  @count: number of bits to shift out</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_shift_out_eeprom_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">,</span>
                                        <span class="n">u16</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">eec</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mask is used to shift &quot;count&quot; bits of &quot;data&quot; out to the EEPROM</span>
<span class="cm">	 * one bit at a time.  Determine the starting bit based on count</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * A &quot;1&quot; is shifted out to the EEPROM by setting bit &quot;DI&quot; to a</span>
<span class="cm">		 * &quot;1&quot;, and then raising and then lowering the clock (the SK</span>
<span class="cm">		 * bit controls the clock input to the EEPROM).  A &quot;0&quot; is</span>
<span class="cm">		 * shifted out to the EEPROM by setting &quot;DI&quot; to &quot;0&quot; and then</span>
<span class="cm">		 * raising and then lowering the clock.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
			<span class="n">eec</span> <span class="o">|=</span> <span class="n">IXGBE_EEC_DI</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">eec</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_EEC_DI</span><span class="p">;</span>

		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">,</span> <span class="n">eec</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">ixgbe_raise_eeprom_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eec</span><span class="p">);</span>
		<span class="n">ixgbe_lower_eeprom_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eec</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Shift mask to signify next bit of data to shift in to the</span>
<span class="cm">		 * EEPROM</span>
<span class="cm">		 */</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We leave the &quot;DI&quot; bit set to &quot;0&quot; when we leave this routine. */</span>
	<span class="n">eec</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_EEC_DI</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">,</span> <span class="n">eec</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_shift_in_eeprom_bits - Shift data bits in from the EEPROM</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">ixgbe_shift_in_eeprom_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In order to read a register from the EEPROM, we need to shift</span>
<span class="cm">	 * &#39;count&#39; bits in from the EEPROM. Bits are &quot;shifted in&quot; by raising</span>
<span class="cm">	 * the clock input to the EEPROM (setting the SK bit), and then reading</span>
<span class="cm">	 * the value of the &quot;DO&quot; bit.  During this &quot;shifting in&quot; process the</span>
<span class="cm">	 * &quot;DI&quot; bit should always be clear.</span>
<span class="cm">	 */</span>
	<span class="n">eec</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">);</span>

	<span class="n">eec</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_EEC_DO</span> <span class="o">|</span> <span class="n">IXGBE_EEC_DI</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ixgbe_raise_eeprom_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eec</span><span class="p">);</span>

		<span class="n">eec</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">);</span>

		<span class="n">eec</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_EEC_DI</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eec</span> <span class="o">&amp;</span> <span class="n">IXGBE_EEC_DO</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">ixgbe_lower_eeprom_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eec</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_raise_eeprom_clk - Raises the EEPROM&#39;s clock input.</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @eec: EEC register&#39;s current value</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_raise_eeprom_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Raise the clock input to the EEPROM</span>
<span class="cm">	 * (setting the SK bit), then delay</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">eec</span> <span class="o">=</span> <span class="o">*</span><span class="n">eec</span> <span class="o">|</span> <span class="n">IXGBE_EEC_SK</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">,</span> <span class="o">*</span><span class="n">eec</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_lower_eeprom_clk - Lowers the EEPROM&#39;s clock input.</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @eecd: EECD&#39;s current value</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_lower_eeprom_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Lower the clock input to the EEPROM (clearing the SK bit), then</span>
<span class="cm">	 * delay</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">eec</span> <span class="o">=</span> <span class="o">*</span><span class="n">eec</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IXGBE_EEC_SK</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">,</span> <span class="o">*</span><span class="n">eec</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_release_eeprom - Release EEPROM, release semaphores</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_release_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eec</span><span class="p">;</span>

	<span class="n">eec</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">);</span>

	<span class="n">eec</span> <span class="o">|=</span> <span class="n">IXGBE_EEC_CS</span><span class="p">;</span>  <span class="cm">/* Pull CS high */</span>
	<span class="n">eec</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_EEC_SK</span><span class="p">;</span> <span class="cm">/* Lower SCK */</span>

	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">,</span> <span class="n">eec</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Stop requesting EEPROM access */</span>
	<span class="n">eec</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_EEC_REQ</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEC</span><span class="p">,</span> <span class="n">eec</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release_swfw_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GSSR_EEP_SM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Delay before attempt to obtain semaphore again to allow FW</span>
<span class="cm">	 * access. semaphore_delay is in ms we need us for usleep_range</span>
<span class="cm">	 */</span>
	<span class="n">usleep_range</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">semaphore_delay</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>
		     <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">semaphore_delay</span> <span class="o">*</span> <span class="mi">2000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_calc_eeprom_checksum_generic - Calculates and returns the checksum</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> **/</span>
<span class="n">u16</span> <span class="nf">ixgbe_calc_eeprom_checksum_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pointer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Include 0x0-0x3F in the checksum */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_EEPROM_CHECKSUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">word</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;EEPROM read failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">checksum</span> <span class="o">+=</span> <span class="n">word</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Include all data from pointers except for the fw pointer */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">IXGBE_PCIE_ANALOG_PTR</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_FW_PTR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pointer</span><span class="p">);</span>

		<span class="cm">/* Make sure the pointer seems valid */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pointer</span> <span class="o">!=</span> <span class="mh">0xFFFF</span> <span class="o">&amp;&amp;</span> <span class="n">pointer</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">pointer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="mh">0xFFFF</span> <span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">pointer</span><span class="o">+</span><span class="n">length</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">word</span><span class="p">);</span>
					<span class="n">checksum</span> <span class="o">+=</span> <span class="n">word</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">checksum</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">IXGBE_EEPROM_SUM</span> <span class="o">-</span> <span class="n">checksum</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">checksum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_validate_eeprom_checksum_generic - Validate EEPROM checksum</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @checksum_val: calculated checksum</span>
<span class="cm"> *</span>
<span class="cm"> *  Performs checksum calculation and validates the EEPROM checksum.  If the</span>
<span class="cm"> *  caller does not need checksum_val, the value can be NULL.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_validate_eeprom_checksum_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
                                           <span class="n">u16</span> <span class="o">*</span><span class="n">checksum_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">read_checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the first word from the EEPROM. If this times out or fails, do</span>
<span class="cm">	 * not continue or we could be in for a very long wait while every</span>
<span class="cm">	 * EEPROM read fails</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">checksum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">checksum</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">calc_checksum</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEPROM_CHECKSUM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read_checksum</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Verify read checksum from EEPROM is the same as</span>
<span class="cm">		 * calculated checksum</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_checksum</span> <span class="o">!=</span> <span class="n">checksum</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM_CHECKSUM</span><span class="p">;</span>

		<span class="cm">/* If the user cares, return the calculated checksum */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">checksum_val</span><span class="p">)</span>
			<span class="o">*</span><span class="n">checksum_val</span> <span class="o">=</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;EEPROM read failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_update_eeprom_checksum_generic - Updates the EEPROM checksum</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_update_eeprom_checksum_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">checksum</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the first word from the EEPROM. If this times out or fails, do</span>
<span class="cm">	 * not continue or we could be in for a very long wait while every</span>
<span class="cm">	 * EEPROM read fails</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">checksum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">checksum</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">calc_checksum</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EEPROM_CHECKSUM</span><span class="p">,</span>
					      <span class="n">checksum</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;EEPROM read failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_validate_mac_addr - Validate MAC address</span>
<span class="cm"> *  @mac_addr: pointer to MAC address.</span>
<span class="cm"> *</span>
<span class="cm"> *  Tests a MAC address to ensure it is a valid Individual Address</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_validate_mac_addr</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Make sure it is not a multicast address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IXGBE_IS_MULTICAST</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_INVALID_MAC_ADDR</span><span class="p">;</span>
	<span class="cm">/* Not a broadcast address */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IXGBE_IS_BROADCAST</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_INVALID_MAC_ADDR</span><span class="p">;</span>
	<span class="cm">/* Reject the zero address */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	         <span class="n">mac_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_INVALID_MAC_ADDR</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_set_rar_generic - Set Rx address register</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @index: Receive address register to write</span>
<span class="cm"> *  @addr: Address to put into receive address register</span>
<span class="cm"> *  @vmdq: VMDq &quot;set&quot; or &quot;pool&quot; index</span>
<span class="cm"> *  @enable_addr: set flag that address is active</span>
<span class="cm"> *</span>
<span class="cm"> *  Puts an ethernet address into a receive address register.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_set_rar_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vmdq</span><span class="p">,</span>
                          <span class="n">u32</span> <span class="n">enable_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rar_low</span><span class="p">,</span> <span class="n">rar_high</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rar_entries</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">num_rar_entries</span><span class="p">;</span>

	<span class="cm">/* Make sure we are using a valid rar index range */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">rar_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;RAR index %d is out of range.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_INVALID_ARGUMENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* setup VMDq pool selection before this RAR gets enabled */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">set_vmdq</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vmdq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * HW expects these in little endian so we reverse the byte</span>
<span class="cm">	 * order from network order (big endian) to little endian</span>
<span class="cm">	 */</span>
	<span class="n">rar_low</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span>
		   <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Some parts put the VMDq setting in the extra RAH bits,</span>
<span class="cm">	 * so save everything except the lower 16 bits that hold part</span>
<span class="cm">	 * of the address and the address valid bit.</span>
<span class="cm">	 */</span>
	<span class="n">rar_high</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RAH</span><span class="p">(</span><span class="n">index</span><span class="p">));</span>
	<span class="n">rar_high</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x0000FFFF</span> <span class="o">|</span> <span class="n">IXGBE_RAH_AV</span><span class="p">);</span>
	<span class="n">rar_high</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rar_high</span> <span class="o">|=</span> <span class="n">IXGBE_RAH_AV</span><span class="p">;</span>

	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RAL</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">rar_low</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RAH</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">rar_high</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_clear_rar_generic - Remove Rx address register</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @index: Receive address register to write</span>
<span class="cm"> *</span>
<span class="cm"> *  Clears an ethernet address from a receive address register.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_clear_rar_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rar_high</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rar_entries</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">num_rar_entries</span><span class="p">;</span>

	<span class="cm">/* Make sure we are using a valid rar index range */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">rar_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;RAR index %d is out of range.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_INVALID_ARGUMENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some parts put the VMDq setting in the extra RAH bits,</span>
<span class="cm">	 * so save everything except the lower 16 bits that hold part</span>
<span class="cm">	 * of the address and the address valid bit.</span>
<span class="cm">	 */</span>
	<span class="n">rar_high</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RAH</span><span class="p">(</span><span class="n">index</span><span class="p">));</span>
	<span class="n">rar_high</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x0000FFFF</span> <span class="o">|</span> <span class="n">IXGBE_RAH_AV</span><span class="p">);</span>

	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RAL</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RAH</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">rar_high</span><span class="p">);</span>

	<span class="cm">/* clear VMDq pool/queue selection for this RAR */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">clear_vmdq</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">IXGBE_CLEAR_VMDQ_ALL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_init_rx_addrs_generic - Initializes receive address filters.</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Places the MAC address in receive address register 0 and clears the rest</span>
<span class="cm"> *  of the receive address registers. Clears the multicast table. Assumes</span>
<span class="cm"> *  the receiver is in reset when the routine is called.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_init_rx_addrs_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rar_entries</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">num_rar_entries</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the current mac address is valid, assume it is a software override</span>
<span class="cm">	 * to the permanent address.</span>
<span class="cm">	 * Otherwise, use the permanent address from the eeprom.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_validate_mac_addr</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IXGBE_ERR_INVALID_MAC_ADDR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get the MAC address from the RAR0 for later reference */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_mac_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>

		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; Keeping Current RAR0 Addr =%pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Setup the receive address. */</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Overriding MAC Address in RAR[0]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; New MAC Addr =%pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>

		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">set_rar</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IXGBE_RAH_AV</span><span class="p">);</span>

		<span class="cm">/*  clear VMDq pool/queue selection for RAR 0 */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">clear_vmdq</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IXGBE_CLEAR_VMDQ_ALL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_ctrl</span><span class="p">.</span><span class="n">overflow_promisc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_ctrl</span><span class="p">.</span><span class="n">rar_used_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Zero out the other receive addresses. */</span>
	<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Clearing RAR[1-%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rar_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rar_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RAL</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RAH</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Clear the MTA */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_ctrl</span><span class="p">.</span><span class="n">mta_in_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MCSTCTRL</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mc_filter_type</span><span class="p">);</span>

	<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; Clearing MTA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mcft_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MTA</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_uta_tables</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_uta_tables</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_mta_vector - Determines bit-vector in multicast table to set</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @mc_addr: the multicast address</span>
<span class="cm"> *</span>
<span class="cm"> *  Extracts the 12 bits, from a multicast address, to determine which</span>
<span class="cm"> *  bit-vector to set in the multicast table. The hardware uses 12 bits, from</span>
<span class="cm"> *  incoming rx multicast addresses, to determine the bit-vector to check in</span>
<span class="cm"> *  the MTA. Which of the 4 combination, of 12-bits, the hardware uses is set</span>
<span class="cm"> *  by the MO field of the MCSTCTRL. The MO field is set during initialization</span>
<span class="cm"> *  to mc_filter_type.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_mta_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mc_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mc_filter_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:   <span class="cm">/* use bits [47:36] of the address */</span>
		<span class="n">vector</span> <span class="o">=</span> <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:   <span class="cm">/* use bits [46:35] of the address */</span>
		<span class="n">vector</span> <span class="o">=</span> <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:   <span class="cm">/* use bits [45:34] of the address */</span>
		<span class="n">vector</span> <span class="o">=</span> <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:   <span class="cm">/* use bits [43:32] of the address */</span>
		<span class="n">vector</span> <span class="o">=</span> <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>  <span class="cm">/* Invalid mc_filter_type */</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;MC filter type param set incorrectly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* vector can only be 12-bits or boundary will be exceeded */</span>
	<span class="n">vector</span> <span class="o">&amp;=</span> <span class="mh">0xFFF</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vector</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_set_mta - Set bit-vector in multicast table</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @hash_value: Multicast address hash value</span>
<span class="cm"> *</span>
<span class="cm"> *  Sets the bit-vector in the multicast table.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_set_mta</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mc_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">vector</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vector_bit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vector_reg</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_ctrl</span><span class="p">.</span><span class="n">mta_in_use</span><span class="o">++</span><span class="p">;</span>

	<span class="n">vector</span> <span class="o">=</span> <span class="n">ixgbe_mta_vector</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mc_addr</span><span class="p">);</span>
	<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; bit-vector = 0x%03X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The MTA is a register array of 128 32-bit registers. It is treated</span>
<span class="cm">	 * like an array of 4096 bits.  We want to set bit</span>
<span class="cm">	 * BitArray[vector_value]. So we figure out what register the bit is</span>
<span class="cm">	 * in, read it, OR in the new bit, then write back the new value.  The</span>
<span class="cm">	 * register is determined by the upper 7 bits of the vector value and</span>
<span class="cm">	 * the bit within that register are determined by the lower 5 bits of</span>
<span class="cm">	 * the value.</span>
<span class="cm">	 */</span>
	<span class="n">vector_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">vector</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
	<span class="n">vector_bit</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mta_shadow</span><span class="p">[</span><span class="n">vector_reg</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">vector_bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_update_mc_addr_list_generic - Updates MAC list of multicast addresses</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @netdev: pointer to net device structure</span>
<span class="cm"> *</span>
<span class="cm"> *  The given list replaces any existing list. Clears the MC addrs from receive</span>
<span class="cm"> *  address registers and the multicast table. Uses unused receive address</span>
<span class="cm"> *  registers for the first multicast addresses, and hashes the rest into the</span>
<span class="cm"> *  multicast table.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_update_mc_addr_list_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the new number of MC addresses that we are being requested to</span>
<span class="cm">	 * use.</span>
<span class="cm">	 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_ctrl</span><span class="p">.</span><span class="n">num_mc_addrs</span> <span class="o">=</span> <span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_ctrl</span><span class="p">.</span><span class="n">mta_in_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clear mta_shadow */</span>
	<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; Clearing MTA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mta_shadow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mta_shadow</span><span class="p">));</span>

	<span class="cm">/* Update mta shadow */</span>
	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; Adding the multicast addresses:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ixgbe_set_mta</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable mta */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mcft_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MTA</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span>
				      <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mta_shadow</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_ctrl</span><span class="p">.</span><span class="n">mta_in_use</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MCSTCTRL</span><span class="p">,</span>
		                <span class="n">IXGBE_MCSTCTRL_MFE</span> <span class="o">|</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mc_filter_type</span><span class="p">);</span>

	<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;ixgbe_update_mc_addr_list_generic Complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_enable_mc_generic - Enable multicast address in RAR</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Enables multicast address in RAR and the use of the multicast hash table.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_enable_mc_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_addr_filter_info</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_ctrl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">mta_in_use</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MCSTCTRL</span><span class="p">,</span> <span class="n">IXGBE_MCSTCTRL_MFE</span> <span class="o">|</span>
		                <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mc_filter_type</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_disable_mc_generic - Disable multicast address in RAR</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Disables multicast address in RAR and the use of the multicast hash table.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_disable_mc_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_addr_filter_info</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_ctrl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">mta_in_use</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MCSTCTRL</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mc_filter_type</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_fc_enable_generic - Enable flow control</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Enable flow control according to the current settings.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_fc_enable_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mflcn_reg</span><span class="p">,</span> <span class="n">fccfg_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fcrtl</span><span class="p">,</span> <span class="n">fcrth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate the water mark configuration for packet buffer 0.  Zero</span>
<span class="cm">	 * water marks indicate that the packet buffer was not configured</span>
<span class="cm">	 * and the watermarks for packet buffer 0 should always be configured.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">low_water</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">high_water</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">pause_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Invalid water mark configuration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_INVALID_LINK_SETTINGS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Negotiate the fc mode to use */</span>
	<span class="n">ixgbe_fc_autoneg</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Disable any previous flow control settings */</span>
	<span class="n">mflcn_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MFLCN</span><span class="p">);</span>
	<span class="n">mflcn_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_MFLCN_RPFCE_MASK</span> <span class="o">|</span> <span class="n">IXGBE_MFLCN_RFCE</span><span class="p">);</span>

	<span class="n">fccfg_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FCCFG</span><span class="p">);</span>
	<span class="n">fccfg_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_FCCFG_TFCE_802_3X</span> <span class="o">|</span> <span class="n">IXGBE_FCCFG_TFCE_PRIORITY</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The possible values of fc.current_mode are:</span>
<span class="cm">	 * 0: Flow control is completely disabled</span>
<span class="cm">	 * 1: Rx flow control is enabled (we can receive pause frames,</span>
<span class="cm">	 *    but not send pause frames).</span>
<span class="cm">	 * 2: Tx flow control is enabled (we can send pause frames but</span>
<span class="cm">	 *    we do not support receiving pause frames).</span>
<span class="cm">	 * 3: Both Rx and Tx flow control (symmetric) are enabled.</span>
<span class="cm">	 * other: Invalid.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_fc_none</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Flow control is disabled by software override or autoneg.</span>
<span class="cm">		 * The code below will actually disable it in the HW.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_fc_rx_pause</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Rx Flow control is enabled and Tx Flow control is</span>
<span class="cm">		 * disabled by software override. Since there really</span>
<span class="cm">		 * isn&#39;t a way to advertise that we are capable of RX</span>
<span class="cm">		 * Pause ONLY, we will advertise that we support both</span>
<span class="cm">		 * symmetric and asymmetric Rx PAUSE.  Later, we will</span>
<span class="cm">		 * disable the adapter&#39;s ability to send PAUSE frames.</span>
<span class="cm">		 */</span>
		<span class="n">mflcn_reg</span> <span class="o">|=</span> <span class="n">IXGBE_MFLCN_RFCE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_fc_tx_pause</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Tx Flow control is enabled, and Rx Flow control is</span>
<span class="cm">		 * disabled by software override.</span>
<span class="cm">		 */</span>
		<span class="n">fccfg_reg</span> <span class="o">|=</span> <span class="n">IXGBE_FCCFG_TFCE_802_3X</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_fc_full</span>:
		<span class="cm">/* Flow control (both Rx and Tx) is enabled by SW override. */</span>
		<span class="n">mflcn_reg</span> <span class="o">|=</span> <span class="n">IXGBE_MFLCN_RFCE</span><span class="p">;</span>
		<span class="n">fccfg_reg</span> <span class="o">|=</span> <span class="n">IXGBE_FCCFG_TFCE_802_3X</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Flow control param set incorrectly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_CONFIG</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set 802.3x based flow control settings. */</span>
	<span class="n">mflcn_reg</span> <span class="o">|=</span> <span class="n">IXGBE_MFLCN_DPF</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MFLCN</span><span class="p">,</span> <span class="n">mflcn_reg</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FCCFG</span><span class="p">,</span> <span class="n">fccfg_reg</span><span class="p">);</span>

	<span class="n">fcrtl</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">low_water</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="n">IXGBE_FCRTL_XONE</span><span class="p">;</span>

	<span class="cm">/* Set up and enable Rx high/low water mark thresholds, enable XON. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_TRAFFIC_CLASS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span> <span class="o">&amp;</span> <span class="n">ixgbe_fc_tx_pause</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">high_water</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FCRTL_82599</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">fcrtl</span><span class="p">);</span>
			<span class="n">fcrth</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">high_water</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="n">IXGBE_FCRTH_FCEN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FCRTL_82599</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * In order to prevent Tx hangs when the internal Tx</span>
<span class="cm">			 * switch is enabled we must set the high water mark</span>
<span class="cm">			 * to the maximum FCRTH value.  This allows the Tx</span>
<span class="cm">			 * switch to function even under heavy Rx workloads.</span>
<span class="cm">			 */</span>
			<span class="n">fcrth</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXPBSIZE</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">-</span> <span class="mi">32</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FCRTH_82599</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">fcrth</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Configure pause time (2 TCs per register) */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">pause_time</span> <span class="o">*</span> <span class="mh">0x00010001</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX_TRAFFIC_CLASS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FCTTV</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FCRTV</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">pause_time</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_negotiate_fc - Negotiate flow control</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @adv_reg: flow control advertised settings</span>
<span class="cm"> *  @lp_reg: link partner&#39;s flow control settings</span>
<span class="cm"> *  @adv_sym: symmetric pause bit in advertisement</span>
<span class="cm"> *  @adv_asm: asymmetric pause bit in advertisement</span>
<span class="cm"> *  @lp_sym: symmetric pause bit in link partner advertisement</span>
<span class="cm"> *  @lp_asm: asymmetric pause bit in link partner advertisement</span>
<span class="cm"> *</span>
<span class="cm"> *  Find the intersection between advertised settings and link partner&#39;s</span>
<span class="cm"> *  advertised settings</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_negotiate_fc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">adv_reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lp_reg</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">adv_sym</span><span class="p">,</span> <span class="n">u32</span> <span class="n">adv_asm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lp_sym</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lp_asm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">adv_reg</span><span class="p">))</span> <span class="o">||</span>  <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp_reg</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_FC_NOT_NEGOTIATED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">adv_reg</span> <span class="o">&amp;</span> <span class="n">adv_sym</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lp_reg</span> <span class="o">&amp;</span> <span class="n">lp_sym</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now we need to check if the user selected Rx ONLY</span>
<span class="cm">		 * of pause frames.  In this case, we had to advertise</span>
<span class="cm">		 * FULL flow control because we could not advertise RX</span>
<span class="cm">		 * ONLY. Hence, we must now check to see if we need to</span>
<span class="cm">		 * turn OFF the TRANSMISSION of PAUSE frames.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">requested_mode</span> <span class="o">==</span> <span class="n">ixgbe_fc_full</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span> <span class="o">=</span> <span class="n">ixgbe_fc_full</span><span class="p">;</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Flow Control = FULL.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span> <span class="o">=</span> <span class="n">ixgbe_fc_rx_pause</span><span class="p">;</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Flow Control=RX PAUSE frames only</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adv_reg</span> <span class="o">&amp;</span> <span class="n">adv_sym</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adv_reg</span> <span class="o">&amp;</span> <span class="n">adv_asm</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">lp_reg</span> <span class="o">&amp;</span> <span class="n">lp_sym</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lp_reg</span> <span class="o">&amp;</span> <span class="n">lp_asm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span> <span class="o">=</span> <span class="n">ixgbe_fc_tx_pause</span><span class="p">;</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Flow Control = TX PAUSE frames only.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">adv_reg</span> <span class="o">&amp;</span> <span class="n">adv_sym</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adv_reg</span> <span class="o">&amp;</span> <span class="n">adv_asm</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="p">(</span><span class="n">lp_reg</span> <span class="o">&amp;</span> <span class="n">lp_sym</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lp_reg</span> <span class="o">&amp;</span> <span class="n">lp_asm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span> <span class="o">=</span> <span class="n">ixgbe_fc_rx_pause</span><span class="p">;</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Flow Control = RX PAUSE frames only.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span> <span class="o">=</span> <span class="n">ixgbe_fc_none</span><span class="p">;</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Flow Control = NONE.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_fc_autoneg_fiber - Enable flow control on 1 gig fiber</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Enable flow control according on 1 gig fiber.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_fc_autoneg_fiber</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pcs_anadv_reg</span><span class="p">,</span> <span class="n">pcs_lpab_reg</span><span class="p">,</span> <span class="n">linkstat</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_FC_NOT_NEGOTIATED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * On multispeed fiber at 1g, bail out if</span>
<span class="cm">	 * - link is up but AN did not complete, or if</span>
<span class="cm">	 * - link is up and AN completed but timed out</span>
<span class="cm">	 */</span>

	<span class="n">linkstat</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PCS1GLSTA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!!</span><span class="p">(</span><span class="n">linkstat</span> <span class="o">&amp;</span> <span class="n">IXGBE_PCS1GLSTA_AN_COMPLETE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!!</span><span class="p">(</span><span class="n">linkstat</span> <span class="o">&amp;</span> <span class="n">IXGBE_PCS1GLSTA_AN_TIMED_OUT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pcs_anadv_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PCS1GANA</span><span class="p">);</span>
	<span class="n">pcs_lpab_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PCS1GANLP</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span>  <span class="n">ixgbe_negotiate_fc</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">pcs_anadv_reg</span><span class="p">,</span>
			       <span class="n">pcs_lpab_reg</span><span class="p">,</span> <span class="n">IXGBE_PCS1GANA_SYM_PAUSE</span><span class="p">,</span>
			       <span class="n">IXGBE_PCS1GANA_ASM_PAUSE</span><span class="p">,</span>
			       <span class="n">IXGBE_PCS1GANA_SYM_PAUSE</span><span class="p">,</span>
			       <span class="n">IXGBE_PCS1GANA_ASM_PAUSE</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_fc_autoneg_backplane - Enable flow control IEEE clause 37</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Enable flow control according to IEEE clause 37.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_fc_autoneg_backplane</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">links2</span><span class="p">,</span> <span class="n">anlp1_reg</span><span class="p">,</span> <span class="n">autoc_reg</span><span class="p">,</span> <span class="n">links</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_FC_NOT_NEGOTIATED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * On backplane, bail out if</span>
<span class="cm">	 * - backplane autoneg was not completed, or if</span>
<span class="cm">	 * - we are 82599 and link partner is not AN enabled</span>
<span class="cm">	 */</span>
	<span class="n">links</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LINKS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">links</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINKS_KX_AN_COMP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_mac_82599EB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">links2</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LINKS2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">links2</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINKS2_AN_SUPPORTED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read the 10g AN autoc and LP ability registers and resolve</span>
<span class="cm">	 * local flow control settings accordingly</span>
<span class="cm">	 */</span>
	<span class="n">autoc_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">);</span>
	<span class="n">anlp1_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ANLP1</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_negotiate_fc</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">autoc_reg</span><span class="p">,</span>
		<span class="n">anlp1_reg</span><span class="p">,</span> <span class="n">IXGBE_AUTOC_SYM_PAUSE</span><span class="p">,</span> <span class="n">IXGBE_AUTOC_ASM_PAUSE</span><span class="p">,</span>
		<span class="n">IXGBE_ANLP1_SYM_PAUSE</span><span class="p">,</span> <span class="n">IXGBE_ANLP1_ASM_PAUSE</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_fc_autoneg_copper - Enable flow control IEEE clause 37</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Enable flow control according to IEEE clause 37.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_fc_autoneg_copper</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">technology_ability_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">lp_technology_ability_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MDIO_AN_ADVERTISE</span><span class="p">,</span>
			     <span class="n">MDIO_MMD_AN</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">technology_ability_reg</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MDIO_AN_LPA</span><span class="p">,</span>
			     <span class="n">MDIO_MMD_AN</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">lp_technology_ability_reg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ixgbe_negotiate_fc</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">technology_ability_reg</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">lp_technology_ability_reg</span><span class="p">,</span>
				  <span class="n">IXGBE_TAF_SYM_PAUSE</span><span class="p">,</span> <span class="n">IXGBE_TAF_ASM_PAUSE</span><span class="p">,</span>
				  <span class="n">IXGBE_TAF_SYM_PAUSE</span><span class="p">,</span> <span class="n">IXGBE_TAF_ASM_PAUSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_fc_autoneg - Configure flow control</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Compares our advertised flow control capabilities to those advertised by</span>
<span class="cm"> *  our link partner, and determines the proper flow control mode to use.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">ixgbe_fc_autoneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_FC_NOT_NEGOTIATED</span><span class="p">;</span>
	<span class="n">ixgbe_link_speed</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link_up</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * AN should have completed when the cable was plugged in.</span>
<span class="cm">	 * Look for reasons to bail out.  Bail out if:</span>
<span class="cm">	 * - FC autoneg is disabled, or if</span>
<span class="cm">	 * - link is not up.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Since we&#39;re being called from an LSC, link is already known to be up.</span>
<span class="cm">	 * So use link_up_wait_to_complete=false.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">disable_fc_autoneg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_link</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_up</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link_up</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* Autoneg flow control on fiber adapters */</span>
	<span class="k">case</span> <span class="n">ixgbe_media_type_fiber</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">==</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_fc_autoneg_fiber</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Autoneg flow control on backplane adapters */</span>
	<span class="k">case</span> <span class="n">ixgbe_media_type_backplane</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_fc_autoneg_backplane</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Autoneg flow control on copper adapters */</span>
	<span class="k">case</span> <span class="n">ixgbe_media_type_copper</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_device_supports_autoneg_fc</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_fc_autoneg_copper</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">fc_was_autonegged</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">fc_was_autonegged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">requested_mode</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_disable_pcie_master - Disable PCI-express master access</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Disables PCI-Express master access and verifies there are no pending</span>
<span class="cm"> *  requests. IXGBE_ERR_MASTER_REQUESTS_PENDING is returned if master disable</span>
<span class="cm"> *  bit hasn&#39;t caused the master requests to be disabled, else 0</span>
<span class="cm"> *  is returned signifying master requests disabled.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_disable_pcie_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">value</span><span class="p">;</span>

	<span class="cm">/* Always set this bit to ensure any future transactions are blocked */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CTRL</span><span class="p">,</span> <span class="n">IXGBE_CTRL_GIO_DIS</span><span class="p">);</span>

	<span class="cm">/* Exit if master requests are blocked */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IXGBE_STATUS_GIO</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Poll for master request bit to clear */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_PCI_MASTER_DISABLE_TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IXGBE_STATUS_GIO</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Two consecutive resets are required via CTRL.RST per datasheet</span>
<span class="cm">	 * 5.2.5.3.2 Master Disable.  We set a flag to inform the reset routine</span>
<span class="cm">	 * of this need.  The first reset prevents new master requests from</span>
<span class="cm">	 * being issued by our device.  We then must wait 1usec or more for any</span>
<span class="cm">	 * remaining completions from the PCIe bus to trickle in, and then reset</span>
<span class="cm">	 * again to clear out any effects they may have had on our device.</span>
<span class="cm">	 */</span>
	<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;GIO Master Disable bit didn&#39;t clear - requesting resets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IXGBE_FLAGS_DOUBLE_RESET_REQUIRED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before proceeding, make sure that the PCIe block does not have</span>
<span class="cm">	 * transactions pending.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_PCI_MASTER_DISABLE_TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IXGBE_PCI_DEVICE_STATUS</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;PCIe transaction pending bit also did not clear.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_MASTER_REQUESTS_PENDING</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_acquire_swfw_sync - Acquire SWFW semaphore</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @mask: Mask to specify which semaphore to acquire</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires the SWFW semaphore through the GSSR register for the specified</span>
<span class="cm"> *  function (CSR, PHY0, PHY1, EEPROM, Flash)</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_acquire_swfw_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">gssr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">swmask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fwmask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * SW EEPROM semaphore bit is used for access to all</span>
<span class="cm">		 * SW_FW_SYNC/GSSR bits (not just EEPROM)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_get_eeprom_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IXGBE_ERR_SWFW_SYNC</span><span class="p">;</span>

		<span class="n">gssr</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GSSR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gssr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fwmask</span> <span class="o">|</span> <span class="n">swmask</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Firmware currently using resource (fwmask) or other software</span>
<span class="cm">		 * thread currently using resource (swmask)</span>
<span class="cm">		 */</span>
		<span class="n">ixgbe_release_eeprom_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">5000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">);</span>
		<span class="n">timeout</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Driver can&#39;t access resource, SW_FW_SYNC timeout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_SWFW_SYNC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gssr</span> <span class="o">|=</span> <span class="n">swmask</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GSSR</span><span class="p">,</span> <span class="n">gssr</span><span class="p">);</span>

	<span class="n">ixgbe_release_eeprom_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_release_swfw_sync - Release SWFW semaphore</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @mask: Mask to specify which semaphore to release</span>
<span class="cm"> *</span>
<span class="cm"> *  Releases the SWFW semaphore through the GSSR register for the specified</span>
<span class="cm"> *  function (CSR, PHY0, PHY1, EEPROM, Flash)</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">ixgbe_release_swfw_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">gssr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">swmask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">ixgbe_get_eeprom_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">gssr</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GSSR</span><span class="p">);</span>
	<span class="n">gssr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">swmask</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GSSR</span><span class="p">,</span> <span class="n">gssr</span><span class="p">);</span>

	<span class="n">ixgbe_release_eeprom_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_disable_rx_buff_generic - Stops the receive data path</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Stops the receive data path and waits for the HW to internally</span>
<span class="cm"> *  empty the Rx security block.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_disable_rx_buff_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define IXGBE_MAX_SECRX_POLL 40</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">secrxreg</span><span class="p">;</span>

	<span class="n">secrxreg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SECRXCTRL</span><span class="p">);</span>
	<span class="n">secrxreg</span> <span class="o">|=</span> <span class="n">IXGBE_SECRXCTRL_RX_DIS</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SECRXCTRL</span><span class="p">,</span> <span class="n">secrxreg</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_MAX_SECRX_POLL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">secrxreg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SECRXSTAT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">secrxreg</span> <span class="o">&amp;</span> <span class="n">IXGBE_SECRXSTAT_SECRX_RDY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* Use interrupt-safe sleep just in case */</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* For informational purposes only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">IXGBE_MAX_SECRX_POLL</span><span class="p">)</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Rx unit being enabled before security &quot;</span>
		       <span class="s">&quot;path fully disabled.  Continuing with init.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_enable_rx_buff - Enables the receive data path</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Enables the receive data path</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_enable_rx_buff_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">secrxreg</span><span class="p">;</span>

	<span class="n">secrxreg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SECRXCTRL</span><span class="p">);</span>
	<span class="n">secrxreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_SECRXCTRL_RX_DIS</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SECRXCTRL</span><span class="p">,</span> <span class="n">secrxreg</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_enable_rx_dma_generic - Enable the Rx DMA unit</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @regval: register value to write to RXCTRL</span>
<span class="cm"> *</span>
<span class="cm"> *  Enables the Rx DMA unit</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_enable_rx_dma_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">regval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXCTRL</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_blink_led_start_generic - Blink LED based on index.</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @index: led number to blink</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_blink_led_start_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ixgbe_link_speed</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link_up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">autoc_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">led_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LEDCTL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Link must be up to auto-blink the LEDs;</span>
<span class="cm">	 * Force it if link is down.</span>
<span class="cm">	 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_link</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_up</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">autoc_reg</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_AN_RESTART</span><span class="p">;</span>
		<span class="n">autoc_reg</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_FLU</span><span class="p">;</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">,</span> <span class="n">autoc_reg</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">led_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_LED_MODE_MASK</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">led_reg</span> <span class="o">|=</span> <span class="n">IXGBE_LED_BLINK</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LEDCTL</span><span class="p">,</span> <span class="n">led_reg</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_blink_led_stop_generic - Stop blinking LED based on index.</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @index: led number to stop blinking</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_blink_led_stop_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">autoc_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">led_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LEDCTL</span><span class="p">);</span>

	<span class="n">autoc_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_AUTOC_FLU</span><span class="p">;</span>
	<span class="n">autoc_reg</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_AN_RESTART</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">,</span> <span class="n">autoc_reg</span><span class="p">);</span>

	<span class="n">led_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_LED_MODE_MASK</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">led_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_LED_BLINK</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">led_reg</span> <span class="o">|=</span> <span class="n">IXGBE_LED_LINK_ACTIVE</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_LED_MODE_SHIFT</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LEDCTL</span><span class="p">,</span> <span class="n">led_reg</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_san_mac_addr_offset - Get SAN MAC address offset from the EEPROM</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @san_mac_offset: SAN MAC address offset</span>
<span class="cm"> *</span>
<span class="cm"> *  This function will read the EEPROM location for the SAN MAC address</span>
<span class="cm"> *  pointer, and returns the value at that location.  This is used in both</span>
<span class="cm"> *  get and set mac_addr routines.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_get_san_mac_addr_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
                                        <span class="n">u16</span> <span class="o">*</span><span class="n">san_mac_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * First read the EEPROM pointer to see if the MAC addresses are</span>
<span class="cm">	 * available.</span>
<span class="cm">	 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SAN_MAC_ADDR_PTR</span><span class="p">,</span> <span class="n">san_mac_offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_san_mac_addr_generic - SAN MAC address retrieval from the EEPROM</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @san_mac_addr: SAN MAC address</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the SAN MAC address from the EEPROM, if it&#39;s available.  This is</span>
<span class="cm"> *  per-port, so set_lan_id() must be called before reading the addresses.</span>
<span class="cm"> *  set_lan_id() is called by identify_sfp(), but this cannot be relied</span>
<span class="cm"> *  upon for non-SFP connections, so we must call it here.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_get_san_mac_addr_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">san_mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">san_mac_data</span><span class="p">,</span> <span class="n">san_mac_offset</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First read the EEPROM pointer to see if the MAC addresses are</span>
<span class="cm">	 * available.  If they&#39;re not, no point in calling set_lan_id() here.</span>
<span class="cm">	 */</span>
	<span class="n">ixgbe_get_san_mac_addr_offset</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">san_mac_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">san_mac_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">san_mac_offset</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * No addresses available in this EEPROM.  It&#39;s not an</span>
<span class="cm">		 * error though, so just wipe the local address and return.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">san_mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">san_mac_addr_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* make sure we know which port we need to program */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">set_lan_id</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="cm">/* apply the port offset to the address offset */</span>
	<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">func</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">san_mac_offset</span> <span class="o">+=</span> <span class="n">IXGBE_SAN_MAC_ADDR_PORT1_OFFSET</span><span class="p">)</span> <span class="o">:</span>
	                 <span class="p">(</span><span class="n">san_mac_offset</span> <span class="o">+=</span> <span class="n">IXGBE_SAN_MAC_ADDR_PORT0_OFFSET</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">san_mac_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">san_mac_data</span><span class="p">);</span>
		<span class="n">san_mac_addr</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">san_mac_data</span><span class="p">);</span>
		<span class="n">san_mac_addr</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">san_mac_data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">san_mac_offset</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">san_mac_addr_out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_pcie_msix_count_generic - Gets MSI-X vector count</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Read PCIe configuration space, and get the MSI-X vector count from</span>
<span class="cm"> *  the capabilities table.</span>
<span class="cm"> **/</span>
<span class="n">u16</span> <span class="nf">ixgbe_get_pcie_msix_count_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">msix_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max_msix_count</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pcie_offset</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_82598EB</span>:
		<span class="n">pcie_offset</span> <span class="o">=</span> <span class="n">IXGBE_PCIE_MSIX_82598_CAPS</span><span class="p">;</span>
		<span class="n">max_msix_count</span> <span class="o">=</span> <span class="n">IXGBE_MAX_MSIX_VECTORS_82598</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_82599EB</span>:
	<span class="k">case</span> <span class="n">ixgbe_mac_X540</span>:
		<span class="n">pcie_offset</span> <span class="o">=</span> <span class="n">IXGBE_PCIE_MSIX_82599_CAPS</span><span class="p">;</span>
		<span class="n">max_msix_count</span> <span class="o">=</span> <span class="n">IXGBE_MAX_MSIX_VECTORS_82599</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">msix_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pcie_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msix_count</span><span class="p">);</span>
	<span class="n">msix_count</span> <span class="o">&amp;=</span> <span class="n">IXGBE_PCIE_MSIX_TBL_SZ_MASK</span><span class="p">;</span>

	<span class="cm">/* MSI-X count is zero-based in HW */</span>
	<span class="n">msix_count</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msix_count</span> <span class="o">&gt;</span> <span class="n">max_msix_count</span><span class="p">)</span>
		<span class="n">msix_count</span> <span class="o">=</span> <span class="n">max_msix_count</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">msix_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_clear_vmdq_generic - Disassociate a VMDq pool index from a rx address</span>
<span class="cm"> *  @hw: pointer to hardware struct</span>
<span class="cm"> *  @rar: receive address register index to disassociate</span>
<span class="cm"> *  @vmdq: VMDq pool index to remove from the rar</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_clear_vmdq_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rar</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vmdq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mpsar_lo</span><span class="p">,</span> <span class="n">mpsar_hi</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rar_entries</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">num_rar_entries</span><span class="p">;</span>

	<span class="cm">/* Make sure we are using a valid rar index range */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rar</span> <span class="o">&gt;=</span> <span class="n">rar_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;RAR index %d is out of range.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rar</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_INVALID_ARGUMENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mpsar_lo</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPSAR_LO</span><span class="p">(</span><span class="n">rar</span><span class="p">));</span>
	<span class="n">mpsar_hi</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPSAR_HI</span><span class="p">(</span><span class="n">rar</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mpsar_lo</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mpsar_hi</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmdq</span> <span class="o">==</span> <span class="n">IXGBE_CLEAR_VMDQ_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mpsar_lo</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPSAR_LO</span><span class="p">(</span><span class="n">rar</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">mpsar_lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mpsar_hi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPSAR_HI</span><span class="p">(</span><span class="n">rar</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">mpsar_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vmdq</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mpsar_lo</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">vmdq</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPSAR_LO</span><span class="p">(</span><span class="n">rar</span><span class="p">),</span> <span class="n">mpsar_lo</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mpsar_hi</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vmdq</span> <span class="o">-</span> <span class="mi">32</span><span class="p">));</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPSAR_HI</span><span class="p">(</span><span class="n">rar</span><span class="p">),</span> <span class="n">mpsar_hi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* was that the last pool using this rar? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpsar_lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mpsar_hi</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rar</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">clear_rar</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">rar</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_set_vmdq_generic - Associate a VMDq pool index with a rx address</span>
<span class="cm"> *  @hw: pointer to hardware struct</span>
<span class="cm"> *  @rar: receive address register index to associate with a VMDq index</span>
<span class="cm"> *  @vmdq: VMDq pool index</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_set_vmdq_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rar</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vmdq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mpsar</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rar_entries</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">num_rar_entries</span><span class="p">;</span>

	<span class="cm">/* Make sure we are using a valid rar index range */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rar</span> <span class="o">&gt;=</span> <span class="n">rar_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;RAR index %d is out of range.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rar</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_INVALID_ARGUMENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmdq</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mpsar</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPSAR_LO</span><span class="p">(</span><span class="n">rar</span><span class="p">));</span>
		<span class="n">mpsar</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">vmdq</span><span class="p">;</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPSAR_LO</span><span class="p">(</span><span class="n">rar</span><span class="p">),</span> <span class="n">mpsar</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mpsar</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPSAR_HI</span><span class="p">(</span><span class="n">rar</span><span class="p">));</span>
		<span class="n">mpsar</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vmdq</span> <span class="o">-</span> <span class="mi">32</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_MPSAR_HI</span><span class="p">(</span><span class="n">rar</span><span class="p">),</span> <span class="n">mpsar</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_init_uta_tables_generic - Initialize the Unicast Table Array</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_init_uta_tables_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_UTA</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_find_vlvf_slot - find the vlanid or the first empty slot</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @vlan: VLAN id to write to VLAN filter</span>
<span class="cm"> *</span>
<span class="cm"> *  return the VLVF index where this VLAN id should be placed</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_find_vlvf_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vlan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first_empty_slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">regindex</span><span class="p">;</span>

	<span class="cm">/* short cut the special case */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	  * Search for the vlan id in the VLVF entries. Save off the first empty</span>
<span class="cm">	  * slot found along the way</span>
<span class="cm">	  */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">regindex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">regindex</span> <span class="o">&lt;</span> <span class="n">IXGBE_VLVF_ENTRIES</span><span class="p">;</span> <span class="n">regindex</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_VLVF</span><span class="p">(</span><span class="n">regindex</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bits</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">first_empty_slot</span><span class="p">))</span>
			<span class="n">first_empty_slot</span> <span class="o">=</span> <span class="n">regindex</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mh">0x0FFF</span><span class="p">)</span> <span class="o">==</span> <span class="n">vlan</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	  * If regindex is less than IXGBE_VLVF_ENTRIES, then we found the vlan</span>
<span class="cm">	  * in the VLVF. Else use the first empty VLVF register for this</span>
<span class="cm">	  * vlan id.</span>
<span class="cm">	  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regindex</span> <span class="o">&gt;=</span> <span class="n">IXGBE_VLVF_ENTRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first_empty_slot</span><span class="p">)</span>
			<span class="n">regindex</span> <span class="o">=</span> <span class="n">first_empty_slot</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;No space in VLVF.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">regindex</span> <span class="o">=</span> <span class="n">IXGBE_ERR_NO_SPACE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">regindex</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_set_vfta_generic - Set VLAN filter table</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @vlan: VLAN id to write to VLAN filter</span>
<span class="cm"> *  @vind: VMDq output index that maps queue to VLAN id in VFVFB</span>
<span class="cm"> *  @vlan_on: boolean flag to turn on/off VLAN in VFVF</span>
<span class="cm"> *</span>
<span class="cm"> *  Turn on/off specified VLAN in the VLAN filter table.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_set_vfta_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vlan</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vind</span><span class="p">,</span>
                           <span class="n">bool</span> <span class="n">vlan_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">regindex</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bitindex</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vfta</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">targetbit</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">vfta_changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span> <span class="o">&gt;</span> <span class="mi">4095</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_PARAM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * this is a 2 part operation - first the VFTA, then the</span>
<span class="cm">	 * VLVF and VLVFB if VT Mode is set</span>
<span class="cm">	 * We don&#39;t write the VFTA until we know the VLVF part succeeded.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Part 1</span>
<span class="cm">	 * The VFTA is a bitstring made up of 128 32-bit registers</span>
<span class="cm">	 * that enable the particular VLAN id, much like the MTA:</span>
<span class="cm">	 *    bits[11-5]: which register</span>
<span class="cm">	 *    bits[4-0]:  which bit in the register</span>
<span class="cm">	 */</span>
	<span class="n">regindex</span> <span class="o">=</span> <span class="p">(</span><span class="n">vlan</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
	<span class="n">bitindex</span> <span class="o">=</span> <span class="n">vlan</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">;</span>
	<span class="n">targetbit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bitindex</span><span class="p">);</span>
	<span class="n">vfta</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_VFTA</span><span class="p">(</span><span class="n">regindex</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vfta</span> <span class="o">&amp;</span> <span class="n">targetbit</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vfta</span> <span class="o">|=</span> <span class="n">targetbit</span><span class="p">;</span>
			<span class="n">vfta_changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vfta</span> <span class="o">&amp;</span> <span class="n">targetbit</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vfta</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">targetbit</span><span class="p">;</span>
			<span class="n">vfta_changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Part 2</span>
<span class="cm">	 * If VT Mode is set</span>
<span class="cm">	 *   Either vlan_on</span>
<span class="cm">	 *     make sure the vlan is in VLVF</span>
<span class="cm">	 *     set the vind bit in the matching VLVFB</span>
<span class="cm">	 *   Or !vlan_on</span>
<span class="cm">	 *     clear the pool bit and possibly the vind</span>
<span class="cm">	 */</span>
	<span class="n">vt</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_VT_CTL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vt</span> <span class="o">&amp;</span> <span class="n">IXGBE_VT_CTL_VT_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s32</span> <span class="n">vlvf_index</span><span class="p">;</span>

		<span class="n">vlvf_index</span> <span class="o">=</span> <span class="n">ixgbe_find_vlvf_slot</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vlan</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vlvf_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">vlvf_index</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vlan_on</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* set the pool bit */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vind</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bits</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						<span class="n">IXGBE_VLVFB</span><span class="p">(</span><span class="n">vlvf_index</span><span class="o">*</span><span class="mi">2</span><span class="p">));</span>
				<span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">vind</span><span class="p">);</span>
				<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						<span class="n">IXGBE_VLVFB</span><span class="p">(</span><span class="n">vlvf_index</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span>
						<span class="n">bits</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">bits</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						<span class="n">IXGBE_VLVFB</span><span class="p">((</span><span class="n">vlvf_index</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
				<span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vind</span><span class="o">-</span><span class="mi">32</span><span class="p">));</span>
				<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						<span class="n">IXGBE_VLVFB</span><span class="p">((</span><span class="n">vlvf_index</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
						<span class="n">bits</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* clear the pool bit */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vind</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bits</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						<span class="n">IXGBE_VLVFB</span><span class="p">(</span><span class="n">vlvf_index</span><span class="o">*</span><span class="mi">2</span><span class="p">));</span>
				<span class="n">bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">vind</span><span class="p">);</span>
				<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						<span class="n">IXGBE_VLVFB</span><span class="p">(</span><span class="n">vlvf_index</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span>
						<span class="n">bits</span><span class="p">);</span>
				<span class="n">bits</span> <span class="o">|=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						<span class="n">IXGBE_VLVFB</span><span class="p">((</span><span class="n">vlvf_index</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">bits</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						<span class="n">IXGBE_VLVFB</span><span class="p">((</span><span class="n">vlvf_index</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
				<span class="n">bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vind</span><span class="o">-</span><span class="mi">32</span><span class="p">));</span>
				<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						<span class="n">IXGBE_VLVFB</span><span class="p">((</span><span class="n">vlvf_index</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
						<span class="n">bits</span><span class="p">);</span>
				<span class="n">bits</span> <span class="o">|=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						<span class="n">IXGBE_VLVFB</span><span class="p">(</span><span class="n">vlvf_index</span><span class="o">*</span><span class="mi">2</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there are still bits set in the VLVFB registers</span>
<span class="cm">		 * for the VLAN ID indicated we need to see if the</span>
<span class="cm">		 * caller is requesting that we clear the VFTA entry bit.</span>
<span class="cm">		 * If the caller has requested that we clear the VFTA</span>
<span class="cm">		 * entry bit but there are still pools/VFs using this VLAN</span>
<span class="cm">		 * ID entry then ignore the request.  We&#39;re not worried</span>
<span class="cm">		 * about the case where we&#39;re turning the VFTA VLAN ID</span>
<span class="cm">		 * entry bit on, only when requested to turn it off as</span>
<span class="cm">		 * there may be multiple pools and/or VFs using the</span>
<span class="cm">		 * VLAN ID entry.  In that case we cannot clear the</span>
<span class="cm">		 * VFTA bit until all pools/VFs using that VLAN ID have also</span>
<span class="cm">		 * been cleared.  This will be indicated by &quot;bits&quot; being</span>
<span class="cm">		 * zero.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_VLVF</span><span class="p">(</span><span class="n">vlvf_index</span><span class="p">),</span>
					<span class="p">(</span><span class="n">IXGBE_VLVF_VIEN</span> <span class="o">|</span> <span class="n">vlan</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vlan_on</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* someone wants to clear the vfta entry</span>
<span class="cm">				 * but some pools/VFs are still using it.</span>
<span class="cm">				 * Ignore it. */</span>
				<span class="n">vfta_changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_VLVF</span><span class="p">(</span><span class="n">vlvf_index</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vfta_changed</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_VFTA</span><span class="p">(</span><span class="n">regindex</span><span class="p">),</span> <span class="n">vfta</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_clear_vfta_generic - Clear VLAN filter table</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Clears the VLAN filer table, and the VMDq index associated with the filter</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_clear_vfta_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">vft_size</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_VFTA</span><span class="p">(</span><span class="n">offset</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">IXGBE_VLVF_ENTRIES</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_VLVF</span><span class="p">(</span><span class="n">offset</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_VLVFB</span><span class="p">(</span><span class="n">offset</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_VLVFB</span><span class="p">((</span><span class="n">offset</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_check_mac_link_generic - Determine link and speed status</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @speed: pointer to link speed</span>
<span class="cm"> *  @link_up: true when link is up</span>
<span class="cm"> *  @link_up_wait_to_complete: bool used to wait for link up or not</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the links register to determine if link is up and the current speed</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_check_mac_link_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">ixgbe_link_speed</span> <span class="o">*</span><span class="n">speed</span><span class="p">,</span>
				 <span class="n">bool</span> <span class="o">*</span><span class="n">link_up</span><span class="p">,</span> <span class="n">bool</span> <span class="n">link_up_wait_to_complete</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">links_reg</span><span class="p">,</span> <span class="n">links_orig</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* clear the old state */</span>
	<span class="n">links_orig</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LINKS</span><span class="p">);</span>

	<span class="n">links_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LINKS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">links_orig</span> <span class="o">!=</span> <span class="n">links_reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;LINKS changed from %08X to %08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">links_orig</span><span class="p">,</span> <span class="n">links_reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link_up_wait_to_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_LINK_UP_TIME</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">links_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINKS_UP</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">link_up</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">link_up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="n">links_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LINKS</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">links_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINKS_UP</span><span class="p">)</span>
			<span class="o">*</span><span class="n">link_up</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">link_up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">links_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINKS_SPEED_82599</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IXGBE_LINKS_SPEED_10G_82599</span><span class="p">)</span>
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">links_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINKS_SPEED_82599</span><span class="p">)</span> <span class="o">==</span>
		 <span class="n">IXGBE_LINKS_SPEED_1G_82599</span><span class="p">)</span>
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">links_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINKS_SPEED_82599</span><span class="p">)</span> <span class="o">==</span>
		 <span class="n">IXGBE_LINKS_SPEED_100_82599</span><span class="p">)</span>
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_100_FULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_UNKNOWN</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_wwn_prefix_generic Get alternative WWNN/WWPN prefix from</span>
<span class="cm"> *  the EEPROM</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @wwnn_prefix: the alternative WWNN prefix</span>
<span class="cm"> *  @wwpn_prefix: the alternative WWPN prefix</span>
<span class="cm"> *</span>
<span class="cm"> *  This function will read the EEPROM from the alternative SAN MAC address</span>
<span class="cm"> *  block to check the support for the alternative WWNN/WWPN prefix support.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_get_wwn_prefix_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">wwnn_prefix</span><span class="p">,</span>
                                        <span class="n">u16</span> <span class="o">*</span><span class="n">wwpn_prefix</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">caps</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">alt_san_mac_blk_offset</span><span class="p">;</span>

	<span class="cm">/* clear output first */</span>
	<span class="o">*</span><span class="n">wwnn_prefix</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>
	<span class="o">*</span><span class="n">wwpn_prefix</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>

	<span class="cm">/* check if alternative SAN MAC is supported */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ALT_SAN_MAC_ADDR_BLK_PTR</span><span class="p">,</span>
	                    <span class="o">&amp;</span><span class="n">alt_san_mac_blk_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">alt_san_mac_blk_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">alt_san_mac_blk_offset</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">wwn_prefix_out</span><span class="p">;</span>

	<span class="cm">/* check capability in alternative san mac address block */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">alt_san_mac_blk_offset</span> <span class="o">+</span> <span class="n">IXGBE_ALT_SAN_MAC_ADDR_CAPS_OFFSET</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">caps</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">IXGBE_ALT_SAN_MAC_ADDR_CAPS_ALTWWN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">wwn_prefix_out</span><span class="p">;</span>

	<span class="cm">/* get the corresponding prefix for WWNN/WWPN */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">alt_san_mac_blk_offset</span> <span class="o">+</span> <span class="n">IXGBE_ALT_SAN_MAC_ADDR_WWNN_OFFSET</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">wwnn_prefix</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">alt_san_mac_blk_offset</span> <span class="o">+</span> <span class="n">IXGBE_ALT_SAN_MAC_ADDR_WWPN_OFFSET</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">wwpn_prefix</span><span class="p">);</span>

<span class="nl">wwn_prefix_out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_set_mac_anti_spoofing - Enable/Disable MAC anti-spoofing</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @enable: enable or disable switch for anti-spoofing</span>
<span class="cm"> *  @pf: Physical Function pool - do not enable anti-spoofing for the PF</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">ixgbe_set_mac_anti_spoofing</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pf_target_reg</span> <span class="o">=</span> <span class="n">pf</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pf_target_shift</span> <span class="o">=</span> <span class="n">pf</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pfvfspoof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_mac_82598EB</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">pfvfspoof</span> <span class="o">=</span> <span class="n">IXGBE_SPOOF_MACAS_MASK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * PFVFSPOOF register array is size 8 with 8 bits assigned to</span>
<span class="cm">	 * MAC anti-spoof enables in each register array element.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">IXGBE_PFVFSPOOF_REG_COUNT</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PFVFSPOOF</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">pfvfspoof</span><span class="p">);</span>

	<span class="cm">/* If not enabling anti-spoofing then done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The PF should be allowed to spoof so that it can support</span>
<span class="cm">	 * emulation mode NICs.  Reset the bit assigned to the PF</span>
<span class="cm">	 */</span>
	<span class="n">pfvfspoof</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PFVFSPOOF</span><span class="p">(</span><span class="n">pf_target_reg</span><span class="p">));</span>
	<span class="n">pfvfspoof</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pf_target_shift</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PFVFSPOOF</span><span class="p">(</span><span class="n">pf_target_reg</span><span class="p">),</span> <span class="n">pfvfspoof</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_set_vlan_anti_spoofing - Enable/Disable VLAN anti-spoofing</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @enable: enable or disable switch for VLAN anti-spoofing</span>
<span class="cm"> *  @pf: Virtual Function pool - VF Pool to set for VLAN anti-spoofing</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">ixgbe_set_vlan_anti_spoofing</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">vf_target_reg</span> <span class="o">=</span> <span class="n">vf</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vf_target_shift</span> <span class="o">=</span> <span class="n">vf</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">IXGBE_SPOOF_VLANAS_SHIFT</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pfvfspoof</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_mac_82598EB</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pfvfspoof</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PFVFSPOOF</span><span class="p">(</span><span class="n">vf_target_reg</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">pfvfspoof</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">vf_target_shift</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pfvfspoof</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">vf_target_shift</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_PFVFSPOOF</span><span class="p">(</span><span class="n">vf_target_reg</span><span class="p">),</span> <span class="n">pfvfspoof</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_device_caps_generic - Get additional device capabilities</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @device_caps: the EEPROM word with the extra device capabilities</span>
<span class="cm"> *</span>
<span class="cm"> *  This function will read the EEPROM location for the device capabilities,</span>
<span class="cm"> *  and return the word through device_caps.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_get_device_caps_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">device_caps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_DEVICE_CAPS</span><span class="p">,</span> <span class="n">device_caps</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_set_rxpba_generic - Initialize RX packet buffer</span>
<span class="cm"> * @hw: pointer to hardware structure</span>
<span class="cm"> * @num_pb: number of packet buffers to allocate</span>
<span class="cm"> * @headroom: reserve n KB of headroom</span>
<span class="cm"> * @strategy: packet buffer allocation strategy</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">ixgbe_set_rxpba_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">num_pb</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">headroom</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">strategy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pbsize</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">rx_pb_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rxpktsize</span><span class="p">,</span> <span class="n">txpktsize</span><span class="p">,</span> <span class="n">txpbthresh</span><span class="p">;</span>

	<span class="cm">/* Reserve headroom */</span>
	<span class="n">pbsize</span> <span class="o">-=</span> <span class="n">headroom</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_pb</span><span class="p">)</span>
		<span class="n">num_pb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Divide remaining packet buffer space amongst the number</span>
<span class="cm">	 * of packet buffers requested using supplied strategy.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">strategy</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="p">(</span><span class="n">PBA_STRATEGY_WEIGHTED</span><span class="p">)</span>:
		<span class="cm">/* pba_80_48 strategy weight first half of packet buffer with</span>
<span class="cm">		 * 5/8 of the packet buffer space.</span>
<span class="cm">		 */</span>
		<span class="n">rxpktsize</span> <span class="o">=</span> <span class="p">((</span><span class="n">pbsize</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_pb</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>
		<span class="n">pbsize</span> <span class="o">-=</span> <span class="n">rxpktsize</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_pb</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">rxpktsize</span> <span class="o">&lt;&lt;=</span> <span class="n">IXGBE_RXPBSIZE_SHIFT</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">num_pb</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXPBSIZE</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">rxpktsize</span><span class="p">);</span>
		<span class="cm">/* Fall through to configure remaining packet buffers */</span>
	<span class="k">case</span> <span class="p">(</span><span class="n">PBA_STRATEGY_EQUAL</span><span class="p">)</span>:
		<span class="cm">/* Divide the remaining Rx packet buffer evenly among the TCs */</span>
		<span class="n">rxpktsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">pbsize</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_pb</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_RXPBSIZE_SHIFT</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXPBSIZE</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">rxpktsize</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup Tx packet buffer and threshold equally for all TCs</span>
<span class="cm">	 * TXPBTHRESH register is set in K so divide by 1024 and subtract</span>
<span class="cm">	 * 10 since the largest packet we support is just over 9K.</span>
<span class="cm">	 */</span>
	<span class="n">txpktsize</span> <span class="o">=</span> <span class="n">IXGBE_TXPBSIZE_MAX</span> <span class="o">/</span> <span class="n">num_pb</span><span class="p">;</span>
	<span class="n">txpbthresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">txpktsize</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">-</span> <span class="n">IXGBE_TXPKT_SIZE_MAX</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TXPBSIZE</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">txpktsize</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TXPBTHRESH</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">txpbthresh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Clear unused TCs, if any, to zero buffer size*/</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_MAX_PB</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXPBSIZE</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TXPBSIZE</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TXPBTHRESH</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_calculate_checksum - Calculate checksum for buffer</span>
<span class="cm"> *  @buffer: pointer to EEPROM</span>
<span class="cm"> *  @length: size of EEPROM to calculate a checksum for</span>
<span class="cm"> *  Calculates the checksum for some buffer on a specified length.  The</span>
<span class="cm"> *  checksum calculated is returned.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">ixgbe_calculate_checksum</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">u32</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="o">-</span> <span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_host_interface_command - Issue command to manageability block</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @buffer: contains the command to write and where the return status will</span>
<span class="cm"> *           be placed</span>
<span class="cm"> *  @length: length of buffer, must be multiple of 4 bytes</span>
<span class="cm"> *</span>
<span class="cm"> *  Communicates with the manageability block.  On success return 0</span>
<span class="cm"> *  else return IXGBE_ERR_HOST_INTERFACE_COMMAND.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_host_interface_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hicr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hdr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hic_hdr</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">buf_len</span><span class="p">,</span> <span class="n">dword_len</span><span class="p">;</span>

	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&amp;</span> <span class="mh">0x3</span> <span class="o">||</span>
	    <span class="n">length</span> <span class="o">&gt;</span> <span class="n">IXGBE_HI_MAX_BLOCK_BYTE_LENGTH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Buffer length failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_HOST_INTERFACE_COMMAND</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check that the host interface is enabled. */</span>
	<span class="n">hicr</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_HICR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hicr</span> <span class="o">&amp;</span> <span class="n">IXGBE_HICR_EN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;IXGBE_HOST_EN bit disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_HOST_INTERFACE_COMMAND</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate length in DWORDs */</span>
	<span class="n">dword_len</span> <span class="o">=</span> <span class="n">length</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The device driver writes the relevant command block</span>
<span class="cm">	 * into the ram area.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dword_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FLEX_MNG</span><span class="p">,</span>
				      <span class="n">i</span><span class="p">,</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>

	<span class="cm">/* Setting this bit tells the ARC that a new command is pending. */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_HICR</span><span class="p">,</span> <span class="n">hicr</span> <span class="o">|</span> <span class="n">IXGBE_HICR_C</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_HI_COMMAND_TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hicr</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_HICR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hicr</span> <span class="o">&amp;</span> <span class="n">IXGBE_HICR_C</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check command successful completion. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">IXGBE_HI_COMMAND_TIMEOUT</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_HICR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IXGBE_HICR_SV</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Command has failed with no status valid.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_HOST_INTERFACE_COMMAND</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate length in DWORDs */</span>
	<span class="n">dword_len</span> <span class="o">=</span> <span class="n">hdr_size</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* first pull in the header so we know the buffer length */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bi</span> <span class="o">&lt;</span> <span class="n">dword_len</span><span class="p">;</span> <span class="n">bi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FLEX_MNG</span><span class="p">,</span> <span class="n">bi</span><span class="p">);</span>
		<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">bi</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* If there is any thing in data position pull it in */</span>
	<span class="n">buf_len</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">ixgbe_hic_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">buf_len</span> <span class="o">+</span> <span class="n">hdr_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Buffer not large enough for reply message.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_HOST_INTERFACE_COMMAND</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate length in DWORDs, add 3 for odd lengths */</span>
	<span class="n">dword_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf_len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Pull in the rest of the buffer (bi is where we left off)*/</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">bi</span> <span class="o">&lt;=</span> <span class="n">dword_len</span><span class="p">;</span> <span class="n">bi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FLEX_MNG</span><span class="p">,</span> <span class="n">bi</span><span class="p">);</span>
		<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">bi</span><span class="p">]);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_set_fw_drv_ver_generic - Sends driver version to firmware</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @maj: driver version major number</span>
<span class="cm"> *  @min: driver version minor number</span>
<span class="cm"> *  @build: driver version build number</span>
<span class="cm"> *  @sub: driver version sub build number</span>
<span class="cm"> *</span>
<span class="cm"> *  Sends driver version number to firmware through the manageability</span>
<span class="cm"> *  block.  On success return 0</span>
<span class="cm"> *  else returns IXGBE_ERR_SWFW_SYNC when encountering an error acquiring</span>
<span class="cm"> *  semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_set_fw_drv_ver_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">maj</span><span class="p">,</span> <span class="n">u8</span> <span class="n">min</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">build</span><span class="p">,</span> <span class="n">u8</span> <span class="n">sub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_hic_drv_info</span> <span class="n">fw_cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire_swfw_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GSSR_SW_MNG_SM</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_SWFW_SYNC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">FW_CEM_CMD_DRIVER_INFO</span><span class="p">;</span>
	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">buf_len</span> <span class="o">=</span> <span class="n">FW_CEM_CMD_DRIVER_INFO_LEN</span><span class="p">;</span>
	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd_or_resp</span><span class="p">.</span><span class="n">cmd_resv</span> <span class="o">=</span> <span class="n">FW_CEM_CMD_RESERVED</span><span class="p">;</span>
	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">port_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">func</span><span class="p">;</span>
	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">ver_maj</span> <span class="o">=</span> <span class="n">maj</span><span class="p">;</span>
	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">ver_min</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">ver_build</span> <span class="o">=</span> <span class="n">build</span><span class="p">;</span>
	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">ver_sub</span> <span class="o">=</span> <span class="n">sub</span><span class="p">;</span>
	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">checksum</span> <span class="o">=</span> <span class="n">ixgbe_calculate_checksum</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fw_cmd</span><span class="p">,</span>
				<span class="p">(</span><span class="n">FW_CEM_HDR_LEN</span> <span class="o">+</span> <span class="n">fw_cmd</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">buf_len</span><span class="p">));</span>
	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fw_cmd</span><span class="p">.</span><span class="n">pad2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">FW_CEM_MAX_RETRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_host_interface_command</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fw_cmd</span><span class="p">,</span>
						       <span class="k">sizeof</span><span class="p">(</span><span class="n">fw_cmd</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fw_cmd</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd_or_resp</span><span class="p">.</span><span class="n">ret_status</span> <span class="o">==</span>
		    <span class="n">FW_CEM_RESP_STATUS_SUCCESS</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_HOST_INTERFACE_COMMAND</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release_swfw_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GSSR_SW_MNG_SM</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_clear_tx_pending - Clear pending TX work from the PCIe fifo</span>
<span class="cm"> * @hw: pointer to the hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> * The 82599 and x540 MACs can experience issues if TX work is still pending</span>
<span class="cm"> * when a reset occurs.  This function prevents this by flushing the PCIe</span>
<span class="cm"> * buffers on the system.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">ixgbe_clear_tx_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">gcr_ext</span><span class="p">,</span> <span class="n">hlreg0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If double reset is not requested then all transactions should</span>
<span class="cm">	 * already be clear and as such there is no work to do</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAGS_DOUBLE_RESET_REQUIRED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set loopback enable to prevent any transmits from being sent</span>
<span class="cm">	 * should the link come up.  This assumes that the RXCTRL.RXEN bit</span>
<span class="cm">	 * has already been cleared.</span>
<span class="cm">	 */</span>
	<span class="n">hlreg0</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_HLREG0</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_HLREG0</span><span class="p">,</span> <span class="n">hlreg0</span> <span class="o">|</span> <span class="n">IXGBE_HLREG0_LPBK</span><span class="p">);</span>

	<span class="cm">/* initiate cleaning flow for buffers in the PCIe transaction layer */</span>
	<span class="n">gcr_ext</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GCR_EXT</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GCR_EXT</span><span class="p">,</span>
			<span class="n">gcr_ext</span> <span class="o">|</span> <span class="n">IXGBE_GCR_EXT_BUFFERS_CLEAR</span><span class="p">);</span>

	<span class="cm">/* Flush all writes and allow 20usec for all transactions to clear */</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

	<span class="cm">/* restore previous register values */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GCR_EXT</span><span class="p">,</span> <span class="n">gcr_ext</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_HLREG0</span><span class="p">,</span> <span class="n">hlreg0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">ixgbe_emc_temp_data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">IXGBE_EMC_INTERNAL_DATA</span><span class="p">,</span>
	<span class="n">IXGBE_EMC_DIODE1_DATA</span><span class="p">,</span>
	<span class="n">IXGBE_EMC_DIODE2_DATA</span><span class="p">,</span>
	<span class="n">IXGBE_EMC_DIODE3_DATA</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">ixgbe_emc_therm_limit</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">IXGBE_EMC_INTERNAL_THERM_LIMIT</span><span class="p">,</span>
	<span class="n">IXGBE_EMC_DIODE1_THERM_LIMIT</span><span class="p">,</span>
	<span class="n">IXGBE_EMC_DIODE2_THERM_LIMIT</span><span class="p">,</span>
	<span class="n">IXGBE_EMC_DIODE3_THERM_LIMIT</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_ets_data - Extracts the ETS bit data</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @ets_cfg: extected ETS data</span>
<span class="cm"> *  @ets_offset: offset of ETS data</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns error code.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_get_ets_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">ets_cfg</span><span class="p">,</span>
			      <span class="n">u16</span> <span class="o">*</span><span class="n">ets_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ETS_CFG</span><span class="p">,</span> <span class="n">ets_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ets_offset</span> <span class="o">==</span> <span class="mh">0x0000</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">ets_offset</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_NOT_IMPLEMENTED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">*</span><span class="n">ets_offset</span><span class="p">,</span> <span class="n">ets_cfg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ets_cfg</span> <span class="o">&amp;</span> <span class="n">IXGBE_ETS_TYPE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">IXGBE_ETS_TYPE_EMC_SHIFTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_NOT_IMPLEMENTED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_thermal_sensor_data - Gathers thermal sensor data</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns the thermal sensor data structure</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_get_thermal_sensor_data_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ets_offset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ets_cfg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ets_sensor</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">num_sensors</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ixgbe_thermal_sensor_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">thermal_sensor_data</span><span class="p">;</span>

	<span class="cm">/* Only support thermal sensors attached to physical port 0 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IXGBE_STATUS_LAN_ID_1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_NOT_IMPLEMENTED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_get_ets_data</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ets_cfg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ets_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">num_sensors</span> <span class="o">=</span> <span class="p">(</span><span class="n">ets_cfg</span> <span class="o">&amp;</span> <span class="n">IXGBE_ETS_NUM_SENSORS_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_sensors</span> <span class="o">&gt;</span> <span class="n">IXGBE_MAX_SENSORS</span><span class="p">)</span>
		<span class="n">num_sensors</span> <span class="o">=</span> <span class="n">IXGBE_MAX_SENSORS</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_sensors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span>  <span class="n">sensor_index</span><span class="p">;</span>
		<span class="n">u8</span>  <span class="n">sensor_location</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">ets_offset</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span>
					     <span class="o">&amp;</span><span class="n">ets_sensor</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">sensor_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">ets_sensor</span> <span class="o">&amp;</span> <span class="n">IXGBE_ETS_DATA_INDEX_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				<span class="n">IXGBE_ETS_DATA_INDEX_SHIFT</span><span class="p">);</span>
		<span class="n">sensor_location</span> <span class="o">=</span> <span class="p">((</span><span class="n">ets_sensor</span> <span class="o">&amp;</span> <span class="n">IXGBE_ETS_DATA_LOC_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				   <span class="n">IXGBE_ETS_DATA_LOC_SHIFT</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sensor_location</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_i2c_byte</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
					<span class="n">ixgbe_emc_temp_data</span><span class="p">[</span><span class="n">sensor_index</span><span class="p">],</span>
					<span class="n">IXGBE_I2C_THERMAL_SENSOR_ADDR</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">sensor</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">temp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_init_thermal_sensor_thresh_generic - Inits thermal sensor thresholds</span>
<span class="cm"> * @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> * Inits the thermal sensor thresholds according to the NVM map</span>
<span class="cm"> * and save off the threshold and location values into mac.thermal_sensor_data</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_init_thermal_sensor_thresh_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ets_offset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ets_cfg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ets_sensor</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">low_thresh_delta</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">num_sensors</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">therm_limit</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ixgbe_thermal_sensor_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">thermal_sensor_data</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_thermal_sensor_data</span><span class="p">));</span>

	<span class="cm">/* Only support thermal sensors attached to physical port 0 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IXGBE_STATUS_LAN_ID_1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_NOT_IMPLEMENTED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_get_ets_data</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ets_cfg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ets_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">low_thresh_delta</span> <span class="o">=</span> <span class="p">((</span><span class="n">ets_cfg</span> <span class="o">&amp;</span> <span class="n">IXGBE_ETS_LTHRES_DELTA_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			     <span class="n">IXGBE_ETS_LTHRES_DELTA_SHIFT</span><span class="p">);</span>
	<span class="n">num_sensors</span> <span class="o">=</span> <span class="p">(</span><span class="n">ets_cfg</span> <span class="o">&amp;</span> <span class="n">IXGBE_ETS_NUM_SENSORS_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_sensors</span> <span class="o">&gt;</span> <span class="n">IXGBE_MAX_SENSORS</span><span class="p">)</span>
		<span class="n">num_sensors</span> <span class="o">=</span> <span class="n">IXGBE_MAX_SENSORS</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_sensors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span>  <span class="n">sensor_index</span><span class="p">;</span>
		<span class="n">u8</span>  <span class="n">sensor_location</span><span class="p">;</span>

		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">ets_offset</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ets_sensor</span><span class="p">);</span>
		<span class="n">sensor_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">ets_sensor</span> <span class="o">&amp;</span> <span class="n">IXGBE_ETS_DATA_INDEX_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				<span class="n">IXGBE_ETS_DATA_INDEX_SHIFT</span><span class="p">);</span>
		<span class="n">sensor_location</span> <span class="o">=</span> <span class="p">((</span><span class="n">ets_sensor</span> <span class="o">&amp;</span> <span class="n">IXGBE_ETS_DATA_LOC_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				   <span class="n">IXGBE_ETS_DATA_LOC_SHIFT</span><span class="p">);</span>
		<span class="n">therm_limit</span> <span class="o">=</span> <span class="n">ets_sensor</span> <span class="o">&amp;</span> <span class="n">IXGBE_ETS_DATA_HTHRESH_MASK</span><span class="p">;</span>

		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write_i2c_byte</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			<span class="n">ixgbe_emc_therm_limit</span><span class="p">[</span><span class="n">sensor_index</span><span class="p">],</span>
			<span class="n">IXGBE_I2C_THERMAL_SENSOR_ADDR</span><span class="p">,</span> <span class="n">therm_limit</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sensor_location</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">data</span><span class="o">-&gt;</span><span class="n">sensor</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">location</span> <span class="o">=</span> <span class="n">sensor_location</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">sensor</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">caution_thresh</span> <span class="o">=</span> <span class="n">therm_limit</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">sensor</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">max_op_thresh</span> <span class="o">=</span> <span class="n">therm_limit</span> <span class="o">-</span> <span class="n">low_thresh_delta</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
