<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › ixgbe › ixgbe_ptp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>ixgbe_ptp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel 10 Gigabit PCI Express Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>
<span class="cp">#include &quot;ixgbe.h&quot;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The 82599 and the X540 do not have true 64bit nanosecond scale</span>
<span class="cm"> * counter registers. Instead, SYSTIME is defined by a fixed point</span>
<span class="cm"> * system which allows the user to define the scale counter increment</span>
<span class="cm"> * value at every level change of the oscillator driving the SYSTIME</span>
<span class="cm"> * value. For both devices the TIMINCA:IV field defines this</span>
<span class="cm"> * increment. On the X540 device, 31 bits are provided. However on the</span>
<span class="cm"> * 82599 only provides 24 bits. The time unit is determined by the</span>
<span class="cm"> * clock frequency of the oscillator in combination with the TIMINCA</span>
<span class="cm"> * register. When these devices link at 10Gb the oscillator has a</span>
<span class="cm"> * period of 6.4ns. In order to convert the scale counter into</span>
<span class="cm"> * nanoseconds the cyclecounter and timecounter structures are</span>
<span class="cm"> * used. The SYSTIME registers need to be converted to ns values by use</span>
<span class="cm"> * of only a right shift (division by power of 2). The following math</span>
<span class="cm"> * determines the largest incvalue that will fit into the available</span>
<span class="cm"> * bits in the TIMINCA register.</span>
<span class="cm"> *</span>
<span class="cm"> * PeriodWidth: Number of bits to store the clock period</span>
<span class="cm"> * MaxWidth: The maximum width value of the TIMINCA register</span>
<span class="cm"> * Period: The clock period for the oscillator</span>
<span class="cm"> * round(): discard the fractional portion of the calculation</span>
<span class="cm"> *</span>
<span class="cm"> * Period * [ 2 ^ ( MaxWidth - PeriodWidth ) ]</span>
<span class="cm"> *</span>
<span class="cm"> * For the X540, MaxWidth is 31 bits, and the base period is 6.4 ns</span>
<span class="cm"> * For the 82599, MaxWidth is 24 bits, and the base period is 6.4 ns</span>
<span class="cm"> *</span>
<span class="cm"> * The period also changes based on the link speed:</span>
<span class="cm"> * At 10Gb link or no link, the period remains the same.</span>
<span class="cm"> * At 1Gb link, the period is multiplied by 10. (64ns)</span>
<span class="cm"> * At 100Mb link, the period is multiplied by 100. (640ns)</span>
<span class="cm"> *</span>
<span class="cm"> * The calculated value allows us to right shift the SYSTIME register</span>
<span class="cm"> * value in order to quickly convert it into a nanosecond clock,</span>
<span class="cm"> * while allowing for the maximum possible adjustment value.</span>
<span class="cm"> *</span>
<span class="cm"> * These diagrams are only for the 10Gb link period</span>
<span class="cm"> *</span>
<span class="cm"> *           SYSTIMEH            SYSTIMEL</span>
<span class="cm"> *       +--------------+  +--------------+</span>
<span class="cm"> * X540  |      32      |  | 1 | 3 |  28  |</span>
<span class="cm"> *       *--------------+  +--------------+</span>
<span class="cm"> *        \________ 36 bits ______/  fract</span>
<span class="cm"> *</span>
<span class="cm"> *       +--------------+  +--------------+</span>
<span class="cm"> * 82599 |      32      |  | 8 | 3 |  21  |</span>
<span class="cm"> *       *--------------+  +--------------+</span>
<span class="cm"> *        \________ 43 bits ______/  fract</span>
<span class="cm"> *</span>
<span class="cm"> * The 36 bit X540 SYSTIME overflows every</span>
<span class="cm"> *   2^36 * 10^-9 / 60 = 1.14 minutes or 69 seconds</span>
<span class="cm"> *</span>
<span class="cm"> * The 43 bit 82599 SYSTIME overflows every</span>
<span class="cm"> *   2^43 * 10^-9 / 3600 = 2.4 hours</span>
<span class="cm"> */</span>
<span class="cp">#define IXGBE_INCVAL_10GB 0x66666666</span>
<span class="cp">#define IXGBE_INCVAL_1GB  0x40000000</span>
<span class="cp">#define IXGBE_INCVAL_100  0x50000000</span>

<span class="cp">#define IXGBE_INCVAL_SHIFT_10GB  28</span>
<span class="cp">#define IXGBE_INCVAL_SHIFT_1GB   24</span>
<span class="cp">#define IXGBE_INCVAL_SHIFT_100   21</span>

<span class="cp">#define IXGBE_INCVAL_SHIFT_82599 7</span>
<span class="cp">#define IXGBE_INCPER_SHIFT_82599 24</span>
<span class="cp">#define IXGBE_MAX_TIMEADJ_VALUE  0x7FFFFFFFFFFFFFFFULL</span>

<span class="cp">#define IXGBE_OVERFLOW_PERIOD    (HZ * 30)</span>

<span class="cp">#ifndef NSECS_PER_SEC</span>
<span class="cp">#define NSECS_PER_SEC 1000000000ULL</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_read - read raw cycle counter (to be used by time counter)</span>
<span class="cm"> * @cc - the cyclecounter structure</span>
<span class="cm"> *</span>
<span class="cm"> * this function reads the cyclecounter registers and is called by the</span>
<span class="cm"> * cyclecounter structure used to construct a ns counter from the</span>
<span class="cm"> * arbitrary fixed point registers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">cycle_t</span> <span class="nf">ixgbe_ptp_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cyclecounter</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ixgbe_adapter</span><span class="p">,</span> <span class="n">cc</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">stamp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SYSTIML</span><span class="p">);</span>
	<span class="n">stamp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SYSTIMH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">stamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_adjfreq</span>
<span class="cm"> * @ptp - the ptp clock structure</span>
<span class="cm"> * @ppb - parts per billion adjustment from base</span>
<span class="cm"> *</span>
<span class="cm"> * adjust the frequency of the ptp cycle counter by the</span>
<span class="cm"> * indicated ppb from the base frequency.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ixgbe_ptp_adjfreq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptp_clock_info</span> <span class="o">*</span><span class="n">ptp</span><span class="p">,</span> <span class="n">s32</span> <span class="n">ppb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">ptp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ixgbe_adapter</span><span class="p">,</span> <span class="n">ptp_caps</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">freq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">diff</span><span class="p">,</span> <span class="n">incval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">neg_adj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">neg_adj</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ppb</span> <span class="o">=</span> <span class="o">-</span><span class="n">ppb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">incval</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">base_incval</span><span class="p">);</span>

	<span class="n">freq</span> <span class="o">=</span> <span class="n">incval</span><span class="p">;</span>
	<span class="n">freq</span> <span class="o">*=</span> <span class="n">ppb</span><span class="p">;</span>
	<span class="n">diff</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="mi">1000000000ULL</span><span class="p">);</span>

	<span class="n">incval</span> <span class="o">=</span> <span class="n">neg_adj</span> <span class="o">?</span> <span class="p">(</span><span class="n">incval</span> <span class="o">-</span> <span class="n">diff</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">incval</span> <span class="o">+</span> <span class="n">diff</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_X540</span>:
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TIMINCA</span><span class="p">,</span> <span class="n">incval</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_82599EB</span>:
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TIMINCA</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_INCPER_SHIFT_82599</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">incval</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_adjtime</span>
<span class="cm"> * @ptp - the ptp clock structure</span>
<span class="cm"> * @delta - offset to adjust the cycle counter by</span>
<span class="cm"> *</span>
<span class="cm"> * adjust the timer by resetting the timecounter structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ixgbe_ptp_adjtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptp_clock_info</span> <span class="o">*</span><span class="n">ptp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">ptp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ixgbe_adapter</span><span class="p">,</span> <span class="n">ptp_caps</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">timecounter_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">);</span>
	<span class="n">now</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>

	<span class="cm">/* reset the timecounter */</span>
	<span class="n">timecounter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">,</span>
			 <span class="n">now</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_gettime</span>
<span class="cm"> * @ptp - the ptp clock structure</span>
<span class="cm"> * @ts - timespec structure to hold the current time value</span>
<span class="cm"> *</span>
<span class="cm"> * read the timecounter and return the correct value on ns,</span>
<span class="cm"> * after converting it into a struct timespec.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ixgbe_ptp_gettime</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptp_clock_info</span> <span class="o">*</span><span class="n">ptp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">ptp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ixgbe_adapter</span><span class="p">,</span> <span class="n">ptp_caps</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">ns</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">remainder</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">timecounter_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="mi">1000000000ULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remainder</span><span class="p">);</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_settime</span>
<span class="cm"> * @ptp - the ptp clock structure</span>
<span class="cm"> * @ts - the timespec containing the new time for the cycle counter</span>
<span class="cm"> *</span>
<span class="cm"> * reset the timecounter to use a new base value instead of the kernel</span>
<span class="cm"> * wall timer value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ixgbe_ptp_settime</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptp_clock_info</span> <span class="o">*</span><span class="n">ptp</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">ptp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ixgbe_adapter</span><span class="p">,</span> <span class="n">ptp_caps</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">ns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000000000ULL</span><span class="p">;</span>
	<span class="n">ns</span> <span class="o">+=</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">;</span>

	<span class="cm">/* reset the timecounter */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">timecounter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_enable</span>
<span class="cm"> * @ptp - the ptp clock structure</span>
<span class="cm"> * @rq - the requested feature to change</span>
<span class="cm"> * @on - whether to enable or disable the feature</span>
<span class="cm"> *</span>
<span class="cm"> * enable (or disable) ancillary features of the phc subsystem.</span>
<span class="cm"> * our driver only supports the PPS feature on the X540</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ixgbe_ptp_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptp_clock_info</span> <span class="o">*</span><span class="n">ptp</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ptp_clock_request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">ptp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ixgbe_adapter</span><span class="p">,</span> <span class="n">ptp_caps</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * When PPS is enabled, unmask the interrupt for the ClockOut</span>
<span class="cm">	 * feature, so that the interrupt handler can send the PPS</span>
<span class="cm">	 * event when the clock SDP triggers. Clear mask when PPS is</span>
<span class="cm">	 * disabled</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PTP_CLK_REQ_PPS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ixgbe_mac_X540</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">|=</span> <span class="n">IXGBE_FLAG2_PTP_PPS_ENABLED</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;=</span>
					<span class="o">~</span><span class="n">IXGBE_FLAG2_PTP_PPS_ENABLED</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_check_pps_event</span>
<span class="cm"> * @adapter - the private adapter structure</span>
<span class="cm"> * @eicr - the interrupt cause register value</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the interrupt routine when checking for</span>
<span class="cm"> * interrupts. It will check and handle a pps event.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ixgbe_ptp_check_pps_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">eicr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptp_clock_event</span> <span class="n">event</span><span class="p">;</span>

	<span class="n">event</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">PTP_CLOCK_PPS</span><span class="p">;</span>

	<span class="cm">/* Make sure ptp clock is valid, and PPS event enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_clock</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG2_PTP_PPS_ENABLED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_X540</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">eicr</span> <span class="o">&amp;</span> <span class="n">IXGBE_EICR_TIMESYNC</span><span class="p">)</span>
			<span class="n">ptp_clock_event</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_clock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_enable_sdp</span>
<span class="cm"> * @hw - the hardware private structure</span>
<span class="cm"> * @shift - the clock shift for calculating nanoseconds</span>
<span class="cm"> *</span>
<span class="cm"> * this function enables the clock out feature on the sdp0 for the</span>
<span class="cm"> * X540 device. It will create a 1second periodic output that can be</span>
<span class="cm"> * used as the PPS (via an interrupt).</span>
<span class="cm"> *</span>
<span class="cm"> * It calculates when the systime will be on an exact second, and then</span>
<span class="cm"> * aligns the start of the PPS signal to that value. The shift is</span>
<span class="cm"> * necessary because it can change based on the link speed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_ptp_enable_sdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">esdp</span><span class="p">,</span> <span class="n">tsauxc</span><span class="p">,</span> <span class="n">clktiml</span><span class="p">,</span> <span class="n">clktimh</span><span class="p">,</span> <span class="n">trgttiml</span><span class="p">,</span> <span class="n">trgttimh</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">clock_edge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rem</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_X540</span>:
		<span class="n">esdp</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ESDP</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * enable the SDP0 pin as output, and connected to the native</span>
<span class="cm">		 * function for Timesync (ClockOut)</span>
<span class="cm">		 */</span>
		<span class="n">esdp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IXGBE_ESDP_SDP0_DIR</span> <span class="o">|</span>
			 <span class="n">IXGBE_ESDP_SDP0_NATIVE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * enable the Clock Out feature on SDP0, and allow interrupts</span>
<span class="cm">		 * to occur when the pin changes</span>
<span class="cm">		 */</span>
		<span class="n">tsauxc</span> <span class="o">=</span> <span class="p">(</span><span class="n">IXGBE_TSAUXC_EN_CLK</span> <span class="o">|</span>
			  <span class="n">IXGBE_TSAUXC_SYNCLK</span> <span class="o">|</span>
			  <span class="n">IXGBE_TSAUXC_SDP0_INT</span><span class="p">);</span>

		<span class="cm">/* clock period (or pulse length) */</span>
		<span class="n">clktiml</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">NSECS_PER_SEC</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">);</span>
		<span class="n">clktimh</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)((</span><span class="n">NSECS_PER_SEC</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>

		<span class="n">clock_edge</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SYSTIML</span><span class="p">);</span>
		<span class="n">clock_edge</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SYSTIMH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * account for the fact that we can&#39;t do u64 division</span>
<span class="cm">		 * with remainder, by converting the clock values into</span>
<span class="cm">		 * nanoseconds first</span>
<span class="cm">		 */</span>
		<span class="n">clock_edge</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>
		<span class="n">div_u64_rem</span><span class="p">(</span><span class="n">clock_edge</span><span class="p">,</span> <span class="n">NSECS_PER_SEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem</span><span class="p">);</span>
		<span class="n">clock_edge</span> <span class="o">+=</span> <span class="p">(</span><span class="n">NSECS_PER_SEC</span> <span class="o">-</span> <span class="n">rem</span><span class="p">);</span>
		<span class="n">clock_edge</span> <span class="o">&lt;&lt;=</span> <span class="n">shift</span><span class="p">;</span>

		<span class="cm">/* specify the initial clock start time */</span>
		<span class="n">trgttiml</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">clock_edge</span><span class="p">;</span>
		<span class="n">trgttimh</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">clock_edge</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>

		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CLKTIML</span><span class="p">,</span> <span class="n">clktiml</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CLKTIMH</span><span class="p">,</span> <span class="n">clktimh</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TRGTTIML0</span><span class="p">,</span> <span class="n">trgttiml</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TRGTTIMH0</span><span class="p">,</span> <span class="n">trgttimh</span><span class="p">);</span>

		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ESDP</span><span class="p">,</span> <span class="n">esdp</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TSAUXC</span><span class="p">,</span> <span class="n">tsauxc</span><span class="p">);</span>

		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EIMS</span><span class="p">,</span> <span class="n">IXGBE_EICR_TIMESYNC</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_disable_sdp</span>
<span class="cm"> * @hw - the private hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> * this function disables the auxiliary SDP clock out feature</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_ptp_disable_sdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_EIMC</span><span class="p">,</span> <span class="n">IXGBE_EICR_TIMESYNC</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TSAUXC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_overflow_check - delayed work to detect SYSTIME overflow</span>
<span class="cm"> * @work: structure containing information about this work task</span>
<span class="cm"> *</span>
<span class="cm"> * this work function is scheduled to continue reading the timecounter</span>
<span class="cm"> * in order to prevent missing when the system time registers wrap</span>
<span class="cm"> * around. This needs to be run approximately twice a minute when no</span>
<span class="cm"> * PTP activity is occurring.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ixgbe_ptp_overflow_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elapsed_jiffies</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">last_overflow_check</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG2_OVERFLOW_CHECK_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">elapsed_jiffies</span> <span class="o">&gt;=</span> <span class="n">IXGBE_OVERFLOW_PERIOD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ixgbe_ptp_gettime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">last_overflow_check</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_tx_hwtstamp - utility function which checks for TX time stamp</span>
<span class="cm"> * @q_vector: structure containing interrupt and ring information</span>
<span class="cm"> * @skb: particular skb to send timestamp with</span>
<span class="cm"> *</span>
<span class="cm"> * if the timestamp is valid, we convert it into the timecounter ns</span>
<span class="cm"> * value, then store that result into the shhwtstamps structure which</span>
<span class="cm"> * is passed up the network stack</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ixgbe_ptp_tx_hwtstamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="n">shhwtstamps</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">regval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ns</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tsynctxctl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* we cannot process timestamps on a ring without a q_vector */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q_vector</span> <span class="o">||</span> <span class="o">!</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">tsynctxctl</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TSYNCTXCTL</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TXSTMPL</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TXSTMPH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if TX timestamp is not valid, exit after clearing the</span>
<span class="cm">	 * timestamp registers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tsynctxctl</span> <span class="o">&amp;</span> <span class="n">IXGBE_TSYNCTXCTL_VALID</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">timecounter_cyc2time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shhwtstamps</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shhwtstamps</span><span class="p">));</span>
	<span class="n">shhwtstamps</span><span class="p">.</span><span class="n">hwtstamp</span> <span class="o">=</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">skb_tstamp_tx</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shhwtstamps</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_rx_hwtstamp - utility function which checks for RX time stamp</span>
<span class="cm"> * @q_vector: structure containing interrupt and ring information</span>
<span class="cm"> * @skb: particular skb to send timestamp with</span>
<span class="cm"> *</span>
<span class="cm"> * if the timestamp is valid, we convert it into the timecounter ns</span>
<span class="cm"> * value, then store that result into the shhwtstamps structure which</span>
<span class="cm"> * is passed up the network stack</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ixgbe_ptp_rx_hwtstamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="o">*</span><span class="n">shhwtstamps</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">regval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ns</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tsyncrxctl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* we cannot process timestamps on a ring without a q_vector */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q_vector</span> <span class="o">||</span> <span class="o">!</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">tsyncrxctl</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TSYNCRXCTL</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXSTMPL</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXSTMPH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this bit is set, then the RX registers contain the time stamp. No</span>
<span class="cm">	 * other packet will be time stamped until we read these registers, so</span>
<span class="cm">	 * read the registers to make them available again. Because only one</span>
<span class="cm">	 * packet can be time stamped at a time, we know that the register</span>
<span class="cm">	 * values must belong to this one here and therefore we don&#39;t need to</span>
<span class="cm">	 * compare any of the additional attributes stored for it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If nothing went wrong, then it should have a skb_shared_tx that we</span>
<span class="cm">	 * can turn into a skb_shared_hwtstamps.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tsyncrxctl</span> <span class="o">&amp;</span> <span class="n">IXGBE_TSYNCRXCTL_VALID</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">timecounter_cyc2time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">shhwtstamps</span> <span class="o">=</span> <span class="n">skb_hwtstamps</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">shhwtstamps</span><span class="o">-&gt;</span><span class="n">hwtstamp</span> <span class="o">=</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_hwtstamp_ioctl - control hardware time stamping</span>
<span class="cm"> * @adapter: pointer to adapter struct</span>
<span class="cm"> * @ifreq: ioctl data</span>
<span class="cm"> * @cmd: particular ioctl requested</span>
<span class="cm"> *</span>
<span class="cm"> * Outgoing time stamping can be enabled and disabled. Play nice and</span>
<span class="cm"> * disable it when requested, although it shouldn&#39;t case any overhead</span>
<span class="cm"> * when no packet needs it. At most one packet in the queue may be</span>
<span class="cm"> * marked for time stamping, otherwise it would be impossible to tell</span>
<span class="cm"> * for sure to which packet the hardware time stamp belongs.</span>
<span class="cm"> *</span>
<span class="cm"> * Incoming time stamping has to be configured via the hardware</span>
<span class="cm"> * filters. Not all combinations are supported, in particular event</span>
<span class="cm"> * type has to be specified. Matching the kind of event packet is</span>
<span class="cm"> * not supported, with the exception of &quot;all V2 events regardless of</span>
<span class="cm"> * level 2 or 4&quot;.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ixgbe_ptp_hwtstamp_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hwtstamp_config</span> <span class="n">config</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tsync_tx_ctl</span> <span class="o">=</span> <span class="n">IXGBE_TSYNCTXCTL_ENABLED</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tsync_rx_ctl</span> <span class="o">=</span> <span class="n">IXGBE_TSYNCRXCTL_ENABLED</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tsync_rx_mtrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_l4</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_l2</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">regval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">config</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* reserved for future extensions */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">tx_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_TX_OFF</span>:
		<span class="n">tsync_tx_ctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_TX_ON</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">rx_filter</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_NONE</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V1_L4_SYNC</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">IXGBE_TSYNCRXCTL_TYPE_L4_V1</span><span class="p">;</span>
		<span class="n">tsync_rx_mtrl</span> <span class="o">=</span> <span class="n">IXGBE_RXMTRL_V1_SYNC_MSG</span><span class="p">;</span>
		<span class="n">is_l4</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">IXGBE_TSYNCRXCTL_TYPE_L4_V1</span><span class="p">;</span>
		<span class="n">tsync_rx_mtrl</span> <span class="o">=</span> <span class="n">IXGBE_RXMTRL_V1_DELAY_REQ_MSG</span><span class="p">;</span>
		<span class="n">is_l4</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_SYNC</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L2_SYNC</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L4_SYNC</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">IXGBE_TSYNCRXCTL_TYPE_L2_L4_V2</span><span class="p">;</span>
		<span class="n">tsync_rx_mtrl</span> <span class="o">=</span> <span class="n">IXGBE_RXMTRL_V2_SYNC_MSG</span><span class="p">;</span>
		<span class="n">is_l2</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">is_l4</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">config</span><span class="p">.</span><span class="n">rx_filter</span> <span class="o">=</span> <span class="n">HWTSTAMP_FILTER_SOME</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_DELAY_REQ</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">IXGBE_TSYNCRXCTL_TYPE_L2_L4_V2</span><span class="p">;</span>
		<span class="n">tsync_rx_mtrl</span> <span class="o">=</span> <span class="n">IXGBE_RXMTRL_V2_DELAY_REQ_MSG</span><span class="p">;</span>
		<span class="n">is_l2</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">is_l4</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">config</span><span class="p">.</span><span class="n">rx_filter</span> <span class="o">=</span> <span class="n">HWTSTAMP_FILTER_SOME</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L4_EVENT</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L2_EVENT</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_EVENT</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">IXGBE_TSYNCRXCTL_TYPE_EVENT_V2</span><span class="p">;</span>
		<span class="n">config</span><span class="p">.</span><span class="n">rx_filter</span> <span class="o">=</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_EVENT</span><span class="p">;</span>
		<span class="n">is_l2</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">is_l4</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V1_L4_EVENT</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_ALL</span>:
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * register RXMTRL must be set, therefore it is not</span>
<span class="cm">		 * possible to time stamp both V1 Sync and Delay_Req messages</span>
<span class="cm">		 * and hardware does not support timestamping all packets</span>
<span class="cm">		 * =&gt; return error</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_mac_82598EB</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsync_rx_ctl</span> <span class="o">|</span> <span class="n">tsync_tx_ctl</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* define ethertype filter for timestamped packets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_l2</span><span class="p">)</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ETQF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
				<span class="p">(</span><span class="n">IXGBE_ETQF_FILTER_EN</span> <span class="o">|</span> <span class="cm">/* enable filter */</span>
				 <span class="n">IXGBE_ETQF_1588</span> <span class="o">|</span> <span class="cm">/* enable timestamping */</span>
				 <span class="n">ETH_P_1588</span><span class="p">));</span>     <span class="cm">/* 1588 eth protocol type */</span>
	<span class="k">else</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ETQF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#define PTP_PORT 319</span>
	<span class="cm">/* L4 Queue Filter[3]: filter by destination port and protocol */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_l4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ftqf</span> <span class="o">=</span> <span class="p">(</span><span class="n">IXGBE_FTQF_PROTOCOL_UDP</span> <span class="cm">/* UDP */</span>
			    <span class="o">|</span> <span class="n">IXGBE_FTQF_POOL_MASK_EN</span> <span class="cm">/* Pool not compared */</span>
			    <span class="o">|</span> <span class="n">IXGBE_FTQF_QUEUE_ENABLE</span><span class="p">);</span>

		<span class="n">ftqf</span> <span class="o">|=</span> <span class="p">((</span><span class="n">IXGBE_FTQF_PROTOCOL_COMP_MASK</span> <span class="cm">/* protocol check */</span>
			  <span class="o">&amp;</span> <span class="n">IXGBE_FTQF_DEST_PORT_MASK</span> <span class="cm">/* dest check */</span>
			  <span class="o">&amp;</span> <span class="n">IXGBE_FTQF_SOURCE_PORT_MASK</span><span class="p">)</span> <span class="cm">/* source check */</span>
			 <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FTQF_5TUPLE_MASK_SHIFT</span><span class="p">);</span>

		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_L34T_IMIR</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
				<span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_IMIR_RX_QUEUE_SHIFT_82599</span> <span class="o">|</span>
				 <span class="n">IXGBE_IMIR_SIZE_BP_82599</span><span class="p">));</span>

		<span class="cm">/* enable port check */</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SDPQF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
				<span class="p">(</span><span class="n">htons</span><span class="p">(</span><span class="n">PTP_PORT</span><span class="p">)</span> <span class="o">|</span>
				 <span class="n">htons</span><span class="p">(</span><span class="n">PTP_PORT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">));</span>

		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FTQF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ftqf</span><span class="p">);</span>

		<span class="n">tsync_rx_mtrl</span> <span class="o">|=</span> <span class="n">PTP_PORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FTQF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* enable/disable TX */</span>
	<span class="n">regval</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TSYNCTXCTL</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_TSYNCTXCTL_ENABLED</span><span class="p">;</span>
	<span class="n">regval</span> <span class="o">|=</span> <span class="n">tsync_tx_ctl</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TSYNCTXCTL</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>

	<span class="cm">/* enable/disable RX */</span>
	<span class="n">regval</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TSYNCRXCTL</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_TSYNCRXCTL_ENABLED</span> <span class="o">|</span> <span class="n">IXGBE_TSYNCRXCTL_TYPE_MASK</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">|=</span> <span class="n">tsync_rx_ctl</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TSYNCRXCTL</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>

	<span class="cm">/* define which PTP packets are time stamped */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXMTRL</span><span class="p">,</span> <span class="n">tsync_rx_mtrl</span><span class="p">);</span>

	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* clear TX/RX time stamp registers, just to be sure */</span>
	<span class="n">regval</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TXSTMPH</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXSTMPH</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">config</span><span class="p">))</span> <span class="o">?</span>
		<span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_start_cyclecounter - create the cycle counter from hw</span>
<span class="cm"> * @adapter - pointer to the adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * this function initializes the timecounter and cyclecounter</span>
<span class="cm"> * structures for use in generated a ns counter from the arbitrary</span>
<span class="cm"> * fixed point cycles registers in the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * A change in link speed impacts the frequency of the DMA clock on</span>
<span class="cm"> * the device, which is used to generate the cycle counter</span>
<span class="cm"> * registers. Therefor this function is called whenever the link speed</span>
<span class="cm"> * changes.</span>
<span class="cm"> *</span>
<span class="cm"> * This function also turns on the SDP pin for clock out feature (X540</span>
<span class="cm"> * only), because this is where the shift is first calculated.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ixgbe_ptp_start_cyclecounter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">incval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">timinca</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cycle_speed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Determine what speed we need to set the cyclecounter</span>
<span class="cm">	 * for. It should be different for 100Mb, 1Gb, and 10Gb. Treat</span>
<span class="cm">	 * unknown speeds as 10Gb. (Hence why we can&#39;t just copy the</span>
<span class="cm">	 * link_speed.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IXGBE_LINK_SPEED_100_FULL</span>:
	<span class="k">case</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span>:
	<span class="k">case</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span>:
		<span class="n">cycle_speed</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* cycle speed should be 10Gb when there is no link */</span>
		<span class="n">cycle_speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * grab the current TIMINCA value from the register so that it can be</span>
<span class="cm">	 * double checked. If the register value has been cleared, it must be</span>
<span class="cm">	 * reset to the correct value for generating a cyclecounter. If</span>
<span class="cm">	 * TIMINCA is zero, the SYSTIME registers do not increment at all.</span>
<span class="cm">	 */</span>
	<span class="n">timinca</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TIMINCA</span><span class="p">);</span>

	<span class="cm">/* Bail if the cycle speed didn&#39;t change and TIMINCA is non-zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cycle_speed</span> <span class="o">==</span> <span class="n">cycle_speed</span> <span class="o">&amp;&amp;</span> <span class="n">timinca</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* disable the SDP clock out */</span>
	<span class="n">ixgbe_ptp_disable_sdp</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * Scale the NIC cycle counter by a large factor so that</span>
<span class="cm">	 * relatively small corrections to the frequency can be added</span>
<span class="cm">	 * or subtracted. The drawbacks of a large factor include</span>
<span class="cm">	 * (a) the clock register overflows more quickly, (b) the cycle</span>
<span class="cm">	 * counter structure must be able to convert the systime value</span>
<span class="cm">	 * to nanoseconds using only a multiplier and a right-shift,</span>
<span class="cm">	 * and (c) the value must fit within the timinca register space</span>
<span class="cm">	 * =&gt; math based on internal DMA clock rate and available bits</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cycle_speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IXGBE_LINK_SPEED_100_FULL</span>:
		<span class="n">incval</span> <span class="o">=</span> <span class="n">IXGBE_INCVAL_100</span><span class="p">;</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="n">IXGBE_INCVAL_SHIFT_100</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span>:
		<span class="n">incval</span> <span class="o">=</span> <span class="n">IXGBE_INCVAL_1GB</span><span class="p">;</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="n">IXGBE_INCVAL_SHIFT_1GB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span>:
		<span class="n">incval</span> <span class="o">=</span> <span class="n">IXGBE_INCVAL_10GB</span><span class="p">;</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="n">IXGBE_INCVAL_SHIFT_10GB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/**</span>
<span class="cm">	 * Modify the calculated values to fit within the correct</span>
<span class="cm">	 * number of bits specified by the hardware. The 82599 doesn&#39;t</span>
<span class="cm">	 * have the same space as the X540, so bitshift the calculated</span>
<span class="cm">	 * values to fit.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_X540</span>:
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TIMINCA</span><span class="p">,</span> <span class="n">incval</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_82599EB</span>:
		<span class="n">incval</span> <span class="o">&gt;&gt;=</span> <span class="n">IXGBE_INCVAL_SHIFT_82599</span><span class="p">;</span>
		<span class="n">shift</span> <span class="o">-=</span> <span class="n">IXGBE_INCVAL_SHIFT_82599</span><span class="p">;</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_TIMINCA</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_INCPER_SHIFT_82599</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">incval</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* other devices aren&#39;t supported */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* reset the system time registers */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SYSTIML</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_SYSTIMH</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* now that the shift has been calculated and the systime</span>
<span class="cm">	 * registers reset, (re-)enable the Clock out feature*/</span>
	<span class="n">ixgbe_ptp_enable_sdp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>

	<span class="cm">/* store the new cycle speed */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cycle_speed</span> <span class="o">=</span> <span class="n">cycle_speed</span><span class="p">;</span>

	<span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">base_incval</span><span class="p">)</span> <span class="o">=</span> <span class="n">incval</span><span class="p">;</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* grab the ptp lock */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">));</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">ixgbe_ptp_read</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">CLOCKSOURCE_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">.</span><span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* reset the ns time counter */</span>
	<span class="n">timecounter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">,</span>
			 <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_get_real</span><span class="p">()));</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_init</span>
<span class="cm"> * @adapter - the ixgbe private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function performs the required steps for enabling ptp</span>
<span class="cm"> * support. If ptp support has already been loaded it simply calls the</span>
<span class="cm"> * cyclecounter init routine and exits.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ixgbe_ptp_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_X540</span>:
		<span class="n">snprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;%pm&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">max_adj</span> <span class="o">=</span> <span class="mi">250000000</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">n_alarm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">n_ext_ts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">n_per_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">pps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">adjfreq</span> <span class="o">=</span> <span class="n">ixgbe_ptp_adjfreq</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">adjtime</span> <span class="o">=</span> <span class="n">ixgbe_ptp_adjtime</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">gettime</span> <span class="o">=</span> <span class="n">ixgbe_ptp_gettime</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">settime</span> <span class="o">=</span> <span class="n">ixgbe_ptp_settime</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">enable</span> <span class="o">=</span> <span class="n">ixgbe_ptp_enable</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_82599EB</span>:
		<span class="n">snprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;%pm&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">max_adj</span> <span class="o">=</span> <span class="mi">250000000</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">n_alarm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">n_ext_ts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">n_per_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">pps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">adjfreq</span> <span class="o">=</span> <span class="n">ixgbe_ptp_adjfreq</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">adjtime</span> <span class="o">=</span> <span class="n">ixgbe_ptp_adjtime</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">gettime</span> <span class="o">=</span> <span class="n">ixgbe_ptp_gettime</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">settime</span> <span class="o">=</span> <span class="n">ixgbe_ptp_settime</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">.</span><span class="n">enable</span> <span class="o">=</span> <span class="n">ixgbe_ptp_enable</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_clock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tmreg_lock</span><span class="p">);</span>

	<span class="n">ixgbe_ptp_start_cyclecounter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* (Re)start the overflow check */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">|=</span> <span class="n">IXGBE_FLAG2_OVERFLOW_CHECK_ENABLED</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_clock</span> <span class="o">=</span> <span class="n">ptp_clock_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_caps</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_clock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_clock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">e_dev_err</span><span class="p">(</span><span class="s">&quot;ptp_clock_register failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">e_dev_info</span><span class="p">(</span><span class="s">&quot;registered PHC device on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_ptp_stop - disable ptp device and stop the overflow check</span>
<span class="cm"> * @adapter: pointer to adapter struct</span>
<span class="cm"> *</span>
<span class="cm"> * this function stops the ptp support, and cancels the delayed work.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ixgbe_ptp_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ixgbe_ptp_disable_sdp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* stop the overflow check task */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_FLAG2_OVERFLOW_CHECK_ENABLED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_clock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ptp_clock_unregister</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_clock</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_clock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">e_dev_info</span><span class="p">(</span><span class="s">&quot;removed PHC on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
