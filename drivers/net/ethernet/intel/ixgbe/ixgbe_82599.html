<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › ixgbe › ixgbe_82599.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>ixgbe_82599.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel 10 Gigabit PCI Express Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#include &quot;ixgbe.h&quot;</span>
<span class="cp">#include &quot;ixgbe_phy.h&quot;</span>
<span class="cp">#include &quot;ixgbe_mbx.h&quot;</span>

<span class="cp">#define IXGBE_82599_MAX_TX_QUEUES 128</span>
<span class="cp">#define IXGBE_82599_MAX_RX_QUEUES 128</span>
<span class="cp">#define IXGBE_82599_RAR_ENTRIES   128</span>
<span class="cp">#define IXGBE_82599_MC_TBL_SIZE   128</span>
<span class="cp">#define IXGBE_82599_VFT_TBL_SIZE  128</span>
<span class="cp">#define IXGBE_82599_RX_PB_SIZE	  512</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgbe_disable_tx_laser_multispeed_fiber</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgbe_enable_tx_laser_multispeed_fiber</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgbe_flap_tx_laser_multispeed_fiber</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_setup_mac_link_multispeed_fiber</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
						 <span class="n">ixgbe_link_speed</span> <span class="n">speed</span><span class="p">,</span>
						 <span class="n">bool</span> <span class="n">autoneg</span><span class="p">,</span>
						 <span class="n">bool</span> <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_setup_mac_link_smartspeed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
                                           <span class="n">ixgbe_link_speed</span> <span class="n">speed</span><span class="p">,</span>
                                           <span class="n">bool</span> <span class="n">autoneg</span><span class="p">,</span>
                                           <span class="n">bool</span> <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_start_mac_link_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				      <span class="n">bool</span> <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_setup_mac_link_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
                               <span class="n">ixgbe_link_speed</span> <span class="n">speed</span><span class="p">,</span>
                               <span class="n">bool</span> <span class="n">autoneg</span><span class="p">,</span>
                               <span class="n">bool</span> <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_setup_copper_link_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
                                         <span class="n">ixgbe_link_speed</span> <span class="n">speed</span><span class="p">,</span>
                                         <span class="n">bool</span> <span class="n">autoneg</span><span class="p">,</span>
                                         <span class="n">bool</span> <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">ixgbe_verify_fw_version_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">ixgbe_verify_lesm_fw_enabled_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_init_mac_link_ops_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>

	<span class="cm">/* enable the laser control functions for SFP+ fiber */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_media_type</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">==</span> <span class="n">ixgbe_media_type_fiber</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">disable_tx_laser</span> <span class="o">=</span>
		                       <span class="o">&amp;</span><span class="n">ixgbe_disable_tx_laser_multispeed_fiber</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">enable_tx_laser</span> <span class="o">=</span>
		                        <span class="o">&amp;</span><span class="n">ixgbe_enable_tx_laser_multispeed_fiber</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">flap_tx_laser</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_flap_tx_laser_multispeed_fiber</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">disable_tx_laser</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">enable_tx_laser</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">flap_tx_laser</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">multispeed_fiber</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set up dual speed SFP+ support */</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_setup_mac_link_multispeed_fiber</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_media_type</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">==</span>
		     <span class="n">ixgbe_media_type_backplane</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">smart_speed</span> <span class="o">==</span> <span class="n">ixgbe_smart_speed_auto</span> <span class="o">||</span>
		     <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">smart_speed</span> <span class="o">==</span> <span class="n">ixgbe_smart_speed_on</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="n">ixgbe_verify_lesm_fw_enabled_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
			<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_setup_mac_link_smartspeed</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_setup_mac_link_82599</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_setup_sfp_modules_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_anlp1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">list_offset</span><span class="p">,</span> <span class="n">data_offset</span><span class="p">,</span> <span class="n">data_value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">sfp_type</span> <span class="o">!=</span> <span class="n">ixgbe_sfp_type_unknown</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ixgbe_init_mac_link_ops_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">reset</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_get_sfp_init_sequence_offsets</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list_offset</span><span class="p">,</span>
		                                              <span class="o">&amp;</span><span class="n">data_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">setup_sfp_out</span><span class="p">;</span>

		<span class="cm">/* PHY config will finish before releasing the semaphore */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire_swfw_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
		                                        <span class="n">IXGBE_GSSR_MAC_CSR_SM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_SWFW_SYNC</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">setup_sfp_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">++</span><span class="n">data_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_value</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">data_value</span> <span class="o">!=</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CORECTL</span><span class="p">,</span> <span class="n">data_value</span><span class="p">);</span>
			<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">++</span><span class="n">data_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_value</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Release the semaphore */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release_swfw_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_GSSR_MAC_CSR_SM</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Delay obtaining semaphore again to allow FW access,</span>
<span class="cm">		 * semaphore_delay is in ms usleep_range needs us.</span>
<span class="cm">		 */</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">semaphore_delay</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>
			     <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">semaphore_delay</span> <span class="o">*</span> <span class="mi">2000</span><span class="p">);</span>

		<span class="cm">/* Now restart DSP by setting Restart_AN and clearing LMS */</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">,</span> <span class="p">((</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
		                <span class="n">IXGBE_AUTOC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IXGBE_AUTOC_LMS_MASK</span><span class="p">)</span> <span class="o">|</span>
		                <span class="n">IXGBE_AUTOC_AN_RESTART</span><span class="p">));</span>

		<span class="cm">/* Wait for AN to leave state 0 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usleep_range</span><span class="p">(</span><span class="mi">4000</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
			<span class="n">reg_anlp1</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ANLP1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reg_anlp1</span> <span class="o">&amp;</span> <span class="n">IXGBE_ANLP1_AN_STATE_MASK</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg_anlp1</span> <span class="o">&amp;</span> <span class="n">IXGBE_ANLP1_AN_STATE_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;sfp module setup not complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_SFP_SETUP_NOT_COMPLETE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">setup_sfp_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Restart DSP by setting Restart_AN and return to SFI mode */</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">,</span> <span class="p">(</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
		                <span class="n">IXGBE_AUTOC</span><span class="p">)</span> <span class="o">|</span> <span class="n">IXGBE_AUTOC_LMS_10G_SERIAL</span> <span class="o">|</span>
		                <span class="n">IXGBE_AUTOC_AN_RESTART</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">setup_sfp_out:</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_get_invariants_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>

	<span class="n">ixgbe_init_mac_link_ops_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">mcft_size</span> <span class="o">=</span> <span class="n">IXGBE_82599_MC_TBL_SIZE</span><span class="p">;</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">vft_size</span> <span class="o">=</span> <span class="n">IXGBE_82599_VFT_TBL_SIZE</span><span class="p">;</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">num_rar_entries</span> <span class="o">=</span> <span class="n">IXGBE_82599_RAR_ENTRIES</span><span class="p">;</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">max_rx_queues</span> <span class="o">=</span> <span class="n">IXGBE_82599_MAX_RX_QUEUES</span><span class="p">;</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">max_tx_queues</span> <span class="o">=</span> <span class="n">IXGBE_82599_MAX_TX_QUEUES</span><span class="p">;</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">max_msix_vectors</span> <span class="o">=</span> <span class="n">ixgbe_get_pcie_msix_count_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_init_phy_ops_82599 - PHY/SFP specific init</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Initialize any function pointers that were not able to be</span>
<span class="cm"> *  set during get_invariants because the PHY/SFP type was</span>
<span class="cm"> *  not known.  Perform the SFP init if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_init_phy_ops_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ixgbe_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Identify the PHY or SFP module */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">identify</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Setup function pointers based on detected SFP module and speeds */</span>
	<span class="n">ixgbe_init_mac_link_ops_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* If copper media, overwrite with copper function pointers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_media_type</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">==</span> <span class="n">ixgbe_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_setup_copper_link_82599</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_link_capabilities</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">ixgbe_get_copper_link_capabilities_generic</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set necessary function pointers based on phy type */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_phy_tn</span>:
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_check_phy_link_tnx</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_setup_phy_link_tnx</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_firmware_version</span> <span class="o">=</span>
		             <span class="o">&amp;</span><span class="n">ixgbe_get_phy_firmware_version_tnx</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_link_capabilities_82599 - Determines link capabilities</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @speed: pointer to link speed</span>
<span class="cm"> *  @negotiation: true when autoneg or autotry is enabled</span>
<span class="cm"> *</span>
<span class="cm"> *  Determines the link capabilities by reading the AUTOC register.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_get_link_capabilities_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
                                             <span class="n">ixgbe_link_speed</span> <span class="o">*</span><span class="n">speed</span><span class="p">,</span>
                                             <span class="n">bool</span> <span class="o">*</span><span class="n">negotiation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">autoc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Determine 1G link capabilities off of SFP+ type */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">sfp_type</span> <span class="o">==</span> <span class="n">ixgbe_sfp_type_1g_cu_core0</span> <span class="o">||</span>
	    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">sfp_type</span> <span class="o">==</span> <span class="n">ixgbe_sfp_type_1g_cu_core1</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">negotiation</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine link capabilities based on the stored value of AUTOC,</span>
<span class="cm">	 * which represents EEPROM defaults.  If AUTOC value has not been</span>
<span class="cm">	 * stored, use the current register value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_link_settings_stored</span><span class="p">)</span>
		<span class="n">autoc</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_autoc</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">autoc</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_LMS_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_1G_LINK_NO_AN</span>:
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">negotiation</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_10G_LINK_NO_AN</span>:
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">negotiation</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_1G_AN</span>:
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">negotiation</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_10G_SERIAL</span>:
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">negotiation</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR</span>:
	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN</span>:
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_UNKNOWN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KR_SUPP</span><span class="p">)</span>
			<span class="o">*</span><span class="n">speed</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KX4_SUPP</span><span class="p">)</span>
			<span class="o">*</span><span class="n">speed</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KX_SUPP</span><span class="p">)</span>
			<span class="o">*</span><span class="n">speed</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">negotiation</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII</span>:
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_100_FULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KR_SUPP</span><span class="p">)</span>
			<span class="o">*</span><span class="n">speed</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KX4_SUPP</span><span class="p">)</span>
			<span class="o">*</span><span class="n">speed</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KX_SUPP</span><span class="p">)</span>
			<span class="o">*</span><span class="n">speed</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">negotiation</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_SGMII_1G_100M</span>:
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span> <span class="o">|</span> <span class="n">IXGBE_LINK_SPEED_100_FULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">negotiation</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_LINK_SETUP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">multispeed_fiber</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">speed</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span> <span class="o">|</span>
		          <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">negotiation</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_media_type_82599 - Get media type</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns the media type (fiber, copper, backplane)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">ixgbe_media_type</span> <span class="nf">ixgbe_get_media_type_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ixgbe_media_type</span> <span class="n">media_type</span><span class="p">;</span>

	<span class="cm">/* Detect if there is a copper PHY attached. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_phy_cu_unknown</span>:
	<span class="k">case</span> <span class="n">ixgbe_phy_tn</span>:
		<span class="n">media_type</span> <span class="o">=</span> <span class="n">ixgbe_media_type_copper</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_KX4</span>:
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_KX4_MEZZ</span>:
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_COMBO_BACKPLANE</span>:
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_KR</span>:
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_BACKPLANE_FCOE</span>:
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_XAUI_LOM</span>:
		<span class="cm">/* Default device ID is mezzanine card KX/KX4 */</span>
		<span class="n">media_type</span> <span class="o">=</span> <span class="n">ixgbe_media_type_backplane</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_SFP</span>:
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_SFP_FCOE</span>:
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_SFP_EM</span>:
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_SFP_SF2</span>:
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_SFP_SF_QP</span>:
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599EN_SFP</span>:
		<span class="n">media_type</span> <span class="o">=</span> <span class="n">ixgbe_media_type_fiber</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_CX4</span>:
		<span class="n">media_type</span> <span class="o">=</span> <span class="n">ixgbe_media_type_cx4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_T3_LOM</span>:
		<span class="n">media_type</span> <span class="o">=</span> <span class="n">ixgbe_media_type_copper</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_DEV_ID_82599_LS</span>:
		<span class="n">media_type</span> <span class="o">=</span> <span class="n">ixgbe_media_type_fiber_lco</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">media_type</span> <span class="o">=</span> <span class="n">ixgbe_media_type_unknown</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">media_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_start_mac_link_82599 - Setup MAC link settings</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @autoneg_wait_to_complete: true when waiting for completion is needed</span>
<span class="cm"> *</span>
<span class="cm"> *  Configures link settings based on values in the ixgbe_hw struct.</span>
<span class="cm"> *  Restarts the link.  Performs autonegotiation if needed.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_start_mac_link_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
                               <span class="n">bool</span> <span class="n">autoneg_wait_to_complete</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">autoc_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">links_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Restart link */</span>
	<span class="n">autoc_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">);</span>
	<span class="n">autoc_reg</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_AN_RESTART</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">,</span> <span class="n">autoc_reg</span><span class="p">);</span>

	<span class="cm">/* Only poll for autoneg to complete if specified to do so */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">autoneg_wait_to_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">autoc_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_LMS_MASK</span><span class="p">)</span> <span class="o">==</span>
		     <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">autoc_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_LMS_MASK</span><span class="p">)</span> <span class="o">==</span>
		     <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">autoc_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_LMS_MASK</span><span class="p">)</span> <span class="o">==</span>
		     <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">links_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Just in case Autoneg time = 0 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_AUTO_NEG_TIME</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">links_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LINKS</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">links_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINKS_KX_AN_COMP</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">links_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINKS_KX_AN_COMP</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_AUTONEG_NOT_COMPLETE</span><span class="p">;</span>
				<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Autoneg did not complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Add delay to filter out noises during initial link setup */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_disable_tx_laser_multispeed_fiber - Disable Tx laser</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  The base drivers may require better control over SFP+ module</span>
<span class="cm"> *  PHY states.  This includes selectively shutting down the Tx</span>
<span class="cm"> *  laser on the PHY, effectively halting physical link.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_disable_tx_laser_multispeed_fiber</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">esdp_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ESDP</span><span class="p">);</span>

	<span class="cm">/* Disable tx laser; allow 100us to go dark per spec */</span>
	<span class="n">esdp_reg</span> <span class="o">|=</span> <span class="n">IXGBE_ESDP_SDP3</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ESDP</span><span class="p">,</span> <span class="n">esdp_reg</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_enable_tx_laser_multispeed_fiber - Enable Tx laser</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  The base drivers may require better control over SFP+ module</span>
<span class="cm"> *  PHY states.  This includes selectively turning on the Tx</span>
<span class="cm"> *  laser on the PHY, effectively starting physical link.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_enable_tx_laser_multispeed_fiber</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">esdp_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ESDP</span><span class="p">);</span>

	<span class="cm">/* Enable tx laser; allow 100ms to light up */</span>
	<span class="n">esdp_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_ESDP_SDP3</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ESDP</span><span class="p">,</span> <span class="n">esdp_reg</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_flap_tx_laser_multispeed_fiber - Flap Tx laser</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  When the driver changes the link speeds that it can support,</span>
<span class="cm"> *  it sets autotry_restart to true to indicate that we need to</span>
<span class="cm"> *  initiate a new autotry session with the link partner.  To do</span>
<span class="cm"> *  so, we set the speed then disable and re-enable the tx laser, to</span>
<span class="cm"> *  alert the link partner that it also needs to restart autotry on its</span>
<span class="cm"> *  end.  This is consistent with true clause 37 autoneg, which also</span>
<span class="cm"> *  involves a loss of signal.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_flap_tx_laser_multispeed_fiber</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">autotry_restart</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ixgbe_disable_tx_laser_multispeed_fiber</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">ixgbe_enable_tx_laser_multispeed_fiber</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">autotry_restart</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_setup_mac_link_multispeed_fiber - Set MAC link speed</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @speed: new link speed</span>
<span class="cm"> *  @autoneg: true if autonegotiation enabled</span>
<span class="cm"> *  @autoneg_wait_to_complete: true when waiting for completion is needed</span>
<span class="cm"> *</span>
<span class="cm"> *  Set the link speed in the AUTOC register and restarts link.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_setup_mac_link_multispeed_fiber</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
                                          <span class="n">ixgbe_link_speed</span> <span class="n">speed</span><span class="p">,</span>
                                          <span class="n">bool</span> <span class="n">autoneg</span><span class="p">,</span>
                                          <span class="n">bool</span> <span class="n">autoneg_wait_to_complete</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ixgbe_link_speed</span> <span class="n">link_speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_UNKNOWN</span><span class="p">;</span>
	<span class="n">ixgbe_link_speed</span> <span class="n">highest_link_speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_UNKNOWN</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">speedcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">esdp_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ESDP</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link_up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">negotiation</span><span class="p">;</span>

	<span class="cm">/* Mask off requested but non-supported speeds */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_link_capabilities</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_speed</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">negotiation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">speed</span> <span class="o">&amp;=</span> <span class="n">link_speed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try each speed one by one, highest priority first.  We do this in</span>
<span class="cm">	 * software because 10gb fiber doesn&#39;t support speed autonegotiation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">speedcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">highest_link_speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">;</span>

		<span class="cm">/* If we already have link at this speed, just jump out */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_link</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_up</span><span class="p">,</span>
						<span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">link_speed</span> <span class="o">==</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">link_up</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Set the module link speed */</span>
		<span class="n">esdp_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IXGBE_ESDP_SDP5_DIR</span> <span class="o">|</span> <span class="n">IXGBE_ESDP_SDP5</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ESDP</span><span class="p">,</span> <span class="n">esdp_reg</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Allow module to change analog characteristics (1G-&gt;10G) */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_setup_mac_link_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						    <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">,</span>
						    <span class="n">autoneg</span><span class="p">,</span>
						    <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

		<span class="cm">/* Flap the tx laser if it has not already been done */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">flap_tx_laser</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait for the controller to acquire link.  Per IEEE 802.3ap,</span>
<span class="cm">		 * Section 73.10.2, we may have to wait up to 500ms if KR is</span>
<span class="cm">		 * attempted.  82599 uses the same timing for 10g SFI.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Wait for the link partner to also set speed */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

			<span class="cm">/* If we have link, just jump out */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_link</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_speed</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">link_up</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">link_up</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">speedcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">highest_link_speed</span> <span class="o">==</span> <span class="n">IXGBE_LINK_SPEED_UNKNOWN</span><span class="p">)</span>
			<span class="n">highest_link_speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">;</span>

		<span class="cm">/* If we already have link at this speed, just jump out */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_link</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_up</span><span class="p">,</span>
						<span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">link_speed</span> <span class="o">==</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">link_up</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Set the module link speed */</span>
		<span class="n">esdp_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_ESDP_SDP5</span><span class="p">;</span>
		<span class="n">esdp_reg</span> <span class="o">|=</span> <span class="n">IXGBE_ESDP_SDP5_DIR</span><span class="p">;</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_ESDP</span><span class="p">,</span> <span class="n">esdp_reg</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Allow module to change analog characteristics (10G-&gt;1G) */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_setup_mac_link_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						    <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">,</span>
						    <span class="n">autoneg</span><span class="p">,</span>
						    <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

		<span class="cm">/* Flap the tx laser if it has not already been done */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">flap_tx_laser</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Wait for the link partner to also set speed */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

		<span class="cm">/* If we have link, just jump out */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_link</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_up</span><span class="p">,</span>
						<span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">link_up</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We didn&#39;t get link.  Configure back to the highest speed we tried,</span>
<span class="cm">	 * (if there was more than one).  We call ourselves back with just the</span>
<span class="cm">	 * single highest speed that the user requested.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">speedcnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_setup_mac_link_multispeed_fiber</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
		                                               <span class="n">highest_link_speed</span><span class="p">,</span>
		                                               <span class="n">autoneg</span><span class="p">,</span>
		                                               <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="cm">/* Set autoneg_advertised value based on input link speed */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_setup_mac_link_smartspeed - Set MAC link speed using SmartSpeed</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @speed: new link speed</span>
<span class="cm"> *  @autoneg: true if autonegotiation enabled</span>
<span class="cm"> *  @autoneg_wait_to_complete: true when waiting for completion is needed</span>
<span class="cm"> *</span>
<span class="cm"> *  Implements the Intel SmartSpeed algorithm.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_setup_mac_link_smartspeed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				     <span class="n">ixgbe_link_speed</span> <span class="n">speed</span><span class="p">,</span> <span class="n">bool</span> <span class="n">autoneg</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">autoneg_wait_to_complete</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ixgbe_link_speed</span> <span class="n">link_speed</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_UNKNOWN</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link_up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">autoc_reg</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">);</span>

	 <span class="cm">/* Set autoneg_advertised value based on input link speed */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINK_SPEED_100_FULL</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">|=</span> <span class="n">IXGBE_LINK_SPEED_100_FULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Implement Intel SmartSpeed algorithm.  SmartSpeed will reduce the</span>
<span class="cm">	 * autoneg advertisement if link is unable to be established at the</span>
<span class="cm">	 * highest negotiated rate.  This can sometimes happen due to integrity</span>
<span class="cm">	 * issues with the physical media connection.</span>
<span class="cm">	 */</span>

	<span class="cm">/* First, try to get link with full advertisement */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">smart_speed_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">IXGBE_SMARTSPEED_MAX_RETRIES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_setup_mac_link_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">autoneg</span><span class="p">,</span>
						    <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait for the controller to acquire link.  Per IEEE 802.3ap,</span>
<span class="cm">		 * Section 73.10.2, we may have to wait up to 500ms if KR is</span>
<span class="cm">		 * attempted, or 200ms if KX/KX4/BX/BX4 is attempted, per</span>
<span class="cm">		 * Table 9 in the AN MAS.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

			<span class="cm">/* If we have link, just jump out */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_link</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_speed</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">link_up</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">link_up</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We didn&#39;t get link.  If we advertised KR plus one of KX4/KX</span>
<span class="cm">	 * (or BX4/BX), then disable KR and try again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">autoc_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KR_SUPP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">autoc_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KX4_KX_SUPP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Turn SmartSpeed on to disable KR support */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">smart_speed_active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_setup_mac_link_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">autoneg</span><span class="p">,</span>
					    <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for the controller to acquire link.  600ms will allow for</span>
<span class="cm">	 * the AN link_fail_inhibit_timer as well for multiple cycles of</span>
<span class="cm">	 * parallel detect, both 10g and 1g. This allows for the maximum</span>
<span class="cm">	 * connect attempts as defined in the AN MAS table 73-7.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

		<span class="cm">/* If we have link, just jump out */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_link</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_speed</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">link_up</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">link_up</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We didn&#39;t get link.  Turn SmartSpeed back off. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">smart_speed_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_setup_mac_link_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">autoneg</span><span class="p">,</span>
					    <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">link_up</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">link_speed</span> <span class="o">==</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">))</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Smartspeed has downgraded the link speed from &quot;</span>
		       <span class="s">&quot;the maximum advertised</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_setup_mac_link_82599 - Set MAC link speed</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @speed: new link speed</span>
<span class="cm"> *  @autoneg: true if autonegotiation enabled</span>
<span class="cm"> *  @autoneg_wait_to_complete: true when waiting for completion is needed</span>
<span class="cm"> *</span>
<span class="cm"> *  Set the link speed in the AUTOC register and restarts link.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_setup_mac_link_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
                               <span class="n">ixgbe_link_speed</span> <span class="n">speed</span><span class="p">,</span> <span class="n">bool</span> <span class="n">autoneg</span><span class="p">,</span>
                               <span class="n">bool</span> <span class="n">autoneg_wait_to_complete</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">autoc</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">autoc2</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC2</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">start_autoc</span> <span class="o">=</span> <span class="n">autoc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">orig_autoc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">link_mode</span> <span class="o">=</span> <span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_LMS_MASK</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pma_pmd_1g</span> <span class="o">=</span> <span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_1G_PMA_PMD_MASK</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pma_pmd_10g_serial</span> <span class="o">=</span> <span class="n">autoc2</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">links_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ixgbe_link_speed</span> <span class="n">link_capabilities</span> <span class="o">=</span> <span class="n">IXGBE_LINK_SPEED_UNKNOWN</span><span class="p">;</span>

	<span class="cm">/* Check to see if speed passed in is supported. */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_link_capabilities</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_capabilities</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">autoneg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">speed</span> <span class="o">&amp;=</span> <span class="n">link_capabilities</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">==</span> <span class="n">IXGBE_LINK_SPEED_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_LINK_SETUP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Use stored value (EEPROM defaults) of AUTOC to find KR/KX4 support*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_link_settings_stored</span><span class="p">)</span>
		<span class="n">orig_autoc</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_autoc</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">orig_autoc</span> <span class="o">=</span> <span class="n">autoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link_mode</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR</span> <span class="o">||</span>
	    <span class="n">link_mode</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN</span> <span class="o">||</span>
	    <span class="n">link_mode</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set KX4/KX/KR support according to speed requested */</span>
		<span class="n">autoc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGBE_AUTOC_KX4_KX_SUPP_MASK</span> <span class="o">|</span> <span class="n">IXGBE_AUTOC_KR_SUPP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">orig_autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KX4_SUPP</span><span class="p">)</span>
				<span class="n">autoc</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_KX4_SUPP</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">orig_autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KR_SUPP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">smart_speed_active</span> <span class="o">==</span> <span class="nb">false</span><span class="p">))</span>
				<span class="n">autoc</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_KR_SUPP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">)</span>
			<span class="n">autoc</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_KX_SUPP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">pma_pmd_1g</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_1G_SFI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	           <span class="p">(</span><span class="n">link_mode</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_LMS_1G_LINK_NO_AN</span> <span class="o">||</span>
	            <span class="n">link_mode</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_LMS_1G_AN</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Switch from 1G SFI to 10G SFI if requested */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">speed</span> <span class="o">==</span> <span class="n">IXGBE_LINK_SPEED_10GB_FULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">pma_pmd_10g_serial</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC2_10G_SFI</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">autoc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_AUTOC_LMS_MASK</span><span class="p">;</span>
			<span class="n">autoc</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_LMS_10G_SERIAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">pma_pmd_10g_serial</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC2_10G_SFI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	           <span class="p">(</span><span class="n">link_mode</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_LMS_10G_SERIAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Switch from 10G SFI to 1G SFI if requested */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">speed</span> <span class="o">==</span> <span class="n">IXGBE_LINK_SPEED_1GB_FULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">pma_pmd_1g</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_1G_SFI</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">autoc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_AUTOC_LMS_MASK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">autoneg</span><span class="p">)</span>
				<span class="n">autoc</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_LMS_1G_AN</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">autoc</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_LMS_1G_LINK_NO_AN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">!=</span> <span class="n">start_autoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Restart link */</span>
		<span class="n">autoc</span> <span class="o">|=</span> <span class="n">IXGBE_AUTOC_AN_RESTART</span><span class="p">;</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">,</span> <span class="n">autoc</span><span class="p">);</span>

		<span class="cm">/* Only poll for autoneg to complete if specified to do so */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">autoneg_wait_to_complete</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">link_mode</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR</span> <span class="o">||</span>
			    <span class="n">link_mode</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN</span> <span class="o">||</span>
			    <span class="n">link_mode</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">links_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/*Just in case Autoneg time=0*/</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_AUTO_NEG_TIME</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">links_reg</span> <span class="o">=</span>
					       <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_LINKS</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">links_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINKS_KX_AN_COMP</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">links_reg</span> <span class="o">&amp;</span> <span class="n">IXGBE_LINKS_KX_AN_COMP</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">status</span> <span class="o">=</span>
					        <span class="n">IXGBE_ERR_AUTONEG_NOT_COMPLETE</span><span class="p">;</span>
					<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Autoneg did not &quot;</span>
					       <span class="s">&quot;complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Add delay to filter out noises during initial link setup */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_setup_copper_link_82599 - Set the PHY autoneg advertised field</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @speed: new link speed</span>
<span class="cm"> *  @autoneg: true if autonegotiation enabled</span>
<span class="cm"> *  @autoneg_wait_to_complete: true if waiting is needed to complete</span>
<span class="cm"> *</span>
<span class="cm"> *  Restarts link on PHY and MAC based on settings passed in.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_setup_copper_link_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
                                         <span class="n">ixgbe_link_speed</span> <span class="n">speed</span><span class="p">,</span>
                                         <span class="n">bool</span> <span class="n">autoneg</span><span class="p">,</span>
                                         <span class="n">bool</span> <span class="n">autoneg_wait_to_complete</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Setup the PHY according to input speed */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_link_speed</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">autoneg</span><span class="p">,</span>
	                                      <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>
	<span class="cm">/* Set up MAC */</span>
	<span class="n">ixgbe_start_mac_link_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">autoneg_wait_to_complete</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_reset_hw_82599 - Perform hardware reset</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Resets the hardware by resetting the transmit and receive units, masks</span>
<span class="cm"> *  and clears all interrupts, perform a PHY reset, and perform a link (MAC)</span>
<span class="cm"> *  reset.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_reset_hw_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ixgbe_link_speed</span> <span class="n">link_speed</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">autoc</span><span class="p">,</span> <span class="n">autoc2</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link_up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Call adapter stop to disable tx/rx and clear interrupts */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">stop_adapter</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset_hw_out</span><span class="p">;</span>

	<span class="cm">/* flush pending Tx transactions */</span>
	<span class="n">ixgbe_clear_tx_pending</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* PHY ops must be identified and initialized prior to reset */</span>

	<span class="cm">/* Identify PHY and related function pointers */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">IXGBE_ERR_SFP_NOT_SUPPORTED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset_hw_out</span><span class="p">;</span>

	<span class="cm">/* Setup SFP module if there is one present. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">sfp_setup_needed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_sfp</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">sfp_setup_needed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">IXGBE_ERR_SFP_NOT_SUPPORTED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset_hw_out</span><span class="p">;</span>

	<span class="cm">/* Reset PHY */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">reset_disable</span> <span class="o">==</span> <span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">reset</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

<span class="nl">mac_reset_top:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Issue global reset to the MAC. Needs to be SW reset if link is up.</span>
<span class="cm">	 * If link reset is used when link is up, it might reset the PHY when</span>
<span class="cm">	 * mng is using it.  If link is down or the flag to force full link</span>
<span class="cm">	 * reset is set, then perform link reset.</span>
<span class="cm">	 */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">IXGBE_CTRL_LNK_RST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">force_full_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_link</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_up</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">link_up</span><span class="p">)</span>
			<span class="n">ctrl</span> <span class="o">=</span> <span class="n">IXGBE_CTRL_RST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CTRL</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Poll for reset bit to self-clear indicating reset is complete */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CTRL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">IXGBE_CTRL_RST_MASK</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">IXGBE_CTRL_RST_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_RESET_FAILED</span><span class="p">;</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Reset polling failed to complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Double resets are required for recovery from certain error</span>
<span class="cm">	 * conditions.  Between resets, it is necessary to stall to allow time</span>
<span class="cm">	 * for any pending HW events to complete.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAGS_DOUBLE_RESET_REQUIRED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_FLAGS_DOUBLE_RESET_REQUIRED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">mac_reset_top</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Store the original AUTOC/AUTOC2 values if they have not been</span>
<span class="cm">	 * stored off yet.  Otherwise restore the stored original</span>
<span class="cm">	 * values since the reset operation sets back to defaults.</span>
<span class="cm">	 */</span>
	<span class="n">autoc</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">);</span>
	<span class="n">autoc2</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_link_settings_stored</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_autoc</span> <span class="o">=</span> <span class="n">autoc</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_autoc2</span> <span class="o">=</span> <span class="n">autoc2</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_link_settings_stored</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">!=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_autoc</span><span class="p">)</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">,</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_autoc</span> <span class="o">|</span>
			                <span class="n">IXGBE_AUTOC_AN_RESTART</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">autoc2</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC2_UPPER_MASK</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_autoc2</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC2_UPPER_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">autoc2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_AUTOC2_UPPER_MASK</span><span class="p">;</span>
			<span class="n">autoc2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">orig_autoc2</span> <span class="o">&amp;</span>
			           <span class="n">IXGBE_AUTOC2_UPPER_MASK</span><span class="p">);</span>
			<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC2</span><span class="p">,</span> <span class="n">autoc2</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Store the permanent mac address */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_mac_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">perm_addr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Store MAC address from RAR0, clear receive address registers, and</span>
<span class="cm">	 * clear the multicast table.  Also reset num_rar_entries to 128,</span>
<span class="cm">	 * since we modify this value when programming the SAN MAC address.</span>
<span class="cm">	 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">num_rar_entries</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_rx_addrs</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Store the permanent SAN mac address */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_san_mac_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">san_addr</span><span class="p">);</span>

	<span class="cm">/* Add the SAN MAC address to the RAR only if it&#39;s a valid address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_validate_mac_addr</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">san_addr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">set_rar</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">num_rar_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		                    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">san_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IXGBE_RAH_AV</span><span class="p">);</span>

		<span class="cm">/* Reserve the last RAR for the SAN MAC address */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">num_rar_entries</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Store the alternative WWNN/WWPN prefix */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_wwn_prefix</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">wwnn_prefix</span><span class="p">,</span>
	                               <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">wwpn_prefix</span><span class="p">);</span>

<span class="nl">reset_hw_out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_reinit_fdir_tables_82599 - Reinitialize Flow Director tables.</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_reinit_fdir_tables_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fdirctrl</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCTRL</span><span class="p">);</span>
	<span class="n">fdirctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_FDIRCTRL_INIT_DONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before starting reinitialization process,</span>
<span class="cm">	 * FDIRCMD.CMD must be zero.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_FDIRCMD_CMD_POLL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCMD</span><span class="p">)</span> <span class="o">&amp;</span>
		      <span class="n">IXGBE_FDIRCMD_CMD_MASK</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">IXGBE_FDIRCMD_CMD_POLL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Flow Director previous command isn&#39;t complete, &quot;</span>
		       <span class="s">&quot;aborting table re-initialization.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_FDIR_REINIT_FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRFREE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * 82599 adapters flow director init flow cannot be restarted,</span>
<span class="cm">	 * Workaround 82599 silicon errata by performing the following steps</span>
<span class="cm">	 * before re-writing the FDIRCTRL control register with the same value.</span>
<span class="cm">	 * - write 1 to bit 8 of FDIRCMD register &amp;</span>
<span class="cm">	 * - write 0 to bit 8 of FDIRCMD register</span>
<span class="cm">	 */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCMD</span><span class="p">,</span>
	                <span class="p">(</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCMD</span><span class="p">)</span> <span class="o">|</span>
	                 <span class="n">IXGBE_FDIRCMD_CLEARHT</span><span class="p">));</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCMD</span><span class="p">,</span>
	                <span class="p">(</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCMD</span><span class="p">)</span> <span class="o">&amp;</span>
	                 <span class="o">~</span><span class="n">IXGBE_FDIRCMD_CLEARHT</span><span class="p">));</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear FDIR Hash register to clear any leftover hashes</span>
<span class="cm">	 * waiting to be programmed.</span>
<span class="cm">	 */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRHASH</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCTRL</span><span class="p">,</span> <span class="n">fdirctrl</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Poll init-done after we write FDIRCTRL register */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_FDIR_INIT_DONE_POLL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCTRL</span><span class="p">)</span> <span class="o">&amp;</span>
		                   <span class="n">IXGBE_FDIRCTRL_INIT_DONE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">IXGBE_FDIR_INIT_DONE_POLL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Flow Director Signature poll time exceeded!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_FDIR_REINIT_FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear FDIR statistics registers (read to clear) */</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRUSTAT</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRFSTAT</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRMATCH</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRMISS</span><span class="p">);</span>
	<span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRLEN</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_fdir_enable_82599 - Initialize Flow Director control registers</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @fdirctrl: value to write to flow director control register</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_fdir_enable_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fdirctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Prime the keys for hashing */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRHKEY</span><span class="p">,</span> <span class="n">IXGBE_ATR_BUCKET_HASH_KEY</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRSKEY</span><span class="p">,</span> <span class="n">IXGBE_ATR_SIGNATURE_HASH_KEY</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Poll init-done after we write the register.  Estimated times:</span>
<span class="cm">	 *      10G: PBALLOC = 11b, timing is 60us</span>
<span class="cm">	 *       1G: PBALLOC = 11b, timing is 600us</span>
<span class="cm">	 *     100M: PBALLOC = 11b, timing is 6ms</span>
<span class="cm">	 *</span>
<span class="cm">	 *     Multiple these timings by 4 if under full Rx load</span>
<span class="cm">	 *</span>
<span class="cm">	 * So we&#39;ll poll for IXGBE_FDIR_INIT_DONE_POLL times, sleeping for</span>
<span class="cm">	 * 1 msec per poll time.  If we&#39;re at line rate and drop to 100M, then</span>
<span class="cm">	 * this might not finish in our poll time, but we can live with that</span>
<span class="cm">	 * for now.</span>
<span class="cm">	 */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCTRL</span><span class="p">,</span> <span class="n">fdirctrl</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGBE_FDIR_INIT_DONE_POLL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCTRL</span><span class="p">)</span> <span class="o">&amp;</span>
		                   <span class="n">IXGBE_FDIRCTRL_INIT_DONE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">IXGBE_FDIR_INIT_DONE_POLL</span><span class="p">)</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Flow Director poll time exceeded!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_init_fdir_signature_82599 - Initialize Flow Director signature filters</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @fdirctrl: value to write to flow director control register, initially</span>
<span class="cm"> *             contains just the value of the Rx packet buffer allocation</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_init_fdir_signature_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fdirctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Continue setup of fdirctrl register bits:</span>
<span class="cm">	 *  Move the flexible bytes to use the ethertype - shift 6 words</span>
<span class="cm">	 *  Set the maximum length per hash bucket to 0xA filters</span>
<span class="cm">	 *  Send interrupt when 64 filters are left</span>
<span class="cm">	 */</span>
	<span class="n">fdirctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x6</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCTRL_FLEX_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">(</span><span class="mh">0xA</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCTRL_FULL_THRESH_SHIFT</span><span class="p">);</span>

	<span class="cm">/* write hashes and fdirctrl register, poll for completion */</span>
	<span class="n">ixgbe_fdir_enable_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">fdirctrl</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_init_fdir_perfect_82599 - Initialize Flow Director perfect filters</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @fdirctrl: value to write to flow director control register, initially</span>
<span class="cm"> *             contains just the value of the Rx packet buffer allocation</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_init_fdir_perfect_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fdirctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Continue setup of fdirctrl register bits:</span>
<span class="cm">	 *  Turn perfect match filtering on</span>
<span class="cm">	 *  Report hash in RSS field of Rx wb descriptor</span>
<span class="cm">	 *  Initialize the drop queue</span>
<span class="cm">	 *  Move the flexible bytes to use the ethertype - shift 6 words</span>
<span class="cm">	 *  Set the maximum length per hash bucket to 0xA filters</span>
<span class="cm">	 *  Send interrupt when 64 (0x4 * 16) filters are left</span>
<span class="cm">	 */</span>
	<span class="n">fdirctrl</span> <span class="o">|=</span> <span class="n">IXGBE_FDIRCTRL_PERFECT_MATCH</span> <span class="o">|</span>
		    <span class="n">IXGBE_FDIRCTRL_REPORT_STATUS</span> <span class="o">|</span>
		    <span class="p">(</span><span class="n">IXGBE_FDIR_DROP_QUEUE</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCTRL_DROP_Q_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">(</span><span class="mh">0x6</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCTRL_FLEX_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">(</span><span class="mh">0xA</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCTRL_FULL_THRESH_SHIFT</span><span class="p">);</span>

	<span class="cm">/* write hashes and fdirctrl register, poll for completion */</span>
	<span class="n">ixgbe_fdir_enable_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">fdirctrl</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These defines allow us to quickly generate all of the necessary instructions</span>
<span class="cm"> * in the function below by simply calling out IXGBE_COMPUTE_SIG_HASH_ITERATION</span>
<span class="cm"> * for values 0 through 15</span>
<span class="cm"> */</span>
<span class="cp">#define IXGBE_ATR_COMMON_HASH_KEY \</span>
<span class="cp">		(IXGBE_ATR_BUCKET_HASH_KEY &amp; IXGBE_ATR_SIGNATURE_HASH_KEY)</span>
<span class="cp">#define IXGBE_COMPUTE_SIG_HASH_ITERATION(_n) \</span>
<span class="cp">do { \</span>
<span class="cp">	u32 n = (_n); \</span>
<span class="cp">	if (IXGBE_ATR_COMMON_HASH_KEY &amp; (0x01 &lt;&lt; n)) \</span>
<span class="cp">		common_hash ^= lo_hash_dword &gt;&gt; n; \</span>
<span class="cp">	else if (IXGBE_ATR_BUCKET_HASH_KEY &amp; (0x01 &lt;&lt; n)) \</span>
<span class="cp">		bucket_hash ^= lo_hash_dword &gt;&gt; n; \</span>
<span class="cp">	else if (IXGBE_ATR_SIGNATURE_HASH_KEY &amp; (0x01 &lt;&lt; n)) \</span>
<span class="cp">		sig_hash ^= lo_hash_dword &lt;&lt; (16 - n); \</span>
<span class="cp">	if (IXGBE_ATR_COMMON_HASH_KEY &amp; (0x01 &lt;&lt; (n + 16))) \</span>
<span class="cp">		common_hash ^= hi_hash_dword &gt;&gt; n; \</span>
<span class="cp">	else if (IXGBE_ATR_BUCKET_HASH_KEY &amp; (0x01 &lt;&lt; (n + 16))) \</span>
<span class="cp">		bucket_hash ^= hi_hash_dword &gt;&gt; n; \</span>
<span class="cp">	else if (IXGBE_ATR_SIGNATURE_HASH_KEY &amp; (0x01 &lt;&lt; (n + 16))) \</span>
<span class="cp">		sig_hash ^= hi_hash_dword &lt;&lt; (16 - n); \</span>
<span class="cp">} while (0);</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_atr_compute_sig_hash_82599 - Compute the signature hash</span>
<span class="cm"> *  @stream: input bitstream to compute the hash on</span>
<span class="cm"> *</span>
<span class="cm"> *  This function is almost identical to the function above but contains</span>
<span class="cm"> *  several optomizations such as unwinding all of the loops, letting the</span>
<span class="cm"> *  compiler work out all of the conditional ifs since the keys are static</span>
<span class="cm"> *  defines, and computing two keys at once since the hashed dword stream</span>
<span class="cm"> *  will be the same for both keys.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">ixgbe_atr_compute_sig_hash_82599</span><span class="p">(</span><span class="k">union</span> <span class="n">ixgbe_atr_hash_dword</span> <span class="n">input</span><span class="p">,</span>
					    <span class="k">union</span> <span class="n">ixgbe_atr_hash_dword</span> <span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hi_hash_dword</span><span class="p">,</span> <span class="n">lo_hash_dword</span><span class="p">,</span> <span class="n">flow_vm_vlan</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sig_hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bucket_hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">common_hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* record the flow_vm_vlan bits as they are a key part to the hash */</span>
	<span class="n">flow_vm_vlan</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">dword</span><span class="p">);</span>

	<span class="cm">/* generate common hash dword */</span>
	<span class="n">hi_hash_dword</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">common</span><span class="p">.</span><span class="n">dword</span><span class="p">);</span>

	<span class="cm">/* low dword is word swapped version of common */</span>
	<span class="n">lo_hash_dword</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi_hash_dword</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">hi_hash_dword</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* apply flow ID/VM pool/VLAN ID bits to hash words */</span>
	<span class="n">hi_hash_dword</span> <span class="o">^=</span> <span class="n">flow_vm_vlan</span> <span class="o">^</span> <span class="p">(</span><span class="n">flow_vm_vlan</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* Process bits 0 and 16 */</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * apply flow ID/VM pool/VLAN ID bits to lo hash dword, we had to</span>
<span class="cm">	 * delay this because bit 0 of the stream should not be processed</span>
<span class="cm">	 * so we do not add the vlan until after bit 0 was processed</span>
<span class="cm">	 */</span>
	<span class="n">lo_hash_dword</span> <span class="o">^=</span> <span class="n">flow_vm_vlan</span> <span class="o">^</span> <span class="p">(</span><span class="n">flow_vm_vlan</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* Process remaining 30 bit of the key */</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_SIG_HASH_ITERATION</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>

	<span class="cm">/* combine common_hash result with signature and bucket hashes */</span>
	<span class="n">bucket_hash</span> <span class="o">^=</span> <span class="n">common_hash</span><span class="p">;</span>
	<span class="n">bucket_hash</span> <span class="o">&amp;=</span> <span class="n">IXGBE_ATR_HASH_MASK</span><span class="p">;</span>

	<span class="n">sig_hash</span> <span class="o">^=</span> <span class="n">common_hash</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">sig_hash</span> <span class="o">&amp;=</span> <span class="n">IXGBE_ATR_HASH_MASK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* return completed signature hash */</span>
	<span class="k">return</span> <span class="n">sig_hash</span> <span class="o">^</span> <span class="n">bucket_hash</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_atr_add_signature_filter_82599 - Adds a signature hash filter</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @input: unique input dword</span>
<span class="cm"> *  @common: compressed common input dword</span>
<span class="cm"> *  @queue: queue index to direct traffic to</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">ixgbe_fdir_add_signature_filter_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
                                          <span class="k">union</span> <span class="n">ixgbe_atr_hash_dword</span> <span class="n">input</span><span class="p">,</span>
                                          <span class="k">union</span> <span class="n">ixgbe_atr_hash_dword</span> <span class="n">common</span><span class="p">,</span>
                                          <span class="n">u8</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span>  <span class="n">fdirhashcmd</span><span class="p">;</span>
	<span class="n">u32</span>  <span class="n">fdircmd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the flow_type in order to program FDIRCMD properly</span>
<span class="cm">	 * lowest 2 bits are FDIRCMD.L4TYPE, third lowest bit is FDIRCMD.IPV6</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">formatted</span><span class="p">.</span><span class="n">flow_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IXGBE_ATR_FLOW_TYPE_TCPV4</span>:
	<span class="k">case</span> <span class="n">IXGBE_ATR_FLOW_TYPE_UDPV4</span>:
	<span class="k">case</span> <span class="n">IXGBE_ATR_FLOW_TYPE_SCTPV4</span>:
	<span class="k">case</span> <span class="n">IXGBE_ATR_FLOW_TYPE_TCPV6</span>:
	<span class="k">case</span> <span class="n">IXGBE_ATR_FLOW_TYPE_UDPV6</span>:
	<span class="k">case</span> <span class="n">IXGBE_ATR_FLOW_TYPE_SCTPV6</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; Error on flow type input</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* configure FDIRCMD register */</span>
	<span class="n">fdircmd</span> <span class="o">=</span> <span class="n">IXGBE_FDIRCMD_CMD_ADD_FLOW</span> <span class="o">|</span> <span class="n">IXGBE_FDIRCMD_FILTER_UPDATE</span> <span class="o">|</span>
	          <span class="n">IXGBE_FDIRCMD_LAST</span> <span class="o">|</span> <span class="n">IXGBE_FDIRCMD_QUEUE_EN</span><span class="p">;</span>
	<span class="n">fdircmd</span> <span class="o">|=</span> <span class="n">input</span><span class="p">.</span><span class="n">formatted</span><span class="p">.</span><span class="n">flow_type</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCMD_FLOW_TYPE_SHIFT</span><span class="p">;</span>
	<span class="n">fdircmd</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">queue</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCMD_RX_QUEUE_SHIFT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The lower 32-bits of fdirhashcmd is for FDIRHASH, the upper 32-bits</span>
<span class="cm">	 * is for FDIRCMD.  Then do a 64-bit register write from FDIRHASH.</span>
<span class="cm">	 */</span>
	<span class="n">fdirhashcmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">fdircmd</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">fdirhashcmd</span> <span class="o">|=</span> <span class="n">ixgbe_atr_compute_sig_hash_82599</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">common</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG64</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRHASH</span><span class="p">,</span> <span class="n">fdirhashcmd</span><span class="p">);</span>

	<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot;Tx Queue=%x hash=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">fdirhashcmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define IXGBE_COMPUTE_BKT_HASH_ITERATION(_n) \</span>
<span class="cp">do { \</span>
<span class="cp">	u32 n = (_n); \</span>
<span class="cp">	if (IXGBE_ATR_BUCKET_HASH_KEY &amp; (0x01 &lt;&lt; n)) \</span>
<span class="cp">		bucket_hash ^= lo_hash_dword &gt;&gt; n; \</span>
<span class="cp">	if (IXGBE_ATR_BUCKET_HASH_KEY &amp; (0x01 &lt;&lt; (n + 16))) \</span>
<span class="cp">		bucket_hash ^= hi_hash_dword &gt;&gt; n; \</span>
<span class="cp">} while (0);</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_atr_compute_perfect_hash_82599 - Compute the perfect filter hash</span>
<span class="cm"> *  @atr_input: input bitstream to compute the hash on</span>
<span class="cm"> *  @input_mask: mask for the input bitstream</span>
<span class="cm"> *</span>
<span class="cm"> *  This function serves two main purposes.  First it applys the input_mask</span>
<span class="cm"> *  to the atr_input resulting in a cleaned up atr_input data stream.</span>
<span class="cm"> *  Secondly it computes the hash and stores it in the bkt_hash field at</span>
<span class="cm"> *  the end of the input byte stream.  This way it will be available for</span>
<span class="cm"> *  future use without needing to recompute the hash.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">ixgbe_atr_compute_perfect_hash_82599</span><span class="p">(</span><span class="k">union</span> <span class="n">ixgbe_atr_input</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
					  <span class="k">union</span> <span class="n">ixgbe_atr_input</span> <span class="o">*</span><span class="n">input_mask</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">u32</span> <span class="n">hi_hash_dword</span><span class="p">,</span> <span class="n">lo_hash_dword</span><span class="p">,</span> <span class="n">flow_vm_vlan</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bucket_hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Apply masks to input data */</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">&amp;=</span> <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">&amp;=</span> <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="o">&amp;=</span> <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="o">&amp;=</span> <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="o">&amp;=</span> <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="o">&amp;=</span> <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="o">&amp;=</span> <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>  <span class="o">&amp;=</span> <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>  <span class="o">&amp;=</span> <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>  <span class="o">&amp;=</span> <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

	<span class="cm">/* record the flow_vm_vlan bits as they are a key part to the hash */</span>
	<span class="n">flow_vm_vlan</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* generate common hash dword */</span>
	<span class="n">hi_hash_dword</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span>
				    <span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^</span>
				    <span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">^</span>
				    <span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">^</span>
				    <span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span>
				    <span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">^</span>
				    <span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">^</span>
				    <span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">^</span>
				    <span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">^</span>
				    <span class="n">input</span><span class="o">-&gt;</span><span class="n">dword_stream</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>

	<span class="cm">/* low dword is word swapped version of common */</span>
	<span class="n">lo_hash_dword</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi_hash_dword</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">hi_hash_dword</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* apply flow ID/VM pool/VLAN ID bits to hash words */</span>
	<span class="n">hi_hash_dword</span> <span class="o">^=</span> <span class="n">flow_vm_vlan</span> <span class="o">^</span> <span class="p">(</span><span class="n">flow_vm_vlan</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* Process bits 0 and 16 */</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * apply flow ID/VM pool/VLAN ID bits to lo hash dword, we had to</span>
<span class="cm">	 * delay this because bit 0 of the stream should not be processed</span>
<span class="cm">	 * so we do not add the vlan until after bit 0 was processed</span>
<span class="cm">	 */</span>
	<span class="n">lo_hash_dword</span> <span class="o">^=</span> <span class="n">flow_vm_vlan</span> <span class="o">^</span> <span class="p">(</span><span class="n">flow_vm_vlan</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* Process remaining 30 bit of the key */</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
	<span class="n">IXGBE_COMPUTE_BKT_HASH_ITERATION</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Limit hash to 13 bits since max bucket count is 8K.</span>
<span class="cm">	 * Store result at the end of the input stream.</span>
<span class="cm">	 */</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">bkt_hash</span> <span class="o">=</span> <span class="n">bucket_hash</span> <span class="o">&amp;</span> <span class="mh">0x1FFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_fdirtcpm_82599 - generate a tcp port from atr_input_masks</span>
<span class="cm"> *  @input_mask: mask to be bit swapped</span>
<span class="cm"> *</span>
<span class="cm"> *  The source and destination port masks for flow director are bit swapped</span>
<span class="cm"> *  in that bit 15 effects bit 0, 14 effects 1, 13, 2 etc.  In order to</span>
<span class="cm"> *  generate a correctly swapped value we need to bit swap the mask and that</span>
<span class="cm"> *  is what is accomplished by this function.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">ixgbe_get_fdirtcpm_82599</span><span class="p">(</span><span class="k">union</span> <span class="n">ixgbe_atr_input</span> <span class="o">*</span><span class="n">input_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">dst_port</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="n">IXGBE_FDIRTCPM_DPORTM_SHIFT</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">|=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">src_port</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x55555555</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0xAAAAAAAA</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x33333333</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0xCCCCCCCC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x0F0F0F0F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0xF0F0F0F0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x00FF00FF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0xFF00FF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These two macros are meant to address the fact that we have registers</span>
<span class="cm"> * that are either all or in part big-endian.  As a result on big-endian</span>
<span class="cm"> * systems we will end up byte swapping the value to little-endian before</span>
<span class="cm"> * it is byte swapped again and written to the hardware in the original</span>
<span class="cm"> * big-endian format.</span>
<span class="cm"> */</span>
<span class="cp">#define IXGBE_STORE_AS_BE32(_value) \</span>
<span class="cp">	(((u32)(_value) &gt;&gt; 24) | (((u32)(_value) &amp; 0x00FF0000) &gt;&gt; 8) | \</span>
<span class="cp">	 (((u32)(_value) &amp; 0x0000FF00) &lt;&lt; 8) | ((u32)(_value) &lt;&lt; 24))</span>

<span class="cp">#define IXGBE_WRITE_REG_BE32(a, reg, value) \</span>
<span class="cp">	IXGBE_WRITE_REG((a), (reg), IXGBE_STORE_AS_BE32(ntohl(value)))</span>

<span class="cp">#define IXGBE_STORE_AS_BE16(_value) \</span>
<span class="cp">	ntohs(((u16)(_value) &gt;&gt; 8) | ((u16)(_value) &lt;&lt; 8))</span>

<span class="n">s32</span> <span class="nf">ixgbe_fdir_set_input_mask_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				    <span class="k">union</span> <span class="n">ixgbe_atr_input</span> <span class="o">*</span><span class="n">input_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* mask IPv6 since it is currently not supported */</span>
	<span class="n">u32</span> <span class="n">fdirm</span> <span class="o">=</span> <span class="n">IXGBE_FDIRM_DIPv6</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fdirtcpm</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Program the relevant mask registers.  If src/dst_port or src/dst_addr</span>
<span class="cm">	 * are zero, then assume a full mask for that field.  Also assume that</span>
<span class="cm">	 * a VLAN of 0 is unspecified, so mask that out as well.  L4type</span>
<span class="cm">	 * cannot be masked out in this implementation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This also assumes IPv4 only.  IPv6 masking isn&#39;t supported at this</span>
<span class="cm">	 * point in time.</span>
<span class="cm">	 */</span>

	<span class="cm">/* verify bucket hash is cleared on hash generation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">bkt_hash</span><span class="p">)</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; bucket hash should always be 0 in mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Program FDIRM and verify partial masks */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">vm_pool</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0</span>:
		<span class="n">fdirm</span> <span class="o">|=</span> <span class="n">IXGBE_FDIRM_POOL</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x7F</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; Error on vm pool mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">flow_type</span> <span class="o">&amp;</span> <span class="n">IXGBE_ATR_L4TYPE_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0</span>:
		<span class="n">fdirm</span> <span class="o">|=</span> <span class="n">IXGBE_FDIRM_L4P</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">dst_port</span> <span class="o">||</span>
		    <span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">src_port</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; Error on src/dst port mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IXGBE_ERR_CONFIG</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">IXGBE_ATR_L4TYPE_MASK</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; Error on flow type mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">vlan_id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xEFFF</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0000</span>:
		<span class="cm">/* mask VLAN ID, fall through to mask VLAN priority */</span>
		<span class="n">fdirm</span> <span class="o">|=</span> <span class="n">IXGBE_FDIRM_VLANID</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x0FFF</span>:
		<span class="cm">/* mask VLAN priority */</span>
		<span class="n">fdirm</span> <span class="o">|=</span> <span class="n">IXGBE_FDIRM_VLANP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xE000</span>:
		<span class="cm">/* mask VLAN ID only, fall through */</span>
		<span class="n">fdirm</span> <span class="o">|=</span> <span class="n">IXGBE_FDIRM_VLANID</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xEFFF</span>:
		<span class="cm">/* no VLAN fields masked */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; Error on VLAN mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">flex_bytes</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0000</span>:
		<span class="cm">/* Mask Flex Bytes, fall through */</span>
		<span class="n">fdirm</span> <span class="o">|=</span> <span class="n">IXGBE_FDIRM_FLEX</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xFFFF</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hw_dbg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="s">&quot; Error on flexible byte mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IXGBE_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now mask VM pool and destination IPv6 - bits 5 and 2 */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRM</span><span class="p">,</span> <span class="n">fdirm</span><span class="p">);</span>

	<span class="cm">/* store the TCP/UDP port masks, bit reversed from port layout */</span>
	<span class="n">fdirtcpm</span> <span class="o">=</span> <span class="n">ixgbe_get_fdirtcpm_82599</span><span class="p">(</span><span class="n">input_mask</span><span class="p">);</span>

	<span class="cm">/* write both the same so that UDP and TCP use the same mask */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRTCPM</span><span class="p">,</span> <span class="o">~</span><span class="n">fdirtcpm</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRUDPM</span><span class="p">,</span> <span class="o">~</span><span class="n">fdirtcpm</span><span class="p">);</span>

	<span class="cm">/* store source and destination IP masks (big-enian) */</span>
	<span class="n">IXGBE_WRITE_REG_BE32</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRSIP4M</span><span class="p">,</span>
			     <span class="o">~</span><span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">src_ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">IXGBE_WRITE_REG_BE32</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRDIP4M</span><span class="p">,</span>
			     <span class="o">~</span><span class="n">input_mask</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">dst_ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">s32</span> <span class="nf">ixgbe_fdir_write_perfect_filter_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					  <span class="k">union</span> <span class="n">ixgbe_atr_input</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
					  <span class="n">u16</span> <span class="n">soft_id</span><span class="p">,</span> <span class="n">u8</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">fdirport</span><span class="p">,</span> <span class="n">fdirvlan</span><span class="p">,</span> <span class="n">fdirhash</span><span class="p">,</span> <span class="n">fdircmd</span><span class="p">;</span>

	<span class="cm">/* currently IPv6 is not supported, must be programmed with 0 */</span>
	<span class="n">IXGBE_WRITE_REG_BE32</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRSIPv6</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			     <span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">src_ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">IXGBE_WRITE_REG_BE32</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRSIPv6</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
			     <span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">src_ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">IXGBE_WRITE_REG_BE32</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRSIPv6</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
			     <span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">src_ip</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="cm">/* record the source address (big-endian) */</span>
	<span class="n">IXGBE_WRITE_REG_BE32</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRIPSA</span><span class="p">,</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">src_ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* record the first 32 bits of the destination address (big-endian) */</span>
	<span class="n">IXGBE_WRITE_REG_BE32</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRIPDA</span><span class="p">,</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">dst_ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* record source and destination port (little-endian)*/</span>
	<span class="n">fdirport</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">dst_port</span><span class="p">);</span>
	<span class="n">fdirport</span> <span class="o">&lt;&lt;=</span> <span class="n">IXGBE_FDIRPORT_DESTINATION_SHIFT</span><span class="p">;</span>
	<span class="n">fdirport</span> <span class="o">|=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">src_port</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRPORT</span><span class="p">,</span> <span class="n">fdirport</span><span class="p">);</span>

	<span class="cm">/* record vlan (little-endian) and flex_bytes(big-endian) */</span>
	<span class="n">fdirvlan</span> <span class="o">=</span> <span class="n">IXGBE_STORE_AS_BE16</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">flex_bytes</span><span class="p">);</span>
	<span class="n">fdirvlan</span> <span class="o">&lt;&lt;=</span> <span class="n">IXGBE_FDIRVLAN_FLEX_SHIFT</span><span class="p">;</span>
	<span class="n">fdirvlan</span> <span class="o">|=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">vlan_id</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRVLAN</span><span class="p">,</span> <span class="n">fdirvlan</span><span class="p">);</span>

	<span class="cm">/* configure FDIRHASH register */</span>
	<span class="n">fdirhash</span> <span class="o">=</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">bkt_hash</span><span class="p">;</span>
	<span class="n">fdirhash</span> <span class="o">|=</span> <span class="n">soft_id</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRHASH</span><span class="p">,</span> <span class="n">fdirhash</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * flush all previous writes to make certain registers are</span>
<span class="cm">	 * programmed prior to issuing the command</span>
<span class="cm">	 */</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* configure FDIRCMD register */</span>
	<span class="n">fdircmd</span> <span class="o">=</span> <span class="n">IXGBE_FDIRCMD_CMD_ADD_FLOW</span> <span class="o">|</span> <span class="n">IXGBE_FDIRCMD_FILTER_UPDATE</span> <span class="o">|</span>
		  <span class="n">IXGBE_FDIRCMD_LAST</span> <span class="o">|</span> <span class="n">IXGBE_FDIRCMD_QUEUE_EN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue</span> <span class="o">==</span> <span class="n">IXGBE_FDIR_DROP_QUEUE</span><span class="p">)</span>
		<span class="n">fdircmd</span> <span class="o">|=</span> <span class="n">IXGBE_FDIRCMD_DROP</span><span class="p">;</span>
	<span class="n">fdircmd</span> <span class="o">|=</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">flow_type</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCMD_FLOW_TYPE_SHIFT</span><span class="p">;</span>
	<span class="n">fdircmd</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">queue</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCMD_RX_QUEUE_SHIFT</span><span class="p">;</span>
	<span class="n">fdircmd</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">vm_pool</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRCMD_VT_POOL_SHIFT</span><span class="p">;</span>

	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCMD</span><span class="p">,</span> <span class="n">fdircmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">s32</span> <span class="nf">ixgbe_fdir_erase_perfect_filter_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					  <span class="k">union</span> <span class="n">ixgbe_atr_input</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
					  <span class="n">u16</span> <span class="n">soft_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">fdirhash</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fdircmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">retry_count</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* configure FDIRHASH register */</span>
	<span class="n">fdirhash</span> <span class="o">=</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">formatted</span><span class="p">.</span><span class="n">bkt_hash</span><span class="p">;</span>
	<span class="n">fdirhash</span> <span class="o">|=</span> <span class="n">soft_id</span> <span class="o">&lt;&lt;</span> <span class="n">IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRHASH</span><span class="p">,</span> <span class="n">fdirhash</span><span class="p">);</span>

	<span class="cm">/* flush hash to HW */</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Query if filter is present */</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCMD</span><span class="p">,</span> <span class="n">IXGBE_FDIRCMD_CMD_QUERY_REM_FILT</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">retry_count</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">retry_count</span><span class="p">;</span> <span class="n">retry_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* allow 10us for query to process */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="cm">/* verify query completed successfully */</span>
		<span class="n">fdircmd</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCMD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fdircmd</span> <span class="o">&amp;</span> <span class="n">IXGBE_FDIRCMD_CMD_MASK</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retry_count</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">IXGBE_ERR_FDIR_REINIT_FAILED</span><span class="p">;</span>

	<span class="cm">/* if filter exists in hardware then remove it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdircmd</span> <span class="o">&amp;</span> <span class="n">IXGBE_FDIRCMD_FILTER_VALID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRHASH</span><span class="p">,</span> <span class="n">fdirhash</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FDIRCMD</span><span class="p">,</span>
				<span class="n">IXGBE_FDIRCMD_CMD_REMOVE_FLOW</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_read_analog_reg8_82599 - Reads 8 bit Omer analog register</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @reg: analog register to read</span>
<span class="cm"> *  @val: read value</span>
<span class="cm"> *</span>
<span class="cm"> *  Performs read operation to Omer analog register specified.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_read_analog_reg8_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>  <span class="n">core_ctl</span><span class="p">;</span>

	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CORECTL</span><span class="p">,</span> <span class="n">IXGBE_CORECTL_WRITE_CMD</span> <span class="o">|</span>
	                <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">core_ctl</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CORECTL</span><span class="p">);</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">core_ctl</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_write_analog_reg8_82599 - Writes 8 bit Omer analog register</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @reg: atlas register to write</span>
<span class="cm"> *  @val: value to write</span>
<span class="cm"> *</span>
<span class="cm"> *  Performs write operation to Omer analog register specified.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_write_analog_reg8_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>  <span class="n">core_ctl</span><span class="p">;</span>

	<span class="n">core_ctl</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_CORECTL</span><span class="p">,</span> <span class="n">core_ctl</span><span class="p">);</span>
	<span class="n">IXGBE_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_start_hw_82599 - Prepare hardware for Tx/Rx</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Starts the hardware using the generic start_hw function</span>
<span class="cm"> *  and the generation start_hw function.</span>
<span class="cm"> *  Then performs revision-specific operations, if any.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_start_hw_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_start_hw_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_start_hw_gen2</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* We need to run link autotry after the driver loads */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">autotry_restart</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">rx_pb_size</span> <span class="o">=</span> <span class="n">IXGBE_82599_RX_PB_SIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_verify_fw_version_82599</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_identify_phy_82599 - Get physical layer module</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Determines the physical layer module found on the current adapter.</span>
<span class="cm"> *  If PHY already detected, maintains current PHY type in hw struct,</span>
<span class="cm"> *  otherwise executes the PHY detection routine.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_identify_phy_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_PHY_ADDR_INVALID</span><span class="p">;</span>

	<span class="cm">/* Detect PHY if not unknown - returns success if already detected. */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_identify_phy_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 82599 10GBASE-T requires an external PHY */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_media_type</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">==</span> <span class="n">ixgbe_media_type_copper</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ixgbe_identify_sfp_module_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set PHY type none if no PHY detected */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_phy_unknown</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ixgbe_phy_none</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Return error if SFP module has been detected but is not supported */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_phy_sfp_unsupported</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_SFP_NOT_SUPPORTED</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_get_supported_physical_layer_82599 - Returns physical layer type</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Determines physical layer capabilities of the current configuration.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">ixgbe_get_supported_physical_layer_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">physical_layer</span> <span class="o">=</span> <span class="n">IXGBE_PHYSICAL_LAYER_UNKNOWN</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">autoc</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">autoc2</span> <span class="o">=</span> <span class="n">IXGBE_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_AUTOC2</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">pma_pmd_10g_serial</span> <span class="o">=</span> <span class="n">autoc2</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pma_pmd_10g_parallel</span> <span class="o">=</span> <span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_10G_PMA_PMD_MASK</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pma_pmd_1g</span> <span class="o">=</span> <span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_1G_PMA_PMD_MASK</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ext_ability</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">comp_codes_10g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">comp_codes_1g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">identify</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_phy_tn</span>:
	<span class="k">case</span> <span class="n">ixgbe_phy_cu_unknown</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MDIO_PMA_EXTABLE</span><span class="p">,</span> <span class="n">MDIO_MMD_PMAPMD</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">ext_ability</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext_ability</span> <span class="o">&amp;</span> <span class="n">MDIO_PMA_EXTABLE_10GBT</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">|=</span> <span class="n">IXGBE_PHYSICAL_LAYER_10GBASE_T</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext_ability</span> <span class="o">&amp;</span> <span class="n">MDIO_PMA_EXTABLE_1000BT</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">|=</span> <span class="n">IXGBE_PHYSICAL_LAYER_1000BASE_T</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext_ability</span> <span class="o">&amp;</span> <span class="n">MDIO_PMA_EXTABLE_100BTX</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">|=</span> <span class="n">IXGBE_PHYSICAL_LAYER_100BASE_TX</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_LMS_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_1G_AN</span>:
	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_1G_LINK_NO_AN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pma_pmd_1g</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_1G_KX_BX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">physical_layer</span> <span class="o">=</span> <span class="n">IXGBE_PHYSICAL_LAYER_1000BASE_KX</span> <span class="o">|</span>
			    <span class="n">IXGBE_PHYSICAL_LAYER_1000BASE_BX</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* SFI mode so read SFP module */</span>
			<span class="k">goto</span> <span class="n">sfp_check</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_10G_LINK_NO_AN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pma_pmd_10g_parallel</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_10G_CX4</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">=</span> <span class="n">IXGBE_PHYSICAL_LAYER_10GBASE_CX4</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pma_pmd_10g_parallel</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_10G_KX4</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">=</span> <span class="n">IXGBE_PHYSICAL_LAYER_10GBASE_KX4</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pma_pmd_10g_parallel</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC_10G_XAUI</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">=</span> <span class="n">IXGBE_PHYSICAL_LAYER_10GBASE_XAUI</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_10G_SERIAL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pma_pmd_10g_serial</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC2_10G_KR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">physical_layer</span> <span class="o">=</span> <span class="n">IXGBE_PHYSICAL_LAYER_10GBASE_KR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pma_pmd_10g_serial</span> <span class="o">==</span> <span class="n">IXGBE_AUTOC2_10G_SFI</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">sfp_check</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR</span>:
	<span class="k">case</span> <span class="n">IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KX_SUPP</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">|=</span> <span class="n">IXGBE_PHYSICAL_LAYER_1000BASE_KX</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KX4_SUPP</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">|=</span> <span class="n">IXGBE_PHYSICAL_LAYER_10GBASE_KX4</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">autoc</span> <span class="o">&amp;</span> <span class="n">IXGBE_AUTOC_KR_SUPP</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">|=</span> <span class="n">IXGBE_PHYSICAL_LAYER_10GBASE_KR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">sfp_check:</span>
	<span class="cm">/* SFP check must be done last since DA modules are sometimes used to</span>
<span class="cm">	 * test KR mode -  we need to id KR mode correctly before SFP module.</span>
<span class="cm">	 * Call identify_sfp because the pluggable module may have changed */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">identify_sfp</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">sfp_type</span> <span class="o">==</span> <span class="n">ixgbe_sfp_type_not_present</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_phy_sfp_passive_tyco</span>:
	<span class="k">case</span> <span class="n">ixgbe_phy_sfp_passive_unknown</span>:
		<span class="n">physical_layer</span> <span class="o">=</span> <span class="n">IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_phy_sfp_ftl_active</span>:
	<span class="k">case</span> <span class="n">ixgbe_phy_sfp_active_unknown</span>:
		<span class="n">physical_layer</span> <span class="o">=</span> <span class="n">IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_phy_sfp_avago</span>:
	<span class="k">case</span> <span class="n">ixgbe_phy_sfp_ftl</span>:
	<span class="k">case</span> <span class="n">ixgbe_phy_sfp_intel</span>:
	<span class="k">case</span> <span class="n">ixgbe_phy_sfp_unknown</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_i2c_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
		      <span class="n">IXGBE_SFF_1GBE_COMP_CODES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp_codes_1g</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_i2c_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
		      <span class="n">IXGBE_SFF_10GBE_COMP_CODES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp_codes_10g</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">comp_codes_10g</span> <span class="o">&amp;</span> <span class="n">IXGBE_SFF_10GBASESR_CAPABLE</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">=</span> <span class="n">IXGBE_PHYSICAL_LAYER_10GBASE_SR</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">comp_codes_10g</span> <span class="o">&amp;</span> <span class="n">IXGBE_SFF_10GBASELR_CAPABLE</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">=</span> <span class="n">IXGBE_PHYSICAL_LAYER_10GBASE_LR</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">comp_codes_1g</span> <span class="o">&amp;</span> <span class="n">IXGBE_SFF_1GBASET_CAPABLE</span><span class="p">)</span>
			<span class="n">physical_layer</span> <span class="o">=</span> <span class="n">IXGBE_PHYSICAL_LAYER_1000BASE_T</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">physical_layer</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_enable_rx_dma_82599 - Enable the Rx DMA unit on 82599</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @regval: register value to write to RXCTRL</span>
<span class="cm"> *</span>
<span class="cm"> *  Enables the Rx DMA unit for 82599</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_enable_rx_dma_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">regval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Workaround for 82599 silicon errata when enabling the Rx datapath.</span>
<span class="cm">	 * If traffic is incoming before we enable the Rx unit, it could hang</span>
<span class="cm">	 * the Rx DMA unit.  Therefore, make sure the security engine is</span>
<span class="cm">	 * completely disabled prior to enabling the Rx unit.</span>
<span class="cm">	 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">disable_rx_buff</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">IXGBE_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_RXCTRL</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">enable_rx_buff</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_verify_fw_version_82599 - verify fw version for 82599</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Verifies that installed the firmware version is 0.6 or higher</span>
<span class="cm"> *  for SFI devices. All 82599 SFI devices should have version 0.6 or higher.</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns IXGBE_ERR_EEPROM_VERSION if the FW is not present or</span>
<span class="cm"> *  if the FW version is not supported.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_verify_fw_version_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">IXGBE_ERR_EEPROM_VERSION</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fw_offset</span><span class="p">,</span> <span class="n">fw_ptp_cfg_offset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fw_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* firmware check is only necessary for SFI devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">!=</span> <span class="n">ixgbe_media_type_fiber</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fw_version_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the offset to the Firmware Module block */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FW_PTR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fw_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fw_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fw_offset</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fw_version_out</span><span class="p">;</span>

	<span class="cm">/* get the offset to the Pass Through Patch Configuration block */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">fw_offset</span> <span class="o">+</span>
	                         <span class="n">IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR</span><span class="p">),</span>
	                         <span class="o">&amp;</span><span class="n">fw_ptp_cfg_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fw_ptp_cfg_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fw_ptp_cfg_offset</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fw_version_out</span><span class="p">;</span>

	<span class="cm">/* get the firmware version */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">fw_ptp_cfg_offset</span> <span class="o">+</span>
	                         <span class="n">IXGBE_FW_PATCH_VERSION_4</span><span class="p">),</span>
	                         <span class="o">&amp;</span><span class="n">fw_version</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fw_version</span> <span class="o">&gt;</span> <span class="mh">0x5</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fw_version_out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_verify_lesm_fw_enabled_82599 - Checks LESM FW module state.</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns true if the LESM FW module is present and enabled. Otherwise</span>
<span class="cm"> *  returns false. Smart Speed must be disabled if LESM FW module is enabled.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">ixgbe_verify_lesm_fw_enabled_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">lesm_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fw_offset</span><span class="p">,</span> <span class="n">fw_lesm_param_offset</span><span class="p">,</span> <span class="n">fw_lesm_state</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* get the offset to the Firmware Module block */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IXGBE_FW_PTR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fw_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">fw_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fw_offset</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* get the offset to the LESM Parameters block */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">fw_offset</span> <span class="o">+</span>
				     <span class="n">IXGBE_FW_LESM_PARAMETERS_PTR</span><span class="p">),</span>
				     <span class="o">&amp;</span><span class="n">fw_lesm_param_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">fw_lesm_param_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fw_lesm_param_offset</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* get the lesm state word */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">fw_lesm_param_offset</span> <span class="o">+</span>
				     <span class="n">IXGBE_FW_LESM_STATE_1</span><span class="p">),</span>
				     <span class="o">&amp;</span><span class="n">fw_lesm_state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">fw_lesm_state</span> <span class="o">&amp;</span> <span class="n">IXGBE_FW_LESM_STATE_ENABLED</span><span class="p">))</span>
		<span class="n">lesm_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">lesm_enabled</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_read_eeprom_buffer_82599 - Read EEPROM word(s) using</span>
<span class="cm"> *  fastest available method</span>
<span class="cm"> *</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset of  word in EEPROM to read</span>
<span class="cm"> *  @words: number of words</span>
<span class="cm"> *  @data: word(s) read from the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Retrieves 16 bit word(s) read from EEPROM</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_read_eeprom_buffer_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
					  <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_eeprom_info</span> <span class="o">*</span><span class="n">eeprom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_CONFIG</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If EEPROM is detected and can be addressed using 14 bits,</span>
<span class="cm">	 * use EERD otherwise use bit bang</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_eeprom_spi</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">words</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">IXGBE_EERD_MAX_ADDR</span><span class="p">))</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_read_eerd_buffer_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span>
							 <span class="n">data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_read_eeprom_buffer_bit_bang_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
								    <span class="n">words</span><span class="p">,</span>
								    <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  ixgbe_read_eeprom_82599 - Read EEPROM word using</span>
<span class="cm"> *  fastest available method</span>
<span class="cm"> *</span>
<span class="cm"> *  @hw: pointer to hardware structure</span>
<span class="cm"> *  @offset: offset of  word in the EEPROM to read</span>
<span class="cm"> *  @data: word read from the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads a 16 bit word from the EEPROM</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">ixgbe_read_eeprom_82599</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				   <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_eeprom_info</span> <span class="o">*</span><span class="n">eeprom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">IXGBE_ERR_CONFIG</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If EEPROM is detected and can be addressed using 14 bits,</span>
<span class="cm">	 * use EERD otherwise use bit bang</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_eeprom_spi</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">IXGBE_EERD_MAX_ADDR</span><span class="p">))</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_read_eerd_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">ixgbe_read_eeprom_bit_bang_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ixgbe_mac_operations</span> <span class="n">mac_ops_82599</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init_hw</span>                <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_init_hw_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_hw</span>               <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_reset_hw_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_hw</span>               <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_start_hw_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_hw_cntrs</span>         <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_clear_hw_cntrs_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_media_type</span>         <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_get_media_type_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_supported_physical_layer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_get_supported_physical_layer_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_rx_dma</span>          <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_enable_rx_dma_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable_rx_buff</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_disable_rx_buff_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_rx_buff</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_enable_rx_buff_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_mac_addr</span>           <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_get_mac_addr_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_san_mac_addr</span>       <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_get_san_mac_addr_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_device_caps</span>        <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_get_device_caps_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_wwn_prefix</span>         <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_get_wwn_prefix_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_adapter</span>           <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_stop_adapter_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_bus_info</span>           <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_get_bus_info_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_lan_id</span>             <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_set_lan_id_multi_port_pcie</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_analog_reg8</span>       <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_read_analog_reg8_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_analog_reg8</span>      <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_write_analog_reg8_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup_link</span>             <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_setup_mac_link_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_rxpba</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_set_rxpba_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_link</span>             <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_check_mac_link_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link_capabilities</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_get_link_capabilities_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">led_on</span>                 <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_led_on_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">led_off</span>                <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_led_off_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">blink_led_start</span>        <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_blink_led_start_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">blink_led_stop</span>         <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_blink_led_stop_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_rar</span>                <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_set_rar_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_rar</span>              <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_clear_rar_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_vmdq</span>               <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_set_vmdq_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_vmdq</span>             <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_clear_vmdq_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_rx_addrs</span>          <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_init_rx_addrs_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_mc_addr_list</span>    <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_update_mc_addr_list_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_mc</span>              <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_enable_mc_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable_mc</span>             <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_disable_mc_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_vfta</span>             <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_clear_vfta_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_vfta</span>               <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_set_vfta_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fc_enable</span>              <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_fc_enable_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_fw_drv_ver</span>         <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_set_fw_drv_ver_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_uta_tables</span>        <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_init_uta_tables_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup_sfp</span>              <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_setup_sfp_modules_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_mac_anti_spoofing</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_set_mac_anti_spoofing</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_vlan_anti_spoofing</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_set_vlan_anti_spoofing</span><span class="p">,</span>
	<span class="p">.</span><span class="n">acquire_swfw_sync</span>      <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_acquire_swfw_sync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_swfw_sync</span>      <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_release_swfw_sync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_thermal_sensor_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_get_thermal_sensor_data_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_thermal_sensor_thresh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_init_thermal_sensor_thresh_generic</span><span class="p">,</span>

<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ixgbe_eeprom_operations</span> <span class="n">eeprom_ops_82599</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init_params</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_init_eeprom_params_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_read_eeprom_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_buffer</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_read_eeprom_buffer_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_write_eeprom_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_buffer</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_write_eeprom_buffer_bit_bang_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">calc_checksum</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_calc_eeprom_checksum_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">validate_checksum</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_validate_eeprom_checksum_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_checksum</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_update_eeprom_checksum_generic</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ixgbe_phy_operations</span> <span class="n">phy_ops_82599</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">identify</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_identify_phy_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">identify_sfp</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_identify_sfp_module_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_init_phy_ops_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_reset_phy_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_reg</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_read_phy_reg_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_reg</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_write_phy_reg_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup_link</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_setup_phy_link_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup_link_speed</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_setup_phy_link_speed_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_i2c_byte</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_read_i2c_byte_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_i2c_byte</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_write_i2c_byte_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_i2c_eeprom</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_read_i2c_eeprom_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_i2c_eeprom</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_write_i2c_eeprom_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_overtemp</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_tn_check_overtemp</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ixgbe_info</span> <span class="n">ixgbe_82599_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mac</span>                    <span class="o">=</span> <span class="n">ixgbe_mac_82599EB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_invariants</span>         <span class="o">=</span> <span class="o">&amp;</span><span class="n">ixgbe_get_invariants_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mac_ops</span>                <span class="o">=</span> <span class="o">&amp;</span><span class="n">mac_ops_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eeprom_ops</span>             <span class="o">=</span> <span class="o">&amp;</span><span class="n">eeprom_ops_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">phy_ops</span>                <span class="o">=</span> <span class="o">&amp;</span><span class="n">phy_ops_82599</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mbx_ops</span>                <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbx_ops_generic</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
