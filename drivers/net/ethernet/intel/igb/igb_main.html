<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › igb › igb_main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>igb_main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel(R) Gigabit Ethernet Linux driver</span>
<span class="cm">  Copyright(c) 2007-2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;net/ip6_checksum.h&gt;</span>
<span class="cp">#include &lt;linux/net_tstamp.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/if.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pci-aspm.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/sctp.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/aer.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#ifdef CONFIG_IGB_DCA</span>
<span class="cp">#include &lt;linux/dca.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &quot;igb.h&quot;</span>

<span class="cp">#define MAJ 3</span>
<span class="cp">#define MIN 4</span>
<span class="cp">#define BUILD 7</span>
<span class="cp">#define DRV_VERSION __stringify(MAJ) &quot;.&quot; __stringify(MIN) &quot;.&quot; \</span>
<span class="cp">__stringify(BUILD) &quot;-k&quot;</span>
<span class="kt">char</span> <span class="n">igb_driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;igb&quot;</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">igb_driver_version</span><span class="p">[]</span> <span class="o">=</span> <span class="n">DRV_VERSION</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">igb_driver_string</span><span class="p">[]</span> <span class="o">=</span>
				<span class="s">&quot;Intel(R) Gigabit Ethernet Network Driver&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">igb_copyright</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Copyright (c) 2007-2012 Intel Corporation.&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_info</span> <span class="o">*</span><span class="n">igb_info_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">board_82575</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_82575_info</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">igb_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_I211_COPPER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_I210_COPPER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_I210_FIBER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_I210_SERDES</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_I210_SGMII</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_I350_COPPER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_I350_FIBER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_I350_SERDES</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_I350_SGMII</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82580_COPPER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82580_FIBER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82580_QUAD_FIBER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82580_SERDES</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82580_SGMII</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82580_COPPER_DUAL</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_DH89XXCC_SGMII</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_DH89XXCC_SERDES</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_DH89XXCC_BACKPLANE</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_DH89XXCC_SFP</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82576</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82576_NS</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82576_NS_SERDES</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82576_FIBER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82576_SERDES</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82576_SERDES_QUAD</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82576_QUAD_COPPER_ET2</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82576_QUAD_COPPER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82575EB_COPPER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82575EB_FIBER_SERDES</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82575GB_QUAD_COPPER</span><span class="p">),</span> <span class="n">board_82575</span> <span class="p">},</span>
	<span class="cm">/* required last entry */</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">igb_pci_tbl</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">igb_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_setup_all_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_setup_all_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_free_all_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_free_all_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_setup_mrqc</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="n">igb_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_sw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_configure_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_configure_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_clean_all_tx_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_clean_all_rx_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_clean_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_clean_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_update_phy_info</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_watchdog</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_watchdog_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">igb_xmit_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">igb_get_stats64</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_set_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_set_uta</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">igb_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">igb_intr_msi</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">igb_msix_other</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">igb_msix_ring</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IGB_DCA</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_update_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_setup_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IGB_DCA */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">igb_clean_tx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">igb_clean_rx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_vlan_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_vlan_rx_add_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_vlan_rx_kill_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_restore_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_rar_set_qsel</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_ping_all_vfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_msg_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_vmm_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_set_vf_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_restore_vf_multicasts</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_ndo_set_vf_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_ndo_set_vf_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vlan</span><span class="p">,</span> <span class="n">u8</span> <span class="n">qos</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_ndo_set_vf_bw</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_rate</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_ndo_get_vf_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ifla_vf_info</span> <span class="o">*</span><span class="n">ivi</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_check_vf_rate_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI_IOV</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_vf_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_find_enabled_vfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_check_vf_assignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM_RUNTIME</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_runtime_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_runtime_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_runtime_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">igb_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SET_SYSTEM_SLEEP_PM_OPS</span><span class="p">(</span><span class="n">igb_suspend</span><span class="p">,</span> <span class="n">igb_resume</span><span class="p">)</span>
	<span class="n">SET_RUNTIME_PM_OPS</span><span class="p">(</span><span class="n">igb_runtime_suspend</span><span class="p">,</span> <span class="n">igb_runtime_resume</span><span class="p">,</span>
			<span class="n">igb_runtime_idle</span><span class="p">)</span>
<span class="p">};</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IGB_DCA</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">igb_notify_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">dca_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>	<span class="o">=</span> <span class="n">igb_notify_dca</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="cm">/* for netdump / net console */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PCI_IOV</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_vfs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_vfs</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_vfs</span><span class="p">,</span> <span class="s">&quot;Maximum number of virtual functions to allocate &quot;</span>
                 <span class="s">&quot;per physical function&quot;</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI_IOV */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="n">igb_io_error_detected</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span>
		     <span class="n">pci_channel_state_t</span><span class="p">);</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="n">igb_io_slot_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_io_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_error_handlers</span> <span class="n">igb_err_handler</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">error_detected</span> <span class="o">=</span> <span class="n">igb_io_error_detected</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slot_reset</span> <span class="o">=</span> <span class="n">igb_io_slot_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">igb_io_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">igb_init_dmac</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pba</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">igb_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>     <span class="o">=</span> <span class="n">igb_driver_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">igb_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>    <span class="o">=</span> <span class="n">igb_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>   <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">igb_remove</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">igb_pm_ops</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">igb_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">err_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">igb_err_handler</span>
<span class="p">};</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Intel Corporation, &lt;e1000-devel@lists.sourceforge.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Intel(R) Gigabit Ethernet Network Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>

<span class="cp">#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;Debug level (0=none,...,16=all)&quot;</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">igb_reg_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">igb_reg_info</span> <span class="n">igb_reg_info_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>

	<span class="cm">/* General Registers */</span>
	<span class="p">{</span><span class="n">E1000_CTRL</span><span class="p">,</span> <span class="s">&quot;CTRL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_STATUS</span><span class="p">,</span> <span class="s">&quot;STATUS&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_CTRL_EXT</span><span class="p">,</span> <span class="s">&quot;CTRL_EXT&quot;</span><span class="p">},</span>

	<span class="cm">/* Interrupt Registers */</span>
	<span class="p">{</span><span class="n">E1000_ICR</span><span class="p">,</span> <span class="s">&quot;ICR&quot;</span><span class="p">},</span>

	<span class="cm">/* RX Registers */</span>
	<span class="p">{</span><span class="n">E1000_RCTL</span><span class="p">,</span> <span class="s">&quot;RCTL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDLEN</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RDLEN&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RDH&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RDT&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RXDCTL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDBAL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RDBAL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDBAH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RDBAH&quot;</span><span class="p">},</span>

	<span class="cm">/* TX Registers */</span>
	<span class="p">{</span><span class="n">E1000_TCTL</span><span class="p">,</span> <span class="s">&quot;TCTL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDBAL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TDBAL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDBAH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TDBAH&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDLEN</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TDLEN&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TDH&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TDT&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TXDCTL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDFH</span><span class="p">,</span> <span class="s">&quot;TDFH&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDFT</span><span class="p">,</span> <span class="s">&quot;TDFT&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDFHS</span><span class="p">,</span> <span class="s">&quot;TDFHS&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDFPC</span><span class="p">,</span> <span class="s">&quot;TDFPC&quot;</span><span class="p">},</span>

	<span class="cm">/* List Terminator */</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * igb_regdump - register printout routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_regdump</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">igb_reg_info</span> <span class="o">*</span><span class="n">reginfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">rname</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">regs</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reginfo</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_RDLEN</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RDLEN</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_RDH</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RDH</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_RDT</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RDT</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RXDCTL</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_RDBAL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RDBAL</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_RDBAH</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RDBAH</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_TDBAL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RDBAL</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_TDBAH</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TDBAH</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_TDLEN</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TDLEN</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_TDH</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TDH</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_TDT</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TDT</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TXDCTL</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%-15s %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reginfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rd32</span><span class="p">(</span><span class="n">reginfo</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">rname</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;%s%s&quot;</span><span class="p">,</span> <span class="n">reginfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;[0-3]&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%-15s %08x %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rname</span><span class="p">,</span> <span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">regs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="n">regs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">regs</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * igb_dump - Print registers, tx-rings and rx-rings</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_reg_info</span> <span class="o">*</span><span class="n">reginfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_adv_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">my_u0</span> <span class="p">{</span> <span class="n">u64</span> <span class="n">a</span><span class="p">;</span> <span class="n">u64</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span> <span class="o">*</span><span class="n">u0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">staterr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Print netdevice Info */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Net device Info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Device Name     state            trans_start      &quot;</span>
			<span class="s">&quot;last_rx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%-15s %016lX %016lX %016lX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">trans_start</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">last_rx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Print Registers */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Register Dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; Register Name   Value</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">reginfo</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">igb_reg_info</span> <span class="o">*</span><span class="p">)</span><span class="n">igb_reg_info_tbl</span><span class="p">;</span>
	     <span class="n">reginfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span> <span class="n">reginfo</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">igb_regdump</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">reginfo</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Print TX Ring Summary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span> <span class="o">||</span> <span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX Rings Summary</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Queue [NTU] [NTC] [bi(ntc)-&gt;dma  ] leng ntw timestamp</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
		<span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">];</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; %5d %5X %5X %016llX %04X %p %016llX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">n</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Print TX Rings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_msg_tx_done</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">rx_ring_summary</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX Rings Dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Transmit Descriptor Formats</span>
<span class="cm">	 *</span>
<span class="cm">	 * Advanced Transmit Descriptor</span>
<span class="cm">	 *   +--------------------------------------------------------------+</span>
<span class="cm">	 * 0 |         Buffer Address [63:0]                                |</span>
<span class="cm">	 *   +--------------------------------------------------------------+</span>
<span class="cm">	 * 8 | PAYLEN  | PORTS  |CC|IDX | STA | DCMD  |DTYP|MAC|RSV| DTALEN |</span>
<span class="cm">	 *   +--------------------------------------------------------------+</span>
<span class="cm">	 *   63      46 45    40 39 38 36 35 32 31   24             15       0</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;TX QUEUE INDEX = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;T [desc]     [address 63:0  ] [PlPOCIStDDM Ln] &quot;</span>
			<span class="s">&quot;[bi-&gt;dma       ] leng  ntw timestamp        &quot;</span>
			<span class="s">&quot;bi-&gt;skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">next_desc</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
			<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">u0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_u0</span> <span class="o">*</span><span class="p">)</span><span class="n">tx_desc</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">&amp;&amp;</span>
			    <span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">)</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTC/U&quot;</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">)</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTU&quot;</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">)</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTC&quot;</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;T [0x%03X]    %016llX %016llX %016llX&quot;</span>
				<span class="s">&quot; %04X  %p %016llX %p%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u0</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">),</span>
				<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u0</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span>
				<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span><span class="p">,</span>
				<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">,</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">next_desc</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_pktdata</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
					<span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span>
					<span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">),</span>
					<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Print RX Rings Summary */</span>
<span class="nl">rx_ring_summary:</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RX Rings Summary</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Queue [NTU] [NTC]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; %5d %5X %5X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">n</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Print RX Rings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_msg_rx_status</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RX Rings Dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Advanced Receive Descriptor (Read) Format</span>
<span class="cm">	 *    63                                           1        0</span>
<span class="cm">	 *    +-----------------------------------------------------+</span>
<span class="cm">	 *  0 |       Packet Buffer Address [63:1]           |A0/NSE|</span>
<span class="cm">	 *    +----------------------------------------------+------+</span>
<span class="cm">	 *  8 |       Header Buffer Address [63:1]           |  DD  |</span>
<span class="cm">	 *    +-----------------------------------------------------+</span>
<span class="cm">	 *</span>
<span class="cm">	 *</span>
<span class="cm">	 * Advanced Receive Descriptor (Write-Back) Format</span>
<span class="cm">	 *</span>
<span class="cm">	 *   63       48 47    32 31  30      21 20 17 16   4 3     0</span>
<span class="cm">	 *   +------------------------------------------------------+</span>
<span class="cm">	 * 0 | Packet     IP     |SPH| HDR_LEN   | RSV|Packet|  RSS |</span>
<span class="cm">	 *   | Checksum   Ident  |   |           |    | Type | Type |</span>
<span class="cm">	 *   +------------------------------------------------------+</span>
<span class="cm">	 * 8 | VLAN Tag | Length | Extended Error | Extended Status |</span>
<span class="cm">	 *   +------------------------------------------------------+</span>
<span class="cm">	 *   63       48 47    32 31            20 19               0</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;RX QUEUE INDEX = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;R  [desc]      [ PktBuf     A0] [  HeadBuf   DD] &quot;</span>
			<span class="s">&quot;[bi-&gt;dma       ] [bi-&gt;skb] &lt;-- Adv Rx Read format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;RWB[desc]      [PcsmIpSHl PtRs] [vl er S cks ln] -----&quot;</span>
			<span class="s">&quot;----------- [bi-&gt;skb] &lt;-- Adv Rx Write-Back format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">next_desc</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">igb_rx_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
			<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">IGB_RX_DESC</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">u0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_u0</span> <span class="o">*</span><span class="p">)</span><span class="n">rx_desc</span><span class="p">;</span>
			<span class="n">staterr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">)</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTU&quot;</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">)</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTC&quot;</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_DD</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Descriptor Done */</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s[0x%03X]     %016llX %016llX -------&quot;</span>
					<span class="s">&quot;--------- %p%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;RWB&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u0</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">),</span>
					<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u0</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span>
					<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">next_desc</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s[0x%03X]     %016llX %016llX %016llX&quot;</span>
					<span class="s">&quot; %p%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;R  &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u0</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">),</span>
					<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u0</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span>
					<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">next_desc</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_pktdata</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
						<span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span>
						<span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">phys_to_virt</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">),</span>
						<span class="n">IGB_RX_HDR_LEN</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
					<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
					  <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span>
					  <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					  <span class="n">phys_to_virt</span><span class="p">(</span>
					    <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span> <span class="o">+</span>
					    <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">),</span>
					  <span class="n">PAGE_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">exit:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_get_hw_dev - return device</span>
<span class="cm"> * used by hardware layer to print debugging information</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">igb_get_hw_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_init_module - Driver Registration Routine</span>
<span class="cm"> *</span>
<span class="cm"> * igb_init_module is the first routine called when the driver is</span>
<span class="cm"> * loaded. All it does is register with the PCI subsystem.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">igb_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s - version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">igb_driver_string</span><span class="p">,</span> <span class="n">igb_driver_version</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">igb_copyright</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IGB_DCA</span>
	<span class="n">dca_register_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dca_notifier</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">igb_driver</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">igb_init_module</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * igb_exit_module - Driver Exit Cleanup Routine</span>
<span class="cm"> *</span>
<span class="cm"> * igb_exit_module is called just before the driver is removed</span>
<span class="cm"> * from memory.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">igb_exit_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_IGB_DCA</span>
	<span class="n">dca_unregister_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dca_notifier</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">igb_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">igb_exit_module</span><span class="p">);</span>

<span class="cp">#define Q_IDX_82576(i) (((i &amp; 0x1) &lt;&lt; 3) + (i &gt;&gt; 1))</span>
<span class="cm">/**</span>
<span class="cm"> * igb_cache_ring_register - Descriptor ring to register mapping</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Once we know the feature-set enabled for the device, we&#39;ll cache</span>
<span class="cm"> * the register offset the descriptor ring is assigned to.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_cache_ring_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rbase_offset</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82576</span>:
		<span class="cm">/* The queues are allocated for virtualization such that VF 0</span>
<span class="cm">		 * is allocated queues 0 and 8, VF 1 queues 1 and 9, etc.</span>
<span class="cm">		 * In order to avoid collision we start at the first free queue</span>
<span class="cm">		 * and continue consuming queues in the same sequence</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">rbase_offset</span> <span class="o">+</span>
				                               <span class="n">Q_IDX_82576</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">e1000_82575</span>:
	<span class="k">case</span> <span class="n">e1000_82580</span>:
	<span class="k">case</span> <span class="n">e1000_i350</span>:
	<span class="k">case</span> <span class="n">e1000_i210</span>:
	<span class="k">case</span> <span class="n">e1000_i211</span>:
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">rbase_offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">rbase_offset</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_free_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_alloc_queues - Allocate memory for all rings</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * We allocate one ring per queue at run-time since we don&#39;t know the</span>
<span class="cm"> * number of queues at compile-time.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_alloc_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orig_node</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">orig_node</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="n">next_online_node</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur_node</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
				<span class="n">cur_node</span> <span class="o">=</span> <span class="n">first_online_node</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ring</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring</span><span class="p">)</span>
			<span class="n">ring</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring_count</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">queue_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">numa_node</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
		<span class="cm">/* For 82575, context index must be unique per ring. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82575</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_TX_CTX_IDX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ring</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Restore the adapter&#39;s original node */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">orig_node</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">orig_node</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="n">next_online_node</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur_node</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
				<span class="n">cur_node</span> <span class="o">=</span> <span class="n">first_online_node</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ring</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring</span><span class="p">)</span>
			<span class="n">ring</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring_count</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">queue_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">numa_node</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
		<span class="cm">/* set flag indicating ring supports SCTP checksum offload */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_82576</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_RX_SCTP_CSUM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * On i350, i210, and i211, loopback VLAN packets</span>
<span class="cm">		 * have the tag byte-swapped.</span>
<span class="cm">		 * */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_i350</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_RX_LB_VLAN_BSWAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ring</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Restore the adapter&#39;s original node */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">orig_node</span><span class="p">;</span>

	<span class="n">igb_cache_ring_register</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="cm">/* Restore the adapter&#39;s original node */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">orig_node</span><span class="p">;</span>
	<span class="n">igb_free_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  igb_write_ivar - configure ivar for given MSI-X vector</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @msix_vector: vector number we are allocating to a given ring</span>
<span class="cm"> *  @index: row index of IVAR register to write within IVAR table</span>
<span class="cm"> *  @offset: column offset of in IVAR, should be multiple of 8</span>
<span class="cm"> *</span>
<span class="cm"> *  This function is intended to handle the writing of the IVAR register</span>
<span class="cm"> *  for adapters 82576 and newer.  The IVAR table consists of 2 columns,</span>
<span class="cm"> *  each containing an cause allocation for an Rx and Tx ring, and a</span>
<span class="cm"> *  variable number of rows depending on the number of queues supported.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_write_ivar</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msix_vector</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ivar</span> <span class="o">=</span> <span class="n">array_rd32</span><span class="p">(</span><span class="n">E1000_IVAR0</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="cm">/* clear any bits that are currently set */</span>
	<span class="n">ivar</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="mh">0xFF</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">);</span>

	<span class="cm">/* write vector and valid bit */</span>
	<span class="n">ivar</span> <span class="o">|=</span> <span class="p">(</span><span class="n">msix_vector</span> <span class="o">|</span> <span class="n">E1000_IVAR_VALID</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">array_wr32</span><span class="p">(</span><span class="n">E1000_IVAR0</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ivar</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define IGB_N0_QUEUE -1</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_assign_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msix_vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_queue</span> <span class="o">=</span> <span class="n">IGB_N0_QUEUE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_queue</span> <span class="o">=</span> <span class="n">IGB_N0_QUEUE</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msixbm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
		<span class="n">rx_queue</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">reg_idx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">reg_idx</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82575</span>:
		<span class="cm">/* The 82575 assigns vectors using a bitmask, which matches the</span>
<span class="cm">		   bitmask for the EICR/EIMS/EIMC registers.  To assign one</span>
<span class="cm">		   or more queues to a vector, we write the appropriate bits</span>
<span class="cm">		   into the MSIXBM register for that vector. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_queue</span> <span class="o">&gt;</span> <span class="n">IGB_N0_QUEUE</span><span class="p">)</span>
			<span class="n">msixbm</span> <span class="o">=</span> <span class="n">E1000_EICR_RX_QUEUE0</span> <span class="o">&lt;&lt;</span> <span class="n">rx_queue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_queue</span> <span class="o">&gt;</span> <span class="n">IGB_N0_QUEUE</span><span class="p">)</span>
			<span class="n">msixbm</span> <span class="o">|=</span> <span class="n">E1000_EICR_TX_QUEUE0</span> <span class="o">&lt;&lt;</span> <span class="n">tx_queue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">&amp;&amp;</span> <span class="n">msix_vector</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">msixbm</span> <span class="o">|=</span> <span class="n">E1000_EIMS_OTHER</span><span class="p">;</span>
		<span class="n">array_wr32</span><span class="p">(</span><span class="n">E1000_MSIXBM</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">msix_vector</span><span class="p">,</span> <span class="n">msixbm</span><span class="p">);</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">eims_value</span> <span class="o">=</span> <span class="n">msixbm</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82576</span>:
		<span class="cm">/*</span>
<span class="cm">		 * 82576 uses a table that essentially consists of 2 columns</span>
<span class="cm">		 * with 8 rows.  The ordering is column-major so we use the</span>
<span class="cm">		 * lower 3 bits as the row index, and the 4th bit as the</span>
<span class="cm">		 * column offset.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_queue</span> <span class="o">&gt;</span> <span class="n">IGB_N0_QUEUE</span><span class="p">)</span>
			<span class="n">igb_write_ivar</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">msix_vector</span><span class="p">,</span>
				       <span class="n">rx_queue</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">rx_queue</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_queue</span> <span class="o">&gt;</span> <span class="n">IGB_N0_QUEUE</span><span class="p">)</span>
			<span class="n">igb_write_ivar</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">msix_vector</span><span class="p">,</span>
				       <span class="n">tx_queue</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">,</span>
				       <span class="p">((</span><span class="n">tx_queue</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">eims_value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">msix_vector</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82580</span>:
	<span class="k">case</span> <span class="n">e1000_i350</span>:
	<span class="k">case</span> <span class="n">e1000_i210</span>:
	<span class="k">case</span> <span class="n">e1000_i211</span>:
		<span class="cm">/*</span>
<span class="cm">		 * On 82580 and newer adapters the scheme is similar to 82576</span>
<span class="cm">		 * however instead of ordering column-major we have things</span>
<span class="cm">		 * ordered row-major.  So we traverse the table by using</span>
<span class="cm">		 * bit 0 as the column offset, and the remaining bits as the</span>
<span class="cm">		 * row index.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_queue</span> <span class="o">&gt;</span> <span class="n">IGB_N0_QUEUE</span><span class="p">)</span>
			<span class="n">igb_write_ivar</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">msix_vector</span><span class="p">,</span>
				       <span class="n">rx_queue</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">rx_queue</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_queue</span> <span class="o">&gt;</span> <span class="n">IGB_N0_QUEUE</span><span class="p">)</span>
			<span class="n">igb_write_ivar</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">msix_vector</span><span class="p">,</span>
				       <span class="n">tx_queue</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span>
				       <span class="p">((</span><span class="n">tx_queue</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">eims_value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">msix_vector</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* add q_vector eims value to global eims_enable_mask */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span> <span class="o">|=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">eims_value</span><span class="p">;</span>

	<span class="cm">/* configure q_vector to set itr on first interrupt */</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">set_itr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_configure_msix - Configure MSI-X hardware</span>
<span class="cm"> *</span>
<span class="cm"> * igb_configure_msix sets up the hardware to properly</span>
<span class="cm"> * generate MSI-X interrupts.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_configure_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* set vector for other causes, i.e. link changes */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82575</span>:
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">);</span>
		<span class="cm">/* enable MSI-X PBA support*/</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_PBA_CLR</span><span class="p">;</span>

		<span class="cm">/* Auto-Mask interrupts upon ICR read. */</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_EIAME</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_IRCA</span><span class="p">;</span>

		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

		<span class="cm">/* enable msix_other interrupt */</span>
		<span class="n">array_wr32</span><span class="p">(</span><span class="n">E1000_MSIXBM</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">vector</span><span class="o">++</span><span class="p">,</span>
		                      <span class="n">E1000_EIMS_OTHER</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_other</span> <span class="o">=</span> <span class="n">E1000_EIMS_OTHER</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">e1000_82576</span>:
	<span class="k">case</span> <span class="n">e1000_82580</span>:
	<span class="k">case</span> <span class="n">e1000_i350</span>:
	<span class="k">case</span> <span class="n">e1000_i210</span>:
	<span class="k">case</span> <span class="n">e1000_i211</span>:
		<span class="cm">/* Turn on MSI-X capability first, or our settings</span>
<span class="cm">		 * won&#39;t stick.  And it will take days to debug. */</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_GPIE</span><span class="p">,</span> <span class="n">E1000_GPIE_MSIX_MODE</span> <span class="o">|</span>
		                <span class="n">E1000_GPIE_PBA</span> <span class="o">|</span> <span class="n">E1000_GPIE_EIAME</span> <span class="o">|</span>
		                <span class="n">E1000_GPIE_NSICR</span><span class="p">);</span>

		<span class="cm">/* enable msix_other interrupt */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_other</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">vector</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">vector</span><span class="o">++</span> <span class="o">|</span> <span class="n">E1000_IVAR_VALID</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>

		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_IVAR_MISC</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* do nothing, since nothing else supports MSI-X */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="cm">/* switch (hw-&gt;mac.type) */</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span> <span class="o">|=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_other</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">igb_assign_vector</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vector</span><span class="o">++</span><span class="p">);</span>

	<span class="n">wrfl</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_request_msix - Initialize MSI-X interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * igb_request_msix allocates MSI-X vectors and requests interrupts from the</span>
<span class="cm"> * kernel.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_request_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
	                  <span class="n">igb_msix_other</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">++</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_register</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">E1000_EITR</span><span class="p">(</span><span class="n">vector</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span> <span class="o">&amp;&amp;</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s-TxRx-%u&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s-tx-%u&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s-rx-%u&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s-unused&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
		                  <span class="n">igb_msix_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		                  <span class="n">q_vector</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">vector</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">igb_configure_msix</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_reset_interrupt_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_FLAG_HAS_MSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_free_q_vectors - Free memory allocated for interrupt vectors</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * This function frees the memory allocated to the q_vectors.  In addition if</span>
<span class="cm"> * NAPI is enabled it will delete any references to the NAPI struct prior</span>
<span class="cm"> * to freeing the q_vector.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_free_q_vectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">v_idx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">v_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v_idx</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">v_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">v_idx</span><span class="p">];</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">v_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q_vector</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">netif_napi_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_clear_interrupt_scheme - reset the device to a state of no interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * This function resets the device so that it has 0 rx queues, tx queues, and</span>
<span class="cm"> * MSI-X interrupts allocated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_clear_interrupt_scheme</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">igb_free_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_free_q_vectors</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_set_interrupt_capability - set MSI or MSI-X if supported</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to configure interrupts using the best available</span>
<span class="cm"> * capabilities of the hardware and kernel.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_set_interrupt_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numvecs</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Number of supported queues. */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span><span class="p">;</span>

	<span class="cm">/* start with one vector for every rx queue */</span>
	<span class="n">numvecs</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span>

	<span class="cm">/* if tx handler is separate add 1 for every tx queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_FLAG_QUEUE_PAIRS</span><span class="p">))</span>
		<span class="n">numvecs</span> <span class="o">+=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span>

	<span class="cm">/* i210 and i211 can only have 4 MSIX vectors for rx/tx queues. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_i210</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_i211</span><span class="p">))</span>
		<span class="n">numvecs</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* store the number of vectors reserved for queues */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span> <span class="o">=</span> <span class="n">numvecs</span><span class="p">;</span>

	<span class="cm">/* add 1 vector for link status interrupts */</span>
	<span class="n">numvecs</span><span class="o">++</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">numvecs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msix_entry</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">msi_only</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numvecs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			      <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">,</span>
			      <span class="n">numvecs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">igb_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* If we can&#39;t do MSI-X, try MSI */</span>
<span class="nl">msi_only:</span>
<span class="cp">#ifdef CONFIG_PCI_IOV</span>
	<span class="cm">/* disable SR-IOV for non MSI-X configurations */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
		<span class="cm">/* disable iov and allow time for transactions to clear */</span>
		<span class="n">pci_disable_sriov</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_IOVCTL</span><span class="p">,</span> <span class="n">E1000_IOVCTL_REUSE_VFQ</span><span class="p">);</span>
		<span class="n">wrfl</span><span class="p">();</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IOV Disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IGB_FLAG_QUEUE_PAIRS</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IGB_FLAG_HAS_MSI</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="cm">/* Notify the stack of the (possibly) reduced queue counts. */</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">netif_set_real_num_tx_queues</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_alloc_q_vectors - Allocate memory for interrupt vectors</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * We allocate one q_vector per queue interrupt.  If allocation fails we</span>
<span class="cm"> * return -ENOMEM.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_alloc_q_vectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">v_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orig_node</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">v_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v_idx</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">v_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span> <span class="o">==</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">+</span>
						<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">==</span> <span class="n">v_idx</span><span class="p">))</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">orig_node</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">orig_node</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="n">next_online_node</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur_node</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
				<span class="n">cur_node</span> <span class="o">=</span> <span class="n">first_online_node</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">q_vector</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q_vector</span><span class="p">)</span>
			<span class="n">q_vector</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span><span class="p">),</span>
					   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q_vector</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_register</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">E1000_EITR</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">IGB_START_ITR</span><span class="p">;</span>
		<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">igb_poll</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">v_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_vector</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Restore the adapter&#39;s original node */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">orig_node</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="cm">/* Restore the adapter&#39;s original node */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">orig_node</span><span class="p">;</span>
	<span class="n">igb_free_q_vectors</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_map_rx_ring_to_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                                      <span class="kt">int</span> <span class="n">ring_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">v_idx</span><span class="p">];</span>

	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">];</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">q_vector</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr_setting</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">&amp;&amp;</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">IGB_START_ITR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_map_tx_ring_to_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                                      <span class="kt">int</span> <span class="n">ring_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">v_idx</span><span class="p">];</span>

	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">ring_idx</span><span class="p">];</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">q_vector</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr_setting</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">work_limit</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_work_limit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">&amp;&amp;</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">IGB_START_ITR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_map_ring_to_vector - maps allocated queues to vectors</span>
<span class="cm"> *</span>
<span class="cm"> * This function maps the recently allocated queues to vectors.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_map_ring_to_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">v_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span> <span class="o">&gt;=</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">igb_map_rx_ring_to_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v_idx</span><span class="o">++</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">igb_map_tx_ring_to_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v_idx</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">)</span>
				<span class="n">igb_map_tx_ring_to_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v_idx</span><span class="p">);</span>
			<span class="n">igb_map_rx_ring_to_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v_idx</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">igb_map_tx_ring_to_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v_idx</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_init_interrupt_scheme - initialize interrupts, allocate queues/vectors</span>
<span class="cm"> *</span>
<span class="cm"> * This function initializes the interrupts and allocates all of the queues.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_init_interrupt_scheme</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">igb_set_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">igb_alloc_q_vectors</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for vectors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_alloc_q_vectors</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">igb_alloc_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_alloc_queues</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">igb_map_ring_to_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid q_vector to ring mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_map_queues</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_map_queues:</span>
	<span class="n">igb_free_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_alloc_queues:</span>
	<span class="n">igb_free_q_vectors</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_alloc_q_vectors:</span>
	<span class="n">igb_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_request_irq - initialize interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * Attempts to configure interrupts using the best available</span>
<span class="cm"> * capabilities of the hardware and kernel.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_request_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">igb_request_msix</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">request_done</span><span class="p">;</span>
		<span class="cm">/* fall back to MSI */</span>
		<span class="n">igb_clear_interrupt_scheme</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IGB_FLAG_HAS_MSI</span><span class="p">;</span>
		<span class="n">igb_free_all_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">igb_free_all_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">igb_alloc_q_vectors</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			        <span class="s">&quot;Unable to allocate memory for vectors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">request_done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">igb_alloc_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			        <span class="s">&quot;Unable to allocate memory for queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">igb_free_q_vectors</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">request_done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">igb_setup_all_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">igb_setup_all_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">igb_assign_vector</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_FLAG_HAS_MSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">igb_intr_msi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">request_done</span><span class="p">;</span>

		<span class="cm">/* fall back to legacy interrupts */</span>
		<span class="n">igb_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGB_FLAG_HAS_MSI</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">igb_intr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			  <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error %d getting interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">err</span><span class="p">);</span>

<span class="nl">request_done:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_free_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="o">++</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="o">++</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_irq_disable - Mask off interrupt generation on the NIC</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_irq_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we need to be careful when disabling interrupts.  The VFs are also</span>
<span class="cm">	 * mapped into these registers and so clearing the bits can cause</span>
<span class="cm">	 * issues on the VF drivers so we only need to clear what we set</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">regval</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_EIAM</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_EIAM</span><span class="p">,</span> <span class="n">regval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_EIMC</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span><span class="p">);</span>
		<span class="n">regval</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_EIAC</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_EIAC</span><span class="p">,</span> <span class="n">regval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_IAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_IMC</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">wrfl</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_irq_enable - Enable default interrupt generation settings</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ims</span> <span class="o">=</span> <span class="n">E1000_IMS_LSC</span> <span class="o">|</span> <span class="n">E1000_IMS_DOUTSYNC</span> <span class="o">|</span> <span class="n">E1000_IMS_DRSTA</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">regval</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_EIAC</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_EIAC</span><span class="p">,</span> <span class="n">regval</span> <span class="o">|</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span><span class="p">);</span>
		<span class="n">regval</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_EIAM</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_EIAM</span><span class="p">,</span> <span class="n">regval</span> <span class="o">|</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_EIMS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_MBVFIMR</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
			<span class="n">ims</span> <span class="o">|=</span> <span class="n">E1000_IMS_VMMB</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_IMS</span><span class="p">,</span> <span class="n">ims</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_IMS</span><span class="p">,</span> <span class="n">IMS_ENABLE_MASK</span> <span class="o">|</span>
				<span class="n">E1000_IMS_DRSTA</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_IAM</span><span class="p">,</span> <span class="n">IMS_ENABLE_MASK</span> <span class="o">|</span>
				<span class="n">E1000_IMS_DRSTA</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_update_mng_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vid</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">vlan_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">old_vid</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_MNG_DHCP_COOKIE_STATUS_VLAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* add VID to filter table */</span>
		<span class="n">igb_vfta_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span> <span class="o">=</span> <span class="n">vid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span> <span class="o">=</span> <span class="n">IGB_MNG_VLAN_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">old_vid</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">IGB_MNG_VLAN_NONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">vid</span> <span class="o">!=</span> <span class="n">old_vid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">old_vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* remove VID from filter table */</span>
		<span class="n">igb_vfta_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">old_vid</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_release_hw_control - release control of the h/w to f/w</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * igb_release_hw_control resets CTRL_EXT:DRV_LOAD bit.</span>
<span class="cm"> * For ASF and Pass Through versions of f/w this means that the</span>
<span class="cm"> * driver is no longer loaded.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_release_hw_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">;</span>

	<span class="cm">/* Let firmware take over control of h/w */</span>
	<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">,</span>
			<span class="n">ctrl_ext</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_CTRL_EXT_DRV_LOAD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_get_hw_control - get control of the h/w from f/w</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * igb_get_hw_control sets CTRL_EXT:DRV_LOAD bit.</span>
<span class="cm"> * For ASF and Pass Through versions of f/w this means that</span>
<span class="cm"> * the driver is loaded.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_get_hw_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">;</span>

	<span class="cm">/* Let firmware know the driver has taken over */</span>
	<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">,</span>
			<span class="n">ctrl_ext</span> <span class="o">|</span> <span class="n">E1000_CTRL_EXT_DRV_LOAD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_configure - configure the hardware for RX and TX</span>
<span class="cm"> * @adapter: private board structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">igb_get_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_set_rx_mode</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">igb_restore_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">igb_setup_tctl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_setup_mrqc</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_setup_rctl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">igb_configure_tx</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_configure_rx</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">igb_rx_fifo_flush_82575</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* call igb_desc_unused which always leaves</span>
<span class="cm">	 * at least 1 descriptor unused to make sure</span>
<span class="cm">	 * next_to_use != next_to_clean */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">igb_alloc_rx_buffers</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">igb_desc_unused</span><span class="p">(</span><span class="n">ring</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_power_up_link - Power up the phy/serdes link</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">igb_power_up_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span>
		<span class="n">igb_power_up_phy_copper</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">igb_power_up_serdes_link_82575</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">igb_reset_phy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_power_down_link - Power down the phy/serdes link</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_power_down_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span>
		<span class="n">igb_power_down_phy_copper_82575</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">igb_shutdown_serdes_link_82575</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_up - Open the interface and prepare it to handle traffic</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">igb_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* hardware has been reset, we need to reload some things */</span>
	<span class="n">igb_configure</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="n">igb_configure_msix</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">igb_assign_vector</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Clear any pending interrupts. */</span>
	<span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICR</span><span class="p">);</span>
	<span class="n">igb_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* notify VFs that reset has been completed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">reg_data</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">);</span>
		<span class="n">reg_data</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_PFRSTD</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netif_tx_start_all_queues</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* start the watchdog. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">igb_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tctl</span><span class="p">,</span> <span class="n">rctl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* signal that we&#39;re down so the interrupt handler does not</span>
<span class="cm">	 * reschedule our watchdog timer */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="cm">/* disable receives in the hardware */</span>
	<span class="n">rctl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RCTL</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RCTL</span><span class="p">,</span> <span class="n">rctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_RCTL_EN</span><span class="p">);</span>
	<span class="cm">/* flush and sleep below */</span>

	<span class="n">netif_tx_stop_all_queues</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* disable transmits in the hardware */</span>
	<span class="n">tctl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TCTL</span><span class="p">);</span>
	<span class="n">tctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_TCTL_EN</span><span class="p">;</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TCTL</span><span class="p">,</span> <span class="n">tctl</span><span class="p">);</span>
	<span class="cm">/* flush both disables and wait for them to finish */</span>
	<span class="n">wrfl</span><span class="p">();</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">));</span>

	<span class="n">igb_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">);</span>

	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* record the stats before reset*/</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>
	<span class="n">igb_update_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">igb_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_clean_all_tx_rings</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_clean_all_rx_rings</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IGB_DCA</span>

	<span class="cm">/* since we reset the hardware DCA settings were cleared */</span>
	<span class="n">igb_setup_dca</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">igb_reinit_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__IGB_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">igb_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__IGB_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">igb_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_fc_info</span> <span class="o">*</span><span class="n">fc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pba</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tx_space</span><span class="p">,</span> <span class="n">min_tx_space</span><span class="p">,</span> <span class="n">min_rx_space</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hwm</span><span class="p">;</span>

	<span class="cm">/* Repartition Pba for greater than 9k mtu</span>
<span class="cm">	 * To take effect CTRL.RST is required.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_i350</span>:
	<span class="k">case</span> <span class="n">e1000_82580</span>:
		<span class="n">pba</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RXPBS</span><span class="p">);</span>
		<span class="n">pba</span> <span class="o">=</span> <span class="n">igb_rxpbs_adjust_82580</span><span class="p">(</span><span class="n">pba</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82576</span>:
		<span class="n">pba</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RXPBS</span><span class="p">);</span>
		<span class="n">pba</span> <span class="o">&amp;=</span> <span class="n">E1000_RXPBS_SIZE_MASK_82576</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82575</span>:
	<span class="k">case</span> <span class="n">e1000_i210</span>:
	<span class="k">case</span> <span class="n">e1000_i211</span>:
	<span class="nl">default:</span>
		<span class="n">pba</span> <span class="o">=</span> <span class="n">E1000_PBA_34K</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">&gt;</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">e1000_82576</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* adjust PBA for jumbo frames */</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_PBA</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>

		<span class="cm">/* To maintain wire speed transmits, the Tx FIFO should be</span>
<span class="cm">		 * large enough to accommodate two full transmit packets,</span>
<span class="cm">		 * rounded up to the next 1KB and expressed in KB.  Likewise,</span>
<span class="cm">		 * the Rx FIFO should be large enough to accommodate at least</span>
<span class="cm">		 * one full receive packet and is similarly rounded up and</span>
<span class="cm">		 * expressed in KB. */</span>
		<span class="n">pba</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PBA</span><span class="p">);</span>
		<span class="cm">/* upper 16 bits has Tx packet buffer allocation size in KB */</span>
		<span class="n">tx_space</span> <span class="o">=</span> <span class="n">pba</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="cm">/* lower 16 bits has Rx packet buffer allocation size in KB */</span>
		<span class="n">pba</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="cm">/* the tx fifo also stores 16 bytes of information about the tx</span>
<span class="cm">		 * but don&#39;t include ethernet FCS because hardware appends it */</span>
		<span class="n">min_tx_space</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_tx_desc</span><span class="p">)</span> <span class="o">-</span>
				<span class="n">ETH_FCS_LEN</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">min_tx_space</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">min_tx_space</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
		<span class="n">min_tx_space</span> <span class="o">&gt;&gt;=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* software strips receive CRC, so leave room for it */</span>
		<span class="n">min_rx_space</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">;</span>
		<span class="n">min_rx_space</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">min_rx_space</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
		<span class="n">min_rx_space</span> <span class="o">&gt;&gt;=</span> <span class="mi">10</span><span class="p">;</span>

		<span class="cm">/* If current Tx allocation is less than the min Tx FIFO size,</span>
<span class="cm">		 * and the min Tx FIFO size is less than the current Rx FIFO</span>
<span class="cm">		 * allocation, take space away from current Rx allocation */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_space</span> <span class="o">&lt;</span> <span class="n">min_tx_space</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">min_tx_space</span> <span class="o">-</span> <span class="n">tx_space</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">pba</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pba</span> <span class="o">=</span> <span class="n">pba</span> <span class="o">-</span> <span class="p">(</span><span class="n">min_tx_space</span> <span class="o">-</span> <span class="n">tx_space</span><span class="p">);</span>

			<span class="cm">/* if short on rx space, rx wins and must trump tx</span>
<span class="cm">			 * adjustment */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pba</span> <span class="o">&lt;</span> <span class="n">min_rx_space</span><span class="p">)</span>
				<span class="n">pba</span> <span class="o">=</span> <span class="n">min_rx_space</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_PBA</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* flow control settings */</span>
	<span class="cm">/* The high water mark must be low enough to fit one full frame</span>
<span class="cm">	 * (or the size used for early receive) above it in the Rx FIFO.</span>
<span class="cm">	 * Set it to the lower of:</span>
<span class="cm">	 * - 90% of the Rx FIFO size, or</span>
<span class="cm">	 * - the full Rx FIFO size minus one full frame */</span>
	<span class="n">hwm</span> <span class="o">=</span> <span class="n">min</span><span class="p">(((</span><span class="n">pba</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">10</span><span class="p">),</span>
			<span class="p">((</span><span class="n">pba</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">));</span>

	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">high_water</span> <span class="o">=</span> <span class="n">hwm</span> <span class="o">&amp;</span> <span class="mh">0xFFF0</span><span class="p">;</span>	<span class="cm">/* 16-byte granularity */</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">low_water</span> <span class="o">=</span> <span class="n">fc</span><span class="o">-&gt;</span><span class="n">high_water</span> <span class="o">-</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">pause_time</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">send_xon</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">current_mode</span> <span class="o">=</span> <span class="n">fc</span><span class="o">-&gt;</span><span class="n">requested_mode</span><span class="p">;</span>

	<span class="cm">/* disable receive for all VFs and wait one second */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">IGB_VF_FLAG_PF_SET_MAC</span><span class="p">;</span>

		<span class="cm">/* ping all the active vfs to let them know we are going down */</span>
		<span class="n">igb_ping_all_vfs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="cm">/* disable transmits and receives */</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VFRE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VFTE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Allow time for pending master requests to run */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">reset_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_WUC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Hardware Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flow control settings reset on hardware reset, so guarantee flow</span>
<span class="cm">	 * control is off when forcing speed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">autoneg</span><span class="p">)</span>
		<span class="n">igb_force_mac_fc</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">igb_init_dmac</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">igb_power_down_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">igb_update_mng_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Enable h/w to recognize an 802.1Q VLAN Ethernet packet */</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VET</span><span class="p">,</span> <span class="n">ETHERNET_IEEE_VLAN_TYPE</span><span class="p">);</span>

	<span class="n">igb_get_phy_info</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_features_t</span> <span class="nf">igb_fix_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since there is no support for separate rx/tx vlan accel</span>
<span class="cm">	 * enable/disable make sure tx flag is always in same state as rx.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span>
		<span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">features</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_set_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netdev_features_t</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">^</span> <span class="n">features</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">changed</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span>
		<span class="n">igb_vlan_mode</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">changed</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXALL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">features</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">igb_reinit_locked</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">igb_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">igb_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">igb_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">igb_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">igb_xmit_frame</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats64</span>	<span class="o">=</span> <span class="n">igb_get_stats64</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">igb_set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">igb_set_mac</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">igb_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">igb_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">igb_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_add_vid</span>	<span class="o">=</span> <span class="n">igb_vlan_rx_add_vid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_kill_vid</span>	<span class="o">=</span> <span class="n">igb_vlan_rx_kill_vid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_vf_mac</span>		<span class="o">=</span> <span class="n">igb_ndo_set_vf_mac</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_vf_vlan</span>	<span class="o">=</span> <span class="n">igb_ndo_set_vf_vlan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_vf_tx_rate</span>	<span class="o">=</span> <span class="n">igb_ndo_set_vf_bw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_vf_config</span>	<span class="o">=</span> <span class="n">igb_ndo_get_vf_config</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">igb_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">ndo_fix_features</span>	<span class="o">=</span> <span class="n">igb_fix_features</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_features</span>	<span class="o">=</span> <span class="n">igb_set_features</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * igb_probe - Device Initialization Routine</span>
<span class="cm"> * @pdev: PCI device information struct</span>
<span class="cm"> * @ent: entry in igb_pci_tbl</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> *</span>
<span class="cm"> * igb_probe initializes an adapter identified by a pci_dev structure.</span>
<span class="cm"> * The OS initialization, configuring of the adapter private structure,</span>
<span class="cm"> * and a hardware reset occur.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">igb_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">global_quad_port_a</span><span class="p">;</span> <span class="cm">/* global quad port a indication */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">igb_info_tbl</span><span class="p">[</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmio_start</span><span class="p">,</span> <span class="n">mmio_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">pci_using_dac</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_apme_mask</span> <span class="o">=</span> <span class="n">IGB_EEPROM_APME</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">part_str</span><span class="p">[</span><span class="n">E1000_PBANUM_LENGTH</span><span class="p">];</span>

	<span class="cm">/* Catch broken hardware that put the wrong VF device ID in</span>
<span class="cm">	 * the PCIe SR-IOV capability.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">is_virtfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;%s (%hx:%hx) should not be a VF!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_coherent_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_coherent_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No usable DMA &quot;</span>
					<span class="s">&quot;configuration, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err_dma</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
	                                   <span class="n">IORESOURCE_MEM</span><span class="p">),</span>
	                                   <span class="n">igb_driver_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_pci_reg</span><span class="p">;</span>

	<span class="n">pci_enable_pcie_error_reporting</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">netdev</span> <span class="o">=</span> <span class="n">alloc_etherdev_mq</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span><span class="p">),</span>
				   <span class="n">IGB_MAX_TX_QUEUES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc_etherdev</span><span class="p">;</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">netif_msg_init</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">DEFAULT_MSG_ENABLE</span><span class="p">);</span>

	<span class="n">mmio_start</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mmio_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">mmio_start</span><span class="p">,</span> <span class="n">mmio_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_ioremap</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">igb_netdev_ops</span><span class="p">;</span>
	<span class="n">igb_set_ethtool_ops</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">=</span> <span class="n">mmio_start</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">=</span> <span class="n">mmio_start</span> <span class="o">+</span> <span class="n">mmio_len</span><span class="p">;</span>

	<span class="cm">/* PCI config space info */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">revision_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">subsystem_vendor_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">subsystem_device_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">;</span>

	<span class="cm">/* Copy the default MAC, PHY and NVM function pointers */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">mac_ops</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">phy_ops</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">ops</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">nvm_ops</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">ops</span><span class="p">));</span>
	<span class="cm">/* Initialize skew-specific constants */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">get_invariants</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_sw_init</span><span class="p">;</span>

	<span class="cm">/* setup the private structure */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">igb_sw_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_sw_init</span><span class="p">;</span>

	<span class="n">igb_get_bus_info_pcie</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_wait_to_complete</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Copper options */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">mdix</span> <span class="o">=</span> <span class="n">AUTO_ALL_MODES</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">disable_polarity_correction</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ms_type</span> <span class="o">=</span> <span class="n">e1000_ms_hw_default</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">igb_check_reset_block</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;PHY reset is blocked due to SOL/IDER session.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * features is initialized to 0 in allocation, it might have bits</span>
<span class="cm">	 * set by igb_sw_init so we should use an or instead of an</span>
<span class="cm">	 * assignment.</span>
<span class="cm">	 */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span>
			    <span class="n">NETIF_F_IP_CSUM</span> <span class="o">|</span>
			    <span class="n">NETIF_F_IPV6_CSUM</span> <span class="o">|</span>
			    <span class="n">NETIF_F_TSO</span> <span class="o">|</span>
			    <span class="n">NETIF_F_TSO6</span> <span class="o">|</span>
			    <span class="n">NETIF_F_RXHASH</span> <span class="o">|</span>
			    <span class="n">NETIF_F_RXCSUM</span> <span class="o">|</span>
			    <span class="n">NETIF_F_HW_VLAN_RX</span> <span class="o">|</span>
			    <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">;</span>

	<span class="cm">/* copy netdev features into list of user selectable features */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_RXALL</span><span class="p">;</span>

	<span class="cm">/* set this bit last since it cannot be part of hw_features */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_VLAN_FILTER</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO</span> <span class="o">|</span>
				 <span class="n">NETIF_F_TSO6</span> <span class="o">|</span>
				 <span class="n">NETIF_F_IP_CSUM</span> <span class="o">|</span>
				 <span class="n">NETIF_F_IPV6_CSUM</span> <span class="o">|</span>
				 <span class="n">NETIF_F_SG</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">IFF_SUPP_NOFCS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_using_dac</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_82576</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_SCTP_CSUM</span><span class="p">;</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_SCTP_CSUM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">IFF_UNICAST_FLT</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">en_mng_pt</span> <span class="o">=</span> <span class="n">igb_enable_mng_pass_thru</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* before reading the NVM, reset the controller to put the device in a</span>
<span class="cm">	 * known good starting state */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">reset_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure the NVM is good , i211 parts have special NVM that</span>
<span class="cm">	 * doesn&#39;t contain a checksum</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_i211</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">validate</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;The NVM Checksum Is Not Valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_eeprom</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* copy the MAC address out of the NVM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_mac_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NVM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid MAC Address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_eeprom</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">igb_watchdog</span><span class="p">,</span>
	            <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">adapter</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">,</span> <span class="n">igb_update_phy_info</span><span class="p">,</span>
	            <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">,</span> <span class="n">igb_reset_task</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">,</span> <span class="n">igb_watchdog_task</span><span class="p">);</span>

	<span class="cm">/* Initialize link properties that are user-changeable */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fc_autoneg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">autoneg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="mh">0x2f</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">requested_mode</span> <span class="o">=</span> <span class="n">e1000_fc_default</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span> <span class="o">=</span> <span class="n">e1000_fc_default</span><span class="p">;</span>

	<span class="n">igb_validate_mdi_setting</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Initial Wake on LAN setting If APM wake is enabled in the EEPROM,</span>
<span class="cm">	 * enable the ACPI Magic Packet filter</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">func</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_INIT_CONTROL3_PORT_A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_82580</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_INIT_CONTROL3_PORT_A</span> <span class="o">+</span>
		                 <span class="n">NVM_82580_LAN_FUNC_OFFSET</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">func</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
		                 <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">func</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_INIT_CONTROL3_PORT_B</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom_data</span> <span class="o">&amp;</span> <span class="n">eeprom_apme_mask</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span> <span class="o">|=</span> <span class="n">E1000_WUFC_MAG</span><span class="p">;</span>

	<span class="cm">/* now that we have the eeprom settings, apply the special cases where</span>
<span class="cm">	 * the eeprom may be wrong or the board simply won&#39;t support wake on</span>
<span class="cm">	 * lan on a particular port */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82575GB_QUAD_COPPER</span>:
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82575EB_FIBER_SERDES</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82576_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82576_SERDES</span>:
		<span class="cm">/* Wake events only supported on port A for dual fiber</span>
<span class="cm">		 * regardless of eeprom setting */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rd32</span><span class="p">(</span><span class="n">E1000_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_FUNC_1</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82576_QUAD_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82576_QUAD_COPPER_ET2</span>:
		<span class="cm">/* if quad port adapter, disable WoL on all but port A */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">global_quad_port_a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IGB_FLAG_QUAD_PORT_A</span><span class="p">;</span>
		<span class="cm">/* Reset for multiple quad port adapters */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">global_quad_port_a</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">global_quad_port_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize the wol settings based on the eeprom settings */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span><span class="p">;</span>
	<span class="n">device_set_wakeup_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span><span class="p">);</span>

	<span class="cm">/* reset the hardware with the new settings */</span>
	<span class="n">igb_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* let the f/w know that the h/w is now under the control of the</span>
<span class="cm">	 * driver. */</span>
	<span class="n">igb_get_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;eth%d&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_register</span><span class="p">;</span>

	<span class="cm">/* carrier off reporting is important to ethtool even BEFORE open */</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IGB_DCA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dca_add_requester</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IGB_FLAG_DCA_ENABLED</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DCA enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">igb_setup_dca</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_IGB_PTP</span>
	<span class="cm">/* do hw tstamp init after resetting */</span>
	<span class="n">igb_ptp_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

<span class="cp">#endif</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Intel(R) Gigabit Ethernet Network Connection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* print bus type/speed/width info */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: (PCIe:%s:%s) %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		 <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">e1000_bus_speed_2500</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;2.5Gb/s&quot;</span> <span class="o">:</span>
		  <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">e1000_bus_speed_5000</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;5.0Gb/s&quot;</span> <span class="o">:</span>
		                                            <span class="s">&quot;unknown&quot;</span><span class="p">),</span>
		 <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">e1000_bus_width_pcie_x4</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Width x4&quot;</span> <span class="o">:</span>
		  <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">e1000_bus_width_pcie_x2</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Width x2&quot;</span> <span class="o">:</span>
		  <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">e1000_bus_width_pcie_x1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Width x1&quot;</span> <span class="o">:</span>
		   <span class="s">&quot;unknown&quot;</span><span class="p">),</span>
		 <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">igb_read_part_string</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">part_str</span><span class="p">,</span> <span class="n">E1000_PBANUM_LENGTH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">part_str</span><span class="p">,</span> <span class="s">&quot;Unknown&quot;</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: PBA No: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">part_str</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Using %s interrupts. %d rx queue(s), %d tx queue(s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">?</span> <span class="s">&quot;MSI-X&quot;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_FLAG_HAS_MSI</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;MSI&quot;</span> <span class="o">:</span> <span class="s">&quot;legacy&quot;</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_i350</span>:
	<span class="k">case</span> <span class="n">e1000_i210</span>:
	<span class="k">case</span> <span class="n">e1000_i211</span>:
		<span class="n">igb_set_eee_i350</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pm_runtime_put_noidle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_register:</span>
	<span class="n">igb_release_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_eeprom:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igb_check_reset_block</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">igb_reset_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">flash_address</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">flash_address</span><span class="p">);</span>
<span class="nl">err_sw_init:</span>
	<span class="n">igb_clear_interrupt_scheme</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
<span class="nl">err_ioremap:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="nl">err_alloc_etherdev:</span>
	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
	                             <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">));</span>
<span class="nl">err_pci_reg:</span>
<span class="nl">err_dma:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_remove - Device Removal Routine</span>
<span class="cm"> * @pdev: PCI device information struct</span>
<span class="cm"> *</span>
<span class="cm"> * igb_remove is called by the PCI subsystem to alert the driver</span>
<span class="cm"> * that it should release a PCI device.  The could be caused by a</span>
<span class="cm"> * Hot-Plug event, or because the driver is going to be removed from</span>
<span class="cm"> * memory.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">igb_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">pm_runtime_get_noresume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IGB_PTP</span>
	<span class="n">igb_ptp_remove</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * The watchdog timer may be rescheduled, so explicitly</span>
<span class="cm">	 * disable watchdog from being rescheduled.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">);</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IGB_DCA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_FLAG_DCA_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DCA disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dca_remove_requester</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGB_FLAG_DCA_ENABLED</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DCA_CTRL</span><span class="p">,</span> <span class="n">E1000_DCA_CTRL_DCA_MODE_DISABLE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Release control of h/w to f/w.  If f/w is AMT enabled, this</span>
<span class="cm">	 * would have already happened in close and is redundant. */</span>
	<span class="n">igb_release_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">igb_clear_interrupt_scheme</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI_IOV</span>
	<span class="cm">/* reclaim resources allocated to VFs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* disable iov and allow time for transactions to clear */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igb_check_vf_assignment</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pci_disable_sriov</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VF(s) assigned to guests!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_IOVCTL</span><span class="p">,</span> <span class="n">E1000_IOVCTL_REUSE_VFQ</span><span class="p">);</span>
		<span class="n">wrfl</span><span class="p">();</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IOV Disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">flash_address</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">flash_address</span><span class="p">);</span>
	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
	                             <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">));</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shadow_vfta</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">pci_disable_pcie_error_reporting</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_probe_vfs - Initialize vf data storage and add VFs to pci config space</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * This function initializes the vf specific data storage and then attempts to</span>
<span class="cm"> * allocate the VFs.  The reason for ordering it this way is because it is much</span>
<span class="cm"> * mor expensive time wise to disable SR-IOV than it is to allocate and free</span>
<span class="cm"> * the memory for the VFs.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">igb_probe_vfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span> <span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI_IOV</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_vfs</span> <span class="o">=</span> <span class="n">igb_find_enabled_vfs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Virtualization features not supported on i210 family. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_i210</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_i211</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_vfs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%d pre-allocated VFs found - override &quot;</span>
			 <span class="s">&quot;max_vfs setting of %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">old_vfs</span><span class="p">,</span> <span class="n">max_vfs</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span> <span class="o">=</span> <span class="n">old_vfs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vf_data_storage</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="cm">/* if allocation failed then we do not support SR-IOV */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for VF &quot;</span>
			<span class="s">&quot;Data Storage</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_vfs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_sriov</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%d VFs allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">igb_vf_configure</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/* DMA Coalescing is not supported in IOV mode. */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGB_FLAG_DMAC</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI_IOV */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_sw_init - Initialize general software structures (struct igb_adapter)</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * igb_sw_init initializes the Adapter private data structure.</span>
<span class="cm"> * Fields are initialized based on PCI device information and</span>
<span class="cm"> * OS network device settings (MTU size).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">igb_sw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">pci_cmd_word</span><span class="p">);</span>

	<span class="cm">/* set default ring sizes */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring_count</span> <span class="o">=</span> <span class="n">IGB_DEFAULT_TXD</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring_count</span> <span class="o">=</span> <span class="n">IGB_DEFAULT_RXD</span><span class="p">;</span>

	<span class="cm">/* set default ITR values */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr_setting</span> <span class="o">=</span> <span class="n">IGB_DEFAULT_ITR</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr_setting</span> <span class="o">=</span> <span class="n">IGB_DEFAULT_ITR</span><span class="p">;</span>

	<span class="cm">/* set default work limits */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_work_limit</span> <span class="o">=</span> <span class="n">IGB_DEFAULT_TX_WORK</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span> <span class="o">+</span>
				  <span class="n">VLAN_HLEN</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">min_frame_size</span> <span class="o">=</span> <span class="n">ETH_ZLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PCI_IOV</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82576</span>:
	<span class="k">case</span> <span class="n">e1000_i350</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">max_vfs</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Maximum of 7 VFs per PF, using max</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span> <span class="o">=</span> <span class="n">max_vfs</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_i210</span>:
	<span class="k">case</span> <span class="n">e1000_i211</span>:
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI_IOV */</span><span class="cp"></span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_i210</span>:
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">IGB_MAX_RX_QUEUES_I210</span><span class="p">,</span>
			<span class="n">num_online_cpus</span><span class="p">());</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_i211</span>:
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">IGB_MAX_RX_QUEUES_I211</span><span class="p">,</span>
			<span class="n">num_online_cpus</span><span class="p">());</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">IGB_MAX_RX_QUEUES</span><span class="p">,</span>
		<span class="n">num_online_cpus</span><span class="p">());</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* i350 cannot do RSS and SR-IOV at the same time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_i350</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if rss_queues &gt; 4 or vfs are going to be allocated with rss_queues</span>
<span class="cm">	 * then we should combine the queues into a queue pair in order to</span>
<span class="cm">	 * conserve interrupts due to limited supply</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IGB_FLAG_QUEUE_PAIRS</span><span class="p">;</span>

	<span class="cm">/* Setup and initialize a copy of the hw vlan table array */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">shadow_vfta</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span>
				<span class="n">E1000_VLAN_FILTER_TBL_SIZE</span><span class="p">,</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="cm">/* This call may decrease the number of queues */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igb_init_interrupt_scheme</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">igb_probe_vfs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Explicitly disable IRQ since the NIC can be in any state. */</span>
	<span class="n">igb_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_i350</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGB_FLAG_DMAC</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_open - Called when a network interface is made active</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative value on failure</span>
<span class="cm"> *</span>
<span class="cm"> * The open entry point is called when a network interface is made</span>
<span class="cm"> * active by the system (IFF_UP).  At this point all resources needed</span>
<span class="cm"> * for transmit and receive operations are allocated, the interrupt</span>
<span class="cm"> * handler is registered with the OS, the watchdog timer is started,</span>
<span class="cm"> * and the stack is notified that the interface is ready.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__igb_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">resuming</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* disallow open during test */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_TESTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">resuming</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resuming</span><span class="p">)</span>
		<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* allocate transmit descriptors */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">igb_setup_all_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_setup_tx</span><span class="p">;</span>

	<span class="cm">/* allocate receive descriptors */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">igb_setup_all_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_setup_rx</span><span class="p">;</span>

	<span class="n">igb_power_up_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* before we allocate an interrupt, we must be ready to handle it.</span>
<span class="cm">	 * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt</span>
<span class="cm">	 * as soon as we call pci_request_irq, so we have to setup our</span>
<span class="cm">	 * clean_rx handler before we do so.  */</span>
	<span class="n">igb_configure</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">igb_request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_req_irq</span><span class="p">;</span>

	<span class="cm">/* From here on the code is the same as igb_up() */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">));</span>

	<span class="cm">/* Clear any pending interrupts. */</span>
	<span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICR</span><span class="p">);</span>

	<span class="n">igb_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* notify VFs that reset has been completed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">reg_data</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">);</span>
		<span class="n">reg_data</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_PFRSTD</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netif_tx_start_all_queues</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resuming</span><span class="p">)</span>
		<span class="n">pm_runtime_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* start the watchdog. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_req_irq:</span>
	<span class="n">igb_release_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_power_down_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_free_all_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_setup_rx:</span>
	<span class="n">igb_free_all_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_setup_tx:</span>
	<span class="n">igb_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resuming</span><span class="p">)</span>
		<span class="n">pm_runtime_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__igb_open</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_close - Disables a network interface</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0, this is not allowed to fail</span>
<span class="cm"> *</span>
<span class="cm"> * The close entry point is called when an interface is de-activated</span>
<span class="cm"> * by the OS.  The hardware is still under the driver&#39;s control, but</span>
<span class="cm"> * needs to be disabled.  A global MAC reset is issued to stop the</span>
<span class="cm"> * hardware, and all transmit and receive resources are freed.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__igb_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">suspending</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">suspending</span><span class="p">)</span>
		<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">igb_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">igb_free_all_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igb_free_all_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">suspending</span><span class="p">)</span>
		<span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__igb_close</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_setup_tx_resources - allocate Tx resources (Descriptors)</span>
<span class="cm"> * @tx_ring: tx descriptor ring (for a specific queue) to setup</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">igb_setup_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orig_node</span> <span class="o">=</span> <span class="n">dev_to_node</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_tx_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span> <span class="o">=</span> <span class="n">vzalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">numa_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">)</span>
		<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* round up to nearest 4K */</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_tx_desc</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="n">set_dev_node</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">numa_node</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					   <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					   <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">set_dev_node</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span>
		<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
						   <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
						   <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">);</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Unable to allocate memory for the transmit descriptor ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_setup_all_tx_resources - wrapper to allocate Tx resources</span>
<span class="cm"> *				  (Descriptors) for all queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_setup_all_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">igb_setup_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Allocation for Tx Queue %u failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
				<span class="n">igb_free_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_setup_tctl - configure the transmit control registers</span>
<span class="cm"> * @adapter: Board private structure</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">igb_setup_tctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tctl</span><span class="p">;</span>

	<span class="cm">/* disable queue 0 which is enabled by default on 82575 and 82576 */</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Program the Transmit Control Register */</span>
	<span class="n">tctl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TCTL</span><span class="p">);</span>
	<span class="n">tctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_TCTL_CT</span><span class="p">;</span>
	<span class="n">tctl</span> <span class="o">|=</span> <span class="n">E1000_TCTL_PSP</span> <span class="o">|</span> <span class="n">E1000_TCTL_RTLC</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">E1000_COLLISION_THRESHOLD</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_CT_SHIFT</span><span class="p">);</span>

	<span class="n">igb_config_collision_dist</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Enable transmits */</span>
	<span class="n">tctl</span> <span class="o">|=</span> <span class="n">E1000_TCTL_EN</span><span class="p">;</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TCTL</span><span class="p">,</span> <span class="n">tctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_configure_tx_ring - Configure transmit ring after Reset</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @ring: tx ring to configure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure a transmit ring after a reset.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">igb_configure_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                           <span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">txdctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tdba</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg_idx</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">reg_idx</span><span class="p">;</span>

	<span class="cm">/* disable the queue */</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TXDCTL</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wrfl</span><span class="p">();</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TDLEN</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span>
	                <span class="n">ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_tx_desc</span><span class="p">));</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TDBAL</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span>
	                <span class="n">tdba</span> <span class="o">&amp;</span> <span class="mh">0x00000000ffffffffULL</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TDBAH</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span> <span class="n">tdba</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">E1000_TDT</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TDH</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>

	<span class="n">txdctl</span> <span class="o">|=</span> <span class="n">IGB_TX_PTHRESH</span><span class="p">;</span>
	<span class="n">txdctl</span> <span class="o">|=</span> <span class="n">IGB_TX_HTHRESH</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">txdctl</span> <span class="o">|=</span> <span class="n">IGB_TX_WTHRESH</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">txdctl</span> <span class="o">|=</span> <span class="n">E1000_TXDCTL_QUEUE_ENABLE</span><span class="p">;</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TXDCTL</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span> <span class="n">txdctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_configure_tx - Configure transmit Unit after Reset</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the Tx unit of the MAC after a reset.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_configure_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">igb_configure_tx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_setup_rx_resources - allocate Rx resources (Descriptors)</span>
<span class="cm"> * @rx_ring:    rx descriptor ring (for a specific queue) to setup</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">igb_setup_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orig_node</span> <span class="o">=</span> <span class="n">dev_to_node</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">desc_len</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_rx_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span> <span class="o">=</span> <span class="n">vzalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">numa_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">)</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">desc_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_rx_desc</span><span class="p">);</span>

	<span class="cm">/* Round up to nearest 4K */</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="n">desc_len</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="n">set_dev_node</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">numa_node</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					   <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					   <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">set_dev_node</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
						   <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
						   <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for the receive descriptor&quot;</span>
		<span class="s">&quot; ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_setup_all_rx_resources - wrapper to allocate Rx resources</span>
<span class="cm"> *				  (Descriptors) for all queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_setup_all_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">igb_setup_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Allocation for Rx Queue %u failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
				<span class="n">igb_free_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_setup_mrqc - configure the multiple receive queue control registers</span>
<span class="cm"> * @adapter: Board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_setup_mrqc</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mrqc</span><span class="p">,</span> <span class="n">rxcsum</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">j</span><span class="p">,</span> <span class="n">num_rx_queues</span><span class="p">,</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shift2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_reta</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">dword</span><span class="p">;</span>
		<span class="n">u8</span>  <span class="n">bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">reta</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">rsshash</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x6d</span><span class="p">,</span> <span class="mh">0x5a</span><span class="p">,</span> <span class="mh">0x56</span><span class="p">,</span> <span class="mh">0xda</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x5b</span><span class="p">,</span> <span class="mh">0x0e</span><span class="p">,</span> <span class="mh">0xc2</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x67</span><span class="p">,</span>
		<span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x3d</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">,</span> <span class="mh">0xa3</span><span class="p">,</span> <span class="mh">0x8f</span><span class="p">,</span> <span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0xd0</span><span class="p">,</span> <span class="mh">0xca</span><span class="p">,</span> <span class="mh">0x2b</span><span class="p">,</span> <span class="mh">0xcb</span><span class="p">,</span>
		<span class="mh">0xae</span><span class="p">,</span> <span class="mh">0x7b</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">,</span> <span class="mh">0xb4</span><span class="p">,</span>	<span class="mh">0x77</span><span class="p">,</span> <span class="mh">0xcb</span><span class="p">,</span> <span class="mh">0x2d</span><span class="p">,</span> <span class="mh">0xa3</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">,</span>
		<span class="mh">0xf2</span><span class="p">,</span> <span class="mh">0x0c</span><span class="p">,</span> <span class="mh">0x6a</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="mh">0xb7</span><span class="p">,</span> <span class="mh">0x3b</span><span class="p">,</span> <span class="mh">0xbe</span><span class="p">,</span> <span class="mh">0xac</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xfa</span> <span class="p">};</span>

	<span class="cm">/* Fill out hash function seeds */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">rsskey</span> <span class="o">=</span> <span class="n">rsshash</span><span class="p">[(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)];</span>
		<span class="n">rsskey</span> <span class="o">|=</span> <span class="n">rsshash</span><span class="p">[(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">rsskey</span> <span class="o">|=</span> <span class="n">rsshash</span><span class="p">[(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">rsskey</span> <span class="o">|=</span> <span class="n">rsshash</span><span class="p">[(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
		<span class="n">array_wr32</span><span class="p">(</span><span class="n">E1000_RSSRK</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">j</span><span class="p">,</span> <span class="n">rsskey</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 82575 and 82576 supports 2 RSS queues for VMDq */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">e1000_i350</span>:
		<span class="k">case</span> <span class="n">e1000_82580</span>:
			<span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">e1000_82576</span>:
			<span class="n">shift</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">e1000_82575</span>:
			<span class="n">shift</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">shift2</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82575</span><span class="p">)</span>
			<span class="n">shift</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reta</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="n">num_rx_queues</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shift2</span><span class="p">)</span>
			<span class="n">reta</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">|=</span> <span class="n">num_rx_queues</span> <span class="o">&lt;&lt;</span> <span class="n">shift2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RETA</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">reta</span><span class="p">.</span><span class="n">dword</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable raw packet checksumming so that RSS hash is placed in</span>
<span class="cm">	 * descriptor on writeback.  No need to enable TCP/UDP/IP checksum</span>
<span class="cm">	 * offloads as they are enabled by default</span>
<span class="cm">	 */</span>
	<span class="n">rxcsum</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RXCSUM</span><span class="p">);</span>
	<span class="n">rxcsum</span> <span class="o">|=</span> <span class="n">E1000_RXCSUM_PCSD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_82576</span><span class="p">)</span>
		<span class="cm">/* Enable Receive Checksum Offload for SCTP */</span>
		<span class="n">rxcsum</span> <span class="o">|=</span> <span class="n">E1000_RXCSUM_CRCOFL</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t need to set TUOFL or IPOFL, they default to 1 */</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RXCSUM</span><span class="p">,</span> <span class="n">rxcsum</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Generate RSS hash based on TCP port numbers and/or</span>
<span class="cm">	 * IPv4/v6 src and dst addresses since UDP cannot be</span>
<span class="cm">	 * hashed reliably due to IP fragmentation</span>
<span class="cm">	 */</span>

	<span class="n">mrqc</span> <span class="o">=</span> <span class="n">E1000_MRQC_RSS_FIELD_IPV4</span> <span class="o">|</span>
	       <span class="n">E1000_MRQC_RSS_FIELD_IPV4_TCP</span> <span class="o">|</span>
	       <span class="n">E1000_MRQC_RSS_FIELD_IPV6</span> <span class="o">|</span>
	       <span class="n">E1000_MRQC_RSS_FIELD_IPV6_TCP</span> <span class="o">|</span>
	       <span class="n">E1000_MRQC_RSS_FIELD_IPV6_TCP_EX</span><span class="p">;</span>

	<span class="cm">/* If VMDq is enabled then we set the appropriate mode for that, else</span>
<span class="cm">	 * we default to RSS so that an RSS hash is calculated per packet even</span>
<span class="cm">	 * if we are only using one queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">e1000_82575</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Set the default pool for the PF&#39;s first queue */</span>
			<span class="n">u32</span> <span class="n">vtctl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VT_CTL</span><span class="p">);</span>
			<span class="n">vtctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_VT_CTL_DEFAULT_POOL_MASK</span> <span class="o">|</span>
				   <span class="n">E1000_VT_CTL_DISABLE_DEF_POOL</span><span class="p">);</span>
			<span class="n">vtctl</span> <span class="o">|=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span> <span class="o">&lt;&lt;</span>
				<span class="n">E1000_VT_CTL_DEFAULT_POOL_SHIFT</span><span class="p">;</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VT_CTL</span><span class="p">,</span> <span class="n">vtctl</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">mrqc</span> <span class="o">|=</span> <span class="n">E1000_MRQC_ENABLE_VMDQ_RSS_2Q</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mrqc</span> <span class="o">|=</span> <span class="n">E1000_MRQC_ENABLE_VMDQ</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_i211</span><span class="p">)</span>
			<span class="n">mrqc</span> <span class="o">|=</span> <span class="n">E1000_MRQC_ENABLE_RSS_4Q</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">igb_vmm_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_MRQC</span><span class="p">,</span> <span class="n">mrqc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_setup_rctl - configure the receive control registers</span>
<span class="cm"> * @adapter: Board private structure</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">igb_setup_rctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">;</span>

	<span class="n">rctl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RCTL</span><span class="p">);</span>

	<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_RCTL_MO_SHIFT</span><span class="p">);</span>
	<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_RCTL_LBM_TCVR</span> <span class="o">|</span> <span class="n">E1000_RCTL_LBM_MAC</span><span class="p">);</span>

	<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_EN</span> <span class="o">|</span> <span class="n">E1000_RCTL_BAM</span> <span class="o">|</span> <span class="n">E1000_RCTL_RDMTS_HALF</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">mc_filter_type</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_RCTL_MO_SHIFT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * enable stripping of CRC. It&#39;s unlikely this will break BMC</span>
<span class="cm">	 * redirection as it did with e1000. Newer features require</span>
<span class="cm">	 * that the HW strips the CRC.</span>
<span class="cm">	 */</span>
	<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SECRC</span><span class="p">;</span>

	<span class="cm">/* disable store bad packets and clear size bits. */</span>
	<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_RCTL_SBP</span> <span class="o">|</span> <span class="n">E1000_RCTL_SZ_256</span><span class="p">);</span>

	<span class="cm">/* enable LPE to prevent packets larger than max_frame_size */</span>
	<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_LPE</span><span class="p">;</span>

	<span class="cm">/* disable queue 0 to prevent tail write w/o re-config */</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Attention!!!  For SR-IOV PF driver operations you must enable</span>
<span class="cm">	 * queue drop for all VF and PF queues to prevent head of line blocking</span>
<span class="cm">	 * if an un-trusted VF does not provide descriptors to hardware.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set all queue drop enable bits */</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_QDE</span><span class="p">,</span> <span class="n">ALL_QUEUES</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* This is useful for sniffing bad packets. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* UPE and MPE will be handled by normal PROMISC logic</span>
<span class="cm">		 * in e1000e_set_rx_mode */</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_RCTL_SBP</span> <span class="o">|</span> <span class="cm">/* Receive bad packets */</span>
			 <span class="n">E1000_RCTL_BAM</span> <span class="o">|</span> <span class="cm">/* RX All Bcast Pkts */</span>
			 <span class="n">E1000_RCTL_PMCF</span><span class="p">);</span> <span class="cm">/* RX All MAC Ctrl Pkts */</span>

		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_RCTL_VFE</span> <span class="o">|</span> <span class="cm">/* Disable VLAN filter */</span>
			  <span class="n">E1000_RCTL_DPF</span> <span class="o">|</span> <span class="cm">/* Allow filtered pause */</span>
			  <span class="n">E1000_RCTL_CFIEN</span><span class="p">);</span> <span class="cm">/* Dis VLAN CFIEN Filter */</span>
		<span class="cm">/* Do not mess with E1000_CTRL_VME, it affects transmit as well,</span>
<span class="cm">		 * and that breaks VLANs.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">igb_set_vf_rlpml</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
                                   <span class="kt">int</span> <span class="n">vfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vmolr</span><span class="p">;</span>

	<span class="cm">/* if it isn&#39;t the PF check to see if VFs are enabled and</span>
<span class="cm">	 * increase the size to support vlan tags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vfn</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vfn</span><span class="p">].</span><span class="n">vlans_enabled</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">VLAN_TAG_SIZE</span><span class="p">;</span>

	<span class="n">vmolr</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vfn</span><span class="p">));</span>
	<span class="n">vmolr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_VMOLR_RLPML_MASK</span><span class="p">;</span>
	<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">size</span> <span class="o">|</span> <span class="n">E1000_VMOLR_LPE</span><span class="p">;</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vfn</span><span class="p">),</span> <span class="n">vmolr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_rlpml_set - set maximum receive packet size</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure maximum receivable packet size.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_rlpml_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pf_id</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pf_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">igb_set_vf_rlpml</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">max_frame_size</span><span class="p">,</span> <span class="n">pf_id</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we&#39;re in VMDQ or SR-IOV mode, then set global RLPML</span>
<span class="cm">		 * to our max jumbo frame size, in case we need to enable</span>
<span class="cm">		 * jumbo frames on one of the rings later.</span>
<span class="cm">		 * This will not pass over-length frames into the default</span>
<span class="cm">		 * queue because it&#39;s gated by the VMOLR.RLPML.</span>
<span class="cm">		 */</span>
		<span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">MAX_JUMBO_FRAME_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RLPML</span><span class="p">,</span> <span class="n">max_frame_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">igb_set_vmolr</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">vfn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">aupe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vmolr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This register exists only on 82576 and newer so if we are older then</span>
<span class="cm">	 * we should exit and do nothing</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">e1000_82576</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vmolr</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vfn</span><span class="p">));</span>
	<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_STRVLAN</span><span class="p">;</span>      <span class="cm">/* Strip vlan tags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aupe</span><span class="p">)</span>
		<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_AUPE</span><span class="p">;</span>        <span class="cm">/* Accept untagged packets */</span>
	<span class="k">else</span>
		<span class="n">vmolr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_VMOLR_AUPE</span><span class="p">);</span> <span class="cm">/* Tagged packets ONLY */</span>

	<span class="cm">/* clear all bits that might not be set */</span>
	<span class="n">vmolr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_VMOLR_BAM</span> <span class="o">|</span> <span class="n">E1000_VMOLR_RSSE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rss_queues</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">vfn</span> <span class="o">==</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span>
		<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_RSSE</span><span class="p">;</span> <span class="cm">/* enable RSS */</span>
	<span class="cm">/*</span>
<span class="cm">	 * for VMDq only allow the VFs and pool 0 to accept broadcast and</span>
<span class="cm">	 * multicast packets</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vfn</span> <span class="o">&lt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span>
		<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_BAM</span><span class="p">;</span>	   <span class="cm">/* Accept broadcast */</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vfn</span><span class="p">),</span> <span class="n">vmolr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_configure_rx_ring - Configure a receive ring after Reset</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @ring: receive ring to be configured</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the Rx unit of the MAC after a reset.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">igb_configure_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                           <span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rdba</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg_idx</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">reg_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">srrctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rxdctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* disable the queue */</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RXDCTL</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Set DMA base address registers */</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RDBAL</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span>
	     <span class="n">rdba</span> <span class="o">&amp;</span> <span class="mh">0x00000000ffffffffULL</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RDBAH</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span> <span class="n">rdba</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RDLEN</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span>
	               <span class="n">ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_rx_desc</span><span class="p">));</span>

	<span class="cm">/* initialize head and tail */</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">E1000_RDT</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RDH</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>

	<span class="cm">/* set descriptor configuration */</span>
	<span class="n">srrctl</span> <span class="o">=</span> <span class="n">IGB_RX_HDR_LEN</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_SRRCTL_BSIZEHDRSIZE_SHIFT</span><span class="p">;</span>
<span class="cp">#if (PAGE_SIZE / 2) &gt; IGB_RXBUFFER_16384</span>
	<span class="n">srrctl</span> <span class="o">|=</span> <span class="n">IGB_RXBUFFER_16384</span> <span class="o">&gt;&gt;</span> <span class="n">E1000_SRRCTL_BSIZEPKT_SHIFT</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">srrctl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">E1000_SRRCTL_BSIZEPKT_SHIFT</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">srrctl</span> <span class="o">|=</span> <span class="n">E1000_SRRCTL_DESCTYPE_HDR_SPLIT_ALWAYS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_82580</span><span class="p">)</span>
		<span class="n">srrctl</span> <span class="o">|=</span> <span class="n">E1000_SRRCTL_TIMESTAMP</span><span class="p">;</span>
	<span class="cm">/* Only set Drop Enable if we are supporting multiple queues */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span> <span class="o">||</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">srrctl</span> <span class="o">|=</span> <span class="n">E1000_SRRCTL_DROP_EN</span><span class="p">;</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_SRRCTL</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span> <span class="n">srrctl</span><span class="p">);</span>

	<span class="cm">/* set filtering for VMDQ pools */</span>
	<span class="n">igb_set_vmolr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">reg_idx</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">rxdctl</span> <span class="o">|=</span> <span class="n">IGB_RX_PTHRESH</span><span class="p">;</span>
	<span class="n">rxdctl</span> <span class="o">|=</span> <span class="n">IGB_RX_HTHRESH</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">rxdctl</span> <span class="o">|=</span> <span class="n">IGB_RX_WTHRESH</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* enable receive descriptor fetching */</span>
	<span class="n">rxdctl</span> <span class="o">|=</span> <span class="n">E1000_RXDCTL_QUEUE_ENABLE</span><span class="p">;</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RXDCTL</span><span class="p">(</span><span class="n">reg_idx</span><span class="p">),</span> <span class="n">rxdctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_configure_rx - Configure receive Unit after Reset</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the Rx unit of the MAC after a reset.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_configure_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* set UTA to appropriate mode */</span>
	<span class="n">igb_set_uta</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* set the correct pool for the PF default MAC address in entry 0 */</span>
	<span class="n">igb_rar_set_qsel</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	                 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">);</span>

	<span class="cm">/* Setup the HW Rx Head and Tail Descriptor Pointers and</span>
<span class="cm">	 * the Base and Length of the Rx Descriptor Ring */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">igb_configure_rx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_free_tx_resources - Free Tx Resources per Queue</span>
<span class="cm"> * @tx_ring: Tx descriptor ring for a specific queue</span>
<span class="cm"> *</span>
<span class="cm"> * Free all transmit software resources</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">igb_free_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">igb_clean_tx_ring</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">);</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* if not set, then don&#39;t free */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
			  <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_free_all_tx_resources - Free Tx Resources for All Queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Free all transmit software resources</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_free_all_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">igb_free_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">igb_unmap_and_free_tx_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">tx_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					 <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
					 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			       <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
			       <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
			       <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* buffer_info must be completely set up in the transmit path */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_clean_tx_ring - Free Tx Buffers</span>
<span class="cm"> * @tx_ring: ring to be cleaned</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_clean_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* Free all the Tx ring sk_buffs */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">igb_unmap_and_free_tx_resource</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">buffer_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netdev_tx_reset_queue</span><span class="p">(</span><span class="n">txring_txq</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">));</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_tx_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Zero out the descriptor ring */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_clean_all_tx_rings - Free Tx Buffers for all queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_clean_all_tx_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">igb_clean_tx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_free_rx_resources - Free Rx Resources</span>
<span class="cm"> * @rx_ring: ring to clean the resources from</span>
<span class="cm"> *</span>
<span class="cm"> * Free all receive software resources</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">igb_free_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">igb_clean_rx_ring</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">);</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* if not set, then don&#39;t free */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
			  <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_free_all_rx_resources - Free Rx Resources for All Queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Free all receive software resources</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_free_all_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">igb_free_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_clean_rx_ring - Free Rx Buffers per Queue</span>
<span class="cm"> * @rx_ring: ring to free buffers from</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_clean_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Free all the Rx ring sk_buffs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">igb_rx_buffer</span> <span class="o">*</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			                 <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					 <span class="n">IGB_RX_HDR_LEN</span><span class="p">,</span>
					 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			               <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span><span class="p">,</span>
				       <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
				       <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_rx_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Zero out the descriptor ring */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_clean_all_rx_rings - Free Rx Buffers for all queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_clean_all_rx_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">igb_clean_rx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_set_mac - Change the Ethernet Address of the NIC</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> * @p: pointer to an address structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_set_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="cm">/* set the correct pool for the new PF MAC address in entry 0 */</span>
	<span class="n">igb_rar_set_qsel</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	                 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_write_mc_addr_list - write multicast addresses to MTA</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Writes multicast address list to the MTA hash table.</span>
<span class="cm"> * Returns: -ENOMEM on failure</span>
<span class="cm"> *                0 on no addresses written</span>
<span class="cm"> *                X on writing X addresses to MTA</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_write_mc_addr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="o">*</span><span class="n">mta_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev_mc_empty</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* nothing to program, so clear mc list */</span>
		<span class="n">igb_update_mc_addr_list</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">igb_restore_vf_multicasts</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mta_list</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mta_list</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* The shared function expects a packed array of only addresses. */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mta_list</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">*</span> <span class="n">ETH_ALEN</span><span class="p">),</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">igb_update_mc_addr_list</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mta_list</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mta_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_write_uc_addr_list - write unicast addresses to RAR table</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Writes unicast address list to the RAR table.</span>
<span class="cm"> * Returns: -ENOMEM on failure/insufficient address space</span>
<span class="cm"> *                0 on no addresses written</span>
<span class="cm"> *                X on writing X addresses to the RAR table</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_write_uc_addr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vfn</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rar_entries</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">rar_entry_count</span> <span class="o">-</span> <span class="p">(</span><span class="n">vfn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* return ENOMEM indicating insufficient memory for addresses */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netdev_uc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rar_entries</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev_uc_empty</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rar_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

		<span class="n">netdev_for_each_uc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rar_entries</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">igb_rar_set_qsel</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
			                 <span class="n">rar_entries</span><span class="o">--</span><span class="p">,</span>
			                 <span class="n">vfn</span><span class="p">);</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* write the addresses in reverse order to avoid write combining */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">rar_entries</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">rar_entries</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RAH</span><span class="p">(</span><span class="n">rar_entries</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RAL</span><span class="p">(</span><span class="n">rar_entries</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">wrfl</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_set_rx_mode - Secondary Unicast, Multicast and Promiscuous mode set</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * The set_rx_mode entry point is called whenever the unicast or multicast</span>
<span class="cm"> * address lists or the network interface flags are updated.  This routine is</span>
<span class="cm"> * responsible for configuring the hardware for proper unicast, multicast,</span>
<span class="cm"> * promiscuous mode, and all-multi behavior.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vfn</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">,</span> <span class="n">vmolr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* Check for Promiscuous and All Multicast modes */</span>
	<span class="n">rctl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RCTL</span><span class="p">);</span>

	<span class="cm">/* clear the effected bits */</span>
	<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_RCTL_UPE</span> <span class="o">|</span> <span class="n">E1000_RCTL_MPE</span> <span class="o">|</span> <span class="n">E1000_RCTL_VFE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_RCTL_UPE</span> <span class="o">|</span> <span class="n">E1000_RCTL_MPE</span><span class="p">);</span>
		<span class="n">vmolr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_VMOLR_ROPE</span> <span class="o">|</span> <span class="n">E1000_VMOLR_MPME</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_MPE</span><span class="p">;</span>
			<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_MPME</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Write addresses to the MTA, if the attempt fails</span>
<span class="cm">			 * then we should just turn on promiscuous mode so</span>
<span class="cm">			 * that we can at least receive multicast traffic</span>
<span class="cm">			 */</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">igb_write_mc_addr_list</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_MPE</span><span class="p">;</span>
				<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_MPME</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_ROMPE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Write addresses to available RAR registers, if there is not</span>
<span class="cm">		 * sufficient space to store all the addresses then enable</span>
<span class="cm">		 * unicast promiscuous mode</span>
<span class="cm">		 */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">igb_write_uc_addr_list</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_UPE</span><span class="p">;</span>
			<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_ROPE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_VFE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In order to support SR-IOV and eventually VMDq it is necessary to set</span>
<span class="cm">	 * the VMOLR to enable the appropriate modes.  Without this workaround</span>
<span class="cm">	 * we will have issues with VLAN tag stripping not being done for frames</span>
<span class="cm">	 * that are only arriving because we are the default pool</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">e1000_82576</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">e1000_i350</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vfn</span><span class="p">))</span> <span class="o">&amp;</span>
	         <span class="o">~</span><span class="p">(</span><span class="n">E1000_VMOLR_ROPE</span> <span class="o">|</span> <span class="n">E1000_VMOLR_MPME</span> <span class="o">|</span> <span class="n">E1000_VMOLR_ROMPE</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vfn</span><span class="p">),</span> <span class="n">vmolr</span><span class="p">);</span>
	<span class="n">igb_restore_vf_multicasts</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_check_wvbr</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wvbr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82576</span>:
	<span class="k">case</span> <span class="n">e1000_i350</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wvbr</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_WVBR</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wvbr</span> <span class="o">|=</span> <span class="n">wvbr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define IGB_STAGGERED_QUEUE_OFFSET 8</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_spoof_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wvbr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wvbr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wvbr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">IGB_STAGGERED_QUEUE_OFFSET</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Spoof event(s) detected on VF %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wvbr</span> <span class="o">&amp;=</span>
				<span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">|</span>
				  <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">IGB_STAGGERED_QUEUE_OFFSET</span><span class="p">)));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Need to wait a few seconds after link up to get diagnostic information from</span>
<span class="cm"> * the phy */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_update_phy_info</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">igb_get_phy_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_has_link - check shared code for link and determine up/down</span>
<span class="cm"> * @adapter: pointer to driver private info</span>
<span class="cm"> **/</span>
<span class="n">bool</span> <span class="nf">igb_has_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* get_link_status is set on LSC (link status) interrupt or</span>
<span class="cm">	 * rx sequence error interrupt.  get_link_status will stay</span>
<span class="cm">	 * false until the e1000_check_for_link establishes link</span>
<span class="cm">	 * for copper adapters ONLY</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_media_type_copper</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_for_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">link_active</span> <span class="o">=</span> <span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">link_active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_media_type_internal_serdes</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_for_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">link_active</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">serdes_has_link</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="n">e1000_media_type_unknown</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">link_active</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">igb_thermal_sensor_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">,</span> <span class="n">thstat</span><span class="p">;</span>

	<span class="cm">/* check for thermal sensor event on i350 copper only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_i350</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">thstat</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_THSTAT</span><span class="p">);</span>
		<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">ctrl_ext</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_EXT_LINK_MODE_SGMII</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">thstat</span> <span class="o">&amp;</span> <span class="n">event</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_watchdog - Timer Call-back</span>
<span class="cm"> * @data: pointer to adapter cast into an unsigned long</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_watchdog</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="cm">/* Do the rest outside of interrupt context */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_watchdog_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
	                                           <span class="k">struct</span> <span class="n">igb_adapter</span><span class="p">,</span>
                                                   <span class="n">watchdog_task</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">link</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">link</span> <span class="o">=</span> <span class="n">igb_has_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Cancel scheduled suspend requests. */</span>
		<span class="n">pm_runtime_resume</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_speed_and_duplex</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			                                 <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">,</span>
			                                 <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span><span class="p">);</span>

			<span class="n">ctrl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CTRL</span><span class="p">);</span>
			<span class="cm">/* Links status message must follow this format */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;igb: %s NIC Link is Up %d Mbps %s &quot;</span>
			       <span class="s">&quot;Duplex, Flow Control: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">,</span>
			       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">==</span> <span class="n">FULL_DUPLEX</span> <span class="o">?</span>
			       <span class="s">&quot;Full&quot;</span> <span class="o">:</span> <span class="s">&quot;Half&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_TFCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			       <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_RFCE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;RX/TX&quot;</span> <span class="o">:</span>
			       <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_RFCE</span><span class="p">)</span> <span class="o">?</span>  <span class="s">&quot;RX&quot;</span> <span class="o">:</span>
			       <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_TFCE</span><span class="p">)</span> <span class="o">?</span>  <span class="s">&quot;TX&quot;</span> <span class="o">:</span> <span class="s">&quot;None&quot;</span><span class="p">);</span>

			<span class="cm">/* check for thermal sensor event */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">igb_thermal_sensor_event</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			    <span class="n">E1000_THSTAT_LINK_THROTTLE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">netdev_info</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;The network adapter link &quot;</span>
					    <span class="s">&quot;speed was downshifted because it &quot;</span>
					    <span class="s">&quot;overheated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* adjust timeout factor according to speed/duplex */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SPEED_10</span>:
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_factor</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SPEED_100</span>:
				<span class="cm">/* maybe add some timeout factor ? */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

			<span class="n">igb_ping_all_vfs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="n">igb_check_vf_rate_limit</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

			<span class="cm">/* link state has changed, schedule phy info update */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
				<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">,</span>
					  <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* check for thermal sensor event */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">igb_thermal_sensor_event</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			    <span class="n">E1000_THSTAT_PWR_DOWN</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;The network adapter was &quot;</span>
					   <span class="s">&quot;stopped because it overheated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Links status message must follow this format */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;igb: %s NIC Link is Down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

			<span class="n">igb_ping_all_vfs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

			<span class="cm">/* link state has changed, schedule phy info update */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
				<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">,</span>
					  <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">));</span>

			<span class="n">pm_schedule_suspend</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
					    <span class="n">MSEC_PER_SEC</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>
	<span class="n">igb_update_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* We&#39;ve lost link, so the controller stops DMA,</span>
<span class="cm">			 * but we&#39;ve got queued Tx work that&#39;s never going</span>
<span class="cm">			 * to get done, so reset controller to flush Tx.</span>
<span class="cm">			 * (Do the reset outside of interrupt context). */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">igb_desc_unused</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_count</span><span class="o">++</span><span class="p">;</span>
				<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
				<span class="cm">/* return immediately since reset is imminent */</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Force detection of hung controller every watchdog period */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_TX_DETECT_HANG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Cause software interrupt to ensure rx ring is cleaned */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">eics</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">eics</span> <span class="o">|=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eims_value</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_EICS</span><span class="p">,</span> <span class="n">eics</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_ICS</span><span class="p">,</span> <span class="n">E1000_ICS_RXDMT0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">igb_spoof_check</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Reset the timer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span>
			  <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">latency_range</span> <span class="p">{</span>
	<span class="n">lowest_latency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">low_latency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">bulk_latency</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">latency_invalid</span> <span class="o">=</span> <span class="mi">255</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * igb_update_ring_itr - update the dynamic ITR value based on packet size</span>
<span class="cm"> *</span>
<span class="cm"> *      Stores a new ITR value based on strictly on packet size.  This</span>
<span class="cm"> *      algorithm is less sophisticated than that used in igb_update_itr,</span>
<span class="cm"> *      due to the difficulty of synchronizing statistics across multiple</span>
<span class="cm"> *      receive rings.  The divisors and thresholds used by this function</span>
<span class="cm"> *      were determined based on theoretical maximum wire speed and testing</span>
<span class="cm"> *      data, in order to minimize response time while increasing bulk</span>
<span class="cm"> *      throughput.</span>
<span class="cm"> *      This functionality is controlled by the InterruptThrottleRate module</span>
<span class="cm"> *      parameter (see igb_param.c)</span>
<span class="cm"> *      NOTE:  This function is called only when operating in a multiqueue</span>
<span class="cm"> *             receive environment.</span>
<span class="cm"> * @q_vector: pointer to q_vector</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_update_ring_itr</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">new_val</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">avg_wire_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">packets</span><span class="p">;</span>

	<span class="cm">/* For non-gigabit speeds, just fix the interrupt rate at 4000</span>
<span class="cm">	 * ints/sec - ITR timer value of 120 ticks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">!=</span> <span class="n">SPEED_1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_val</span> <span class="o">=</span> <span class="n">IGB_4K_ITR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">set_itr_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">packets</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">total_packets</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packets</span><span class="p">)</span>
		<span class="n">avg_wire_size</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">total_bytes</span> <span class="o">/</span> <span class="n">packets</span><span class="p">;</span>

	<span class="n">packets</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">total_packets</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packets</span><span class="p">)</span>
		<span class="n">avg_wire_size</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">avg_wire_size</span><span class="p">,</span>
				      <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">total_bytes</span> <span class="o">/</span> <span class="n">packets</span><span class="p">);</span>

	<span class="cm">/* if avg_wire_size isn&#39;t set no work was done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avg_wire_size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">clear_counts</span><span class="p">;</span>

	<span class="cm">/* Add 24 bytes to size to account for CRC, preamble, and gap */</span>
	<span class="n">avg_wire_size</span> <span class="o">+=</span> <span class="mi">24</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t starve jumbo frames */</span>
	<span class="n">avg_wire_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">avg_wire_size</span><span class="p">,</span> <span class="mi">3000</span><span class="p">);</span>

	<span class="cm">/* Give a little boost to mid-size frames */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">avg_wire_size</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">avg_wire_size</span> <span class="o">&lt;</span> <span class="mi">1200</span><span class="p">))</span>
		<span class="n">new_val</span> <span class="o">=</span> <span class="n">avg_wire_size</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">new_val</span> <span class="o">=</span> <span class="n">avg_wire_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* conservative mode (itr 3) eliminates the lowest_latency setting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_val</span> <span class="o">&lt;</span> <span class="n">IGB_20K_ITR</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr_setting</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="o">!</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr_setting</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)))</span>
		<span class="n">new_val</span> <span class="o">=</span> <span class="n">IGB_20K_ITR</span><span class="p">;</span>

<span class="nl">set_itr_val:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_val</span> <span class="o">!=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">set_itr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">clear_counts:</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">total_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">total_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">total_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">total_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_update_itr - update the dynamic ITR value based on statistics</span>
<span class="cm"> *      Stores a new ITR value based on packets and byte</span>
<span class="cm"> *      counts during the last interrupt.  The advantage of per interrupt</span>
<span class="cm"> *      computation is faster updates and more accurate ITR for the current</span>
<span class="cm"> *      traffic pattern.  Constants in this function were computed</span>
<span class="cm"> *      based on theoretical maximum wire speed and thresholds were set based</span>
<span class="cm"> *      on testing data as well as attempting to minimize response time</span>
<span class="cm"> *      while increasing bulk throughput.</span>
<span class="cm"> *      this functionality is controlled by the InterruptThrottleRate module</span>
<span class="cm"> *      parameter (see igb_param.c)</span>
<span class="cm"> *      NOTE:  These calculations are only valid when operating in a single-</span>
<span class="cm"> *             queue environment.</span>
<span class="cm"> * @q_vector: pointer to q_vector</span>
<span class="cm"> * @ring_container: ring info to update the itr for</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_update_itr</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">igb_ring_container</span> <span class="o">*</span><span class="n">ring_container</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">packets</span> <span class="o">=</span> <span class="n">ring_container</span><span class="o">-&gt;</span><span class="n">total_packets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">ring_container</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">itrval</span> <span class="o">=</span> <span class="n">ring_container</span><span class="o">-&gt;</span><span class="n">itr</span><span class="p">;</span>

	<span class="cm">/* no packets, exit with status unchanged */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">itrval</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">lowest_latency</span>:
		<span class="cm">/* handle TSO and jumbo frames */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">8000</span><span class="p">)</span>
			<span class="n">itrval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">))</span>
			<span class="n">itrval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">low_latency</span>:  <span class="cm">/* 50 usec aka 20000 ints/s */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this if handles the TSO accounting */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">8000</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">itrval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1200</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">itrval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">itrval</span> <span class="o">=</span> <span class="n">lowest_latency</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">itrval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">itrval</span> <span class="o">=</span> <span class="n">lowest_latency</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">bulk_latency</span>: <span class="cm">/* 250 usec aka 4000 ints/s */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">25000</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">)</span>
				<span class="n">itrval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">1500</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">itrval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear work counters since we have the values we need */</span>
	<span class="n">ring_container</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ring_container</span><span class="o">-&gt;</span><span class="n">total_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* write updated itr to ring container */</span>
	<span class="n">ring_container</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">=</span> <span class="n">itrval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_set_itr</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_itr</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">current_itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* for non-gigabit speeds, just fix the interrupt rate at 4000 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">!=</span> <span class="n">SPEED_1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">IGB_4K_ITR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">set_itr_now</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">igb_update_itr</span><span class="p">(</span><span class="n">q_vector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">);</span>
	<span class="n">igb_update_itr</span><span class="p">(</span><span class="n">q_vector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>

	<span class="n">current_itr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">itr</span><span class="p">,</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">itr</span><span class="p">);</span>

	<span class="cm">/* conservative mode (itr 3) eliminates the lowest_latency setting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_itr</span> <span class="o">==</span> <span class="n">lowest_latency</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr_setting</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="o">!</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr_setting</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)))</span>
		<span class="n">current_itr</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">current_itr</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* counts and packets in update_itr are dependent on these numbers */</span>
	<span class="k">case</span> <span class="n">lowest_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">IGB_70K_ITR</span><span class="p">;</span> <span class="cm">/* 70,000 ints/sec */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">low_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">IGB_20K_ITR</span><span class="p">;</span> <span class="cm">/* 20,000 ints/sec */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">bulk_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">IGB_4K_ITR</span><span class="p">;</span>  <span class="cm">/* 4,000 ints/sec */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">set_itr_now:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_itr</span> <span class="o">!=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this attempts to bias the interrupt rate towards Bulk</span>
<span class="cm">		 * by adding intermediate steps when interrupt rate is</span>
<span class="cm">		 * increasing */</span>
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">new_itr</span> <span class="o">&gt;</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">?</span>
		             <span class="n">max</span><span class="p">((</span><span class="n">new_itr</span> <span class="o">*</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">)</span> <span class="o">/</span>
		                 <span class="p">(</span><span class="n">new_itr</span> <span class="o">+</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)),</span>
				 <span class="n">new_itr</span><span class="p">)</span> <span class="o">:</span>
			     <span class="n">new_itr</span><span class="p">;</span>
		<span class="cm">/* Don&#39;t write the value here; it resets the adapter&#39;s</span>
<span class="cm">		 * internal timer, and causes us to delay far longer than</span>
<span class="cm">		 * we should between interrupts.  Instead, we write the ITR</span>
<span class="cm">		 * value at the beginning of the next interrupt so the timing</span>
<span class="cm">		 * ends up being correct.</span>
<span class="cm">		 */</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">new_itr</span><span class="p">;</span>
		<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">set_itr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_tx_ctxtdesc</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vlan_macip_lens</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">type_tucmd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mss_l4len_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adv_tx_context_desc</span> <span class="o">*</span><span class="n">context_desc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="n">context_desc</span> <span class="o">=</span> <span class="n">IGB_TX_CTXTDESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* set bits to identify this as an advanced context descriptor */</span>
	<span class="n">type_tucmd</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_DEXT</span> <span class="o">|</span> <span class="n">E1000_ADVTXD_DTYP_CTXT</span><span class="p">;</span>

	<span class="cm">/* For 82575, context index must be unique per ring. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_TX_CTX_IDX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">mss_l4len_idx</span> <span class="o">|=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">vlan_macip_lens</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">vlan_macip_lens</span><span class="p">);</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">seqnum_seed</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">type_tucmd_mlhl</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">type_tucmd</span><span class="p">);</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">mss_l4len_idx</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mss_l4len_idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_tso</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span>
		   <span class="n">u8</span> <span class="o">*</span><span class="n">hdr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vlan_macip_lens</span><span class="p">,</span> <span class="n">type_tucmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mss_l4len_idx</span><span class="p">,</span> <span class="n">l4len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_header_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ADV DTYP TUCMD MKRLOC/ISCSIHEDLEN */</span>
	<span class="n">type_tucmd</span> <span class="o">=</span> <span class="n">E1000_ADVTXD_TUCMD_L4T_TCP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">__constant_htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">tot_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_tcpudp_magic</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
							 <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							 <span class="n">IPPROTO_TCP</span><span class="p">,</span>
							 <span class="mi">0</span><span class="p">);</span>
		<span class="n">type_tucmd</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_TUCMD_IPV4</span><span class="p">;</span>
		<span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">IGB_TX_FLAGS_TSO</span> <span class="o">|</span>
				   <span class="n">IGB_TX_FLAGS_CSUM</span> <span class="o">|</span>
				   <span class="n">IGB_TX_FLAGS_IPV4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">payload_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_ipv6_magic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span>
						       <span class="mi">0</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">IGB_TX_FLAGS_TSO</span> <span class="o">|</span>
				   <span class="n">IGB_TX_FLAGS_CSUM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* compute header lengths */</span>
	<span class="n">l4len</span> <span class="o">=</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="o">*</span><span class="n">hdr_len</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">l4len</span><span class="p">;</span>

	<span class="cm">/* update gso size and bytecount with header size */</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span><span class="p">;</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">bytecount</span> <span class="o">+=</span> <span class="p">(</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="o">*</span><span class="n">hdr_len</span><span class="p">;</span>

	<span class="cm">/* MSS L4LEN IDX */</span>
	<span class="n">mss_l4len_idx</span> <span class="o">=</span> <span class="n">l4len</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_ADVTXD_L4LEN_SHIFT</span><span class="p">;</span>
	<span class="n">mss_l4len_idx</span> <span class="o">|=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_ADVTXD_MSS_SHIFT</span><span class="p">;</span>

	<span class="cm">/* VLAN MACLEN IPLEN */</span>
	<span class="n">vlan_macip_lens</span> <span class="o">=</span> <span class="n">skb_network_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">vlan_macip_lens</span> <span class="o">|=</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_ADVTXD_MACLEN_SHIFT</span><span class="p">;</span>
	<span class="n">vlan_macip_lens</span> <span class="o">|=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGB_TX_FLAGS_VLAN_MASK</span><span class="p">;</span>

	<span class="n">igb_tx_ctxtdesc</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">vlan_macip_lens</span><span class="p">,</span> <span class="n">type_tucmd</span><span class="p">,</span> <span class="n">mss_l4len_idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_tx_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">first</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vlan_macip_lens</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mss_l4len_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">type_tucmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGB_TX_FLAGS_VLAN</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">l4_hdr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">__constant_htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">)</span>:
			<span class="n">vlan_macip_lens</span> <span class="o">|=</span> <span class="n">skb_network_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">type_tucmd</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_TUCMD_IPV4</span><span class="p">;</span>
			<span class="n">l4_hdr</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">__constant_htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">)</span>:
			<span class="n">vlan_macip_lens</span> <span class="o">|=</span> <span class="n">skb_network_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">l4_hdr</span> <span class="o">=</span> <span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">net_ratelimit</span><span class="p">()))</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;partial checksum but proto=%x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">first</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">l4_hdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IPPROTO_TCP</span>:
			<span class="n">type_tucmd</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_TUCMD_L4T_TCP</span><span class="p">;</span>
			<span class="n">mss_l4len_idx</span> <span class="o">=</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
					<span class="n">E1000_ADVTXD_L4LEN_SHIFT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IPPROTO_SCTP</span>:
			<span class="n">type_tucmd</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_TUCMD_L4T_SCTP</span><span class="p">;</span>
			<span class="n">mss_l4len_idx</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctphdr</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
					<span class="n">E1000_ADVTXD_L4LEN_SHIFT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IPPROTO_UDP</span>:
			<span class="n">mss_l4len_idx</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
					<span class="n">E1000_ADVTXD_L4LEN_SHIFT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">net_ratelimit</span><span class="p">()))</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;partial checksum but l4 proto=%x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">l4_hdr</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* update TX checksum flag */</span>
		<span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">IGB_TX_FLAGS_CSUM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vlan_macip_lens</span> <span class="o">|=</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_ADVTXD_MACLEN_SHIFT</span><span class="p">;</span>
	<span class="n">vlan_macip_lens</span> <span class="o">|=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGB_TX_FLAGS_VLAN_MASK</span><span class="p">;</span>

	<span class="n">igb_tx_ctxtdesc</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">vlan_macip_lens</span><span class="p">,</span> <span class="n">type_tucmd</span><span class="p">,</span> <span class="n">mss_l4len_idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__le32</span> <span class="nf">igb_tx_cmd_type</span><span class="p">(</span><span class="n">u32</span> <span class="n">tx_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* set type for advanced descriptor with frame checksum insertion */</span>
	<span class="n">__le32</span> <span class="n">cmd_type</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_ADVTXD_DTYP_DATA</span> <span class="o">|</span>
				      <span class="n">E1000_ADVTXD_DCMD_IFCS</span> <span class="o">|</span>
				      <span class="n">E1000_ADVTXD_DCMD_DEXT</span><span class="p">);</span>

	<span class="cm">/* set HW vlan bit if vlan is present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGB_TX_FLAGS_VLAN</span><span class="p">)</span>
		<span class="n">cmd_type</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_ADVTXD_DCMD_VLE</span><span class="p">);</span>

	<span class="cm">/* set timestamp bit if present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGB_TX_FLAGS_TSTAMP</span><span class="p">)</span>
		<span class="n">cmd_type</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_ADVTXD_MAC_TSTAMP</span><span class="p">);</span>

	<span class="cm">/* set segmentation bits for TSO */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGB_TX_FLAGS_TSO</span><span class="p">)</span>
		<span class="n">cmd_type</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_ADVTXD_DCMD_TSE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cmd_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_tx_olinfo_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span>
				 <span class="k">union</span> <span class="n">e1000_adv_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">tx_flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">paylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">olinfo_status</span> <span class="o">=</span> <span class="n">paylen</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_ADVTXD_PAYLEN_SHIFT</span><span class="p">;</span>

	<span class="cm">/* 82575 requires a unique index per ring if any offload is enabled */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IGB_TX_FLAGS_CSUM</span> <span class="o">|</span> <span class="n">IGB_TX_FLAGS_VLAN</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_TX_CTX_IDX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">olinfo_status</span> <span class="o">|=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* insert L4 checksum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGB_TX_FLAGS_CSUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">olinfo_status</span> <span class="o">|=</span> <span class="n">E1000_TXD_POPTS_TXSM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>

		<span class="cm">/* insert IPv4 checksum */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGB_TX_FLAGS_IPV4</span><span class="p">)</span>
			<span class="n">olinfo_status</span> <span class="o">|=</span> <span class="n">E1000_TXD_POPTS_IXSM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">olinfo_status</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">olinfo_status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The largest size we can write to the descriptor is 65535.  In order to</span>
<span class="cm"> * maintain a power of two alignment we have to limit ourselves to 32K.</span>
<span class="cm"> */</span>
<span class="cp">#define IGB_MAX_TXD_PWR	15</span>
<span class="cp">#define IGB_MAX_DATA_PER_TXD	(1&lt;&lt;IGB_MAX_TXD_PWR)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_tx_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">u8</span> <span class="n">hdr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">tx_buffer_info</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_adv_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">paylen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hdr_len</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">cmd_type</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_flags</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">igb_tx_olinfo_status</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">tx_desc</span><span class="p">,</span> <span class="n">tx_flags</span><span class="p">,</span> <span class="n">paylen</span><span class="p">);</span>
	<span class="n">cmd_type</span> <span class="o">=</span> <span class="n">igb_tx_cmd_type</span><span class="p">(</span><span class="n">tx_flags</span><span class="p">);</span>

	<span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">dma_error</span><span class="p">;</span>

	<span class="cm">/* record length, and DMA address */</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
	<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">IGB_MAX_DATA_PER_TXD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">cmd_type_len</span> <span class="o">=</span>
				<span class="n">cmd_type</span> <span class="o">|</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">IGB_MAX_DATA_PER_TXD</span><span class="p">);</span>

			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">tx_desc</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">dma</span> <span class="o">+=</span> <span class="n">IGB_MAX_DATA_PER_TXD</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="n">IGB_MAX_DATA_PER_TXD</span><span class="p">;</span>

			<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">olinfo_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">data_len</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">cmd_type_len</span> <span class="o">=</span> <span class="n">cmd_type</span> <span class="o">|</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tx_desc</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="n">data_len</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">dma</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				   <span class="n">size</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">dma_error</span><span class="p">;</span>

		<span class="n">tx_buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">tx_buffer_info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">tx_buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>

		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">olinfo_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>

		<span class="n">frag</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netdev_tx_sent_queue</span><span class="p">(</span><span class="n">txring_txq</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">),</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">bytecount</span><span class="p">);</span>

	<span class="cm">/* write last descriptor with RS and EOP bits */</span>
	<span class="n">cmd_type</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">|</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">IGB_TXD_DCMD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">no_fcs</span><span class="p">))</span>
		<span class="n">cmd_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_ADVTXD_DCMD_IFCS</span><span class="p">));</span>
	<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">cmd_type_len</span> <span class="o">=</span> <span class="n">cmd_type</span><span class="p">;</span>

	<span class="cm">/* set the timestamp */</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Force memory writes to complete before letting h/w know there</span>
<span class="cm">	 * are new descriptors to fetch.  (Only applicable for weak-ordered</span>
<span class="cm">	 * memory model archs, such as IA-64).</span>
<span class="cm">	 *</span>
<span class="cm">	 * We also need this memory barrier to make certain all of the</span>
<span class="cm">	 * status bits have been updated before next_to_watch is written.</span>
<span class="cm">	 */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="cm">/* set next_to_watch value indicating a packet is present */</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">tx_desc</span><span class="p">;</span>

	<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>

	<span class="cm">/* we need this if more than one processor can write to our tail</span>
<span class="cm">	 * at a time, it syncronizes IO on IA64/Altix systems */</span>
	<span class="n">mmiowb</span><span class="p">();</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">dma_error:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX DMA map failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* clear dma mappings for failed tx_buffer_info map */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">tx_buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">igb_unmap_and_free_tx_resource</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">tx_buffer_info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_buffer_info</span> <span class="o">==</span> <span class="n">first</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__igb_maybe_stop_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">netif_stop_subqueue</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>

	<span class="cm">/* Herbert&#39;s original patch had:</span>
<span class="cm">	 *  smp_mb__after_netif_stop_queue();</span>
<span class="cm">	 * but since that doesn&#39;t exist yet, just open code it. */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* We need to check again in a case another CPU has just</span>
<span class="cm">	 * made room available. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igb_desc_unused</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* A reprieve! */</span>
	<span class="n">netif_wake_subqueue</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>

	<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_syncp2</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_stats</span><span class="p">.</span><span class="n">restart_queue2</span><span class="o">++</span><span class="p">;</span>
	<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_syncp2</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">igb_maybe_stop_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igb_desc_unused</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__igb_maybe_stop_tx</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">netdev_tx_t</span> <span class="nf">igb_xmit_frame_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tso</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">protocol</span> <span class="o">=</span> <span class="n">vlan_get_protocol</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">hdr_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* need: 1 descriptor per page,</span>
<span class="cm">	 *       + 2 desc gap to keep tail from touching head,</span>
<span class="cm">	 *       + 1 desc for skb-&gt;data,</span>
<span class="cm">	 *       + 1 desc for context descriptor,</span>
<span class="cm">	 * otherwise try next time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igb_maybe_stop_tx</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* this is a hard error */</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* record the location of the first descriptor for this packet */</span>
	<span class="n">first</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">];</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">bytecount</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_HW_TSTAMP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">SKBTX_IN_PROGRESS</span><span class="p">;</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">IGB_TX_FLAGS_TSTAMP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">IGB_TX_FLAGS_VLAN</span><span class="p">;</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">IGB_TX_FLAGS_VLAN_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* record initial flags and protocol */</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">=</span> <span class="n">tx_flags</span><span class="p">;</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>

	<span class="n">tso</span> <span class="o">=</span> <span class="n">igb_tso</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tso</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_drop</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tso</span><span class="p">)</span>
		<span class="n">igb_tx_csum</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>

	<span class="n">igb_tx_map</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">hdr_len</span><span class="p">);</span>

	<span class="cm">/* Make sure there is space in the ring for the next send. */</span>
	<span class="n">igb_maybe_stop_tx</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

<span class="nl">out_drop:</span>
	<span class="n">igb_unmap_and_free_tx_resource</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="nf">igb_tx_queue_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_idx</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r_idx</span> <span class="o">&gt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">)</span>
		<span class="n">r_idx</span> <span class="o">=</span> <span class="n">r_idx</span> <span class="o">%</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">r_idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">igb_xmit_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The minimum packet size with TCTL.PSP set is 17 so pad the skb</span>
<span class="cm">	 * in order to meet this minimum size requirement.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">17</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_padto</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">17</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">igb_xmit_frame_ring</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">igb_tx_queue_mapping</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">skb</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_tx_timeout - Respond to a Tx Hang</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* Do the reset outside of interrupt context */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_count</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_82580</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_spec</span><span class="p">.</span><span class="n">_82575</span><span class="p">.</span><span class="n">global_device_reset</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_EICS</span><span class="p">,</span>
	     <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_other</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">igb_adapter</span><span class="p">,</span> <span class="n">reset_task</span><span class="p">);</span>

	<span class="n">igb_dump</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">netdev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Reset adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">igb_reinit_locked</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_get_stats64 - Get System Network Statistics</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> * @stats: rtnl_link_stats64 pointer</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="nf">igb_get_stats64</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>
	<span class="n">igb_update_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_change_mtu - Change the Maximum Transfer Unit</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> * @new_mtu: new value for maximum frame size</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_frame</span> <span class="o">=</span> <span class="n">new_mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="mi">68</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">max_frame</span> <span class="o">&gt;</span> <span class="n">MAX_JUMBO_FRAME_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid MTU setting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#define MAX_STD_JUMBO_FRAME_SIZE 9238</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_frame</span> <span class="o">&gt;</span> <span class="n">MAX_STD_JUMBO_FRAME_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MTU &gt; 9216 not supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__IGB_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* igb_down has a dependency on max_frame_size */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">max_frame</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">igb_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;changing MTU from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">igb_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">igb_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__IGB_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_update_stats - Update the board statistics counters</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">igb_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">net_stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">mpc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">packets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">_bytes</span><span class="p">,</span> <span class="n">_packets</span><span class="p">;</span>

<span class="cp">#define PHY_IDLE_ERROR_COUNT_MASK 0x00FF</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent stats update while adapter is being reset, or if the pci</span>
<span class="cm">	 * connection is down.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">rqdpc_tmp</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RQDPC</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0FFF</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_stats</span><span class="p">.</span><span class="n">drops</span> <span class="o">+=</span> <span class="n">rqdpc_tmp</span><span class="p">;</span>
		<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_fifo_errors</span> <span class="o">+=</span> <span class="n">rqdpc_tmp</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">u64_stats_fetch_begin_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_syncp</span><span class="p">);</span>
			<span class="n">_bytes</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_stats</span><span class="p">.</span><span class="n">bytes</span><span class="p">;</span>
			<span class="n">_packets</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_stats</span><span class="p">.</span><span class="n">packets</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">u64_stats_fetch_retry_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_syncp</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>
		<span class="n">bytes</span> <span class="o">+=</span> <span class="n">_bytes</span><span class="p">;</span>
		<span class="n">packets</span> <span class="o">+=</span> <span class="n">_packets</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span> <span class="o">=</span> <span class="n">packets</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">u64_stats_fetch_begin_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">tx_syncp</span><span class="p">);</span>
			<span class="n">_bytes</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">tx_stats</span><span class="p">.</span><span class="n">bytes</span><span class="p">;</span>
			<span class="n">_packets</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">tx_stats</span><span class="p">.</span><span class="n">packets</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">u64_stats_fetch_retry_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">tx_syncp</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>
		<span class="n">bytes</span> <span class="o">+=</span> <span class="n">_bytes</span><span class="p">;</span>
		<span class="n">packets</span> <span class="o">+=</span> <span class="n">_packets</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span> <span class="o">=</span> <span class="n">packets</span><span class="p">;</span>

	<span class="cm">/* read stats registers */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">crcerrs</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CRCERRS</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gprc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_GPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gorc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_GORCL</span><span class="p">);</span>
	<span class="n">rd32</span><span class="p">(</span><span class="n">E1000_GORCH</span><span class="p">);</span> <span class="cm">/* clear GORCL */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">bprc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_BPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mprc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_MPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">roc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ROC</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc64</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PRC64</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc127</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PRC127</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc255</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PRC255</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc511</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PRC511</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc1023</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PRC1023</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc1522</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PRC1522</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">symerrs</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_SYMERRS</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sec</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_SEC</span><span class="p">);</span>

	<span class="n">mpc</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_MPC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mpc</span> <span class="o">+=</span> <span class="n">mpc</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_fifo_errors</span> <span class="o">+=</span> <span class="n">mpc</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">scc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_SCC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ECOL</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mcc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_MCC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_LATECOL</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">dc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_DC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rlec</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RLEC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xonrxc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_XONRXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xontxc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_XONTXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xoffrxc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_XOFFRXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xofftxc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_XOFFTXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">fcruc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_FCRUC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gptc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_GPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gotc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_GOTCL</span><span class="p">);</span>
	<span class="n">rd32</span><span class="p">(</span><span class="n">E1000_GOTCH</span><span class="p">);</span> <span class="cm">/* clear GOTCL */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rnbc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RNBC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ruc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RUC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rfc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RFC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rjc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RJC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tor</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TORH</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tot</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TOTH</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tpr</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TPR</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc64</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PTC64</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc127</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PTC127</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc255</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PTC255</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc511</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PTC511</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc1023</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PTC1023</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc1522</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PTC1522</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mptc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_MPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">bptc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_BPTC</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tpt</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TPT</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">colc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_COLC</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">algnerrc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ALGNERRC</span><span class="p">);</span>
	<span class="cm">/* read internal phy specific stats */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CTRL_EXT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_EXT_LINK_MODE_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rxerrc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RXERRC</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tncrs</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TNCRS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tsctc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TSCTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tsctfc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TSCTFC</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iac</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_IAC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">icrxoc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICRXOC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">icrxptc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICRXPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">icrxatc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICRXATC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ictxptc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICTXPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ictxatc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICTXATC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ictxqec</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICTXQEC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ictxqmtc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICTXQMTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">icrxdmtc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICRXDMTC</span><span class="p">);</span>

	<span class="cm">/* Fill out the OS statistics structure */</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">multicast</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mprc</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">collisions</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">colc</span><span class="p">;</span>

	<span class="cm">/* Rx Errors */</span>

	<span class="cm">/* RLEC on some newer hardware can be incorrect so build</span>
<span class="cm">	 * our own version based on RUC and ROC */</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rxerrc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">crcerrs</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">algnerrc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ruc</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">roc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cexterr</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_length_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ruc</span> <span class="o">+</span>
				      <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">roc</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">crcerrs</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_frame_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">algnerrc</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_missed_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mpc</span><span class="p">;</span>

	<span class="cm">/* Tx Errors */</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">tx_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span> <span class="o">+</span>
			       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">tx_aborted_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">tx_window_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">tx_carrier_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tncrs</span><span class="p">;</span>

	<span class="cm">/* Tx Dropped needs to be maintained elsewhere */</span>

	<span class="cm">/* Phy Stats */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">==</span> <span class="n">SPEED_1000</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="o">!</span><span class="n">igb_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_tmp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">phy_tmp</span> <span class="o">&amp;=</span> <span class="n">PHY_IDLE_ERROR_COUNT_MASK</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_stats</span><span class="p">.</span><span class="n">idle_errors</span> <span class="o">+=</span> <span class="n">phy_tmp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Management Stats */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mgptc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_MGTPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mgprc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_MGTPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mgpdc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_MGTPDC</span><span class="p">);</span>

	<span class="cm">/* OS2BMC Stats */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_MANC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_MANC_EN_BMC2OS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">o2bgptc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_O2BGPTC</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">o2bspc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_O2BSPC</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">b2ospc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_B2OSPC</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">b2ogprc</span> <span class="o">+=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_B2OGPRC</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">igb_msix_other</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">icr</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICR</span><span class="p">);</span>
	<span class="cm">/* reading ICR causes bit 31 of EICR to be cleared */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_DRSTA</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_DOUTSYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* HW is reporting DMA is out of sync */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">doosync</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* The DMA Out of Sync is also indication of a spoof event</span>
<span class="cm">		 * in IOV mode. Check the Wrong VM Behavior register to</span>
<span class="cm">		 * see if it is really a spoof event. */</span>
		<span class="n">igb_check_wvbr</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check for a mailbox event */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_VMMB</span><span class="p">)</span>
		<span class="n">igb_msg_task</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_LSC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* guard against interrupt when we&#39;re going down */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_EIMS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_other</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_write_itr</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">itr_val</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">&amp;</span> <span class="mh">0x7FFC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">set_itr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">itr_val</span><span class="p">)</span>
		<span class="n">itr_val</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82575</span><span class="p">)</span>
		<span class="n">itr_val</span> <span class="o">|=</span> <span class="n">itr_val</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">itr_val</span> <span class="o">|=</span> <span class="n">E1000_EITR_CNT_IGNR</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">itr_val</span><span class="p">,</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">itr_register</span><span class="p">);</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">set_itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">igb_msix_ring</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Write the ITR value calculated from the previous interrupt. */</span>
	<span class="n">igb_write_itr</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>

	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IGB_DCA</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_update_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_update</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">reg_idx</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">dca_txctrl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_DCA_TXCTRL</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82575</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dca_txctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_DCA_TXCTRL_CPUID_MASK</span><span class="p">;</span>
			<span class="n">dca_txctrl</span> <span class="o">|=</span> <span class="n">dca3_get_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dca_txctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_DCA_TXCTRL_CPUID_MASK_82576</span><span class="p">;</span>
			<span class="n">dca_txctrl</span> <span class="o">|=</span> <span class="n">dca3_get_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			              <span class="n">E1000_DCA_TXCTRL_CPUID_SHIFT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dca_txctrl</span> <span class="o">|=</span> <span class="n">E1000_DCA_TXCTRL_DESC_DCA_EN</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DCA_TXCTRL</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="n">dca_txctrl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">reg_idx</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">dca_rxctrl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_DCA_RXCTRL</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82575</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dca_rxctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_DCA_RXCTRL_CPUID_MASK</span><span class="p">;</span>
			<span class="n">dca_rxctrl</span> <span class="o">|=</span> <span class="n">dca3_get_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dca_rxctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_DCA_RXCTRL_CPUID_MASK_82576</span><span class="p">;</span>
			<span class="n">dca_rxctrl</span> <span class="o">|=</span> <span class="n">dca3_get_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			              <span class="n">E1000_DCA_RXCTRL_CPUID_SHIFT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dca_rxctrl</span> <span class="o">|=</span> <span class="n">E1000_DCA_RXCTRL_DESC_DCA_EN</span><span class="p">;</span>
		<span class="n">dca_rxctrl</span> <span class="o">|=</span> <span class="n">E1000_DCA_RXCTRL_HEAD_DCA_EN</span><span class="p">;</span>
		<span class="n">dca_rxctrl</span> <span class="o">|=</span> <span class="n">E1000_DCA_RXCTRL_DATA_DCA_EN</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DCA_RXCTRL</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="n">dca_rxctrl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="nl">out_no_update:</span>
	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_setup_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_FLAG_DCA_ENABLED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Always use CB2 mode, difference is masked in the CB driver. */</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DCA_CTRL</span><span class="p">,</span> <span class="n">E1000_DCA_CTRL_DCA_MODE_CB2</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">igb_update_dca</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__igb_notify_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DCA_PROVIDER_ADD</span>:
		<span class="cm">/* if already enabled, don&#39;t do it again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_FLAG_DCA_ENABLED</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dca_add_requester</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IGB_FLAG_DCA_ENABLED</span><span class="p">;</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DCA enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">igb_setup_dca</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Fall Through since DCA is disabled. */</span>
	<span class="k">case</span> <span class="n">DCA_PROVIDER_REMOVE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_FLAG_DCA_ENABLED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* without this a class_device is left</span>
<span class="cm">			 * hanging around in the sysfs model */</span>
			<span class="n">dca_remove_requester</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DCA disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGB_FLAG_DCA_ENABLED</span><span class="p">;</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DCA_CTRL</span><span class="p">,</span> <span class="n">E1000_DCA_CTRL_DCA_MODE_DISABLE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_notify_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span>
                          <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">driver_for_each_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">igb_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span>
	                                 <span class="n">__igb_notify_dca</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span> <span class="o">?</span> <span class="n">NOTIFY_BAD</span> <span class="o">:</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IGB_DCA */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PCI_IOV</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_vf_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mac_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pvfdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">thisvf_devfn</span><span class="p">;</span>

	<span class="n">random_ether_addr</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">);</span>
	<span class="n">igb_set_vf_mac</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">mac_addr</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82576</span>:
		<span class="n">device_id</span> <span class="o">=</span> <span class="n">IGB_82576_VF_DEV_ID</span><span class="p">;</span>
		<span class="cm">/* VF Stride for 82576 is 2 */</span>
		<span class="n">thisvf_devfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">+</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="p">(</span><span class="n">vf</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_i350</span>:
		<span class="n">device_id</span> <span class="o">=</span> <span class="n">IGB_I350_VF_DEV_ID</span><span class="p">;</span>
		<span class="cm">/* VF Stride for I350 is 4 */</span>
		<span class="n">thisvf_devfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">+</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="p">(</span><span class="n">vf</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">device_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">thisvf_devfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pvfdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">vendor_id</span><span class="p">,</span> <span class="n">device_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pvfdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pvfdev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">==</span> <span class="n">thisvf_devfn</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">pvfdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">vendor_id</span><span class="p">,</span>
					<span class="n">device_id</span><span class="p">,</span> <span class="n">pvfdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvfdev</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">vfdev</span> <span class="o">=</span> <span class="n">pvfdev</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Couldn&#39;t find pci dev ptr for VF %4.4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">thisvf_devfn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pvfdev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_find_enabled_vfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pvfdev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vf_devfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vf_stride</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vfs_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82576</span>:
		<span class="n">device_id</span> <span class="o">=</span> <span class="n">IGB_82576_VF_DEV_ID</span><span class="p">;</span>
		<span class="cm">/* VF Stride for 82576 is 2 */</span>
		<span class="n">vf_stride</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_i350</span>:
		<span class="n">device_id</span> <span class="o">=</span> <span class="n">IGB_I350_VF_DEV_ID</span><span class="p">;</span>
		<span class="cm">/* VF Stride for I350 is 4 */</span>
		<span class="n">vf_stride</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">device_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vf_stride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vf_devfn</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">+</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="n">pvfdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">vendor_id</span><span class="p">,</span> <span class="n">device_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pvfdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pvfdev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">==</span> <span class="n">vf_devfn</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">pvfdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&gt;=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
			<span class="n">vfs_found</span><span class="o">++</span><span class="p">;</span>
		<span class="n">vf_devfn</span> <span class="o">+=</span> <span class="n">vf_stride</span><span class="p">;</span>
		<span class="n">pvfdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">vendor_id</span><span class="p">,</span>
					<span class="n">device_id</span><span class="p">,</span> <span class="n">pvfdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">vfs_found</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_check_vf_assignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vfdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vfdev</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span>
			    <span class="n">PCI_DEV_FLAGS_ASSIGNED</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_ping_all_vfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ping</span> <span class="o">=</span> <span class="n">E1000_PF_CONTROL_MSG</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_VF_FLAG_CTS</span><span class="p">)</span>
			<span class="n">ping</span> <span class="o">|=</span> <span class="n">E1000_VT_MSGTYPE_CTS</span><span class="p">;</span>
		<span class="n">igb_write_mbx</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ping</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_set_vf_promisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">msgbuf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vmolr</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vf</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">vf_data_storage</span> <span class="o">*</span><span class="n">vf_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">];</span>

	<span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IGB_VF_FLAG_UNI_PROMISC</span> <span class="o">|</span>
	                    <span class="n">IGB_VF_FLAG_MULTI_PROMISC</span><span class="p">);</span>
	<span class="n">vmolr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_VMOLR_ROPE</span> <span class="o">|</span> <span class="n">E1000_VMOLR_ROMPE</span> <span class="o">|</span> <span class="n">E1000_VMOLR_MPME</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">msgbuf</span> <span class="o">&amp;</span> <span class="n">E1000_VF_SET_PROMISC_MULTICAST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_MPME</span><span class="p">;</span>
		<span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IGB_VF_FLAG_MULTI_PROMISC</span><span class="p">;</span>
		<span class="o">*</span><span class="n">msgbuf</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_VF_SET_PROMISC_MULTICAST</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if we have hashes and we are clearing a multicast promisc</span>
<span class="cm">		 * flag we need to write the hashes to the MTA as this step</span>
<span class="cm">		 * was previously skipped</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">num_vf_mc_hashes</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_MPME</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">num_vf_mc_hashes</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
			<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_ROMPE</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">num_vf_mc_hashes</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">igb_mta_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">vf_mc_hashes</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vf</span><span class="p">),</span> <span class="n">vmolr</span><span class="p">);</span>

	<span class="cm">/* there are flags left unprocessed, likely not supported */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">msgbuf</span> <span class="o">&amp;</span> <span class="n">E1000_VT_MSGINFO_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_set_vf_multicasts</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="o">*</span><span class="n">msgbuf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">E1000_VT_MSGINFO_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">E1000_VT_MSGINFO_SHIFT</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">hash_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">vf_data_storage</span> <span class="o">*</span><span class="n">vf_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* salt away the number of multicast addresses assigned</span>
<span class="cm">	 * to this VF for later use to restore when the PF multi cast</span>
<span class="cm">	 * list changes</span>
<span class="cm">	 */</span>
	<span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">num_vf_mc_hashes</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* only up to 30 hash values supported */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">)</span>
		<span class="n">n</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

	<span class="cm">/* store the hashes for later use */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">vf_mc_hashes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hash_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/* Flush and reset the mta with the new values */</span>
	<span class="n">igb_set_rx_mode</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_restore_vf_multicasts</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vf_data_storage</span> <span class="o">*</span><span class="n">vf_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">vmolr</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">vmolr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_VMOLR_ROMPE</span> <span class="o">|</span> <span class="n">E1000_VMOLR_MPME</span><span class="p">);</span>

		<span class="n">vf_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">num_vf_mc_hashes</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_VF_FLAG_MULTI_PROMISC</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_MPME</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">num_vf_mc_hashes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vmolr</span> <span class="o">|=</span> <span class="n">E1000_VMOLR_ROMPE</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">num_vf_mc_hashes</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">igb_mta_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">vf_mc_hashes</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">vmolr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_clear_vf_vfta</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pool_mask</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pool_mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">E1000_VLVF_POOLSEL_SHIFT</span> <span class="o">+</span> <span class="n">vf</span><span class="p">);</span>

	<span class="cm">/* Find the vlan filter for this id */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E1000_VLVF_ARRAY_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VLVF</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

		<span class="cm">/* remove the vf from the pool */</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">pool_mask</span><span class="p">;</span>

		<span class="cm">/* if pool is empty then remove entry from vfta */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_VLVF_POOLSEL_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_VLVF_VLANID_ENABLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">vid</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_VLVF_VLANID_MASK</span><span class="p">;</span>
			<span class="n">igb_vfta_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VLVF</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">vlans_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">igb_vlvf_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vid</span><span class="p">,</span> <span class="n">bool</span> <span class="n">add</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* The vlvf table only exists on 82576 hardware and newer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">e1000_82576</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* we only need to do this if VMDq is enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Find the vlan filter for this id */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E1000_VLVF_ARRAY_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VLVF</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_VLVF_VLANID_ENABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">vid</span> <span class="o">==</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_VLVF_VLANID_MASK</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">E1000_VLVF_ARRAY_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Did not find a matching VLAN ID entry that was</span>
<span class="cm">			 * enabled.  Search for a free filter entry, i.e.</span>
<span class="cm">			 * one without the enable bit set</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E1000_VLVF_ARRAY_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VLVF</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_VLVF_VLANID_ENABLE</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">E1000_VLVF_ARRAY_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Found an enabled/available entry */</span>
			<span class="n">reg</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">E1000_VLVF_POOLSEL_SHIFT</span> <span class="o">+</span> <span class="n">vf</span><span class="p">);</span>

			<span class="cm">/* if !enabled we need to set this up in vfta */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_VLVF_VLANID_ENABLE</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* add VID to filter table */</span>
				<span class="n">igb_vfta_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
				<span class="n">reg</span> <span class="o">|=</span> <span class="n">E1000_VLVF_VLANID_ENABLE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_VLVF_VLANID_MASK</span><span class="p">;</span>
			<span class="n">reg</span> <span class="o">|=</span> <span class="n">vid</span><span class="p">;</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VLVF</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>

			<span class="cm">/* do not modify RLPML for PF devices */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vf</span> <span class="o">&gt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">vlans_enabled</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
				<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vf</span><span class="p">));</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_VMOLR_RLPML_MASK</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_VMOLR_RLPML_MASK</span><span class="p">;</span>
				<span class="n">reg</span> <span class="o">|=</span> <span class="n">size</span><span class="p">;</span>
				<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vf</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">vlans_enabled</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">E1000_VLVF_ARRAY_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* remove vf from the pool */</span>
			<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">E1000_VLVF_POOLSEL_SHIFT</span> <span class="o">+</span> <span class="n">vf</span><span class="p">));</span>
			<span class="cm">/* if pool is empty then remove entry from vfta */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_VLVF_POOLSEL_MASK</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">igb_vfta_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VLVF</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>

			<span class="cm">/* do not modify RLPML for PF devices */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vf</span> <span class="o">&gt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">vlans_enabled</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">vlans_enabled</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
				<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vf</span><span class="p">));</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_VMOLR_RLPML_MASK</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_VMOLR_RLPML_MASK</span><span class="p">;</span>
				<span class="n">reg</span> <span class="o">|=</span> <span class="n">size</span><span class="p">;</span>
				<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VMOLR</span><span class="p">(</span><span class="n">vf</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_set_vmvir</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vid</span><span class="p">)</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VMVIR</span><span class="p">(</span><span class="n">vf</span><span class="p">),</span> <span class="p">(</span><span class="n">vid</span> <span class="o">|</span> <span class="n">E1000_VMVIR_VLANA_DEFAULT</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VMVIR</span><span class="p">(</span><span class="n">vf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_ndo_set_vf_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vlan</span><span class="p">,</span> <span class="n">u8</span> <span class="n">qos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vf</span> <span class="o">&gt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">vlan</span> <span class="o">&gt;</span> <span class="mi">4095</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">qos</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span> <span class="o">||</span> <span class="n">qos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">igb_vlvf_set</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vlan</span><span class="p">,</span> <span class="o">!!</span><span class="n">vlan</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">igb_set_vmvir</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vlan</span> <span class="o">|</span> <span class="p">(</span><span class="n">qos</span> <span class="o">&lt;&lt;</span> <span class="n">VLAN_PRIO_SHIFT</span><span class="p">),</span> <span class="n">vf</span><span class="p">);</span>
		<span class="n">igb_set_vmolr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="o">!</span><span class="n">vlan</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">pf_vlan</span> <span class="o">=</span> <span class="n">vlan</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">pf_qos</span> <span class="o">=</span> <span class="n">qos</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;Setting VLAN %d, QOS 0x%x on VF %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vlan</span><span class="p">,</span> <span class="n">qos</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;The VF VLAN has been set,&quot;</span>
				 <span class="s">&quot; but the PF device is not up.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Bring the PF device up before&quot;</span>
				 <span class="s">&quot; attempting to use the VF device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">igb_vlvf_set</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">pf_vlan</span><span class="p">,</span>
				   <span class="nb">false</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="n">igb_set_vmvir</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vlan</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="n">igb_set_vmolr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">pf_vlan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">pf_qos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
       <span class="p">}</span>
<span class="nl">out:</span>
       <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_set_vf_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">msgbuf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">add</span> <span class="o">=</span> <span class="p">(</span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">E1000_VT_MSGINFO_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">E1000_VT_MSGINFO_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vid</span> <span class="o">=</span> <span class="p">(</span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">E1000_VLVF_VLANID_MASK</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">igb_vlvf_set</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">igb_vf_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* clear flags - except flag that indicates PF has set the MAC */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">IGB_VF_FLAG_PF_SET_MAC</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">last_nack</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* reset offloads to defaults */</span>
	<span class="n">igb_set_vmolr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* reset vlans for device */</span>
	<span class="n">igb_clear_vf_vfta</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">pf_vlan</span><span class="p">)</span>
		<span class="n">igb_ndo_set_vf_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">pf_vlan</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">pf_qos</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">igb_clear_vf_vfta</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>

	<span class="cm">/* reset multicast table array for vf */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">num_vf_mc_hashes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Flush and reset the mta with the new values */</span>
	<span class="n">igb_set_rx_mode</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_vf_reset_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vf_mac</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">vf_mac_addresses</span><span class="p">;</span>

	<span class="cm">/* generate a new mac address as we were hotplug removed/added */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_VF_FLAG_PF_SET_MAC</span><span class="p">))</span>
		<span class="n">random_ether_addr</span><span class="p">(</span><span class="n">vf_mac</span><span class="p">);</span>

	<span class="cm">/* process remaining reset events */</span>
	<span class="n">igb_vf_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_vf_reset_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vf_mac</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">vf_mac_addresses</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rar_entry</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">rar_entry_count</span> <span class="o">-</span> <span class="p">(</span><span class="n">vf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">msgbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="cm">/* process all the same items cleared in a function level reset */</span>
	<span class="n">igb_vf_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>

	<span class="cm">/* set vf mac address */</span>
	<span class="n">igb_rar_set_qsel</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf_mac</span><span class="p">,</span> <span class="n">rar_entry</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>

	<span class="cm">/* enable transmit and receive for vf */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VFTE</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VFTE</span><span class="p">,</span> <span class="n">reg</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">vf</span><span class="p">));</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_VFRE</span><span class="p">);</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_VFRE</span><span class="p">,</span> <span class="n">reg</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">vf</span><span class="p">));</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IGB_VF_FLAG_CTS</span><span class="p">;</span>

	<span class="cm">/* reply to reset with ack and vf mac address */</span>
	<span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">E1000_VF_RESET</span> <span class="o">|</span> <span class="n">E1000_VT_MSGTYPE_ACK</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">vf_mac</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">igb_write_mbx</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">msgbuf</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_set_vf_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The VF MAC Address is stored in a packed array of bytes</span>
<span class="cm">	 * starting at the second 32 bit word of the msg array</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">igb_set_vf_mac</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_rcv_ack_from_vf</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vf_data_storage</span> <span class="o">*</span><span class="n">vf_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">E1000_VT_MSGTYPE_NACK</span><span class="p">;</span>

	<span class="cm">/* if device isn&#39;t clear to send it shouldn&#39;t be reading either */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_VF_FLAG_CTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">last_nack</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">igb_write_mbx</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">last_nack</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_rcv_msg_from_vf</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msgbuf</span><span class="p">[</span><span class="n">E1000_VFMAILBOX_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vf_data_storage</span> <span class="o">*</span><span class="n">vf_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">];</span>
	<span class="n">s32</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">igb_read_mbx</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">msgbuf</span><span class="p">,</span> <span class="n">E1000_VFMAILBOX_SIZE</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if receive failed revoke VF CTS stats and restart init */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error receiving message from VF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGB_VF_FLAG_CTS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">last_nack</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this is a message we already processed, do nothing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">E1000_VT_MSGTYPE_ACK</span> <span class="o">|</span> <span class="n">E1000_VT_MSGTYPE_NACK</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * until the vf completes a reset it should not be</span>
<span class="cm">	 * allowed to start any configuration.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">E1000_VF_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">igb_vf_reset_msg</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_VF_FLAG_CTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">last_nack</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">((</span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_VF_SET_MAC_ADDR</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_VF_FLAG_PF_SET_MAC</span><span class="p">))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">igb_set_vf_mac_addr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">msgbuf</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;VF %d attempted to override administratively &quot;</span>
				 <span class="s">&quot;set MAC address</span><span class="se">\n</span><span class="s">Reload the VF driver to &quot;</span>
				 <span class="s">&quot;resume operations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_VF_SET_PROMISC</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">igb_set_vf_promisc</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">msgbuf</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_VF_SET_MULTICAST</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">igb_set_vf_multicasts</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">msgbuf</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_VF_SET_LPE</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">igb_set_vf_rlpml</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">msgbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_VF_SET_VLAN</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vf_data</span><span class="o">-&gt;</span><span class="n">pf_vlan</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;VF %d attempted to override administratively &quot;</span>
				 <span class="s">&quot;set VLAN tag</span><span class="se">\n</span><span class="s">Reload the VF driver to &quot;</span>
				 <span class="s">&quot;resume operations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">igb_set_vf_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">msgbuf</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unhandled Msg %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">E1000_VT_MSGTYPE_CTS</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="cm">/* notify the VF of the results of what it sent us */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">E1000_VT_MSGTYPE_NACK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">E1000_VT_MSGTYPE_ACK</span><span class="p">;</span>

	<span class="n">igb_write_mbx</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">msgbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_msg_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vf</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vf</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span> <span class="n">vf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* process any reset requests */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igb_check_for_rst</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vf</span><span class="p">))</span>
			<span class="n">igb_vf_reset_event</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>

		<span class="cm">/* process any messages pending */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igb_check_for_msg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vf</span><span class="p">))</span>
			<span class="n">igb_rcv_msg_from_vf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>

		<span class="cm">/* process any acks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igb_check_for_ack</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vf</span><span class="p">))</span>
			<span class="n">igb_rcv_ack_from_vf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  igb_set_uta - Set unicast filter table address</span>
<span class="cm"> *  @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> *  The unicast table address is a register array of 32-bit registers.</span>
<span class="cm"> *  The table is meant to be used in a way similar to how the MTA is used</span>
<span class="cm"> *  however due to certain limitations in the hardware it is necessary to</span>
<span class="cm"> *  set all the hash bits to 1 and use the VMOLR ROPE bit as a promiscuous</span>
<span class="cm"> *  enable bit to allow vlan tag stripping when promiscuous mode is enabled</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_set_uta</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* The UTA table only exists on 82576 hardware and newer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">e1000_82576</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* we only need to do this if VMDq is enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">uta_reg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">array_wr32</span><span class="p">(</span><span class="n">E1000_UTA</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_intr_msi - Interrupt Handler</span>
<span class="cm"> * @irq: interrupt number</span>
<span class="cm"> * @data: pointer to a network interface device structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">igb_intr_msi</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="cm">/* read ICR disables interrupts using IAM */</span>
	<span class="n">u32</span> <span class="n">icr</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICR</span><span class="p">);</span>

	<span class="n">igb_write_itr</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_DRSTA</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_DOUTSYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* HW is reporting DMA is out of sync */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">doosync</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">E1000_ICR_RXSEQ</span> <span class="o">|</span> <span class="n">E1000_ICR_LSC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_intr - Legacy Interrupt Handler</span>
<span class="cm"> * @irq: interrupt number</span>
<span class="cm"> * @data: pointer to a network interface device structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">igb_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="cm">/* Interrupt Auto-Mask...upon reading ICR, interrupts are masked.  No</span>
<span class="cm">	 * need for the IMC write */</span>
	<span class="n">u32</span> <span class="n">icr</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_ICR</span><span class="p">);</span>

	<span class="cm">/* IMS will not auto-mask if INT_ASSERTED is not set, and if it is</span>
<span class="cm">	 * not set, then the adapter didn&#39;t send an interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_INT_ASSERTED</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">igb_write_itr</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_DRSTA</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_DOUTSYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* HW is reporting DMA is out of sync */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">doosync</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">E1000_ICR_RXSEQ</span> <span class="o">|</span> <span class="n">E1000_ICR_LSC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* guard against interrupt when we&#39;re going down */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_ring_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr_setting</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr_setting</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">)</span>
			<span class="n">igb_set_itr</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">igb_update_ring_itr</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_EIMS</span><span class="p">,</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">eims_value</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">igb_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_poll - NAPI Rx polling callback</span>
<span class="cm"> * @napi: napi polling structure</span>
<span class="cm"> * @budget: count of how many packets we should handle</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span>
	                                             <span class="k">struct</span> <span class="n">igb_q_vector</span><span class="p">,</span>
	                                             <span class="n">napi</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">clean_complete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IGB_DCA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_FLAG_DCA_ENABLED</span><span class="p">)</span>
		<span class="n">igb_update_dca</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
		<span class="n">clean_complete</span> <span class="o">=</span> <span class="n">igb_clean_tx_irq</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
		<span class="n">clean_complete</span> <span class="o">&amp;=</span> <span class="n">igb_clean_rx_irq</span><span class="p">(</span><span class="n">q_vector</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

	<span class="cm">/* If all work not completed, return budget and keep polling */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clean_complete</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">budget</span><span class="p">;</span>

	<span class="cm">/* If not enough Rx work done, exit the polling mode */</span>
	<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">igb_ring_irq_enable</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IGB_PTP</span>
<span class="cm">/**</span>
<span class="cm"> * igb_tx_hwtstamp - utility function which checks for TX time stamp</span>
<span class="cm"> * @q_vector: pointer to q_vector containing needed info</span>
<span class="cm"> * @buffer: pointer to igb_tx_buffer structure</span>
<span class="cm"> *</span>
<span class="cm"> * If we were asked to do hardware stamping and such a time stamp is</span>
<span class="cm"> * available, then it must have been for this skb here because we only</span>
<span class="cm"> * allow only one such packet into the queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_tx_hwtstamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="n">shhwtstamps</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">regval</span><span class="p">;</span>

	<span class="cm">/* if skb does not support hw timestamp or TX stamp not valid exit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGB_TX_FLAGS_TSTAMP</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TSYNCTXCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_TSYNCTXCTL_VALID</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">regval</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TXSTMPL</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TXSTMPH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>

	<span class="n">igb_systim_to_hwtstamp</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shhwtstamps</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>
	<span class="n">skb_tstamp_tx</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shhwtstamps</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>
<span class="cm">/**</span>
<span class="cm"> * igb_clean_tx_irq - Reclaim resources after transmit completes</span>
<span class="cm"> * @q_vector: pointer to q_vector containing needed info</span>
<span class="cm"> * returns true if ring is completely cleaned</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">igb_clean_tx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">tx_buffer</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_adv_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span><span class="p">,</span> <span class="o">*</span><span class="n">eop_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">budget</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">work_limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">tx_buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">-=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">budget</span><span class="p">;</span> <span class="n">budget</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eop_desc</span> <span class="o">=</span> <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">next_to_watch</span><span class="p">;</span>

		<span class="cm">/* prevent any other reads prior to eop_desc */</span>
		<span class="n">rmb</span><span class="p">();</span>

		<span class="cm">/* if next_to_watch is not set then there is no work pending */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eop_desc</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* if DD is not set pending work has not been completed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">eop_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_TXD_STAT_DD</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* clear next_to_watch to prevent false hangs */</span>
		<span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* update the statistics for this packet */</span>
		<span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">bytecount</span><span class="p">;</span>
		<span class="n">total_packets</span> <span class="o">+=</span> <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">gso_segs</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IGB_PTP</span>
		<span class="cm">/* retrieve hardware timestamp */</span>
		<span class="n">igb_tx_hwtstamp</span><span class="p">(</span><span class="n">q_vector</span><span class="p">,</span> <span class="n">tx_buffer</span><span class="p">);</span>

<span class="cp">#endif</span>
		<span class="cm">/* free the skb */</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* unmap skb header data */</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				 <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
				 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

		<span class="cm">/* clear last DMA location and unmap remaining buffers */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">tx_desc</span> <span class="o">!=</span> <span class="n">eop_desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">tx_buffer</span><span class="o">++</span><span class="p">;</span>
			<span class="n">tx_desc</span><span class="o">++</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">i</span> <span class="o">-=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
				<span class="n">tx_buffer</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">;</span>
				<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* unmap any remaining paged data */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					       <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					       <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
					       <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* clear last DMA location */</span>
		<span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* move us one more past the eop_desc for start of next pkt */</span>
		<span class="n">tx_buffer</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tx_desc</span><span class="o">++</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">-=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
			<span class="n">tx_buffer</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">;</span>
			<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">netdev_tx_completed_queue</span><span class="p">(</span><span class="n">txring_txq</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">),</span>
				  <span class="n">total_packets</span><span class="p">,</span> <span class="n">total_bytes</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">+=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_syncp</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_stats</span><span class="p">.</span><span class="n">bytes</span> <span class="o">+=</span> <span class="n">total_bytes</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_stats</span><span class="p">.</span><span class="n">packets</span> <span class="o">+=</span> <span class="n">total_packets</span><span class="p">;</span>
	<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_syncp</span><span class="p">);</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">total_bytes</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">total_packets</span> <span class="o">+=</span> <span class="n">total_packets</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_TX_DETECT_HANG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

		<span class="n">eop_desc</span> <span class="o">=</span> <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">next_to_watch</span><span class="p">;</span>

		<span class="cm">/* Detect a transmit hang in hardware, this serializes the</span>
<span class="cm">		 * check with the clearing of time_stamp and movement of i */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_TX_DETECT_HANG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eop_desc</span> <span class="o">&amp;&amp;</span>
		    <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">+</span>
			       <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_factor</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">rd32</span><span class="p">(</span><span class="n">E1000_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_TXOFF</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* detected Tx unit hang */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Detected Tx Unit Hang</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;  Tx Queue             &lt;%d&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;  TDH                  &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;  TDT                  &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;  next_to_use          &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;  next_to_clean        &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;buffer_info[next_to_clean]</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;  time_stamp           &lt;%lx&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;  next_to_watch        &lt;%p&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;  jiffies              &lt;%lx&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;  desc.status          &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">,</span>
				<span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TDH</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">reg_idx</span><span class="p">)),</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">),</span>
				<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">,</span>
				<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">,</span>
				<span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">,</span>
				<span class="n">eop_desc</span><span class="p">,</span>
				<span class="n">jiffies</span><span class="p">,</span>
				<span class="n">eop_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
			<span class="n">netif_stop_subqueue</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
					    <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>

			<span class="cm">/* we are about to reset, no point in enabling stuff */</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">total_packets</span> <span class="o">&amp;&amp;</span>
		     <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">igb_desc_unused</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">IGB_TX_QUEUE_WAKE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Make sure that anybody stopping the queue after this</span>
<span class="cm">		 * sees the new next_to_clean.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__netif_subqueue_stopped</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
					     <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">netif_wake_subqueue</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
					    <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>

			<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_syncp</span><span class="p">);</span>
			<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_stats</span><span class="p">.</span><span class="n">restart_queue</span><span class="o">++</span><span class="p">;</span>
			<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_syncp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">!!</span><span class="n">budget</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">igb_rx_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
				   <span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Ignore Checksum bit is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igb_test_staterr</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">,</span> <span class="n">E1000_RXD_STAT_IXSM</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Rx checksum disabled via ethtool */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* TCP/UDP checksum error bit is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igb_test_staterr</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">,</span>
			     <span class="n">E1000_RXDEXT_STATERR_TCPE</span> <span class="o">|</span>
			     <span class="n">E1000_RXDEXT_STATERR_IPE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * work around errata with sctp packets where the TCPE aka</span>
<span class="cm">		 * L4E bit is set incorrectly on 64 byte (60 byte w/o crc)</span>
<span class="cm">		 * packets, (aka let the stack check the crc32c)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">60</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		      <span class="n">test_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_RX_SCTP_CSUM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_syncp</span><span class="p">);</span>
			<span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_stats</span><span class="p">.</span><span class="n">csum_err</span><span class="o">++</span><span class="p">;</span>
			<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_syncp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* let the stack verify checksum errors */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* It must be a TCP or UDP packet with a valid checksum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igb_test_staterr</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">,</span> <span class="n">E1000_RXD_STAT_TCPCS</span> <span class="o">|</span>
				      <span class="n">E1000_RXD_STAT_UDPCS</span><span class="p">))</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cksum success: bits %08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">igb_rx_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
			       <span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXHASH</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">lower</span><span class="p">.</span><span class="n">hi_dword</span><span class="p">.</span><span class="n">rss</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IGB_PTP</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_rx_hwtstamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">,</span>
			    <span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">regval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igb_test_staterr</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">,</span> <span class="n">E1000_RXDADV_STAT_TSIP</span> <span class="o">|</span>
				       <span class="n">E1000_RXDADV_STAT_TS</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this bit is set, then the RX registers contain the time stamp. No</span>
<span class="cm">	 * other packet will be time stamped until we read these registers, so</span>
<span class="cm">	 * read the registers to make them available again. Because only one</span>
<span class="cm">	 * packet can be time stamped at a time, we know that the register</span>
<span class="cm">	 * values must belong to this one here and therefore we don&#39;t need to</span>
<span class="cm">	 * compare any of the additional attributes stored for it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If nothing went wrong, then it should have a shared tx_flags that we</span>
<span class="cm">	 * can turn into a skb_shared_hwtstamps.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igb_test_staterr</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">,</span> <span class="n">E1000_RXDADV_STAT_TSIP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">stamp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">regval</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">stamp</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
		<span class="n">regval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">stamp</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IGB_TS_HDR_LEN</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TSYNCRXCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_TSYNCRXCTL_VALID</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">regval</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RXSTMPL</span><span class="p">);</span>
		<span class="n">regval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RXSTMPH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">igb_systim_to_hwtstamp</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">skb_hwtstamps</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">regval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_rx_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
			<span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igb_test_staterr</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">,</span> <span class="n">E1000_RXD_STAT_VP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">vid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">igb_test_staterr</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">,</span> <span class="n">E1000_RXDEXT_STATERR_LB</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">test_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_RX_LB_VLAN_BSWAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">vid</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">vlan</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">vid</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">vlan</span><span class="p">);</span>

		<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">igb_get_hlen</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* HW will not DMA in data larger than the given buffer, even if it</span>
<span class="cm">	 * parses the (NFS, of course) header to be larger.  In that case, it</span>
<span class="cm">	 * fills the header buffer and spills the rest into the page.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">hlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">lower</span><span class="p">.</span><span class="n">lo_dword</span><span class="p">.</span><span class="n">hdr_info</span><span class="p">)</span> <span class="o">&amp;</span>
	           <span class="n">E1000_RXDADV_HDRBUFLEN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">E1000_RXDADV_HDRBUFLEN_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlen</span> <span class="o">&gt;</span> <span class="n">IGB_RX_HDR_LEN</span><span class="p">)</span>
		<span class="n">hlen</span> <span class="o">=</span> <span class="n">IGB_RX_HDR_LEN</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">igb_clean_rx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">current_node</span> <span class="o">=</span> <span class="n">numa_node_id</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cleaned_count</span> <span class="o">=</span> <span class="n">igb_desc_unused</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>

	<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">IGB_RX_DESC</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">igb_test_staterr</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">,</span> <span class="n">E1000_RXD_STAT_DD</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">igb_rx_buffer</span> <span class="o">*</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">next_rxd</span><span class="p">;</span>

		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">next_rxd</span> <span class="o">=</span> <span class="n">IGB_RX_DESC</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">next_rxd</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * This memory barrier is needed to keep us from reading</span>
<span class="cm">		 * any other fields out of the rx_desc until we know the</span>
<span class="cm">		 * RXD_STAT_DD bit is set</span>
<span class="cm">		 */</span>
		<span class="n">rmb</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">igb_get_hlen</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">));</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					 <span class="n">IGB_RX_HDR_LEN</span><span class="p">,</span>
					 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

			<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span>
						<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span>
						<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">,</span>
						<span class="n">length</span><span class="p">);</span>

			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">page_count</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">page_to_nid</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">current_node</span><span class="p">))</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">get_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span><span class="p">,</span>
				       <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igb_test_staterr</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">,</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">igb_rx_buffer</span> <span class="o">*</span><span class="n">next_buffer</span><span class="p">;</span>
			<span class="n">next_buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">next_buffer</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">next_buffer</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
			<span class="n">next_buffer</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="n">next_buffer</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">igb_test_staterr</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">,</span>
					       <span class="n">E1000_RXDEXT_ERR_FRAME_ERR_MASK</span><span class="p">))</span>
			     <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXALL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IGB_PTP</span>
		<span class="n">igb_rx_hwtstamp</span><span class="p">(</span><span class="n">q_vector</span><span class="p">,</span> <span class="n">rx_desc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">igb_rx_hash</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">rx_desc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">igb_rx_checksum</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">rx_desc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">igb_rx_vlan</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">rx_desc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">total_packets</span><span class="o">++</span><span class="p">;</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

		<span class="n">napi_gro_receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">budget</span><span class="o">--</span><span class="p">;</span>
<span class="nl">next_desc:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">budget</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">cleaned_count</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* return some buffers to hardware, one at a time is too slow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cleaned_count</span> <span class="o">&gt;=</span> <span class="n">IGB_RX_BUFFER_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">igb_alloc_rx_buffers</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">);</span>
			<span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* use prefetched values */</span>
		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">next_rxd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_syncp</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_stats</span><span class="p">.</span><span class="n">packets</span> <span class="o">+=</span> <span class="n">total_packets</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_stats</span><span class="p">.</span><span class="n">bytes</span> <span class="o">+=</span> <span class="n">total_bytes</span><span class="p">;</span>
	<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_syncp</span><span class="p">);</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">total_packets</span> <span class="o">+=</span> <span class="n">total_packets</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">total_bytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="p">)</span>
		<span class="n">igb_alloc_rx_buffers</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!!</span><span class="n">budget</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">igb_alloc_mapped_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">igb_rx_buffer</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
						<span class="n">IGB_RX_HDR_LEN</span><span class="p">);</span>
		<span class="n">bi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_stats</span><span class="p">.</span><span class="n">alloc_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* initialize skb for ring */</span>
		<span class="n">skb_record_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			     <span class="n">IGB_RX_HDR_LEN</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_stats</span><span class="p">.</span><span class="n">alloc_failed</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">igb_alloc_mapped_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">igb_rx_buffer</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">page_dma</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">page_dma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_offset</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">^</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_dma</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_COLD</span><span class="p">);</span>
		<span class="n">bi</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_stats</span><span class="p">.</span><span class="n">alloc_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">page_dma</span> <span class="o">=</span> <span class="n">dma_map_page</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
				<span class="n">page_offset</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
				<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">page_dma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_stats</span><span class="p">.</span><span class="n">alloc_failed</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">page_dma</span> <span class="o">=</span> <span class="n">page_dma</span><span class="p">;</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_alloc_rx_buffers - Replace used receive buffers; packet split</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">igb_alloc_rx_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">u16</span> <span class="n">cleaned_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_rx_buffer</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">IGB_RX_DESC</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">bi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">i</span> <span class="o">-=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igb_alloc_mapped_skb</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">bi</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Refresh the desc even if buffer_addrs didn&#39;t change</span>
<span class="cm">		 * because each write-back erases this info. */</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">hdr_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igb_alloc_mapped_page</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">bi</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">pkt_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">page_dma</span><span class="p">);</span>

		<span class="n">rx_desc</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bi</span><span class="o">++</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">IGB_RX_DESC</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bi</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_buffer_info</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">-=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* clear the hdr_addr for the next_to_use descriptor */</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">hdr_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">+=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* Force memory writes to complete before letting h/w</span>
<span class="cm">		 * know there are new descriptors to fetch.  (Only</span>
<span class="cm">		 * applicable for weak-ordered memory model archs,</span>
<span class="cm">		 * such as IA-64). */</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_mii_ioctl -</span>
<span class="cm"> * @netdev:</span>
<span class="cm"> * @ifreq:</span>
<span class="cm"> * @cmd:</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_mii_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mii_ioctl_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">ifr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">!=</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">igb_read_phy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">,</span>
		                     <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_hwtstamp_ioctl - control hardware time stamping</span>
<span class="cm"> * @netdev:</span>
<span class="cm"> * @ifreq:</span>
<span class="cm"> * @cmd:</span>
<span class="cm"> *</span>
<span class="cm"> * Outgoing time stamping can be enabled and disabled. Play nice and</span>
<span class="cm"> * disable it when requested, although it shouldn&#39;t case any overhead</span>
<span class="cm"> * when no packet needs it. At most one packet in the queue may be</span>
<span class="cm"> * marked for time stamping, otherwise it would be impossible to tell</span>
<span class="cm"> * for sure to which packet the hardware time stamp belongs.</span>
<span class="cm"> *</span>
<span class="cm"> * Incoming time stamping has to be configured via the hardware</span>
<span class="cm"> * filters. Not all combinations are supported, in particular event</span>
<span class="cm"> * type has to be specified. Matching the kind of event packet is</span>
<span class="cm"> * not supported, with the exception of &quot;all V2 events regardless of</span>
<span class="cm"> * level 2 or 4&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_hwtstamp_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hwtstamp_config</span> <span class="n">config</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tsync_tx_ctl</span> <span class="o">=</span> <span class="n">E1000_TSYNCTXCTL_ENABLED</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tsync_rx_ctl</span> <span class="o">=</span> <span class="n">E1000_TSYNCRXCTL_ENABLED</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tsync_rx_cfg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_l4</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_l2</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">regval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">config</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* reserved for future extensions */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">tx_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_TX_OFF</span>:
		<span class="n">tsync_tx_ctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_TX_ON</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">rx_filter</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_NONE</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V1_L4_EVENT</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L4_EVENT</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L2_EVENT</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_ALL</span>:
		<span class="cm">/*</span>
<span class="cm">		 * register TSYNCRXCFG must be set, therefore it is not</span>
<span class="cm">		 * possible to time stamp both Sync and Delay_Req messages</span>
<span class="cm">		 * =&gt; fall back to time stamping all packets</span>
<span class="cm">		 */</span>
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">E1000_TSYNCRXCTL_TYPE_ALL</span><span class="p">;</span>
		<span class="n">config</span><span class="p">.</span><span class="n">rx_filter</span> <span class="o">=</span> <span class="n">HWTSTAMP_FILTER_ALL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V1_L4_SYNC</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">E1000_TSYNCRXCTL_TYPE_L4_V1</span><span class="p">;</span>
		<span class="n">tsync_rx_cfg</span> <span class="o">=</span> <span class="n">E1000_TSYNCRXCFG_PTP_V1_SYNC_MESSAGE</span><span class="p">;</span>
		<span class="n">is_l4</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">E1000_TSYNCRXCTL_TYPE_L4_V1</span><span class="p">;</span>
		<span class="n">tsync_rx_cfg</span> <span class="o">=</span> <span class="n">E1000_TSYNCRXCFG_PTP_V1_DELAY_REQ_MESSAGE</span><span class="p">;</span>
		<span class="n">is_l4</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L2_SYNC</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L4_SYNC</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">E1000_TSYNCRXCTL_TYPE_L2_L4_V2</span><span class="p">;</span>
		<span class="n">tsync_rx_cfg</span> <span class="o">=</span> <span class="n">E1000_TSYNCRXCFG_PTP_V2_SYNC_MESSAGE</span><span class="p">;</span>
		<span class="n">is_l2</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">is_l4</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">config</span><span class="p">.</span><span class="n">rx_filter</span> <span class="o">=</span> <span class="n">HWTSTAMP_FILTER_SOME</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">E1000_TSYNCRXCTL_TYPE_L2_L4_V2</span><span class="p">;</span>
		<span class="n">tsync_rx_cfg</span> <span class="o">=</span> <span class="n">E1000_TSYNCRXCFG_PTP_V2_DELAY_REQ_MESSAGE</span><span class="p">;</span>
		<span class="n">is_l2</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">is_l4</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">config</span><span class="p">.</span><span class="n">rx_filter</span> <span class="o">=</span> <span class="n">HWTSTAMP_FILTER_SOME</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_EVENT</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_SYNC</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_DELAY_REQ</span>:
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">E1000_TSYNCRXCTL_TYPE_EVENT_V2</span><span class="p">;</span>
		<span class="n">config</span><span class="p">.</span><span class="n">rx_filter</span> <span class="o">=</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_EVENT</span><span class="p">;</span>
		<span class="n">is_l2</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">is_l4</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82575</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsync_rx_ctl</span> <span class="o">|</span> <span class="n">tsync_tx_ctl</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Per-packet timestamping only works if all packets are</span>
<span class="cm">	 * timestamped, so enable timestamping in all packets as</span>
<span class="cm">	 * long as one rx filter was configured.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_82580</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tsync_rx_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tsync_rx_ctl</span> <span class="o">=</span> <span class="n">E1000_TSYNCRXCTL_ENABLED</span><span class="p">;</span>
		<span class="n">tsync_rx_ctl</span> <span class="o">|=</span> <span class="n">E1000_TSYNCRXCTL_TYPE_ALL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* enable/disable TX */</span>
	<span class="n">regval</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TSYNCTXCTL</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_TSYNCTXCTL_ENABLED</span><span class="p">;</span>
	<span class="n">regval</span> <span class="o">|=</span> <span class="n">tsync_tx_ctl</span><span class="p">;</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TSYNCTXCTL</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>

	<span class="cm">/* enable/disable RX */</span>
	<span class="n">regval</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TSYNCRXCTL</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_TSYNCRXCTL_ENABLED</span> <span class="o">|</span> <span class="n">E1000_TSYNCRXCTL_TYPE_MASK</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">|=</span> <span class="n">tsync_rx_ctl</span><span class="p">;</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TSYNCRXCTL</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>

	<span class="cm">/* define which PTP packets are time stamped */</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_TSYNCRXCFG</span><span class="p">,</span> <span class="n">tsync_rx_cfg</span><span class="p">);</span>

	<span class="cm">/* define ethertype filter for timestamped packets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_l2</span><span class="p">)</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_ETQF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
		                <span class="p">(</span><span class="n">E1000_ETQF_FILTER_ENABLE</span> <span class="o">|</span> <span class="cm">/* enable filter */</span>
		                 <span class="n">E1000_ETQF_1588</span> <span class="o">|</span> <span class="cm">/* enable timestamping */</span>
		                 <span class="n">ETH_P_1588</span><span class="p">));</span>     <span class="cm">/* 1588 eth protocol type */</span>
	<span class="k">else</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_ETQF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#define PTP_PORT 319</span>
	<span class="cm">/* L4 Queue Filter[3]: filter by destination port and protocol */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_l4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ftqf</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPPROTO_UDP</span> <span class="cm">/* UDP */</span>
			<span class="o">|</span> <span class="n">E1000_FTQF_VF_BP</span> <span class="cm">/* VF not compared */</span>
			<span class="o">|</span> <span class="n">E1000_FTQF_1588_TIME_STAMP</span> <span class="cm">/* Enable Timestamping */</span>
			<span class="o">|</span> <span class="n">E1000_FTQF_MASK</span><span class="p">);</span> <span class="cm">/* mask all inputs */</span>
		<span class="n">ftqf</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_FTQF_MASK_PROTO_BP</span><span class="p">;</span> <span class="cm">/* enable protocol check */</span>

		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_IMIR</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">htons</span><span class="p">(</span><span class="n">PTP_PORT</span><span class="p">));</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_IMIREXT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
		     <span class="p">(</span><span class="n">E1000_IMIREXT_SIZE_BP</span> <span class="o">|</span> <span class="n">E1000_IMIREXT_CTRL_BP</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82576</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* enable source port check */</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_SPQF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">htons</span><span class="p">(</span><span class="n">PTP_PORT</span><span class="p">));</span>
			<span class="n">ftqf</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_FTQF_MASK_SOURCE_PORT_BP</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_FTQF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ftqf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_FTQF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">E1000_FTQF_MASK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">wrfl</span><span class="p">();</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hwtstamp_config</span> <span class="o">=</span> <span class="n">config</span><span class="p">;</span>

	<span class="cm">/* clear TX/RX time stamp registers, just to be sure */</span>
	<span class="n">regval</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TXSTMPH</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RXSTMPH</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">config</span><span class="p">))</span> <span class="o">?</span>
		<span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_ioctl -</span>
<span class="cm"> * @netdev:</span>
<span class="cm"> * @ifreq:</span>
<span class="cm"> * @cmd:</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:
	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:
	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:
		<span class="k">return</span> <span class="n">igb_mii_ioctl</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SIOCSHWTSTAMP</span>:
		<span class="k">return</span> <span class="n">igb_hwtstamp_ioctl</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">s32</span> <span class="nf">igb_read_pcie_cap_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cap_offset</span><span class="p">;</span>

	<span class="n">cap_offset</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">pcie_cap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cap_offset</span> <span class="o">+</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">s32</span> <span class="nf">igb_write_pcie_cap_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cap_offset</span><span class="p">;</span>

	<span class="n">cap_offset</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">pcie_cap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>

	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cap_offset</span> <span class="o">+</span> <span class="n">reg</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_vlan_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">rctl</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">enable</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enable VLAN tag insert/strip */</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CTRL</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_VME</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

		<span class="cm">/* Disable CFI check */</span>
		<span class="n">rctl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RCTL</span><span class="p">);</span>
		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_CFIEN</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* disable VLAN tag insert/strip */</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CTRL</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_VME</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">igb_rlpml_set</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_vlan_rx_add_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pf_id</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span>

	<span class="cm">/* attempt to add filter to vlvf array */</span>
	<span class="n">igb_vlvf_set</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">pf_id</span><span class="p">);</span>

	<span class="cm">/* add the filter since PF can receive vlans w/o entry in vlvf */</span>
	<span class="n">igb_vfta_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_vlan_rx_kill_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pf_id</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* remove vlan from VLVF table array */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">igb_vlvf_set</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">pf_id</span><span class="p">);</span>

	<span class="cm">/* if vid was not present in VLVF just remove it from table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">igb_vfta_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_restore_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">vid</span><span class="p">;</span>

	<span class="n">igb_vlan_mode</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">);</span>

	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">,</span> <span class="n">VLAN_N_VID</span><span class="p">)</span>
		<span class="n">igb_vlan_rx_add_vid</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">igb_set_spd_dplx</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">spd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dplx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">;</span>

	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Make sure dplx is at most 1 bit and lsb of speed is not set</span>
<span class="cm">	 * for the switch() below to work */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">spd</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dplx</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_inval</span><span class="p">;</span>

	<span class="cm">/* Fiber NIC&#39;s only allow 1000 Gbps Full duplex */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_internal_serdes</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">spd</span> <span class="o">!=</span> <span class="n">SPEED_1000</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dplx</span> <span class="o">!=</span> <span class="n">DUPLEX_FULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_inval</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">spd</span> <span class="o">+</span> <span class="n">dplx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SPEED_10</span> <span class="o">+</span> <span class="n">DUPLEX_HALF</span>:
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">=</span> <span class="n">ADVERTISE_10_HALF</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPEED_10</span> <span class="o">+</span> <span class="n">DUPLEX_FULL</span>:
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">=</span> <span class="n">ADVERTISE_10_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPEED_100</span> <span class="o">+</span> <span class="n">DUPLEX_HALF</span>:
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">=</span> <span class="n">ADVERTISE_100_HALF</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPEED_100</span> <span class="o">+</span> <span class="n">DUPLEX_FULL</span>:
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">=</span> <span class="n">ADVERTISE_100_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPEED_1000</span> <span class="o">+</span> <span class="n">DUPLEX_FULL</span>:
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="n">ADVERTISE_1000_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPEED_1000</span> <span class="o">+</span> <span class="n">DUPLEX_HALF</span>: <span class="cm">/* not supported */</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">err_inval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_inval:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unsupported Speed/Duplex configuration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__igb_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">enable_wake</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">runtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">rctl</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wufc</span> <span class="o">=</span> <span class="n">runtime</span> <span class="o">?</span> <span class="n">E1000_WUFC_LNKC</span> <span class="o">:</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">__igb_close</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">igb_clear_interrupt_scheme</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">)</span>
		<span class="n">wufc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_WUFC_LNKC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wufc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">igb_setup_rctl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">igb_set_rx_mode</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

		<span class="cm">/* turn on all-multi mode if wake on multicast is enabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wufc</span> <span class="o">&amp;</span> <span class="n">E1000_WUFC_MC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rctl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RCTL</span><span class="p">);</span>
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_MPE</span><span class="p">;</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_CTRL</span><span class="p">);</span>
		<span class="cm">/* advertise wake from D3Cold */</span>
		<span class="cp">#define E1000_CTRL_ADVD3WUC 0x00100000</span>
		<span class="cm">/* phy power management enable */</span>
		<span class="cp">#define E1000_CTRL_EN_PHY_PWR_MGMT 0x00200000</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_ADVD3WUC</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

		<span class="cm">/* Allow time for pending master requests to run */</span>
		<span class="n">igb_disable_pcie_master</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_WUC</span><span class="p">,</span> <span class="n">E1000_WUC_PME_EN</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_WUFC</span><span class="p">,</span> <span class="n">wufc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_WUC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_WUFC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">enable_wake</span> <span class="o">=</span> <span class="n">wufc</span> <span class="o">||</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">en_mng_pt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">enable_wake</span><span class="p">)</span>
		<span class="n">igb_power_down_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">igb_power_up_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Release control of h/w to f/w.  If f/w is AMT enabled, this</span>
<span class="cm">	 * would have already happened in close and is redundant. */</span>
	<span class="n">igb_release_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wake</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">__igb_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wake</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_prepare_to_sleep</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;igb: Cannot enable PCI device from suspend</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3cold</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">igb_init_interrupt_scheme</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">igb_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* let the f/w know that the h/w is now under the control of the</span>
<span class="cm">	 * driver. */</span>
	<span class="n">igb_get_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_WUS</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__igb_open</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM_RUNTIME</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_runtime_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igb_has_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="n">pm_schedule_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MSEC_PER_SEC</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_runtime_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wake</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">__igb_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wake</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_prepare_to_sleep</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_runtime_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">igb_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_RUNTIME */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">wake</span><span class="p">;</span>

	<span class="n">__igb_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wake</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_POWER_OFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">wake</span><span class="p">);</span>
		<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="cm">/*</span>
<span class="cm"> * Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<span class="cm"> * without having to re-enable interrupts. It&#39;s not called while</span>
<span class="cm"> * the interrupt routine is executing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_q_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q_vector</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_EIMC</span><span class="p">,</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">eims_value</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">igb_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NET_POLL_CONTROLLER */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * igb_io_error_detected - called when PCI error is detected</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> * @state: The current pci connection state</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called after a PCI bus error affecting</span>
<span class="cm"> * this device has been detected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="nf">igb_io_error_detected</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
					      <span class="n">pci_channel_state_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">pci_channel_io_perm_failure</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">igb_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Request a slot slot reset. */</span>
	<span class="k">return</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_io_slot_reset - called after the pci bus has been reset.</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Restart the card from scratch, as if from a cold-boot. Implementation</span>
<span class="cm"> * resembles the first-half of the igb_resume routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="nf">igb_io_slot_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">pci_ers_result_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Cannot re-enable PCI device after reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

		<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3cold</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">igb_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_WUS</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_RECOVERED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_cleanup_aer_uncorrect_error_status</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci_cleanup_aer_uncorrect_error_status &quot;</span>
		        <span class="s">&quot;failed 0x%0x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="cm">/* non-fatal, continue */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igb_io_resume - called when traffic can start flowing again.</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is called when the error recovery driver tells us that</span>
<span class="cm"> * its OK to resume normal operation. Implementation resembles the</span>
<span class="cm"> * second-half of the igb_resume routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_io_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">igb_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;igb_up failed after reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* let the f/w know that the h/w is now under the control of the</span>
<span class="cm">	 * driver. */</span>
	<span class="n">igb_get_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_rar_set_qsel</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
                             <span class="n">u8</span> <span class="n">qsel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rar_low</span><span class="p">,</span> <span class="n">rar_high</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* HW expects these in little endian so we reverse the byte order</span>
<span class="cm">	 * from network order (big endian) to little endian</span>
<span class="cm">	 */</span>
	<span class="n">rar_low</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
	          <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">));</span>
	<span class="n">rar_high</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>

	<span class="cm">/* Indicate to hardware the Address is Valid. */</span>
	<span class="n">rar_high</span> <span class="o">|=</span> <span class="n">E1000_RAH_AV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82575</span><span class="p">)</span>
		<span class="n">rar_high</span> <span class="o">|=</span> <span class="n">E1000_RAH_POOL_1</span> <span class="o">*</span> <span class="n">qsel</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rar_high</span> <span class="o">|=</span> <span class="n">E1000_RAH_POOL_1</span> <span class="o">&lt;&lt;</span> <span class="n">qsel</span><span class="p">;</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RAL</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">rar_low</span><span class="p">);</span>
	<span class="n">wrfl</span><span class="p">();</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RAH</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">rar_high</span><span class="p">);</span>
	<span class="n">wrfl</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_set_vf_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="cm">/* VF MAC addresses start at end of receive addresses and moves</span>
<span class="cm">	 * torwards the first, as a result a collision should not be possible */</span>
	<span class="kt">int</span> <span class="n">rar_entry</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">rar_entry_count</span> <span class="o">-</span> <span class="p">(</span><span class="n">vf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">vf_mac_addresses</span><span class="p">,</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">igb_rar_set_qsel</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="n">rar_entry</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_ndo_set_vf_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">mac</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">vf</span> <span class="o">&gt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IGB_VF_FLAG_PF_SET_MAC</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;setting MAC %pM on VF %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mac</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Reload the VF driver to make this&quot;</span>
				      <span class="s">&quot; change effective.&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;The VF MAC address has been set,&quot;</span>
			 <span class="s">&quot; but the PF device is not up.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Bring the PF device up before&quot;</span>
			 <span class="s">&quot; attempting to use the VF device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">igb_set_vf_mac</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">mac</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_link_mbps</span><span class="p">(</span><span class="kt">int</span> <span class="n">internal_link_speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">internal_link_speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SPEED_100</span>:
		<span class="k">return</span> <span class="mi">100</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPEED_1000</span>:
		<span class="k">return</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_set_vf_rate_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_rate</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">link_speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rf_dec</span><span class="p">,</span> <span class="n">rf_int</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bcnrc_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_rate</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Calculate the rate factor values to set */</span>
		<span class="n">rf_int</span> <span class="o">=</span> <span class="n">link_speed</span> <span class="o">/</span> <span class="n">tx_rate</span><span class="p">;</span>
		<span class="n">rf_dec</span> <span class="o">=</span> <span class="p">(</span><span class="n">link_speed</span> <span class="o">-</span> <span class="p">(</span><span class="n">rf_int</span> <span class="o">*</span> <span class="n">tx_rate</span><span class="p">));</span>
		<span class="n">rf_dec</span> <span class="o">=</span> <span class="p">(</span><span class="n">rf_dec</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">E1000_RTTBCNRC_RF_INT_SHIFT</span><span class="p">))</span> <span class="o">/</span> <span class="n">tx_rate</span><span class="p">;</span>

		<span class="n">bcnrc_val</span> <span class="o">=</span> <span class="n">E1000_RTTBCNRC_RS_ENA</span><span class="p">;</span>
		<span class="n">bcnrc_val</span> <span class="o">|=</span> <span class="p">((</span><span class="n">rf_int</span><span class="o">&lt;&lt;</span><span class="n">E1000_RTTBCNRC_RF_INT_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		               <span class="n">E1000_RTTBCNRC_RF_INT_MASK</span><span class="p">);</span>
		<span class="n">bcnrc_val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">rf_dec</span> <span class="o">&amp;</span> <span class="n">E1000_RTTBCNRC_RF_DEC_MASK</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bcnrc_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RTTDQSEL</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span> <span class="cm">/* vf X uses queue X */</span>
	<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RTTBCNRC</span><span class="p">,</span> <span class="n">bcnrc_val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_check_vf_rate_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">actual_link_speed</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">reset_rate</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* VF TX rate limit was not set or not supported */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_rate_link_speed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_82576</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">actual_link_speed</span> <span class="o">=</span> <span class="n">igb_link_mbps</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">actual_link_speed</span> <span class="o">!=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_rate_link_speed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reset_rate</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_rate_link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		         <span class="s">&quot;Link speed has been changed. VF Transmit &quot;</span>
		         <span class="s">&quot;rate is disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reset_rate</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">igb_set_vf_rate_limit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
		                      <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_rate</span><span class="p">,</span>
		                      <span class="n">actual_link_speed</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_ndo_set_vf_bw</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">actual_link_speed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_82576</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">actual_link_speed</span> <span class="o">=</span> <span class="n">igb_link_mbps</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vf</span> <span class="o">&gt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rd32</span><span class="p">(</span><span class="n">E1000_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">tx_rate</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tx_rate</span> <span class="o">&gt;</span> <span class="n">actual_link_speed</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_rate_link_speed</span> <span class="o">=</span> <span class="n">actual_link_speed</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">tx_rate</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">tx_rate</span><span class="p">;</span>
	<span class="n">igb_set_vf_rate_limit</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">tx_rate</span><span class="p">,</span> <span class="n">actual_link_speed</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_ndo_get_vf_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifla_vf_info</span> <span class="o">*</span><span class="n">ivi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vf</span> <span class="o">&gt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ivi</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">=</span> <span class="n">vf</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ivi</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">vf_mac_addresses</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">ivi</span><span class="o">-&gt;</span><span class="n">tx_rate</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">tx_rate</span><span class="p">;</span>
	<span class="n">ivi</span><span class="o">-&gt;</span><span class="n">vlan</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">pf_vlan</span><span class="p">;</span>
	<span class="n">ivi</span><span class="o">-&gt;</span><span class="n">qos</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vf_data</span><span class="p">[</span><span class="n">vf</span><span class="p">].</span><span class="n">pf_qos</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_vmm_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82575</span>:
	<span class="k">case</span> <span class="n">e1000_i210</span>:
	<span class="k">case</span> <span class="n">e1000_i211</span>:
	<span class="nl">default:</span>
		<span class="cm">/* replication is not supported for 82575 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82576</span>:
		<span class="cm">/* notify HW that the MAC is adding vlan tags */</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_DTXCTL</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">E1000_DTXCTL_VLAN_ADDED</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DTXCTL</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">e1000_82580</span>:
		<span class="cm">/* enable replication vlan tag stripping */</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_RPLOLR</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">E1000_RPLOLR_STRVLAN</span><span class="p">;</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_RPLOLR</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">e1000_i350</span>:
		<span class="cm">/* none of the above registers are supported by i350 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">igb_vmdq_set_loopback_pf</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">igb_vmdq_set_replication_pf</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">igb_vmdq_set_anti_spoofing_pf</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
						<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">vfs_allocated_count</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">igb_vmdq_set_loopback_pf</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">igb_vmdq_set_replication_pf</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_init_dmac</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dmac_thr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hwm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">e1000_82580</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_FLAG_DMAC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

			<span class="cm">/* force threshold to 0. */</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DMCTXTH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * DMA Coalescing high water mark needs to be greater</span>
<span class="cm">			 * than the Rx threshold. Set hwm to PBA - max frame</span>
<span class="cm">			 * size in 16B units, capping it at PBA - 6KB.</span>
<span class="cm">			 */</span>
			<span class="n">hwm</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">pba</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hwm</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">*</span> <span class="p">(</span><span class="n">pba</span> <span class="o">-</span> <span class="mi">6</span><span class="p">))</span>
				<span class="n">hwm</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="p">(</span><span class="n">pba</span> <span class="o">-</span> <span class="mi">6</span><span class="p">);</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_FCRTC</span><span class="p">);</span>
			<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_FCRTC_RTH_COAL_MASK</span><span class="p">;</span>
			<span class="n">reg</span> <span class="o">|=</span> <span class="p">((</span><span class="n">hwm</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_FCRTC_RTH_COAL_SHIFT</span><span class="p">)</span>
				<span class="o">&amp;</span> <span class="n">E1000_FCRTC_RTH_COAL_MASK</span><span class="p">);</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_FCRTC</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Set the DMA Coalescing Rx threshold to PBA - 2 * max</span>
<span class="cm">			 * frame size, capping it at PBA - 10KB.</span>
<span class="cm">			 */</span>
			<span class="n">dmac_thr</span> <span class="o">=</span> <span class="n">pba</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">/</span> <span class="mi">512</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dmac_thr</span> <span class="o">&lt;</span> <span class="n">pba</span> <span class="o">-</span> <span class="mi">10</span><span class="p">)</span>
				<span class="n">dmac_thr</span> <span class="o">=</span> <span class="n">pba</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_DMACR</span><span class="p">);</span>
			<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_DMACR_DMACTHR_MASK</span><span class="p">;</span>
			<span class="n">reg</span> <span class="o">|=</span> <span class="p">((</span><span class="n">dmac_thr</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_DMACR_DMACTHR_SHIFT</span><span class="p">)</span>
				<span class="o">&amp;</span> <span class="n">E1000_DMACR_DMACTHR_MASK</span><span class="p">);</span>

			<span class="cm">/* transition to L0x or L1 if available..*/</span>
			<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_DMACR_DMAC_EN</span> <span class="o">|</span> <span class="n">E1000_DMACR_DMAC_LX_MASK</span><span class="p">);</span>

			<span class="cm">/* watchdog timer= +-1000 usec in 32usec intervals */</span>
			<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>

			<span class="cm">/* Disable BMC-to-OS Watchdog Enable */</span>
			<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_DMACR_DC_BMC2OSW_EN</span><span class="p">;</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DMACR</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * no lower threshold to disable</span>
<span class="cm">			 * coalescing(smart fifb)-UTRESH=0</span>
<span class="cm">			 */</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DMCRTRH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">IGB_DMCTLX_DCFLUSH_DIS</span> <span class="o">|</span> <span class="mh">0x4</span><span class="p">);</span>

			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DMCTLX</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * free space in tx packet buffer to wake from</span>
<span class="cm">			 * DMA coal</span>
<span class="cm">			 */</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DMCTXTH</span><span class="p">,</span> <span class="p">(</span><span class="n">IGB_MIN_TXPBSIZE</span> <span class="o">-</span>
			     <span class="p">(</span><span class="n">IGB_TX_BUF_4096</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * make low power state decision controlled</span>
<span class="cm">			 * by DMA coal</span>
<span class="cm">			 */</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PCIEMISC</span><span class="p">);</span>
			<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_PCIEMISC_LX_DECISION</span><span class="p">;</span>
			<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_PCIEMISC</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="p">}</span> <span class="cm">/* endif adapter-&gt;dmac is not disabled */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82580</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_PCIEMISC</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_PCIEMISC</span><span class="p">,</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_PCIEMISC_LX_DECISION</span><span class="p">);</span>
		<span class="n">wr32</span><span class="p">(</span><span class="n">E1000_DMACR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* igb_main.c */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
