<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › igb › igb.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>igb.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel(R) Gigabit Ethernet Linux driver</span>
<span class="cm">  Copyright(c) 2007-2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>


<span class="cm">/* Linux PRO/1000 Ethernet Driver main header file */</span>

<span class="cp">#ifndef _IGB_H_</span>
<span class="cp">#define _IGB_H_</span>

<span class="cp">#include &quot;e1000_mac.h&quot;</span>
<span class="cp">#include &quot;e1000_82575.h&quot;</span>

<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/net_tstamp.h&gt;</span>
<span class="cp">#include &lt;linux/ptp_clock_kernel.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>

<span class="k">struct</span> <span class="n">igb_adapter</span><span class="p">;</span>

<span class="cm">/* Interrupt defines */</span>
<span class="cp">#define IGB_START_ITR                    648 </span><span class="cm">/* ~6000 ints/sec */</span><span class="cp"></span>
<span class="cp">#define IGB_4K_ITR                       980</span>
<span class="cp">#define IGB_20K_ITR                      196</span>
<span class="cp">#define IGB_70K_ITR                       56</span>

<span class="cm">/* TX/RX descriptor defines */</span>
<span class="cp">#define IGB_DEFAULT_TXD                  256</span>
<span class="cp">#define IGB_DEFAULT_TX_WORK		 128</span>
<span class="cp">#define IGB_MIN_TXD                       80</span>
<span class="cp">#define IGB_MAX_TXD                     4096</span>

<span class="cp">#define IGB_DEFAULT_RXD                  256</span>
<span class="cp">#define IGB_MIN_RXD                       80</span>
<span class="cp">#define IGB_MAX_RXD                     4096</span>

<span class="cp">#define IGB_DEFAULT_ITR                    3 </span><span class="cm">/* dynamic */</span><span class="cp"></span>
<span class="cp">#define IGB_MAX_ITR_USECS              10000</span>
<span class="cp">#define IGB_MIN_ITR_USECS                 10</span>
<span class="cp">#define NON_Q_VECTORS                      1</span>
<span class="cp">#define MAX_Q_VECTORS                      8</span>

<span class="cm">/* Transmit and receive queues */</span>
<span class="cp">#define IGB_MAX_RX_QUEUES		((adapter-&gt;vfs_allocated_count ? 2 : \</span>
<span class="cp">					(hw-&gt;mac.type &gt; e1000_82575 ? 8 : 4)))</span>
<span class="cp">#define IGB_MAX_RX_QUEUES_I210             4</span>
<span class="cp">#define IGB_MAX_RX_QUEUES_I211             2</span>
<span class="cp">#define IGB_MAX_TX_QUEUES                  16</span>
<span class="cp">#define IGB_MAX_TX_QUEUES_I210             4</span>
<span class="cp">#define IGB_MAX_TX_QUEUES_I211             2</span>
<span class="cp">#define IGB_MAX_VF_MC_ENTRIES              30</span>
<span class="cp">#define IGB_MAX_VF_FUNCTIONS               8</span>
<span class="cp">#define IGB_MAX_VFTA_ENTRIES               128</span>
<span class="cp">#define IGB_82576_VF_DEV_ID                0x10CA</span>
<span class="cp">#define IGB_I350_VF_DEV_ID                 0x1520</span>

<span class="k">struct</span> <span class="n">vf_data_storage</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">vf_mac_addresses</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">vf_mc_hashes</span><span class="p">[</span><span class="n">IGB_MAX_VF_MC_ENTRIES</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">num_vf_mc_hashes</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vlans_enabled</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_nack</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pf_vlan</span><span class="p">;</span> <span class="cm">/* When set, guest VLAN config not allowed. */</span>
	<span class="n">u16</span> <span class="n">pf_qos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tx_rate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">vfdev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IGB_VF_FLAG_CTS            0x00000001 </span><span class="cm">/* VF is clear to send data */</span><span class="cp"></span>
<span class="cp">#define IGB_VF_FLAG_UNI_PROMISC    0x00000002 </span><span class="cm">/* VF has unicast promisc */</span><span class="cp"></span>
<span class="cp">#define IGB_VF_FLAG_MULTI_PROMISC  0x00000004 </span><span class="cm">/* VF has multicast promisc */</span><span class="cp"></span>
<span class="cp">#define IGB_VF_FLAG_PF_SET_MAC     0x00000008 </span><span class="cm">/* PF has set MAC address */</span><span class="cp"></span>

<span class="cm">/* RX descriptor control thresholds.</span>
<span class="cm"> * PTHRESH - MAC will consider prefetch if it has fewer than this number of</span>
<span class="cm"> *           descriptors available in its onboard memory.</span>
<span class="cm"> *           Setting this to 0 disables RX descriptor prefetch.</span>
<span class="cm"> * HTHRESH - MAC will only prefetch if there are at least this many descriptors</span>
<span class="cm"> *           available in host memory.</span>
<span class="cm"> *           If PTHRESH is 0, this should also be 0.</span>
<span class="cm"> * WTHRESH - RX descriptor writeback threshold - MAC will delay writing back</span>
<span class="cm"> *           descriptors until either it has this many to write back, or the</span>
<span class="cm"> *           ITR timer expires.</span>
<span class="cm"> */</span>
<span class="cp">#define IGB_RX_PTHRESH                     8</span>
<span class="cp">#define IGB_RX_HTHRESH                     8</span>
<span class="cp">#define IGB_TX_PTHRESH                     8</span>
<span class="cp">#define IGB_TX_HTHRESH                     1</span>
<span class="cp">#define IGB_RX_WTHRESH                     ((hw-&gt;mac.type == e1000_82576 &amp;&amp; \</span>
<span class="cp">					     adapter-&gt;msix_entries) ? 1 : 4)</span>
<span class="cp">#define IGB_TX_WTHRESH                     ((hw-&gt;mac.type == e1000_82576 &amp;&amp; \</span>
<span class="cp">					     adapter-&gt;msix_entries) ? 1 : 16)</span>

<span class="cm">/* this is the size past which hardware will drop packets when setting LPE=0 */</span>
<span class="cp">#define MAXIMUM_ETHERNET_VLAN_SIZE 1522</span>

<span class="cm">/* Supported Rx Buffer Sizes */</span>
<span class="cp">#define IGB_RXBUFFER_512   512</span>
<span class="cp">#define IGB_RXBUFFER_16384 16384</span>
<span class="cp">#define IGB_RX_HDR_LEN     IGB_RXBUFFER_512</span>

<span class="cm">/* How many Tx Descriptors do we need to call netif_wake_queue ? */</span>
<span class="cp">#define IGB_TX_QUEUE_WAKE	16</span>
<span class="cm">/* How many Rx Buffers do we bundle into one write to the hardware ? */</span>
<span class="cp">#define IGB_RX_BUFFER_WRITE	16	</span><span class="cm">/* Must be power of 2 */</span><span class="cp"></span>

<span class="cp">#define AUTO_ALL_MODES            0</span>
<span class="cp">#define IGB_EEPROM_APME         0x0400</span>

<span class="cp">#ifndef IGB_MASTER_SLAVE</span>
<span class="cm">/* Switch to override PHY master/slave setting */</span>
<span class="cp">#define IGB_MASTER_SLAVE	e1000_ms_hw_default</span>
<span class="cp">#endif</span>

<span class="cp">#define IGB_MNG_VLAN_NONE -1</span>

<span class="cp">#define IGB_TX_FLAGS_CSUM		0x00000001</span>
<span class="cp">#define IGB_TX_FLAGS_VLAN		0x00000002</span>
<span class="cp">#define IGB_TX_FLAGS_TSO		0x00000004</span>
<span class="cp">#define IGB_TX_FLAGS_IPV4		0x00000008</span>
<span class="cp">#define IGB_TX_FLAGS_TSTAMP		0x00000010</span>
<span class="cp">#define IGB_TX_FLAGS_VLAN_MASK		0xffff0000</span>
<span class="cp">#define IGB_TX_FLAGS_VLAN_SHIFT	16</span>

<span class="cm">/* wrapper around a pointer to a socket buffer,</span>
<span class="cm"> * so a DMA handle can be stored along with the buffer */</span>
<span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">e1000_adv_tx_desc</span> <span class="o">*</span><span class="n">next_to_watch</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_stamp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytecount</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">gso_segs</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">igb_rx_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">page_dma</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page_offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">igb_tx_queue_stats</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">packets</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">restart_queue</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">restart_queue2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">igb_rx_queue_stats</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">packets</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">drops</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">csum_err</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alloc_failed</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">igb_ring_container</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>		<span class="cm">/* pointer to linked list of rings */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_bytes</span><span class="p">;</span>	<span class="cm">/* total bytes processed this int */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_packets</span><span class="p">;</span>	<span class="cm">/* total packets processed this int */</span>
	<span class="n">u16</span> <span class="n">work_limit</span><span class="p">;</span>			<span class="cm">/* total work allowed per interrupt */</span>
	<span class="n">u8</span> <span class="n">count</span><span class="p">;</span>			<span class="cm">/* total number of rings in vector */</span>
	<span class="n">u8</span> <span class="n">itr</span><span class="p">;</span>				<span class="cm">/* current ITR setting for ring */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>	<span class="cm">/* backlink */</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>			<span class="cm">/* CPU for DCA */</span>
	<span class="n">u32</span> <span class="n">eims_value</span><span class="p">;</span>			<span class="cm">/* EIMS mask value */</span>

	<span class="k">struct</span> <span class="n">igb_ring_container</span> <span class="n">rx</span><span class="p">,</span> <span class="n">tx</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numa_node</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">itr_val</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">set_itr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">itr_register</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span> <span class="o">+</span> <span class="mi">9</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">igb_ring</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">;</span>	<span class="cm">/* backlink to q_vector */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>	<span class="cm">/* back pointer to net_device */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* device pointer for dma mapping */</span>
	<span class="k">union</span> <span class="p">{</span>				<span class="cm">/* array of buffer info structs */</span>
		<span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">tx_buffer_info</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">igb_rx_buffer</span> <span class="o">*</span><span class="n">rx_buffer_info</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>			<span class="cm">/* descriptor ring memory */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* ring specific flags */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>		<span class="cm">/* pointer to ring tail register */</span>

	<span class="n">u16</span> <span class="n">count</span><span class="p">;</span>			<span class="cm">/* number of desc. in the ring */</span>
	<span class="n">u8</span> <span class="n">queue_index</span><span class="p">;</span>			<span class="cm">/* logical index of the ring*/</span>
	<span class="n">u8</span> <span class="n">reg_idx</span><span class="p">;</span>			<span class="cm">/* physical index of the ring */</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>			<span class="cm">/* length of desc. ring in bytes */</span>

	<span class="cm">/* everything past this point are written often */</span>
	<span class="n">u16</span> <span class="n">next_to_clean</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">next_to_use</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/* TX */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">igb_tx_queue_stats</span> <span class="n">tx_stats</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">u64_stats_sync</span> <span class="n">tx_syncp</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">u64_stats_sync</span> <span class="n">tx_syncp2</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="cm">/* RX */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">igb_rx_queue_stats</span> <span class="n">rx_stats</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">u64_stats_sync</span> <span class="n">rx_syncp</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="p">};</span>
	<span class="cm">/* Items past this point are only used during ring alloc / free */</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>                <span class="cm">/* phys address of the ring */</span>
	<span class="kt">int</span> <span class="n">numa_node</span><span class="p">;</span>                  <span class="cm">/* node to alloc ring memory on */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">e1000_ring_flags_t</span> <span class="p">{</span>
	<span class="n">IGB_RING_FLAG_RX_SCTP_CSUM</span><span class="p">,</span>
	<span class="n">IGB_RING_FLAG_RX_LB_VLAN_BSWAP</span><span class="p">,</span>
	<span class="n">IGB_RING_FLAG_TX_CTX_IDX</span><span class="p">,</span>
	<span class="n">IGB_RING_FLAG_TX_DETECT_HANG</span>
<span class="p">};</span>

<span class="cp">#define IGB_TXD_DCMD (E1000_ADVTXD_DCMD_EOP | E1000_ADVTXD_DCMD_RS)</span>

<span class="cp">#define IGB_RX_DESC(R, i)	    \</span>
<span class="cp">	(&amp;(((union e1000_adv_rx_desc *)((R)-&gt;desc))[i]))</span>
<span class="cp">#define IGB_TX_DESC(R, i)	    \</span>
<span class="cp">	(&amp;(((union e1000_adv_tx_desc *)((R)-&gt;desc))[i]))</span>
<span class="cp">#define IGB_TX_CTXTDESC(R, i)	    \</span>
<span class="cp">	(&amp;(((struct e1000_adv_tx_context_desc *)((R)-&gt;desc))[i]))</span>

<span class="cm">/* igb_test_staterr - tests bits within Rx descriptor status and error fields */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__le32</span> <span class="nf">igb_test_staterr</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">u32</span> <span class="n">stat_err_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">stat_err_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* igb_desc_unused - calculate if we have unused descriptors */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">igb_desc_unused</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">&gt;</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">-</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">-</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* board specific private data structure */</span>
<span class="k">struct</span> <span class="n">igb_adapter</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active_vlans</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">VLAN_N_VID</span><span class="p">)];</span>

	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_q_vectors</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="o">*</span><span class="n">msix_entries</span><span class="p">;</span>

	<span class="cm">/* Interrupt Throttle Rate */</span>
	<span class="n">u32</span> <span class="n">rx_itr_setting</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_itr_setting</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tx_itr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rx_itr</span><span class="p">;</span>

	<span class="cm">/* TX */</span>
	<span class="n">u16</span> <span class="n">tx_work_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_timeout_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_tx_queues</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="cm">/* RX */</span>
	<span class="kt">int</span> <span class="n">num_rx_queues</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="n">u32</span> <span class="n">max_frame_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">min_frame_size</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">watchdog_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">phy_info_timer</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">mng_vlan_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bd_number</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wol</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">en_mng_pt</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">link_speed</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">link_duplex</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reset_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">watchdog_task</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fc_autoneg</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">tx_timeout_factor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">blink_timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">led_status</span><span class="p">;</span>

	<span class="cm">/* OS defined structs */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hwtstamp_config</span> <span class="n">hwtstamp_config</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">stats64_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="n">stats64</span><span class="p">;</span>

	<span class="cm">/* structs defined in e1000_hw.h */</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw_stats</span> <span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="n">phy_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_phy_stats</span> <span class="n">phy_stats</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">test_icr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_ring</span> <span class="n">test_tx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igb_ring</span> <span class="n">test_rx_ring</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">msg_enable</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">[</span><span class="n">MAX_Q_VECTORS</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">eims_enable_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eims_other</span><span class="p">;</span>

	<span class="cm">/* to not mess up cache alignment, always add to the bottom */</span>
	<span class="n">u32</span> <span class="n">eeprom_wol</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">tx_ring_count</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rx_ring_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vfs_allocated_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vf_data_storage</span> <span class="o">*</span><span class="n">vf_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vf_rate_link_speed</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rss_queues</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wvbr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">shadow_vfta</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ptp_clock</span> <span class="o">*</span><span class="n">ptp_clock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptp_clock_info</span> <span class="n">caps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">overflow_work</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">tmreg_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cyclecounter</span> <span class="n">cc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timecounter</span> <span class="n">tc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IGB_FLAG_HAS_MSI           (1 &lt;&lt; 0)</span>
<span class="cp">#define IGB_FLAG_DCA_ENABLED       (1 &lt;&lt; 1)</span>
<span class="cp">#define IGB_FLAG_QUAD_PORT_A       (1 &lt;&lt; 2)</span>
<span class="cp">#define IGB_FLAG_QUEUE_PAIRS       (1 &lt;&lt; 3)</span>
<span class="cp">#define IGB_FLAG_DMAC              (1 &lt;&lt; 4)</span>

<span class="cm">/* DMA Coalescing defines */</span>
<span class="cp">#define IGB_MIN_TXPBSIZE           20408</span>
<span class="cp">#define IGB_TX_BUF_4096            4096</span>
<span class="cp">#define IGB_DMCTLX_DCFLUSH_DIS     0x80000000  </span><span class="cm">/* Disable DMA Coal Flush */</span><span class="cp"></span>

<span class="cp">#define IGB_82576_TSYNC_SHIFT 19</span>
<span class="cp">#define IGB_TS_HDR_LEN        16</span>
<span class="k">enum</span> <span class="n">e1000_state_t</span> <span class="p">{</span>
	<span class="n">__IGB_TESTING</span><span class="p">,</span>
	<span class="n">__IGB_RESETTING</span><span class="p">,</span>
	<span class="n">__IGB_DOWN</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">igb_boards</span> <span class="p">{</span>
	<span class="n">board_82575</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">char</span> <span class="n">igb_driver_name</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">igb_driver_version</span><span class="p">[];</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">igb_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_reinit_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">igb_set_spd_dplx</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">igb_setup_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">igb_setup_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_free_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_free_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_configure_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_configure_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_setup_tctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_setup_rctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">netdev_tx_t</span> <span class="n">igb_xmit_frame_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_unmap_and_free_tx_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_alloc_rx_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">igb_has_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_set_ethtool_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_power_up_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IGB_PTP</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_ptp_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_ptp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">igb_systim_to_hwtstamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="o">*</span><span class="n">hwtstamps</span><span class="p">,</span>
				   <span class="n">u64</span> <span class="n">systim</span><span class="p">);</span>

<span class="cp">#endif</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">s32</span> <span class="nf">igb_reset_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">reset</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s32</span> <span class="nf">igb_read_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s32</span> <span class="nf">igb_write_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write_reg</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s32</span> <span class="nf">igb_get_phy_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_phy_info</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_phy_info</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="nf">txring_txq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* _IGB_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
