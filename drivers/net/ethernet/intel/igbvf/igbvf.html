<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › igbvf › igbvf.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>igbvf.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel(R) 82576 Virtual Function Linux driver</span>
<span class="cm">  Copyright(c) 2009 - 2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cm">/* Linux PRO/1000 Ethernet Driver main header file */</span>

<span class="cp">#ifndef _IGBVF_H_</span>
<span class="cp">#define _IGBVF_H_</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>

<span class="cp">#include &quot;vf.h&quot;</span>

<span class="cm">/* Forward declarations */</span>
<span class="k">struct</span> <span class="n">igbvf_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">igbvf_adapter</span><span class="p">;</span>

<span class="cm">/* Interrupt defines */</span>
<span class="cp">#define IGBVF_START_ITR                    488 </span><span class="cm">/* ~8000 ints/sec */</span><span class="cp"></span>
<span class="cp">#define IGBVF_4K_ITR                       980</span>
<span class="cp">#define IGBVF_20K_ITR                      196</span>
<span class="cp">#define IGBVF_70K_ITR                       56</span>

<span class="k">enum</span> <span class="n">latency_range</span> <span class="p">{</span>
	<span class="n">lowest_latency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">low_latency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">bulk_latency</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">latency_invalid</span> <span class="o">=</span> <span class="mi">255</span>
<span class="p">};</span>


<span class="cm">/* Interrupt modes, as used by the IntMode parameter */</span>
<span class="cp">#define IGBVF_INT_MODE_LEGACY           0</span>
<span class="cp">#define IGBVF_INT_MODE_MSI              1</span>
<span class="cp">#define IGBVF_INT_MODE_MSIX             2</span>

<span class="cm">/* Tx/Rx descriptor defines */</span>
<span class="cp">#define IGBVF_DEFAULT_TXD               256</span>
<span class="cp">#define IGBVF_MAX_TXD                   4096</span>
<span class="cp">#define IGBVF_MIN_TXD                   80</span>

<span class="cp">#define IGBVF_DEFAULT_RXD               256</span>
<span class="cp">#define IGBVF_MAX_RXD                   4096</span>
<span class="cp">#define IGBVF_MIN_RXD                   80</span>

<span class="cp">#define IGBVF_MIN_ITR_USECS             10 </span><span class="cm">/* 100000 irq/sec */</span><span class="cp"></span>
<span class="cp">#define IGBVF_MAX_ITR_USECS             10000 </span><span class="cm">/* 100    irq/sec */</span><span class="cp"></span>

<span class="cm">/* RX descriptor control thresholds.</span>
<span class="cm"> * PTHRESH - MAC will consider prefetch if it has fewer than this number of</span>
<span class="cm"> *           descriptors available in its onboard memory.</span>
<span class="cm"> *           Setting this to 0 disables RX descriptor prefetch.</span>
<span class="cm"> * HTHRESH - MAC will only prefetch if there are at least this many descriptors</span>
<span class="cm"> *           available in host memory.</span>
<span class="cm"> *           If PTHRESH is 0, this should also be 0.</span>
<span class="cm"> * WTHRESH - RX descriptor writeback threshold - MAC will delay writing back</span>
<span class="cm"> *           descriptors until either it has this many to write back, or the</span>
<span class="cm"> *           ITR timer expires.</span>
<span class="cm"> */</span>
<span class="cp">#define IGBVF_RX_PTHRESH                16</span>
<span class="cp">#define IGBVF_RX_HTHRESH                8</span>
<span class="cp">#define IGBVF_RX_WTHRESH                1</span>

<span class="cm">/* this is the size past which hardware will drop packets when setting LPE=0 */</span>
<span class="cp">#define MAXIMUM_ETHERNET_VLAN_SIZE      1522</span>

<span class="cp">#define IGBVF_FC_PAUSE_TIME             0x0680 </span><span class="cm">/* 858 usec */</span><span class="cp"></span>

<span class="cm">/* How many Tx Descriptors do we need to call netif_wake_queue ? */</span>
<span class="cp">#define IGBVF_TX_QUEUE_WAKE             32</span>
<span class="cm">/* How many Rx Buffers do we bundle into one write to the hardware ? */</span>
<span class="cp">#define IGBVF_RX_BUFFER_WRITE           16 </span><span class="cm">/* Must be power of 2 */</span><span class="cp"></span>

<span class="cp">#define AUTO_ALL_MODES                  0</span>
<span class="cp">#define IGBVF_EEPROM_APME               0x0400</span>

<span class="cp">#define IGBVF_MNG_VLAN_NONE             (-1)</span>

<span class="cm">/* Number of packet split data buffers (not including the header buffer) */</span>
<span class="cp">#define PS_PAGE_BUFFERS                 (MAX_PS_BUFFERS - 1)</span>

<span class="k">enum</span> <span class="n">igbvf_boards</span> <span class="p">{</span>
	<span class="n">board_vf</span><span class="p">,</span>
	<span class="n">board_i350_vf</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">igbvf_queue_stats</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">packets</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bytes</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * wrappers around a pointer to a socket buffer,</span>
<span class="cm"> * so a DMA handle can be stored along with the buffer</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/* Tx */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_stamp</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">length</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">next_to_watch</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">mapped_as_page</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="cm">/* Rx */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">page_dma</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_offset</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">igbvf_desc</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="n">rx_desc</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_adv_tx_desc</span> <span class="n">tx_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_adv_tx_context_desc</span> <span class="n">tx_context_desc</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>  <span class="cm">/* backlink */</span>
	<span class="k">union</span> <span class="n">igbvf_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>         <span class="cm">/* pointer to ring memory  */</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>                 <span class="cm">/* phys address of ring    */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>              <span class="cm">/* length of ring in bytes */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>             <span class="cm">/* number of desc. in ring */</span>

	<span class="n">u16</span> <span class="n">next_to_use</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">next_to_clean</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tail</span><span class="p">;</span>

	<span class="cm">/* array of buffer information structs */</span>
	<span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">eims_value</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">itr_val</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">latency_range</span> <span class="n">itr_range</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">itr_register</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">set_itr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rx_skb_top</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">igbvf_queue_stats</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* board specific private data structure */</span>
<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">watchdog_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">blink_timer</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reset_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">watchdog_task</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">igbvf_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active_vlans</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">VLAN_N_VID</span><span class="p">)];</span>
	<span class="n">u32</span> <span class="n">bd_number</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_buffer_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">polling_interval</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mng_vlan_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">link_speed</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">link_duplex</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">tx_queue_lock</span><span class="p">;</span> <span class="cm">/* prevent concurrent tail updates */</span>

	<span class="cm">/* track device up/down/testing state */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* Interrupt Throttle Rate */</span>
	<span class="n">u32</span> <span class="n">requested_itr</span><span class="p">;</span> <span class="cm">/* ints/sec or adaptive */</span>
	<span class="n">u32</span> <span class="n">current_itr</span><span class="p">;</span> <span class="cm">/* Actual ITR register value, not ints/sec */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tx</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="cm">/* One per active queue */</span>
	<span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">restart_queue</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">txd_cmd</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">tx_int_delay</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_abs_int_delay</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_tx_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_tx_packets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_rx_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_rx_packets</span><span class="p">;</span>

	<span class="cm">/* Tx stats */</span>
	<span class="n">u32</span> <span class="n">tx_timeout_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_fifo_head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_head_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_fifo_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_dma_failed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Rx</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">rx_int_delay</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_abs_int_delay</span><span class="p">;</span>

	<span class="cm">/* Rx stats */</span>
	<span class="n">u64</span> <span class="n">hw_csum_err</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hw_csum_good</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_hdr_split</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">alloc_rx_buff_failed</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_dma_failed</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_ps_hdr_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_frame_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">min_frame_size</span><span class="p">;</span>

	<span class="cm">/* OS defined structs */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="n">net_stats</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">stats_lock</span><span class="p">;</span>      <span class="cm">/* prevent concurrent stats updates */</span>

	<span class="cm">/* structs defined in e1000_hw.h */</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* The VF counters don&#39;t clear on read so we have to get a base</span>
<span class="cm">	 * count on driver start up and always subtract that base on</span>
<span class="cm">	 * on the first update, thus the flag..</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">e1000_vf_stats</span> <span class="n">stats</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">zero_base</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="n">test_tx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="n">test_rx_ring</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">test_icr</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">msg_enable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="o">*</span><span class="n">msix_entries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">int_mode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eims_enable_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eims_other</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">int_counter0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">int_counter1</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">eeprom_wol</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wol</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pba</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">fc_autoneg</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">led_status</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_reset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">igbvf_info</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">e1000_mac_type</span>     <span class="n">mac</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span>                     <span class="n">pba</span><span class="p">;</span>
	<span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">init_ops</span><span class="p">)(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">s32</span>                     <span class="p">(</span><span class="o">*</span><span class="n">get_variants</span><span class="p">)(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* hardware capability, feature, and workaround flags */</span>
<span class="cp">#define IGBVF_FLAG_RX_CSUM_DISABLED             (1 &lt;&lt; 0)</span>

<span class="cp">#define IGBVF_RX_DESC_ADV(R, i)     \</span>
<span class="cp">	(&amp;((((R).desc))[i].rx_desc))</span>
<span class="cp">#define IGBVF_TX_DESC_ADV(R, i)     \</span>
<span class="cp">	(&amp;((((R).desc))[i].tx_desc))</span>
<span class="cp">#define IGBVF_TX_CTXTDESC_ADV(R, i) \</span>
<span class="cp">	(&amp;((((R).desc))[i].tx_context_desc))</span>

<span class="k">enum</span> <span class="n">igbvf_state_t</span> <span class="p">{</span>
	<span class="n">__IGBVF_TESTING</span><span class="p">,</span>
	<span class="n">__IGBVF_RESETTING</span><span class="p">,</span>
	<span class="n">__IGBVF_DOWN</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">char</span> <span class="n">igbvf_driver_name</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">igbvf_driver_version</span><span class="p">[];</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">igbvf_check_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igbvf_set_ethtool_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">igbvf_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igbvf_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igbvf_reinit_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">igbvf_setup_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">igbvf_setup_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igbvf_free_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igbvf_free_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">igbvf_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">copybreak</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* _IGBVF_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
