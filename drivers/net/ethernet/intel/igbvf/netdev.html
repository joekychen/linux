<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › igbvf › netdev.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>netdev.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel(R) 82576 Virtual Function Linux driver</span>
<span class="cm">  Copyright(c) 2009 - 2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;net/ip6_checksum.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cp">#include &quot;igbvf.h&quot;</span>

<span class="cp">#define DRV_VERSION &quot;2.0.1-k&quot;</span>
<span class="kt">char</span> <span class="n">igbvf_driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;igbvf&quot;</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">igbvf_driver_version</span><span class="p">[]</span> <span class="o">=</span> <span class="n">DRV_VERSION</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">igbvf_driver_string</span><span class="p">[]</span> <span class="o">=</span>
		  <span class="s">&quot;Intel(R) Gigabit Virtual Function Network Driver&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">igbvf_copyright</span><span class="p">[]</span> <span class="o">=</span>
		  <span class="s">&quot;Copyright (c) 2009 - 2012 Intel Corporation.&quot;</span><span class="p">;</span>

<span class="cp">#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;Debug level (0=none,...,16=all)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">igbvf_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igbvf_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igbvf_set_interrupt_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">igbvf_reset_interrupt_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">igbvf_info</span> <span class="n">igbvf_vf_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mac</span>                    <span class="o">=</span> <span class="n">e1000_vfadapt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>                  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pba</span>                    <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_ops</span>               <span class="o">=</span> <span class="n">e1000_init_function_pointers_vf</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">igbvf_info</span> <span class="n">igbvf_i350_vf_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mac</span>			<span class="o">=</span> <span class="n">e1000_vfadapt_i350</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pba</span>			<span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_ops</span>		<span class="o">=</span> <span class="n">e1000_init_function_pointers_vf</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">igbvf_info</span> <span class="o">*</span><span class="n">igbvf_info_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">board_vf</span><span class="p">]</span>              <span class="o">=</span> <span class="o">&amp;</span><span class="n">igbvf_vf_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_i350_vf</span><span class="p">]</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">igbvf_i350_vf_info</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_desc_unused - calculate if we have unused descriptors</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_desc_unused</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">&gt;</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">-</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">-</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_receive_skb - helper function to handle Rx indications</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @status: descriptor status field as written by hardware</span>
<span class="cm"> * @vlan: descriptor vlan field as written by hardware (no le/be conversion)</span>
<span class="cm"> * @skb: pointer to sk_buff to be indicated to stack</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_receive_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                              <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
                              <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                              <span class="n">u32</span> <span class="n">status</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vlan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_VP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">vid</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">vlan</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_SPC_VLAN_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">))</span>
			<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">igbvf_rx_checksum_adv</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                                         <span class="n">u32</span> <span class="n">status_err</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Ignore Checksum bit is set or checksum is disabled through ethtool */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status_err</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_IXSM</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGBVF_FLAG_RX_CSUM_DISABLED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* TCP/UDP checksum error bit is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status_err</span> <span class="o">&amp;</span>
	    <span class="p">(</span><span class="n">E1000_RXDEXT_STATERR_TCPE</span> <span class="o">|</span> <span class="n">E1000_RXDEXT_STATERR_IPE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* let the stack verify checksum errors */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_csum_err</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* It must be a TCP or UDP packet with a valid checksum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status_err</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">E1000_RXD_STAT_TCPCS</span> <span class="o">|</span> <span class="n">E1000_RXD_STAT_UDPCS</span><span class="p">))</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_csum_good</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_alloc_rx_buffers - Replace used receive buffers; packet split</span>
<span class="cm"> * @rx_ring: address of ring structure to repopulate</span>
<span class="cm"> * @cleaned_count: number of buffers to repopulate</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_alloc_rx_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
                                   <span class="kt">int</span> <span class="n">cleaned_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bufsz</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span><span class="p">)</span>
		<span class="n">bufsz</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bufsz</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">IGBVF_RX_DESC_ADV</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">no_buffers</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">^=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span> <span class="o">=</span>
				<span class="n">dma_map_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span>
				             <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">,</span>
				             <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
					     <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">bufsz</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">no_buffers</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			                                  <span class="n">bufsz</span><span class="p">,</span>
							  <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Refresh the desc even if buffer_addrs didn&#39;t change because</span>
<span class="cm">		 * each write-back erases this info. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">pkt_addr</span> <span class="o">=</span>
			     <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span><span class="p">);</span>
			<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">hdr_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">pkt_addr</span> <span class="o">=</span>
			     <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
			<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">hdr_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

<span class="nl">no_buffers:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">i</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* Force memory writes to complete before letting h/w</span>
<span class="cm">		 * know there are new descriptors to fetch.  (Only</span>
<span class="cm">		 * applicable for weak-ordered memory model archs,</span>
<span class="cm">		 * such as IA-64). */</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_clean_rx_irq - Send received data up the network stack; legacy</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * the return value indicates whether actual cleaning was done, there</span>
<span class="cm"> * is no guarantee that everything was cleaned</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">igbvf_clean_rx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                               <span class="kt">int</span> <span class="o">*</span><span class="n">work_done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_adv_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">,</span> <span class="o">*</span><span class="n">next_rxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">,</span> <span class="o">*</span><span class="n">next_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cleaned</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">staterr</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>
	<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">IGBVF_RX_DESC_ADV</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">staterr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_DD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">work_done</span> <span class="o">&gt;=</span> <span class="n">work_to_do</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">work_done</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span> <span class="cm">/* read descriptor and rx_buffer_info after status DD */</span>

		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* HW will not DMA in data larger than the given buffer, even</span>
<span class="cm">		 * if it parses the (NFS, of course) header to be larger.  In</span>
<span class="cm">		 * that case, it fills the header buffer and spills the rest</span>
<span class="cm">		 * into the page.</span>
<span class="cm">		 */</span>
		<span class="n">hlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">lower</span><span class="p">.</span><span class="n">lo_dword</span><span class="p">.</span><span class="n">hs_rss</span><span class="p">.</span><span class="n">hdr_info</span><span class="p">)</span> <span class="o">&amp;</span>
		  <span class="n">E1000_RXDADV_HDRBUFLEN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">E1000_RXDADV_HDRBUFLEN_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlen</span> <span class="o">&gt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span><span class="p">)</span>
			<span class="n">hlen</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span><span class="p">;</span>

		<span class="n">length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
		<span class="n">cleaned</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">cleaned_count</span><span class="o">++</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
			                 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">,</span>
					 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">send_up</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
			                 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span><span class="p">,</span>
					 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span><span class="p">,</span>
			               <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
				       <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span>
			                   <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span>
			                   <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">,</span>
			                   <span class="n">length</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">get_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">send_up:</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">next_rxd</span> <span class="o">=</span> <span class="n">IGBVF_RX_DESC_ADV</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">next_rxd</span><span class="p">);</span>
		<span class="n">next_buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">next_buffer</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">next_buffer</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
			<span class="n">next_buffer</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="n">next_buffer</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXDEXT_ERR_FRAME_ERR_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">total_packets</span><span class="o">++</span><span class="p">;</span>

		<span class="n">igbvf_rx_checksum_adv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">staterr</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

		<span class="n">igbvf_receive_skb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">netdev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">staterr</span><span class="p">,</span>
		                  <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">vlan</span><span class="p">);</span>

<span class="nl">next_desc:</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* return some buffers to hardware, one at a time is too slow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cleaned_count</span> <span class="o">&gt;=</span> <span class="n">IGBVF_RX_BUFFER_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">igbvf_alloc_rx_buffers</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">);</span>
			<span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* use prefetched values */</span>
		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">next_rxd</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="n">next_buffer</span><span class="p">;</span>

		<span class="n">staterr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">cleaned_count</span> <span class="o">=</span> <span class="n">igbvf_desc_unused</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="p">)</span>
		<span class="n">igbvf_alloc_rx_buffers</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span> <span class="o">+=</span> <span class="n">total_packets</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span> <span class="o">+=</span> <span class="n">total_bytes</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">total_bytes</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">.</span><span class="n">rx_packets</span> <span class="o">+=</span> <span class="n">total_packets</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cleaned</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_put_txbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                            <span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">mapped_as_page</span><span class="p">)</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				       <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				       <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
				       <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					 <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
					 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_setup_tx_resources - allocate Tx resources (Descriptors)</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">igbvf_setup_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                             <span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* round up to nearest 4K */</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_tx_desc</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
	        <span class="s">&quot;Unable to allocate memory for the transmit descriptor ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_setup_rx_resources - allocate Rx resources (Descriptors)</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">igbvf_setup_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">desc_len</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">desc_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_rx_desc</span><span class="p">);</span>

	<span class="cm">/* Round up to nearest 4K */</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="n">desc_len</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
	        <span class="s">&quot;Unable to allocate memory for the receive descriptor ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_clean_tx_ring - Free Tx Buffers</span>
<span class="cm"> * @tx_ring: ring to be cleaned</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_clean_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Free all the Tx ring sk_buffs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">igbvf_put_txbuf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">buffer_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Zero out the descriptor ring */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_free_tx_resources - Free Tx Resources per Queue</span>
<span class="cm"> * @tx_ring: ring to free resources from</span>
<span class="cm"> *</span>
<span class="cm"> * Free all transmit software resources</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">igbvf_free_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">igbvf_clean_tx_ring</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">);</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span>
			  <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_clean_rx_ring - Free Rx Buffers per Queue</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_clean_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Free all the Rx ring sk_buffs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span><span class="p">){</span>
				<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				                 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span><span class="p">,</span>
						 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				                 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">,</span>
						 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span><span class="p">)</span>
				<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					       <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span><span class="p">,</span>
				               <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
					       <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Zero out the descriptor ring */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_free_rx_resources - Free Rx Resources</span>
<span class="cm"> * @rx_ring: ring to clean the resources from</span>
<span class="cm"> *</span>
<span class="cm"> * Free all receive software resources</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">igbvf_free_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">igbvf_clean_rx_ring</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">);</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span>
	                  <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_update_itr - update the dynamic ITR value based on statistics</span>
<span class="cm"> * @adapter: pointer to adapter</span>
<span class="cm"> * @itr_setting: current adapter-&gt;itr</span>
<span class="cm"> * @packets: the number of packets during this measurement interval</span>
<span class="cm"> * @bytes: the number of bytes during this measurement interval</span>
<span class="cm"> *</span>
<span class="cm"> *      Stores a new ITR value based on packets and byte</span>
<span class="cm"> *      counts during the last interrupt.  The advantage of per interrupt</span>
<span class="cm"> *      computation is faster updates and more accurate ITR for the current</span>
<span class="cm"> *      traffic pattern.  Constants in this function were computed</span>
<span class="cm"> *      based on theoretical maximum wire speed and thresholds were set based</span>
<span class="cm"> *      on testing data as well as attempting to minimize response time</span>
<span class="cm"> *      while increasing bulk throughput.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">latency_range</span> <span class="nf">igbvf_update_itr</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
					   <span class="k">enum</span> <span class="n">latency_range</span> <span class="n">itr_setting</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">packets</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">latency_range</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">itr_setting</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">update_itr_done</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">itr_setting</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">lowest_latency</span>:
		<span class="cm">/* handle TSO and jumbo frames */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">8000</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">low_latency</span>:  <span class="cm">/* 50 usec aka 20000 ints/s */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this if handles the TSO accounting */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">8000</span><span class="p">)</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1200</span><span class="p">))</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">))</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">lowest_latency</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">lowest_latency</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">bulk_latency</span>: <span class="cm">/* 250 usec aka 4000 ints/s */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">25000</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">)</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">6000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">update_itr_done:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_range_to_itr</span><span class="p">(</span><span class="k">enum</span> <span class="n">latency_range</span> <span class="n">current_range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">new_itr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">current_range</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* counts and packets in update_itr are dependent on these numbers */</span>
	<span class="k">case</span> <span class="n">lowest_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">IGBVF_70K_ITR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">low_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">IGBVF_20K_ITR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">bulk_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">IGBVF_4K_ITR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">IGBVF_START_ITR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">new_itr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_set_itr</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">new_itr</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_range</span> <span class="o">=</span>
			<span class="n">igbvf_update_itr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
					 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">,</span>
					 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_packets</span><span class="p">,</span>
					 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_bytes</span><span class="p">);</span>

	<span class="cm">/* conservative mode (itr 3) eliminates the lowest_latency setting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">requested_itr</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_range</span> <span class="o">==</span> <span class="n">lowest_latency</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_range</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>

	<span class="n">new_itr</span> <span class="o">=</span> <span class="n">igbvf_range_to_itr</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_range</span><span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">new_itr</span> <span class="o">!=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">current_itr</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * this attempts to bias the interrupt rate towards Bulk</span>
<span class="cm">		 * by adding intermediate steps when interrupt rate is</span>
<span class="cm">		 * increasing</span>
<span class="cm">		 */</span>
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">new_itr</span> <span class="o">&gt;</span> <span class="n">current_itr</span> <span class="o">?</span>
			     <span class="n">min</span><span class="p">(</span><span class="n">current_itr</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_itr</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">new_itr</span><span class="p">)</span> <span class="o">:</span>
			     <span class="n">new_itr</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">new_itr</span><span class="p">;</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">set_itr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_range</span> <span class="o">=</span>
			<span class="n">igbvf_update_itr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">,</span>
					 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span><span class="p">,</span>
					 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">requested_itr</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_range</span> <span class="o">==</span> <span class="n">lowest_latency</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_range</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>

	<span class="n">new_itr</span> <span class="o">=</span> <span class="n">igbvf_range_to_itr</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_range</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_itr</span> <span class="o">!=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">current_itr</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">;</span>
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">new_itr</span> <span class="o">&gt;</span> <span class="n">current_itr</span> <span class="o">?</span>
			     <span class="n">min</span><span class="p">(</span><span class="n">current_itr</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_itr</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">new_itr</span><span class="p">)</span> <span class="o">:</span>
			     <span class="n">new_itr</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">new_itr</span><span class="p">;</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">set_itr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_clean_tx_irq - Reclaim resources after transmit completes</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * returns true if ring is completely cleaned</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">igbvf_clean_tx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_adv_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span><span class="p">,</span> <span class="o">*</span><span class="n">eop_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">eop</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cleaned</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>
	<span class="n">eop</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_to_watch</span><span class="p">;</span>
	<span class="n">eop_desc</span> <span class="o">=</span> <span class="n">IGBVF_TX_DESC_ADV</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">eop</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">eop_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_TXD_STAT_DD</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rmb</span><span class="p">();</span>	<span class="cm">/* read buffer_info after eop_desc status */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">cleaned</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="o">!</span><span class="n">cleaned</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGBVF_TX_DESC_ADV</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">cleaned</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">eop</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">segs</span><span class="p">,</span> <span class="n">bytecount</span><span class="p">;</span>

				<span class="cm">/* gso_segs is currently only valid for tcp */</span>
				<span class="n">segs</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">?:</span> <span class="mi">1</span><span class="p">;</span>
				<span class="cm">/* multiply data chunks by size of headers */</span>
				<span class="n">bytecount</span> <span class="o">=</span> <span class="p">((</span><span class="n">segs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">+</span>
				            <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
				<span class="n">total_packets</span> <span class="o">+=</span> <span class="n">segs</span><span class="p">;</span>
				<span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">bytecount</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">igbvf_put_txbuf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">buffer_info</span><span class="p">);</span>
			<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">eop</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_to_watch</span><span class="p">;</span>
		<span class="n">eop_desc</span> <span class="o">=</span> <span class="n">IGBVF_TX_DESC_ADV</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">eop</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span>
	             <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	             <span class="n">igbvf_desc_unused</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">IGBVF_TX_QUEUE_WAKE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Make sure that anybody stopping the queue after this</span>
<span class="cm">		 * sees the new next_to_clean.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="o">++</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">restart_queue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">total_bytes</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">.</span><span class="n">tx_packets</span> <span class="o">+=</span> <span class="n">total_packets</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">igbvf_msix_other</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_counter1</span><span class="o">++</span><span class="p">;</span>

	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">EIMS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_other</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">igbvf_intr_msix_tx</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">set_itr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">set_itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* auto mask will automatically reenable the interrupt when we write</span>
<span class="cm">	 * EICS */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igbvf_clean_tx_irq</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">))</span>
		<span class="cm">/* Ring was not completely cleaned, so fire another interrupt */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EICS</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">eims_value</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EIMS</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">eims_value</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">igbvf_intr_msix_rx</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_counter0</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Write the ITR value calculated at the end of the</span>
<span class="cm">	 * previous interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">set_itr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">set_itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define IGBVF_NO_QUEUE -1</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_assign_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rx_queue</span><span class="p">,</span>
                                <span class="kt">int</span> <span class="n">tx_queue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msix_vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ivar</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* 82576 uses a table-based method for assigning vectors.</span>
<span class="cm">	   Each queue has a single entry in the table to which we write</span>
<span class="cm">	   a vector number along with a &quot;valid&quot; bit.  Sadly, the layout</span>
<span class="cm">	   of the table is somewhat counterintuitive. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_queue</span> <span class="o">&gt;</span> <span class="n">IGBVF_NO_QUEUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx_queue</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ivar</span> <span class="o">=</span> <span class="n">array_er32</span><span class="p">(</span><span class="n">IVAR0</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_queue</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* vector goes into third byte of register */</span>
			<span class="n">ivar</span> <span class="o">=</span> <span class="n">ivar</span> <span class="o">&amp;</span> <span class="mh">0xFF00FFFF</span><span class="p">;</span>
			<span class="n">ivar</span> <span class="o">|=</span> <span class="p">(</span><span class="n">msix_vector</span> <span class="o">|</span> <span class="n">E1000_IVAR_VALID</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* vector goes into low byte of register */</span>
			<span class="n">ivar</span> <span class="o">=</span> <span class="n">ivar</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF00</span><span class="p">;</span>
			<span class="n">ivar</span> <span class="o">|=</span> <span class="n">msix_vector</span> <span class="o">|</span> <span class="n">E1000_IVAR_VALID</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">rx_queue</span><span class="p">].</span><span class="n">eims_value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">msix_vector</span><span class="p">;</span>
		<span class="n">array_ew32</span><span class="p">(</span><span class="n">IVAR0</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ivar</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_queue</span> <span class="o">&gt;</span> <span class="n">IGBVF_NO_QUEUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx_queue</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ivar</span> <span class="o">=</span> <span class="n">array_er32</span><span class="p">(</span><span class="n">IVAR0</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_queue</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* vector goes into high byte of register */</span>
			<span class="n">ivar</span> <span class="o">=</span> <span class="n">ivar</span> <span class="o">&amp;</span> <span class="mh">0x00FFFFFF</span><span class="p">;</span>
			<span class="n">ivar</span> <span class="o">|=</span> <span class="p">(</span><span class="n">msix_vector</span> <span class="o">|</span> <span class="n">E1000_IVAR_VALID</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* vector goes into second byte of register */</span>
			<span class="n">ivar</span> <span class="o">=</span> <span class="n">ivar</span> <span class="o">&amp;</span> <span class="mh">0xFFFF00FF</span><span class="p">;</span>
			<span class="n">ivar</span> <span class="o">|=</span> <span class="p">(</span><span class="n">msix_vector</span> <span class="o">|</span> <span class="n">E1000_IVAR_VALID</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">tx_queue</span><span class="p">].</span><span class="n">eims_value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">msix_vector</span><span class="p">;</span>
		<span class="n">array_ew32</span><span class="p">(</span><span class="n">IVAR0</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ivar</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_configure_msix - Configure MSI-X hardware</span>
<span class="cm"> *</span>
<span class="cm"> * igbvf_configure_msix sets up the hardware to properly</span>
<span class="cm"> * generate MSI-X interrupts.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_configure_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">igbvf_assign_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">IGBVF_NO_QUEUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">++</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span> <span class="o">|=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">eims_value</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span><span class="p">);</span>
	<span class="n">igbvf_assign_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IGBVF_NO_QUEUE</span><span class="p">,</span> <span class="n">vector</span><span class="o">++</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span> <span class="o">|=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">eims_value</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span><span class="p">);</span>

	<span class="cm">/* set vector for other causes, i.e. link changes */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">vector</span><span class="o">++</span> <span class="o">|</span> <span class="n">E1000_IVAR_VALID</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">IVAR_MISC</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vector</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_other</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vector</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_reset_interrupt_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_set_interrupt_capability - set MSI or MSI-X if supported</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to configure interrupts using the best available</span>
<span class="cm"> * capabilities of the hardware and kernel.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_set_interrupt_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* we allocate 3 vectors, 1 for tx, 1 for rx, one for pf messages */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msix_entry</span><span class="p">),</span>
	                                <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		                      <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* MSI-X failed */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		        <span class="s">&quot;Failed to initialize MSI-X interrupts.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">igbvf_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_request_msix - Initialize MSI-X interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * igbvf_request_msix allocates MSI-X vectors and requests interrupts from the</span>
<span class="cm"> * kernel.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_request_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">IFNAMSIZ</span> <span class="o">-</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s-tx-0&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s-rx-0&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
	                  <span class="n">igbvf_intr_msix_tx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	                  <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span> <span class="o">=</span> <span class="n">E1000_EITR</span><span class="p">(</span><span class="n">vector</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">current_itr</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">++</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
	                  <span class="n">igbvf_intr_msix_rx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	                  <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span> <span class="o">=</span> <span class="n">E1000_EITR</span><span class="p">(</span><span class="n">vector</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">current_itr</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">++</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
	                  <span class="n">igbvf_msix_other</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">igbvf_configure_msix</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_alloc_queues - Allocate memory for all rings</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">igbvf_alloc_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_ring</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_ring</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">igbvf_poll</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_request_irq - initialize interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * Attempts to configure interrupts using the best available</span>
<span class="cm"> * capabilities of the hardware and kernel.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_request_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* igbvf supports msi-x only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">igbvf_request_msix</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
	        <span class="s">&quot;Unable to allocate interrupt, Error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_free_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vector</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vector</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">vector</span><span class="o">++</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_irq_disable - Mask off interrupt generation on the NIC</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_irq_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">EIMC</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EIAC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_irq_enable - Enable default interrupt generation settings</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">EIAC</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EIAM</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EIMS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eims_enable_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_poll - NAPI Rx polling callback</span>
<span class="cm"> * @napi: struct associated with this polling callback</span>
<span class="cm"> * @budget: amount of packets driver is allowed to process this poll</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">igbvf_ring</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">igbvf_clean_rx_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_done</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

	<span class="cm">/* If not enough Rx work done, exit the polling mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">requested_itr</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">igbvf_set_itr</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">EIMS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">eims_value</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_set_rlpml - set receive large packet maximum length</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the maximum size of packets that will be received</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_set_rlpml</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_frame_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">+</span> <span class="n">VLAN_TAG_SIZE</span><span class="p">;</span>
	<span class="n">e1000_rlpml_set_vf</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">max_frame_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_vlan_rx_add_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">set_vfta</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to add vlan id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_vlan_rx_kill_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">set_vfta</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		        <span class="s">&quot;Failed to remove vlan id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_restore_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">vid</span><span class="p">;</span>

	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">,</span> <span class="n">VLAN_N_VID</span><span class="p">)</span>
		<span class="n">igbvf_vlan_rx_add_vid</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_configure_tx - Configure Transmit Unit after Reset</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the Tx unit of the MAC after a reset.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_configure_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tdba</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">txdctl</span><span class="p">,</span> <span class="n">dca_txctrl</span><span class="p">;</span>

	<span class="cm">/* disable transmits */</span>
	<span class="n">txdctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">txdctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_TXDCTL_QUEUE_ENABLE</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* Setup the HW Tx Head and Tail descriptor pointers */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TDLEN</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_tx_desc</span><span class="p">));</span>
	<span class="n">tdba</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TDBAL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">tdba</span> <span class="o">&amp;</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TDBAH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">tdba</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TDH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TDT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">E1000_TDH</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">E1000_TDT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Turn off Relaxed Ordering on head write-backs.  The writebacks</span>
<span class="cm">	 * MUST be delivered in order or it will completely screw up</span>
<span class="cm">	 * our bookeeping.</span>
<span class="cm">	 */</span>
	<span class="n">dca_txctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">DCA_TXCTRL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">dca_txctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_DCA_TXCTRL_TX_WB_RO_EN</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">DCA_TXCTRL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dca_txctrl</span><span class="p">);</span>

	<span class="cm">/* enable transmits */</span>
	<span class="n">txdctl</span> <span class="o">|=</span> <span class="n">E1000_TXDCTL_QUEUE_ENABLE</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">txdctl</span><span class="p">);</span>

	<span class="cm">/* Setup Transmit Descriptor Settings for eop descriptor */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span> <span class="o">=</span> <span class="n">E1000_ADVTXD_DCMD_EOP</span> <span class="o">|</span> <span class="n">E1000_ADVTXD_DCMD_IFCS</span><span class="p">;</span>

	<span class="cm">/* enable Report Status bit */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_DCMD_RS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_setup_srrctl - configure the receive control registers</span>
<span class="cm"> * @adapter: Board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_setup_srrctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">srrctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">srrctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_SRRCTL_DESCTYPE_MASK</span> <span class="o">|</span>
	            <span class="n">E1000_SRRCTL_BSIZEHDR_MASK</span> <span class="o">|</span>
	            <span class="n">E1000_SRRCTL_BSIZEPKT_MASK</span><span class="p">);</span>

	<span class="cm">/* Enable queue drop to avoid head of line blocking */</span>
	<span class="n">srrctl</span> <span class="o">|=</span> <span class="n">E1000_SRRCTL_DROP_EN</span><span class="p">;</span>

	<span class="cm">/* Setup buffer sizes */</span>
	<span class="n">srrctl</span> <span class="o">|=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
	          <span class="n">E1000_SRRCTL_BSIZEPKT_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">&lt;</span> <span class="mi">2048</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">srrctl</span> <span class="o">|=</span> <span class="n">E1000_SRRCTL_DESCTYPE_ADV_ONEBUF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
		<span class="n">srrctl</span> <span class="o">|=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span> <span class="o">&lt;&lt;</span>
		          <span class="n">E1000_SRRCTL_BSIZEHDRSIZE_SHIFT</span><span class="p">;</span>
		<span class="n">srrctl</span> <span class="o">|=</span> <span class="n">E1000_SRRCTL_DESCTYPE_HDR_SPLIT_ALWAYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">SRRCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">srrctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_configure_rx - Configure Receive Unit after Reset</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the Rx unit of the MAC after a reset.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_configure_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rdba</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rdlen</span><span class="p">,</span> <span class="n">rxdctl</span><span class="p">;</span>

	<span class="cm">/* disable receives */</span>
	<span class="n">rxdctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">rxdctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_RXDCTL_QUEUE_ENABLE</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">rdlen</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_rx_desc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup the HW Rx Head and Tail Descriptor Pointers and</span>
<span class="cm">	 * the Base and Length of the Rx Descriptor Ring</span>
<span class="cm">	 */</span>
	<span class="n">rdba</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDBAL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">rdba</span> <span class="o">&amp;</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDBAH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">rdba</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDLEN</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_rx_desc</span><span class="p">));</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">E1000_RDH</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">E1000_RDT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rxdctl</span> <span class="o">|=</span> <span class="n">E1000_RXDCTL_QUEUE_ENABLE</span><span class="p">;</span>
	<span class="n">rxdctl</span> <span class="o">&amp;=</span> <span class="mh">0xFFF00000</span><span class="p">;</span>
	<span class="n">rxdctl</span> <span class="o">|=</span> <span class="n">IGBVF_RX_PTHRESH</span><span class="p">;</span>
	<span class="n">rxdctl</span> <span class="o">|=</span> <span class="n">IGBVF_RX_HTHRESH</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">rxdctl</span> <span class="o">|=</span> <span class="n">IGBVF_RX_WTHRESH</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">igbvf_set_rlpml</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* enable receives */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">rxdctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_set_multi - Multicast and Promiscuous mode set</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * The set_multi entry point is called whenever the multicast address</span>
<span class="cm"> * list or the network interface flags are updated.  This routine is</span>
<span class="cm"> * responsible for configuring the hardware for proper multicast,</span>
<span class="cm"> * promiscuous mode, and all-multi behavior.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_set_multi</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="o">*</span><span class="n">mta_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev_mc_empty</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mta_list</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mta_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			        <span class="s">&quot;failed to allocate multicast filter list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* prepare a packed array of only addresses. */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mta_list</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">*</span> <span class="n">ETH_ALEN</span><span class="p">),</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">update_mc_addr_list</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mta_list</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mta_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_configure - configure the hardware for Rx and Tx</span>
<span class="cm"> * @adapter: private board structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">igbvf_set_multi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">igbvf_restore_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">igbvf_configure_tx</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igbvf_setup_srrctl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igbvf_configure_rx</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igbvf_alloc_rx_buffers</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">,</span>
	                       <span class="n">igbvf_desc_unused</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* igbvf_reset - bring the hardware into a known good state</span>
<span class="cm"> *</span>
<span class="cm"> * This function boots the hardware and enables some settings that</span>
<span class="cm"> * require a configuration cycle of the hardware - those cannot be</span>
<span class="cm"> * set/changed during runtime. After reset the device needs to be</span>
<span class="cm"> * properly configured for Rx, Tx etc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* Allow time for pending master requests to run */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">reset_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PF still resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">init_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
		       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
		       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">last_reset</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">igbvf_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* hardware has been reset, we need to reload some things */</span>
	<span class="n">igbvf_configure</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="n">igbvf_configure_msix</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Clear any pending interrupts. */</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">EICR</span><span class="p">);</span>
	<span class="n">igbvf_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* start the watchdog */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">igbvf_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rxdctl</span><span class="p">,</span> <span class="n">txdctl</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * signal that we&#39;re down so the interrupt handler does not</span>
<span class="cm">	 * reschedule our watchdog timer</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="cm">/* disable receives in the hardware */</span>
	<span class="n">rxdctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">rxdctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_RXDCTL_QUEUE_ENABLE</span><span class="p">);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* disable transmits in the hardware */</span>
	<span class="n">txdctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">txdctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_TXDCTL_QUEUE_ENABLE</span><span class="p">);</span>

	<span class="cm">/* flush both disables and wait for them to finish */</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">igbvf_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* record the stats before reset*/</span>
	<span class="n">igbvf_update_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">igbvf_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igbvf_clean_tx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="n">igbvf_clean_rx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">igbvf_reinit_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__IGBVF_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">igbvf_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">igbvf_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__IGBVF_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_sw_init - Initialize general software structures (struct igbvf_adapter)</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * igbvf_sw_init initializes the Adapter private data structure.</span>
<span class="cm"> * Fields are initialized based on PCI device information and</span>
<span class="cm"> * OS network device settings (MTU size).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">igbvf_sw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_hdr_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">min_frame_size</span> <span class="o">=</span> <span class="n">ETH_ZLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_int_delay</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_abs_int_delay</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_int_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_abs_int_delay</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">requested_itr</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">current_itr</span> <span class="o">=</span> <span class="n">IGBVF_START_ITR</span><span class="p">;</span>

	<span class="cm">/* Set various function pointers */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">init_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mbx</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">init_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">igbvf_set_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">igbvf_alloc_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_queue_lock</span><span class="p">);</span>

	<span class="cm">/* Explicitly disable IRQ since the NIC can be in any state. */</span>
	<span class="n">igbvf_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_initialize_last_counter_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">last_gprc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">last_gorc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGORC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">last_gptc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">last_gotc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGOTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">last_mprc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFMPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">last_gotlbc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGOTLBC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">last_gptlbc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGPTLBC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">last_gorlbc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGORLBC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">last_gprlbc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGPRLBC</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">base_gprc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">base_gorc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGORC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">base_gptc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">base_gotc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGOTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">base_mprc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFMPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">base_gotlbc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGOTLBC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">base_gptlbc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGPTLBC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">base_gorlbc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGORLBC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">base_gprlbc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">VFGPRLBC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_open - Called when a network interface is made active</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative value on failure</span>
<span class="cm"> *</span>
<span class="cm"> * The open entry point is called when a network interface is made</span>
<span class="cm"> * active by the system (IFF_UP).  At this point all resources needed</span>
<span class="cm"> * for transmit and receive operations are allocated, the interrupt</span>
<span class="cm"> * handler is registered with the OS, the watchdog timer is started,</span>
<span class="cm"> * and the stack is notified that the interface is ready.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* disallow open during test */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGBVF_TESTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* allocate transmit descriptors */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">igbvf_setup_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_setup_tx</span><span class="p">;</span>

	<span class="cm">/* allocate receive descriptors */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">igbvf_setup_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_setup_rx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * before we allocate an interrupt, we must be ready to handle it.</span>
<span class="cm">	 * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt</span>
<span class="cm">	 * as soon as we call pci_request_irq, so we have to setup our</span>
<span class="cm">	 * clean_rx handler before we do so.</span>
<span class="cm">	 */</span>
	<span class="n">igbvf_configure</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">igbvf_request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_req_irq</span><span class="p">;</span>

	<span class="cm">/* From here on the code is the same as igbvf_up() */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="cm">/* clear any pending interrupts */</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">EICR</span><span class="p">);</span>

	<span class="n">igbvf_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* start the watchdog */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_req_irq:</span>
	<span class="n">igbvf_free_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>
<span class="nl">err_setup_rx:</span>
	<span class="n">igbvf_free_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
<span class="nl">err_setup_tx:</span>
	<span class="n">igbvf_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_close - Disables a network interface</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0, this is not allowed to fail</span>
<span class="cm"> *</span>
<span class="cm"> * The close entry point is called when an interface is de-activated</span>
<span class="cm"> * by the OS.  The hardware is still under the drivers control, but</span>
<span class="cm"> * needs to be disabled.  A global MAC reset is issued to stop the</span>
<span class="cm"> * hardware, and all transmit and receive resources are freed.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGBVF_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
	<span class="n">igbvf_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">igbvf_free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">igbvf_free_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="n">igbvf_free_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * igbvf_set_mac - Change the Ethernet Address of the NIC</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> * @p: pointer to an address structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_set_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">rar_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_assign_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NET_ADDR_RANDOM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define UPDATE_VF_COUNTER(reg, name)                                    \</span>
<span class="cp">	{                                                               \</span>
<span class="cp">		u32 current_counter = er32(reg);                        \</span>
<span class="cp">		if (current_counter &lt; adapter-&gt;stats.last_##name)       \</span>
<span class="cp">			adapter-&gt;stats.name += 0x100000000LL;           \</span>
<span class="cp">		adapter-&gt;stats.last_##name = current_counter;           \</span>
<span class="cp">		adapter-&gt;stats.name &amp;= 0xFFFFFFFF00000000LL;            \</span>
<span class="cp">		adapter-&gt;stats.name |= current_counter;                 \</span>
<span class="cp">	}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_update_stats - Update the board statistics counters</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm">**/</span>
<span class="kt">void</span> <span class="nf">igbvf_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent stats update while adapter is being reset, link is down</span>
<span class="cm">	 * or if the pci connection is down.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGBVF_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">UPDATE_VF_COUNTER</span><span class="p">(</span><span class="n">VFGPRC</span><span class="p">,</span> <span class="n">gprc</span><span class="p">);</span>
	<span class="n">UPDATE_VF_COUNTER</span><span class="p">(</span><span class="n">VFGORC</span><span class="p">,</span> <span class="n">gorc</span><span class="p">);</span>
	<span class="n">UPDATE_VF_COUNTER</span><span class="p">(</span><span class="n">VFGPTC</span><span class="p">,</span> <span class="n">gptc</span><span class="p">);</span>
	<span class="n">UPDATE_VF_COUNTER</span><span class="p">(</span><span class="n">VFGOTC</span><span class="p">,</span> <span class="n">gotc</span><span class="p">);</span>
	<span class="n">UPDATE_VF_COUNTER</span><span class="p">(</span><span class="n">VFMPRC</span><span class="p">,</span> <span class="n">mprc</span><span class="p">);</span>
	<span class="n">UPDATE_VF_COUNTER</span><span class="p">(</span><span class="n">VFGOTLBC</span><span class="p">,</span> <span class="n">gotlbc</span><span class="p">);</span>
	<span class="n">UPDATE_VF_COUNTER</span><span class="p">(</span><span class="n">VFGPTLBC</span><span class="p">,</span> <span class="n">gptlbc</span><span class="p">);</span>
	<span class="n">UPDATE_VF_COUNTER</span><span class="p">(</span><span class="n">VFGORLBC</span><span class="p">,</span> <span class="n">gorlbc</span><span class="p">);</span>
	<span class="n">UPDATE_VF_COUNTER</span><span class="p">(</span><span class="n">VFGPRLBC</span><span class="p">,</span> <span class="n">gprlbc</span><span class="p">);</span>

	<span class="cm">/* Fill out the OS statistics structure */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">.</span><span class="n">multicast</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mprc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_print_link_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Link is Up %d Mbps %s Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">,</span>
		 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">==</span> <span class="n">FULL_DUPLEX</span> <span class="o">?</span> <span class="s">&quot;Full&quot;</span> <span class="o">:</span> <span class="s">&quot;Half&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">igbvf_has_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link_active</span><span class="p">;</span>

	<span class="cm">/* If interface is down, stay link down */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_for_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">link_active</span> <span class="o">=</span> <span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span><span class="p">;</span>

	<span class="cm">/* if check for link returns error we will need to reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">last_reset</span> <span class="o">+</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)))</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">link_active</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_watchdog - Timer Call-back</span>
<span class="cm"> * @data: pointer to adapter cast into an unsigned long</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_watchdog</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Do the rest outside of interrupt context */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_watchdog_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
	                                             <span class="k">struct</span> <span class="n">igbvf_adapter</span><span class="p">,</span>
	                                             <span class="n">watchdog_task</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">link</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">link</span> <span class="o">=</span> <span class="n">igbvf_has_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_link_up_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span>
			                          <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">,</span>
			                          <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span><span class="p">);</span>
			<span class="n">igbvf_print_link_info</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

			<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Link is Down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">igbvf_update_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tx_pending</span> <span class="o">=</span> <span class="p">(</span><span class="n">igbvf_desc_unused</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span>
		              <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_pending</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We&#39;ve lost link, so the controller stops DMA,</span>
<span class="cm">			 * but we&#39;ve got queued Tx work that&#39;s never going</span>
<span class="cm">			 * to get done, so reset controller to flush Tx.</span>
<span class="cm">			 * (Do the reset outside of interrupt context).</span>
<span class="cm">			 */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Cause software interrupt to ensure Rx ring is cleaned */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EICS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">eims_value</span><span class="p">);</span>

	<span class="cm">/* Reset the timer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span>
			  <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cp">#define IGBVF_TX_FLAGS_CSUM             0x00000001</span>
<span class="cp">#define IGBVF_TX_FLAGS_VLAN             0x00000002</span>
<span class="cp">#define IGBVF_TX_FLAGS_TSO              0x00000004</span>
<span class="cp">#define IGBVF_TX_FLAGS_IPV4             0x00000008</span>
<span class="cp">#define IGBVF_TX_FLAGS_VLAN_MASK        0xffff0000</span>
<span class="cp">#define IGBVF_TX_FLAGS_VLAN_SHIFT       16</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_tso</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                     <span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span>
                     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tx_flags</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">hdr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adv_tx_context_desc</span> <span class="o">*</span><span class="n">context_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tu_cmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mss_l4len_idx</span><span class="p">,</span> <span class="n">l4len</span><span class="p">;</span>
	<span class="o">*</span><span class="n">hdr_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_header_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			        <span class="s">&quot;igbvf_tso returning an error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">l4len</span> <span class="o">=</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="o">*</span><span class="n">hdr_len</span> <span class="o">+=</span> <span class="n">l4len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">tot_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_tcpudp_magic</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
		                                         <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		                                         <span class="n">IPPROTO_TCP</span><span class="p">,</span>
		                                         <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">payload_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_ipv6_magic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
		                                       <span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span>
		                                       <span class="mi">0</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">context_desc</span> <span class="o">=</span> <span class="n">IGBVF_TX_CTXTDESC_ADV</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="cm">/* VLAN MACLEN IPLEN */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGBVF_TX_FLAGS_VLAN</span><span class="p">)</span>
		<span class="n">info</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGBVF_TX_FLAGS_VLAN_MASK</span><span class="p">);</span>
	<span class="n">info</span> <span class="o">|=</span> <span class="p">(</span><span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_ADVTXD_MACLEN_SHIFT</span><span class="p">);</span>
	<span class="o">*</span><span class="n">hdr_len</span> <span class="o">+=</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">info</span> <span class="o">|=</span> <span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="o">*</span><span class="n">hdr_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">vlan_macip_lens</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* ADV DTYP TUCMD MKRLOC/ISCSIHEDLEN */</span>
	<span class="n">tu_cmd</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_TXD_CMD_DEXT</span> <span class="o">|</span> <span class="n">E1000_ADVTXD_DTYP_CTXT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
		<span class="n">tu_cmd</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_TUCMD_IPV4</span><span class="p">;</span>
	<span class="n">tu_cmd</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_TUCMD_L4T_TCP</span><span class="p">;</span>

	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">type_tucmd_mlhl</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">tu_cmd</span><span class="p">);</span>

	<span class="cm">/* MSS L4LEN IDX */</span>
	<span class="n">mss_l4len_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_ADVTXD_MSS_SHIFT</span><span class="p">);</span>
	<span class="n">mss_l4len_idx</span> <span class="o">|=</span> <span class="p">(</span><span class="n">l4len</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_ADVTXD_L4LEN_SHIFT</span><span class="p">);</span>

	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">mss_l4len_idx</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mss_l4len_idx</span><span class="p">);</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">seqnum_seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">igbvf_tx_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                                 <span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span>
                                 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tx_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adv_tx_context_desc</span> <span class="o">*</span><span class="n">context_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tu_cmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGBVF_TX_FLAGS_VLAN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">context_desc</span> <span class="o">=</span> <span class="n">IGBVF_TX_CTXTDESC_ADV</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGBVF_TX_FLAGS_VLAN</span><span class="p">)</span>
			<span class="n">info</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGBVF_TX_FLAGS_VLAN_MASK</span><span class="p">);</span>

		<span class="n">info</span> <span class="o">|=</span> <span class="p">(</span><span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_ADVTXD_MACLEN_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
			<span class="n">info</span> <span class="o">|=</span> <span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span>
			         <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>


		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">vlan_macip_lens</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

		<span class="n">tu_cmd</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_TXD_CMD_DEXT</span> <span class="o">|</span> <span class="n">E1000_ADVTXD_DTYP_CTXT</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">__constant_htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">)</span>:
				<span class="n">tu_cmd</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_TUCMD_IPV4</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
					<span class="n">tu_cmd</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_TUCMD_L4T_TCP</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">__constant_htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">)</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
					<span class="n">tu_cmd</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_TUCMD_L4T_TCP</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">type_tucmd_mlhl</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">tu_cmd</span><span class="p">);</span>
		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">seqnum_seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">mss_l4len_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_maybe_stop_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* there is enough descriptors then we don&#39;t need to worry  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igbvf_desc_unused</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* We need to check again just in case room has been made available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igbvf_desc_unused</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="o">++</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">restart_queue</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define IGBVF_MAX_TXD_PWR       16</span>
<span class="cp">#define IGBVF_MAX_DATA_PER_TXD  (1 &lt;&lt; IGBVF_MAX_TXD_PWR)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">igbvf_tx_map_adv</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                                   <span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span>
                                   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                                   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">IGBVF_MAX_DATA_PER_TXD</span><span class="p">);</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="cm">/* set time_stamp *before* dma to help avoid a possible race */</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">mapped_as_page</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
					  <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">dma_error</span><span class="p">;</span>


	<span class="k">for</span> <span class="p">(</span><span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>

		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>

		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">IGBVF_MAX_DATA_PER_TXD</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">mapped_as_page</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
						<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">dma_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">first</span><span class="p">].</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">++</span><span class="n">count</span><span class="p">;</span>

<span class="nl">dma_error:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX DMA map failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* clear timestamp and dma mappings for failed buffer_info mapping */</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">mapped_as_page</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* clear timestamp and dma mappings for remaining portion of packet */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">igbvf_put_txbuf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">buffer_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">igbvf_tx_queue_adv</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                                      <span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span>
                                      <span class="kt">int</span> <span class="n">tx_flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">u32</span> <span class="n">paylen</span><span class="p">,</span>
                                      <span class="n">u8</span> <span class="n">hdr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">e1000_adv_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">olinfo_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmd_type_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cmd_type_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">E1000_ADVTXD_DTYP_DATA</span> <span class="o">|</span> <span class="n">E1000_ADVTXD_DCMD_IFCS</span> <span class="o">|</span>
	                <span class="n">E1000_ADVTXD_DCMD_DEXT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGBVF_TX_FLAGS_VLAN</span><span class="p">)</span>
		<span class="n">cmd_type_len</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_DCMD_VLE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGBVF_TX_FLAGS_TSO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd_type_len</span> <span class="o">|=</span> <span class="n">E1000_ADVTXD_DCMD_TSE</span><span class="p">;</span>

		<span class="cm">/* insert tcp checksum */</span>
		<span class="n">olinfo_status</span> <span class="o">|=</span> <span class="n">E1000_TXD_POPTS_TXSM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>

		<span class="cm">/* insert ip checksum */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGBVF_TX_FLAGS_IPV4</span><span class="p">)</span>
			<span class="n">olinfo_status</span> <span class="o">|=</span> <span class="n">E1000_TXD_POPTS_IXSM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">IGBVF_TX_FLAGS_CSUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">olinfo_status</span> <span class="o">|=</span> <span class="n">E1000_TXD_POPTS_TXSM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">olinfo_status</span> <span class="o">|=</span> <span class="p">((</span><span class="n">paylen</span> <span class="o">-</span> <span class="n">hdr_len</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_ADVTXD_PAYLEN_SHIFT</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGBVF_TX_DESC_ADV</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">cmd_type_len</span> <span class="o">=</span>
		         <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cmd_type_len</span> <span class="o">|</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">olinfo_status</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">olinfo_status</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">cmd_type_len</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span><span class="p">);</span>
	<span class="cm">/* Force memory writes to complete before letting h/w</span>
<span class="cm">	 * know there are new descriptors to fetch.  (Only</span>
<span class="cm">	 * applicable for weak-ordered memory model archs,</span>
<span class="cm">	 * such as IA-64). */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
	<span class="cm">/* we need this if more than one processor can write to our tail</span>
<span class="cm">	 * at a time, it syncronizes IO on IA64/Altix systems */</span>
	<span class="n">mmiowb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">igbvf_xmit_frame_ring_adv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="n">tx_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hdr_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tso</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * need: count + 4 desc gap to keep tail from touching</span>
<span class="cm">         *       + 2 desc gap to keep tail from touching head,</span>
<span class="cm">         *       + 1 desc for skb-&gt;data,</span>
<span class="cm">         *       + 1 desc for context descriptor,</span>
<span class="cm">	 * head, otherwise try next time</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">igbvf_maybe_stop_tx</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* this is a hard error */</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">IGBVF_TX_FLAGS_VLAN</span><span class="p">;</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">IGBVF_TX_FLAGS_VLAN_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">IGBVF_TX_FLAGS_IPV4</span><span class="p">;</span>

	<span class="n">first</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="n">tso</span> <span class="o">=</span> <span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">igbvf_tso</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tx_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr_len</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tso</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tso</span><span class="p">)</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">IGBVF_TX_FLAGS_TSO</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">igbvf_tx_csum</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tx_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	         <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">))</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">IGBVF_TX_FLAGS_CSUM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * count reflects descriptors mapped, if 0 then mapping error</span>
<span class="cm">	 * has occurred and we need to rewind the descriptor queue</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">igbvf_tx_map_adv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">igbvf_tx_queue_adv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">,</span> <span class="n">tx_flags</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
		                   <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">hdr_len</span><span class="p">);</span>
		<span class="cm">/* Make sure there is space in the ring for the next send. */</span>
		<span class="n">igbvf_maybe_stop_tx</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">first</span><span class="p">].</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">igbvf_xmit_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igbvf_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tx_ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">igbvf_xmit_frame_ring_adv</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">netdev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_tx_timeout - Respond to a Tx Hang</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Do the reset outside of interrupt context */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">igbvf_adapter</span><span class="p">,</span> <span class="n">reset_task</span><span class="p">);</span>

	<span class="n">igbvf_reinit_locked</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_get_stats - Get System Network Statistics</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the address of the device statistics structure.</span>
<span class="cm"> * The statistics are actually updated from the timer callback.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">igbvf_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* only return the current stats */</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_change_mtu - Change the Maximum Transfer Unit</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> * @new_mtu: new value for maximum frame size</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">max_frame</span> <span class="o">=</span> <span class="n">new_mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="mi">68</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">max_frame</span> <span class="o">&gt;</span> <span class="n">MAX_JUMBO_FRAME_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid MTU setting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#define MAX_STD_JUMBO_FRAME_SIZE 9234</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_frame</span> <span class="o">&gt;</span> <span class="n">MAX_STD_JUMBO_FRAME_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MTU &gt; 9216 not supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__IGBVF_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* igbvf_down has a dependency on max_frame_size */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">max_frame</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">igbvf_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN</span>
<span class="cm">	 * means we reserve 2 more, this pushes us to allocate from the next</span>
<span class="cm">	 * larger slab size.</span>
<span class="cm">	 * i.e. RXBUFFER_2048 --&gt; size-4096 slab</span>
<span class="cm">	 * However with the new *_jumbo_rx* routines, jumbo receives will use</span>
<span class="cm">	 * fragmented skbs</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_frame</span> <span class="o">&lt;=</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max_frame</span> <span class="o">&lt;=</span> <span class="mi">2048</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
	<span class="k">else</span>
<span class="cp">#if (PAGE_SIZE / 2) &gt; 16384</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="cp">#endif</span>


	<span class="cm">/* adjust allocation if LPE protects us, and we aren&#39;t using SBP */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">max_frame</span> <span class="o">==</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">max_frame</span> <span class="o">==</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span> <span class="o">+</span>
		                         <span class="n">ETH_FCS_LEN</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;changing MTU from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	         <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">igbvf_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">igbvf_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__IGBVF_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGBVF_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
		<span class="n">igbvf_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">igbvf_free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot enable PCI device from suspend</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">igbvf_request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">igbvf_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">igbvf_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">igbvf_suspend</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="cm">/*</span>
<span class="cm"> * Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<span class="cm"> * without having to re-enable interrupts. It&#39;s not called while</span>
<span class="cm"> * the interrupt routine is executing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">disable_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">igbvf_clean_tx_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>

	<span class="n">enable_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_io_error_detected - called when PCI error is detected</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> * @state: The current pci connection state</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called after a PCI bus error affecting</span>
<span class="cm"> * this device has been detected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="nf">igbvf_io_error_detected</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
                                                <span class="n">pci_channel_state_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">pci_channel_io_perm_failure</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">igbvf_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Request a slot slot reset. */</span>
	<span class="k">return</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_io_slot_reset - called after the pci bus has been reset.</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Restart the card from scratch, as if from a cold-boot. Implementation</span>
<span class="cm"> * resembles the first-half of the igbvf_resume routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="nf">igbvf_io_slot_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Cannot re-enable PCI device after reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">igbvf_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">PCI_ERS_RESULT_RECOVERED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_io_resume - called when traffic can start flowing again.</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is called when the error recovery driver tells us that</span>
<span class="cm"> * its OK to resume normal operation. Implementation resembles the</span>
<span class="cm"> * second-half of the igbvf_resume routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_io_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">igbvf_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;can&#39;t bring device back up after reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">igbvf_print_device_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_vfadapt_i350</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Intel(R) I350 Virtual Function</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Intel(R) 82576 Virtual Function</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Address: %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">igbvf_set_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGBVF_FLAG_RX_CSUM_DISABLED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IGBVF_FLAG_RX_CSUM_DISABLED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">igbvf_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>                       <span class="o">=</span> <span class="n">igbvf_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>                       <span class="o">=</span> <span class="n">igbvf_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>                 <span class="o">=</span> <span class="n">igbvf_xmit_frame</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>                  <span class="o">=</span> <span class="n">igbvf_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>		<span class="o">=</span> <span class="n">igbvf_set_multi</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>            <span class="o">=</span> <span class="n">igbvf_set_mac</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>                 <span class="o">=</span> <span class="n">igbvf_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>                   <span class="o">=</span> <span class="n">igbvf_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>                 <span class="o">=</span> <span class="n">igbvf_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_add_vid</span>            <span class="o">=</span> <span class="n">igbvf_vlan_rx_add_vid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_kill_vid</span>           <span class="o">=</span> <span class="n">igbvf_vlan_rx_kill_vid</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>            <span class="o">=</span> <span class="n">igbvf_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">ndo_set_features</span>               <span class="o">=</span> <span class="n">igbvf_set_features</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_probe - Device Initialization Routine</span>
<span class="cm"> * @pdev: PCI device information struct</span>
<span class="cm"> * @ent: entry in igbvf_pci_tbl</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> *</span>
<span class="cm"> * igbvf_probe initializes an adapter identified by a pci_dev structure.</span>
<span class="cm"> * The OS initialization, configuring of the adapter private structure,</span>
<span class="cm"> * and a hardware reset occur.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">igbvf_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">igbvf_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">igbvf_info_tbl</span><span class="p">[</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">];</span>

	<span class="k">static</span> <span class="kt">int</span> <span class="n">cards_found</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">pci_using_dac</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_coherent_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_coherent_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						    <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No usable DMA &quot;</span>
				        <span class="s">&quot;configuration, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err_dma</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">igbvf_driver_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_pci_reg</span><span class="p">;</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">netdev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igbvf_adapter</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc_etherdev</span><span class="p">;</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ei</span> <span class="o">=</span> <span class="n">ei</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pba</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">pba</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">back</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">netif_msg_init</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">DEFAULT_MSG_ENABLE</span><span class="p">);</span>

	<span class="cm">/* PCI config space info */</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">subsystem_vendor_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">subsystem_device_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">revision_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	                              <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_ioremap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">get_variants</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">get_variants</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_ioremap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* setup adapter struct */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">igbvf_sw_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_sw_init</span><span class="p">;</span>

	<span class="cm">/* construct the net_device struct */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">igbvf_netdev_ops</span><span class="p">;</span>

	<span class="n">igbvf_set_ethtool_ops</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bd_number</span> <span class="o">=</span> <span class="n">cards_found</span><span class="o">++</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">=</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span>
	                   <span class="n">NETIF_F_IP_CSUM</span> <span class="o">|</span>
			   <span class="n">NETIF_F_IPV6_CSUM</span> <span class="o">|</span>
			   <span class="n">NETIF_F_TSO</span> <span class="o">|</span>
			   <span class="n">NETIF_F_TSO6</span> <span class="o">|</span>
			   <span class="n">NETIF_F_RXCSUM</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|</span>
	                   <span class="n">NETIF_F_HW_VLAN_TX</span> <span class="o">|</span>
	                   <span class="n">NETIF_F_HW_VLAN_RX</span> <span class="o">|</span>
	                   <span class="n">NETIF_F_HW_VLAN_FILTER</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_using_dac</span><span class="p">)</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO6</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_IP_CSUM</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_IPV6_CSUM</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_SG</span><span class="p">;</span>

	<span class="cm">/*reset the controller to put the device in a known good state */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">reset_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;PF still in reset state, assigning new address.&quot;</span>
			 <span class="s">&quot; Is the PF interface up?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">eth_hw_addr_random</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
			<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_mac_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error reading MAC address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_hw_init</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
			<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid MAC Address: %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		        <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_hw_init</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">igbvf_watchdog</span><span class="p">,</span>
	            <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">,</span> <span class="n">igbvf_reset_task</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">,</span> <span class="n">igbvf_watchdog_task</span><span class="p">);</span>

	<span class="cm">/* ring size defaults */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="cm">/* reset the hardware with the new settings */</span>
	<span class="n">igbvf_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;eth%d&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_hw_init</span><span class="p">;</span>

	<span class="cm">/* tell the stack to leave us alone until igbvf_open() is called */</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">igbvf_print_device_info</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">igbvf_initialize_last_counter_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_hw_init:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>
<span class="nl">err_sw_init:</span>
	<span class="n">igbvf_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span><span class="p">);</span>
<span class="nl">err_ioremap:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="nl">err_alloc_etherdev:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">err_pci_reg:</span>
<span class="nl">err_dma:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_remove - Device Removal Routine</span>
<span class="cm"> * @pdev: PCI device information struct</span>
<span class="cm"> *</span>
<span class="cm"> * igbvf_remove is called by the PCI subsystem to alert the driver</span>
<span class="cm"> * that it should release a PCI device.  The could be caused by a</span>
<span class="cm"> * Hot-Plug event, or because the driver is going to be removed from</span>
<span class="cm"> * memory.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">igbvf_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">igbvf_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The watchdog timer may be rescheduled, so explicitly</span>
<span class="cm">	 * disable it from being rescheduled.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">__IGBVF_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">igbvf_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * it is important to delete the napi struct prior to freeing the</span>
<span class="cm">	 * rx ring so that you do not end up with null pointer refs</span>
<span class="cm">	 */</span>
	<span class="n">netif_napi_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">flash_address</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">flash_address</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* PCI Error Recovery (ERS) */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_error_handlers</span> <span class="n">igbvf_err_handler</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">error_detected</span> <span class="o">=</span> <span class="n">igbvf_io_error_detected</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slot_reset</span> <span class="o">=</span> <span class="n">igbvf_io_slot_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">igbvf_io_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">igbvf_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82576_VF</span><span class="p">),</span> <span class="n">board_vf</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_I350_VF</span><span class="p">),</span> <span class="n">board_i350_vf</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span> <span class="cm">/* terminate list */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">igbvf_pci_tbl</span><span class="p">);</span>

<span class="cm">/* PCI Device API Driver */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">igbvf_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>     <span class="o">=</span> <span class="n">igbvf_driver_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">igbvf_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>    <span class="o">=</span> <span class="n">igbvf_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>   <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">igbvf_remove</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="cm">/* Power Management Hooks */</span>
	<span class="p">.</span><span class="n">suspend</span>  <span class="o">=</span> <span class="n">igbvf_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>   <span class="o">=</span> <span class="n">igbvf_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">igbvf_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">err_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">igbvf_err_handler</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_init_module - Driver Registration Routine</span>
<span class="cm"> *</span>
<span class="cm"> * igbvf_init_module is the first routine called when the driver is</span>
<span class="cm"> * loaded. All it does is register with the PCI subsystem.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">igbvf_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s - version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">igbvf_driver_string</span><span class="p">,</span> <span class="n">igbvf_driver_version</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">igbvf_copyright</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">igbvf_driver</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">igbvf_init_module</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * igbvf_exit_module - Driver Exit Cleanup Routine</span>
<span class="cm"> *</span>
<span class="cm"> * igbvf_exit_module is called just before the driver is removed</span>
<span class="cm"> * from memory.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">igbvf_exit_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">igbvf_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">igbvf_exit_module</span><span class="p">);</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Intel Corporation, &lt;e1000-devel@lists.sourceforge.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Intel(R) Gigabit Virtual Function Network Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>

<span class="cm">/* netdev.c */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
