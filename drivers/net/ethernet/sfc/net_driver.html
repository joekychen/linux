<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › net_driver.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>net_driver.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2005-2006 Fen Systems Ltd.</span>
<span class="cm"> * Copyright 2005-2011 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>

<span class="cm">/* Common definitions for all Efx net driver code */</span>

<span class="cp">#ifndef EFX_NET_DRIVER_H</span>
<span class="cp">#define EFX_NET_DRIVER_H</span>

<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/mdio.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>

<span class="cp">#include &quot;enum.h&quot;</span>
<span class="cp">#include &quot;bitfield.h&quot;</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Build definitions</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cp">#define EFX_DRIVER_VERSION	&quot;3.1&quot;</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define EFX_BUG_ON_PARANOID(x) BUG_ON(x)</span>
<span class="cp">#define EFX_WARN_ON_PARANOID(x) WARN_ON(x)</span>
<span class="cp">#else</span>
<span class="cp">#define EFX_BUG_ON_PARANOID(x) do {} while (0)</span>
<span class="cp">#define EFX_WARN_ON_PARANOID(x) do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Efx data structures</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cp">#define EFX_MAX_CHANNELS 32U</span>
<span class="cp">#define EFX_MAX_RX_QUEUES EFX_MAX_CHANNELS</span>
<span class="cp">#define EFX_EXTRA_CHANNEL_IOV	0</span>
<span class="cp">#define EFX_MAX_EXTRA_CHANNELS	1U</span>

<span class="cm">/* Checksum generation is a per-queue option in hardware, so each</span>
<span class="cm"> * queue visible to the networking core is backed by two hardware TX</span>
<span class="cm"> * queues. */</span>
<span class="cp">#define EFX_MAX_TX_TC		2</span>
<span class="cp">#define EFX_MAX_CORE_TX_QUEUES	(EFX_MAX_TX_TC * EFX_MAX_CHANNELS)</span>
<span class="cp">#define EFX_TXQ_TYPE_OFFLOAD	1	</span><span class="cm">/* flag */</span><span class="cp"></span>
<span class="cp">#define EFX_TXQ_TYPE_HIGHPRI	2	</span><span class="cm">/* flag */</span><span class="cp"></span>
<span class="cp">#define EFX_TXQ_TYPES		4</span>
<span class="cp">#define EFX_MAX_TX_QUEUES	(EFX_TXQ_TYPES * EFX_MAX_CHANNELS)</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_special_buffer - An Efx special buffer</span>
<span class="cm"> * @addr: CPU base address of the buffer</span>
<span class="cm"> * @dma_addr: DMA base address of the buffer</span>
<span class="cm"> * @len: Buffer length, in bytes</span>
<span class="cm"> * @index: Buffer index within controller;s buffer table</span>
<span class="cm"> * @entries: Number of buffer table entries</span>
<span class="cm"> *</span>
<span class="cm"> * Special buffers are used for the event queues and the TX and RX</span>
<span class="cm"> * descriptor queues for each channel.  They are *not* used for the</span>
<span class="cm"> * actual transmit and receive buffers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_special_buffer</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entries</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_tx_buffer - An Efx TX buffer</span>
<span class="cm"> * @skb: The associated socket buffer.</span>
<span class="cm"> *	Set only on the final fragment of a packet; %NULL for all other</span>
<span class="cm"> *	fragments.  When this fragment completes, then we can free this</span>
<span class="cm"> *	skb.</span>
<span class="cm"> * @tsoh: The associated TSO header structure, or %NULL if this</span>
<span class="cm"> *	buffer is not a TSO header.</span>
<span class="cm"> * @dma_addr: DMA address of the fragment.</span>
<span class="cm"> * @len: Length of this fragment.</span>
<span class="cm"> *	This field is zero when the queue slot is empty.</span>
<span class="cm"> * @continuation: True if this fragment is not the end of a packet.</span>
<span class="cm"> * @unmap_single: True if pci_unmap_single should be used.</span>
<span class="cm"> * @unmap_len: Length of this fragment to unmap</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_tx_buffer</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_tso_header</span> <span class="o">*</span><span class="n">tsoh</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">continuation</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">unmap_single</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">unmap_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_tx_queue - An Efx TX queue</span>
<span class="cm"> *</span>
<span class="cm"> * This is a ring buffer of TX fragments.</span>
<span class="cm"> * Since the TX completion path always executes on the same</span>
<span class="cm"> * CPU and the xmit path can operate on different CPUs,</span>
<span class="cm"> * performance is increased by ensuring that the completion</span>
<span class="cm"> * path and the xmit path operate on different cache lines.</span>
<span class="cm"> * This is particularly important if the xmit path is always</span>
<span class="cm"> * executing on one CPU which is different from the completion</span>
<span class="cm"> * path.  There is also a cache line for members which are</span>
<span class="cm"> * read but not written on the fast path.</span>
<span class="cm"> *</span>
<span class="cm"> * @efx: The associated Efx NIC</span>
<span class="cm"> * @queue: DMA queue number</span>
<span class="cm"> * @channel: The associated channel</span>
<span class="cm"> * @core_txq: The networking core TX queue structure</span>
<span class="cm"> * @buffer: The software buffer ring</span>
<span class="cm"> * @txd: The hardware descriptor ring</span>
<span class="cm"> * @ptr_mask: The size of the ring minus 1.</span>
<span class="cm"> * @initialised: Has hardware queue been initialised?</span>
<span class="cm"> * @read_count: Current read pointer.</span>
<span class="cm"> *	This is the number of buffers that have been removed from both rings.</span>
<span class="cm"> * @old_write_count: The value of @write_count when last checked.</span>
<span class="cm"> *	This is here for performance reasons.  The xmit path will</span>
<span class="cm"> *	only get the up-to-date value of @write_count if this</span>
<span class="cm"> *	variable indicates that the queue is empty.  This is to</span>
<span class="cm"> *	avoid cache-line ping-pong between the xmit path and the</span>
<span class="cm"> *	completion path.</span>
<span class="cm"> * @insert_count: Current insert pointer</span>
<span class="cm"> *	This is the number of buffers that have been added to the</span>
<span class="cm"> *	software ring.</span>
<span class="cm"> * @write_count: Current write pointer</span>
<span class="cm"> *	This is the number of buffers that have been added to the</span>
<span class="cm"> *	hardware ring.</span>
<span class="cm"> * @old_read_count: The value of read_count when last checked.</span>
<span class="cm"> *	This is here for performance reasons.  The xmit path will</span>
<span class="cm"> *	only get the up-to-date value of read_count if this</span>
<span class="cm"> *	variable indicates that the queue is full.  This is to</span>
<span class="cm"> *	avoid cache-line ping-pong between the xmit path and the</span>
<span class="cm"> *	completion path.</span>
<span class="cm"> * @tso_headers_free: A list of TSO headers allocated for this TX queue</span>
<span class="cm"> *	that are not in use, and so available for new TSO sends. The list</span>
<span class="cm"> *	is protected by the TX queue lock.</span>
<span class="cm"> * @tso_bursts: Number of times TSO xmit invoked by kernel</span>
<span class="cm"> * @tso_long_headers: Number of packets with headers too long for standard</span>
<span class="cm"> *	blocks</span>
<span class="cm"> * @tso_packets: Number of packets via the TSO xmit path</span>
<span class="cm"> * @pushes: Number of times the TX push feature has been used</span>
<span class="cm"> * @empty_read_count: If the completion path has seen the queue as empty</span>
<span class="cm"> *	and the transmission path has not yet checked this, the value of</span>
<span class="cm"> *	@read_count bitwise-added to %EFX_EMPTY_COUNT_VALID; otherwise 0.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="p">{</span>
	<span class="cm">/* Members which don&#39;t change on the fast path */</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">core_txq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_tx_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_special_buffer</span> <span class="n">txd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr_mask</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">initialised</span><span class="p">;</span>

	<span class="cm">/* Members used mainly on the completion path */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">read_count</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_write_count</span><span class="p">;</span>

	<span class="cm">/* Members used only on the xmit path */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">insert_count</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">write_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_read_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_tso_header</span> <span class="o">*</span><span class="n">tso_headers_free</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tso_bursts</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tso_long_headers</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tso_packets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pushes</span><span class="p">;</span>

	<span class="cm">/* Members shared between paths and sometimes updated */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">empty_read_count</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
<span class="cp">#define EFX_EMPTY_COUNT_VALID 0x80000000</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_rx_buffer - An Efx RX data buffer</span>
<span class="cm"> * @dma_addr: DMA base address of the buffer</span>
<span class="cm"> * @skb: The associated socket buffer. Valid iff !(@flags &amp; %EFX_RX_BUF_PAGE).</span>
<span class="cm"> *	Will be %NULL if the buffer slot is currently free.</span>
<span class="cm"> * @page: The associated page buffer. Valif iff @flags &amp; %EFX_RX_BUF_PAGE.</span>
<span class="cm"> *	Will be %NULL if the buffer slot is currently free.</span>
<span class="cm"> * @len: Buffer length, in bytes.</span>
<span class="cm"> * @flags: Flags for buffer and packet state.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_rx_buffer</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define EFX_RX_BUF_PAGE		0x0001</span>
<span class="cp">#define EFX_RX_PKT_CSUMMED	0x0002</span>
<span class="cp">#define EFX_RX_PKT_DISCARD	0x0004</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_rx_page_state - Page-based rx buffer state</span>
<span class="cm"> *</span>
<span class="cm"> * Inserted at the start of every page allocated for receive buffers.</span>
<span class="cm"> * Used to facilitate sharing dma mappings between recycled rx buffers</span>
<span class="cm"> * and those passed up to the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * @refcnt: Number of struct efx_rx_buffer&#39;s referencing this page.</span>
<span class="cm"> *	When refcnt falls to zero, the page is unmapped for dma</span>
<span class="cm"> * @dma_addr: The dma address of this page.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_rx_page_state</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">refcnt</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__pad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_rx_queue - An Efx RX queue</span>
<span class="cm"> * @efx: The associated Efx NIC</span>
<span class="cm"> * @buffer: The software buffer ring</span>
<span class="cm"> * @rxd: The hardware descriptor ring</span>
<span class="cm"> * @ptr_mask: The size of the ring minus 1.</span>
<span class="cm"> * @enabled: Receive queue enabled indicator.</span>
<span class="cm"> * @flush_pending: Set when a RX flush is pending. Has the same lifetime as</span>
<span class="cm"> *	@rxq_flush_pending.</span>
<span class="cm"> * @added_count: Number of buffers added to the receive queue.</span>
<span class="cm"> * @notified_count: Number of buffers given to NIC (&lt;= @added_count).</span>
<span class="cm"> * @removed_count: Number of buffers removed from the receive queue.</span>
<span class="cm"> * @max_fill: RX descriptor maximum fill level (&lt;= ring size)</span>
<span class="cm"> * @fast_fill_trigger: RX descriptor fill level that will trigger a fast fill</span>
<span class="cm"> *	(&lt;= @max_fill)</span>
<span class="cm"> * @min_fill: RX descriptor minimum non-zero fill level.</span>
<span class="cm"> *	This records the minimum fill level observed when a ring</span>
<span class="cm"> *	refill was triggered.</span>
<span class="cm"> * @alloc_page_count: RX allocation strategy counter.</span>
<span class="cm"> * @alloc_skb_count: RX allocation strategy counter.</span>
<span class="cm"> * @slow_fill: Timer used to defer efx_nic_generate_fill_event().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_special_buffer</span> <span class="n">rxd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr_mask</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">enabled</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">flush_pending</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">added_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">notified_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">removed_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_fill</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fast_fill_trigger</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_fill</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_overfill</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_page_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_skb_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">slow_fill</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slow_fill_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_buffer - An Efx general-purpose buffer</span>
<span class="cm"> * @addr: host base address of the buffer</span>
<span class="cm"> * @dma_addr: DMA base address of the buffer</span>
<span class="cm"> * @len: Buffer length, in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * The NIC uses these buffers for its interrupt status registers and</span>
<span class="cm"> * MAC stats dumps.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_buffer</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">enum</span> <span class="n">efx_rx_alloc_method</span> <span class="p">{</span>
	<span class="n">RX_ALLOC_METHOD_AUTO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RX_ALLOC_METHOD_SKB</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RX_ALLOC_METHOD_PAGE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_channel - An Efx channel</span>
<span class="cm"> *</span>
<span class="cm"> * A channel comprises an event queue, at least one TX queue, at least</span>
<span class="cm"> * one RX queue, and an associated tasklet for processing the event</span>
<span class="cm"> * queue.</span>
<span class="cm"> *</span>
<span class="cm"> * @efx: Associated Efx NIC</span>
<span class="cm"> * @channel: Channel instance number</span>
<span class="cm"> * @type: Channel type definition</span>
<span class="cm"> * @enabled: Channel enabled indicator</span>
<span class="cm"> * @irq: IRQ number (MSI and MSI-X only)</span>
<span class="cm"> * @irq_moderation: IRQ moderation value (in hardware ticks)</span>
<span class="cm"> * @napi_dev: Net device used with NAPI</span>
<span class="cm"> * @napi_str: NAPI control structure</span>
<span class="cm"> * @work_pending: Is work pending via NAPI?</span>
<span class="cm"> * @eventq: Event queue buffer</span>
<span class="cm"> * @eventq_mask: Event queue pointer mask</span>
<span class="cm"> * @eventq_read_ptr: Event queue read pointer</span>
<span class="cm"> * @event_test_cpu: Last CPU to handle interrupt or test event for this channel</span>
<span class="cm"> * @irq_count: Number of IRQs since last adaptive moderation decision</span>
<span class="cm"> * @irq_mod_score: IRQ moderation score</span>
<span class="cm"> * @rx_alloc_level: Watermark based heuristic counter for pushing descriptors</span>
<span class="cm"> *	and diagnostic counters</span>
<span class="cm"> * @rx_alloc_push_pages: RX allocation method currently in use for pushing</span>
<span class="cm"> *	descriptors</span>
<span class="cm"> * @n_rx_tobe_disc: Count of RX_TOBE_DISC errors</span>
<span class="cm"> * @n_rx_ip_hdr_chksum_err: Count of RX IP header checksum errors</span>
<span class="cm"> * @n_rx_tcp_udp_chksum_err: Count of RX TCP and UDP checksum errors</span>
<span class="cm"> * @n_rx_mcast_mismatch: Count of unmatched multicast frames</span>
<span class="cm"> * @n_rx_frm_trunc: Count of RX_FRM_TRUNC errors</span>
<span class="cm"> * @n_rx_overlength: Count of RX_OVERLENGTH errors</span>
<span class="cm"> * @n_skbuff_leaks: Count of skbuffs leaked due to RX overrun</span>
<span class="cm"> * @rx_queue: RX queue for this channel</span>
<span class="cm"> * @tx_queue: TX queues for this channel</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_channel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_channel_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">enabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_moderation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">napi_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi_str</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">work_pending</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_special_buffer</span> <span class="n">eventq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eventq_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eventq_read_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">event_test_cpu</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_mod_score</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rfs_filters_added</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">int</span> <span class="n">rx_alloc_level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_alloc_push_pages</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">n_rx_tobe_disc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_rx_ip_hdr_chksum_err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_rx_tcp_udp_chksum_err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_rx_mcast_mismatch</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_rx_frm_trunc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_rx_overlength</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_skbuff_leaks</span><span class="p">;</span>

	<span class="cm">/* Used to pipeline received packets in order to optimise memory</span>
<span class="cm">	 * access with prefetches.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">efx_rx_buffer</span> <span class="o">*</span><span class="n">rx_pkt</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="n">rx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="n">tx_queue</span><span class="p">[</span><span class="n">EFX_TXQ_TYPES</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_channel_type - distinguishes traffic and extra channels</span>
<span class="cm"> * @handle_no_channel: Handle failure to allocate an extra channel</span>
<span class="cm"> * @pre_probe: Set up extra state prior to initialisation</span>
<span class="cm"> * @post_remove: Tear down extra state after finalisation, if allocated.</span>
<span class="cm"> *	May be called on channels that have not been probed.</span>
<span class="cm"> * @get_name: Generate the channel&#39;s name (used for its IRQ handler)</span>
<span class="cm"> * @copy: Copy the channel state prior to reallocation.  May be %NULL if</span>
<span class="cm"> *	reallocation is not supported.</span>
<span class="cm"> * @keep_eventq: Flag for whether event queue should be kept initialised</span>
<span class="cm"> *	while the device is stopped</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_channel_type</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handle_no_channel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pre_probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_name</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">keep_eventq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">efx_led_mode</span> <span class="p">{</span>
	<span class="n">EFX_LED_OFF</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">EFX_LED_ON</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">EFX_LED_DEFAULT</span>	<span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="cp">#define STRING_TABLE_LOOKUP(val, member) \</span>
<span class="cp">	((val) &lt; member ## _max) ? member ## _names[val] : &quot;(invalid)&quot;</span>

<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">efx_loopback_mode_names</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">efx_loopback_mode_max</span><span class="p">;</span>
<span class="cp">#define LOOPBACK_MODE(efx) \</span>
<span class="cp">	STRING_TABLE_LOOKUP((efx)-&gt;loopback_mode, efx_loopback_mode)</span>

<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">efx_reset_type_names</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">efx_reset_type_max</span><span class="p">;</span>
<span class="cp">#define RESET_TYPE(type) \</span>
<span class="cp">	STRING_TABLE_LOOKUP(type, efx_reset_type)</span>

<span class="k">enum</span> <span class="n">efx_int_mode</span> <span class="p">{</span>
	<span class="cm">/* Be careful if altering to correct macro below */</span>
	<span class="n">EFX_INT_MODE_MSIX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">EFX_INT_MODE_MSI</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">EFX_INT_MODE_LEGACY</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">EFX_INT_MODE_MAX</span>	<span class="cm">/* Insert any new items before this */</span>
<span class="p">};</span>
<span class="cp">#define EFX_INT_MODE_USE_MSI(x) (((x)-&gt;interrupt_mode) &lt;= EFX_INT_MODE_MSI)</span>

<span class="k">enum</span> <span class="n">nic_state</span> <span class="p">{</span>
	<span class="n">STATE_INIT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">STATE_RUNNING</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">STATE_FINI</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">STATE_DISABLED</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">STATE_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Alignment of page-allocated RX buffers</span>
<span class="cm"> *</span>
<span class="cm"> * Controls the number of bytes inserted at the start of an RX buffer.</span>
<span class="cm"> * This is the equivalent of NET_IP_ALIGN [which controls the alignment</span>
<span class="cm"> * of the skb-&gt;head for hardware DMA].</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS</span>
<span class="cp">#define EFX_PAGE_IP_ALIGN 0</span>
<span class="cp">#else</span>
<span class="cp">#define EFX_PAGE_IP_ALIGN NET_IP_ALIGN</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Alignment of the skb-&gt;head which wraps a page-allocated RX buffer</span>
<span class="cm"> *</span>
<span class="cm"> * The skb allocated to wrap an rx_buffer can have this alignment. Since</span>
<span class="cm"> * the data is memcpy&#39;d from the rx_buf, it does not need to be equal to</span>
<span class="cm"> * EFX_PAGE_IP_ALIGN.</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_PAGE_SKB_ALIGN 2</span>

<span class="cm">/* Forward declaration */</span>
<span class="k">struct</span> <span class="n">efx_nic</span><span class="p">;</span>

<span class="cm">/* Pseudo bit-mask flow control field */</span>
<span class="cp">#define EFX_FC_RX	FLOW_CTRL_RX</span>
<span class="cp">#define EFX_FC_TX	FLOW_CTRL_TX</span>
<span class="cp">#define EFX_FC_AUTO	4</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_link_state - Current state of the link</span>
<span class="cm"> * @up: Link is up</span>
<span class="cm"> * @fd: Link is full-duplex</span>
<span class="cm"> * @fc: Actual flow control flags</span>
<span class="cm"> * @speed: Link speed (Mbps)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_link_state</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">up</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">efx_link_state_equal</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_link_state</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_link_state</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">==</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">&amp;&amp;</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">==</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">&amp;&amp;</span>
		<span class="n">left</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">==</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">&amp;&amp;</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_phy_operations - Efx PHY operations table</span>
<span class="cm"> * @probe: Probe PHY and initialise efx-&gt;mdio.mode_support, efx-&gt;mdio.mmds,</span>
<span class="cm"> *	efx-&gt;loopback_modes.</span>
<span class="cm"> * @init: Initialise PHY</span>
<span class="cm"> * @fini: Shut down PHY</span>
<span class="cm"> * @reconfigure: Reconfigure PHY (e.g. for new link parameters)</span>
<span class="cm"> * @poll: Update @link_state and report whether it changed.</span>
<span class="cm"> *	Serialised by the mac_lock.</span>
<span class="cm"> * @get_settings: Get ethtool settings. Serialised by the mac_lock.</span>
<span class="cm"> * @set_settings: Set ethtool settings. Serialised by the mac_lock.</span>
<span class="cm"> * @set_npage_adv: Set abilities advertised in (Extended) Next Page</span>
<span class="cm"> *	(only needed where AN bit is set in mmds)</span>
<span class="cm"> * @test_alive: Test that PHY is &#39;alive&#39; (online)</span>
<span class="cm"> * @test_name: Get the name of a PHY-specific test/result</span>
<span class="cm"> * @run_tests: Run tests and record results as appropriate (offline).</span>
<span class="cm"> *	Flags are the ethtool tests flags.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_phy_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fini</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reconfigure</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_settings</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_settings</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_npage_adv</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test_alive</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">test_name</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">run_tests</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">results</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_module_eeprom</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ethtool_eeprom</span> <span class="o">*</span><span class="n">ee</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_module_info</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ethtool_modinfo</span> <span class="o">*</span><span class="n">modinfo</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * @enum efx_phy_mode - PHY operating mode flags</span>
<span class="cm"> * @PHY_MODE_NORMAL: on and should pass traffic</span>
<span class="cm"> * @PHY_MODE_TX_DISABLED: on with TX disabled</span>
<span class="cm"> * @PHY_MODE_LOW_POWER: set to low power through MDIO</span>
<span class="cm"> * @PHY_MODE_OFF: switched off through external control</span>
<span class="cm"> * @PHY_MODE_SPECIAL: on but will not pass traffic</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">efx_phy_mode</span> <span class="p">{</span>
	<span class="n">PHY_MODE_NORMAL</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PHY_MODE_TX_DISABLED</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">PHY_MODE_LOW_POWER</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">PHY_MODE_OFF</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">PHY_MODE_SPECIAL</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">efx_phy_mode_disabled</span><span class="p">(</span><span class="k">enum</span> <span class="n">efx_phy_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PHY_MODE_TX_DISABLED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Efx extended statistics</span>
<span class="cm"> *</span>
<span class="cm"> * Not all statistics are provided by all supported MACs.  The purpose</span>
<span class="cm"> * is this structure is to contain the raw statistics provided by each</span>
<span class="cm"> * MAC.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_mac_stats</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">tx_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_good_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_bad_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_packets</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_bad</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_pause</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_control</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_unicast</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_multicast</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_broadcast</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_lt64</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_64</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_65_to_127</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_128_to_255</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_256_to_511</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_512_to_1023</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_1024_to_15xx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_15xx_to_jumbo</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_gtjumbo</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_collision</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_single_collision</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_multiple_collision</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_excessive_collision</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_deferred</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_late_collision</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_excessive_deferred</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_non_tcpudp</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_mac_src_error</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_ip_src_error</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_good_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_bad_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_packets</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_good</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_bad</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_pause</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_control</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_unicast</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_multicast</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_broadcast</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_lt64</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_64</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_65_to_127</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_128_to_255</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_256_to_511</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_512_to_1023</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_1024_to_15xx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_15xx_to_jumbo</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_gtjumbo</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_bad_lt64</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_bad_64_to_15xx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_bad_15xx_to_jumbo</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_bad_gtjumbo</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_overflow</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_missed</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_false_carrier</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_symbol_error</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_align_error</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_length_error</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_internal_error</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_good_lt64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Number of bits used in a multicast filter hash address */</span>
<span class="cp">#define EFX_MCAST_HASH_BITS 8</span>

<span class="cm">/* Number of (single-bit) entries in a multicast filter hash */</span>
<span class="cp">#define EFX_MCAST_HASH_ENTRIES (1 &lt;&lt; EFX_MCAST_HASH_BITS)</span>

<span class="cm">/* An Efx multicast filter hash */</span>
<span class="k">union</span> <span class="n">efx_multicast_hash</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">byte</span><span class="p">[</span><span class="n">EFX_MCAST_HASH_ENTRIES</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
	<span class="n">efx_oword_t</span> <span class="n">oword</span><span class="p">[</span><span class="n">EFX_MCAST_HASH_ENTRIES</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_oword_t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">efx_filter_state</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">efx_vf</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vfdi_status</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_nic - an Efx NIC</span>
<span class="cm"> * @name: Device name (net device name or bus id before net device registered)</span>
<span class="cm"> * @pci_dev: The PCI device</span>
<span class="cm"> * @type: Controller type attributes</span>
<span class="cm"> * @legacy_irq: IRQ number</span>
<span class="cm"> * @legacy_irq_enabled: Are IRQs enabled on NIC (INT_EN_KER register)?</span>
<span class="cm"> * @workqueue: Workqueue for port reconfigures and the HW monitor.</span>
<span class="cm"> *	Work items do not hold and must not acquire RTNL.</span>
<span class="cm"> * @workqueue_name: Name of workqueue</span>
<span class="cm"> * @reset_work: Scheduled reset workitem</span>
<span class="cm"> * @membase_phys: Memory BAR value as physical address</span>
<span class="cm"> * @membase: Memory BAR value</span>
<span class="cm"> * @interrupt_mode: Interrupt mode</span>
<span class="cm"> * @timer_quantum_ns: Interrupt timer quantum, in nanoseconds</span>
<span class="cm"> * @irq_rx_adaptive: Adaptive IRQ moderation enabled for RX event queues</span>
<span class="cm"> * @irq_rx_moderation: IRQ moderation time for RX event queues</span>
<span class="cm"> * @msg_enable: Log message enable flags</span>
<span class="cm"> * @state: Device state flag. Serialised by the rtnl_lock.</span>
<span class="cm"> * @reset_pending: Bitmask for pending resets</span>
<span class="cm"> * @tx_queue: TX DMA queues</span>
<span class="cm"> * @rx_queue: RX DMA queues</span>
<span class="cm"> * @channel: Channels</span>
<span class="cm"> * @channel_name: Names for channels and their IRQs</span>
<span class="cm"> * @extra_channel_types: Types of extra (non-traffic) channels that</span>
<span class="cm"> *	should be allocated for this NIC</span>
<span class="cm"> * @rxq_entries: Size of receive queues requested by user.</span>
<span class="cm"> * @txq_entries: Size of transmit queues requested by user.</span>
<span class="cm"> * @tx_dc_base: Base qword address in SRAM of TX queue descriptor caches</span>
<span class="cm"> * @rx_dc_base: Base qword address in SRAM of RX queue descriptor caches</span>
<span class="cm"> * @sram_lim_qw: Qword address limit of SRAM</span>
<span class="cm"> * @next_buffer_table: First available buffer table id</span>
<span class="cm"> * @n_channels: Number of channels in use</span>
<span class="cm"> * @n_rx_channels: Number of channels used for RX (= number of RX queues)</span>
<span class="cm"> * @n_tx_channels: Number of channels used for TX</span>
<span class="cm"> * @rx_buffer_len: RX buffer length</span>
<span class="cm"> * @rx_buffer_order: Order (log2) of number of pages for each RX buffer</span>
<span class="cm"> * @rx_hash_key: Toeplitz hash key for RSS</span>
<span class="cm"> * @rx_indir_table: Indirection table for RSS</span>
<span class="cm"> * @int_error_count: Number of internal errors seen recently</span>
<span class="cm"> * @int_error_expire: Time at which error count will be expired</span>
<span class="cm"> * @irq_status: Interrupt status buffer</span>
<span class="cm"> * @irq_zero_count: Number of legacy IRQs seen with queue flags == 0</span>
<span class="cm"> * @irq_level: IRQ level/index for IRQs not triggered by an event queue</span>
<span class="cm"> * @selftest_work: Work item for asynchronous self-test</span>
<span class="cm"> * @mtd_list: List of MTDs attached to the NIC</span>
<span class="cm"> * @nic_data: Hardware dependent state</span>
<span class="cm"> * @mac_lock: MAC access lock. Protects @port_enabled, @phy_mode,</span>
<span class="cm"> *	efx_monitor() and efx_reconfigure_port()</span>
<span class="cm"> * @port_enabled: Port enabled indicator.</span>
<span class="cm"> *	Serialises efx_stop_all(), efx_start_all(), efx_monitor() and</span>
<span class="cm"> *	efx_mac_work() with kernel interfaces. Safe to read under any</span>
<span class="cm"> *	one of the rtnl_lock, mac_lock, or netif_tx_lock, but all three must</span>
<span class="cm"> *	be held to modify it.</span>
<span class="cm"> * @port_initialized: Port initialized?</span>
<span class="cm"> * @net_dev: Operating system network device. Consider holding the rtnl lock</span>
<span class="cm"> * @stats_buffer: DMA buffer for statistics</span>
<span class="cm"> * @phy_type: PHY type</span>
<span class="cm"> * @phy_op: PHY interface</span>
<span class="cm"> * @phy_data: PHY private data (including PHY-specific stats)</span>
<span class="cm"> * @mdio: PHY MDIO interface</span>
<span class="cm"> * @mdio_bus: PHY MDIO bus ID (only used by Siena)</span>
<span class="cm"> * @phy_mode: PHY operating mode. Serialised by @mac_lock.</span>
<span class="cm"> * @link_advertising: Autonegotiation advertising flags</span>
<span class="cm"> * @link_state: Current state of the link</span>
<span class="cm"> * @n_link_state_changes: Number of times the link has changed state</span>
<span class="cm"> * @promiscuous: Promiscuous flag. Protected by netif_tx_lock.</span>
<span class="cm"> * @multicast_hash: Multicast hash table</span>
<span class="cm"> * @wanted_fc: Wanted flow control flags</span>
<span class="cm"> * @fc_disable: When non-zero flow control is disabled. Typically used to</span>
<span class="cm"> *	ensure that network back pressure doesn&#39;t delay dma queue flushes.</span>
<span class="cm"> *	Serialised by the rtnl lock.</span>
<span class="cm"> * @mac_work: Work item for changing MAC promiscuity and multicast hash</span>
<span class="cm"> * @loopback_mode: Loopback status</span>
<span class="cm"> * @loopback_modes: Supported loopback mode bitmask</span>
<span class="cm"> * @loopback_selftest: Offline self-test private state</span>
<span class="cm"> * @drain_pending: Count of RX and TX queues that haven&#39;t been flushed and drained.</span>
<span class="cm"> * @rxq_flush_pending: Count of number of receive queues that need to be flushed.</span>
<span class="cm"> *	Decremented when the efx_flush_rx_queue() is called.</span>
<span class="cm"> * @rxq_flush_outstanding: Count of number of RX flushes started but not yet</span>
<span class="cm"> *	completed (either success or failure). Not used when MCDI is used to</span>
<span class="cm"> *	flush receive queues.</span>
<span class="cm"> * @flush_wq: wait queue used by efx_nic_flush_queues() to wait for flush completions.</span>
<span class="cm"> * @vf: Array of &amp;struct efx_vf objects.</span>
<span class="cm"> * @vf_count: Number of VFs intended to be enabled.</span>
<span class="cm"> * @vf_init_count: Number of VFs that have been fully initialised.</span>
<span class="cm"> * @vi_scale: log2 number of vnics per VF.</span>
<span class="cm"> * @vf_buftbl_base: The zeroth buffer table index used to back VF queues.</span>
<span class="cm"> * @vfdi_status: Common VFDI status page to be dmad to VF address space.</span>
<span class="cm"> * @local_addr_list: List of local addresses. Protected by %local_lock.</span>
<span class="cm"> * @local_page_list: List of DMA addressable pages used to broadcast</span>
<span class="cm"> *	%local_addr_list. Protected by %local_lock.</span>
<span class="cm"> * @local_lock: Mutex protecting %local_addr_list and %local_page_list.</span>
<span class="cm"> * @peer_work: Work item to broadcast peer addresses to VMs.</span>
<span class="cm"> * @monitor_work: Hardware monitor workitem</span>
<span class="cm"> * @biu_lock: BIU (bus interface unit) lock</span>
<span class="cm"> * @last_irq_cpu: Last CPU to handle a possible test interrupt.  This</span>
<span class="cm"> *	field is used by efx_test_interrupts() to verify that an</span>
<span class="cm"> *	interrupt has occurred.</span>
<span class="cm"> * @n_rx_nodesc_drop_cnt: RX no descriptor drop count</span>
<span class="cm"> * @mac_stats: MAC statistics. These include all statistics the MACs</span>
<span class="cm"> *	can provide.  Generic code converts these into a standard</span>
<span class="cm"> *	&amp;struct net_device_stats.</span>
<span class="cm"> * @stats_lock: Statistics update lock. Serialises statistics fetches</span>
<span class="cm"> *	and access to @mac_stats.</span>
<span class="cm"> *</span>
<span class="cm"> * This is stored in the private area of the &amp;struct net_device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_nic</span> <span class="p">{</span>
	<span class="cm">/* The following fields should be written very rarely */</span>

	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">legacy_irq</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">legacy_irq_enabled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">workqueue</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">workqueue_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reset_work</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">membase_phys</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">membase</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">efx_int_mode</span> <span class="n">interrupt_mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_quantum_ns</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">irq_rx_adaptive</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_rx_moderation</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_enable</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">nic_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reset_pending</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">[</span><span class="n">EFX_MAX_CHANNELS</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">channel_name</span><span class="p">[</span><span class="n">EFX_MAX_CHANNELS</span><span class="p">][</span><span class="n">IFNAMSIZ</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_channel_type</span> <span class="o">*</span>
	<span class="n">extra_channel_type</span><span class="p">[</span><span class="n">EFX_MAX_EXTRA_CHANNELS</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="n">rxq_entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">txq_entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tx_dc_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rx_dc_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">sram_lim_qw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">next_buffer_table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_channels</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_rx_channels</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rss_spread</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tx_channel_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_tx_channels</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_buffer_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_buffer_order</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rx_hash_key</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">rx_indir_table</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="n">int_error_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">int_error_expire</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">efx_buffer</span> <span class="n">irq_status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">irq_zero_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">irq_level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">selftest_work</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SFC_MTD</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mtd_list</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">nic_data</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mac_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">mac_work</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">port_enabled</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">port_initialized</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">efx_buffer</span> <span class="n">stats_buffer</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">phy_type</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_phy_operations</span> <span class="o">*</span><span class="n">phy_op</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">phy_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mdio_if_info</span> <span class="n">mdio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mdio_bus</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">efx_phy_mode</span> <span class="n">phy_mode</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">link_advertising</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_link_state</span> <span class="n">link_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_link_state_changes</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">promiscuous</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">efx_multicast_hash</span> <span class="n">multicast_hash</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wanted_fc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">fc_disable</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">rx_reset</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">efx_loopback_mode</span> <span class="n">loopback_mode</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">loopback_modes</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">loopback_selftest</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">filter_state</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">drain_pending</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">rxq_flush_pending</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">rxq_flush_outstanding</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">flush_wq</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SFC_SRIOV</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">vfdi_channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vf_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vf_init_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vi_scale</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vf_buftbl_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_buffer</span> <span class="n">vfdi_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">local_addr_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">local_page_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">local_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">peer_work</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* The following fields may be written more often */</span>

	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">monitor_work</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">biu_lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_irq_cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_rx_nodesc_drop_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_mac_stats</span> <span class="n">mac_stats</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">stats_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">efx_dev_registered</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">==</span> <span class="n">NETREG_REGISTERED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">efx_port_num</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_nic_type - Efx device type definition</span>
<span class="cm"> * @probe: Probe the controller</span>
<span class="cm"> * @remove: Free resources allocated by probe()</span>
<span class="cm"> * @init: Initialise the controller</span>
<span class="cm"> * @dimension_resources: Dimension controller resources (buffer table,</span>
<span class="cm"> *	and VIs once the available interrupt resources are clear)</span>
<span class="cm"> * @fini: Shut down the controller</span>
<span class="cm"> * @monitor: Periodic function for polling link state and hardware monitor</span>
<span class="cm"> * @map_reset_reason: Map ethtool reset reason to a reset method</span>
<span class="cm"> * @map_reset_flags: Map ethtool reset flags to a reset method, if possible</span>
<span class="cm"> * @reset: Reset the controller hardware and possibly the PHY.  This will</span>
<span class="cm"> *	be called while the controller is uninitialised.</span>
<span class="cm"> * @probe_port: Probe the MAC and PHY</span>
<span class="cm"> * @remove_port: Free resources allocated by probe_port()</span>
<span class="cm"> * @handle_global_event: Handle a &quot;global&quot; event (may be %NULL)</span>
<span class="cm"> * @prepare_flush: Prepare the hardware for flushing the DMA queues</span>
<span class="cm"> * @update_stats: Update statistics not provided by event handling</span>
<span class="cm"> * @start_stats: Start the regular fetching of statistics</span>
<span class="cm"> * @stop_stats: Stop the regular fetching of statistics</span>
<span class="cm"> * @set_id_led: Set state of identifying LED or revert to automatic function</span>
<span class="cm"> * @push_irq_moderation: Apply interrupt moderation value</span>
<span class="cm"> * @reconfigure_port: Push loopback/power/txdis changes to the MAC and PHY</span>
<span class="cm"> * @reconfigure_mac: Push MAC address, MTU, flow control and filter settings</span>
<span class="cm"> *	to the hardware.  Serialised by the mac_lock.</span>
<span class="cm"> * @check_mac_fault: Check MAC fault state. True if fault present.</span>
<span class="cm"> * @get_wol: Get WoL configuration from driver state</span>
<span class="cm"> * @set_wol: Push WoL configuration to the NIC</span>
<span class="cm"> * @resume_wol: Synchronise WoL state between driver and MC (e.g. after resume)</span>
<span class="cm"> * @test_registers: Test read/write functionality of control registers</span>
<span class="cm"> * @test_nvram: Test validity of NVRAM contents</span>
<span class="cm"> * @revision: Hardware architecture revision</span>
<span class="cm"> * @mem_map_size: Memory BAR mapped size</span>
<span class="cm"> * @txd_ptr_tbl_base: TX descriptor ring base address</span>
<span class="cm"> * @rxd_ptr_tbl_base: RX descriptor ring base address</span>
<span class="cm"> * @buf_tbl_base: Buffer table base address</span>
<span class="cm"> * @evq_ptr_tbl_base: Event queue pointer table base address</span>
<span class="cm"> * @evq_rptr_tbl_base: Event queue read-pointer table base address</span>
<span class="cm"> * @max_dma_mask: Maximum possible DMA mask</span>
<span class="cm"> * @rx_buffer_hash_size: Size of hash at start of RX buffer</span>
<span class="cm"> * @rx_buffer_padding: Size of padding at end of RX buffer</span>
<span class="cm"> * @max_interrupt_mode: Highest capability interrupt mode supported</span>
<span class="cm"> *	from &amp;enum efx_init_mode.</span>
<span class="cm"> * @phys_addr_channels: Number of channels with physically addressed</span>
<span class="cm"> *	descriptors</span>
<span class="cm"> * @timer_period_max: Maximum period of interrupt timer (in ticks)</span>
<span class="cm"> * @offload_features: net_device feature flags for protocol offload</span>
<span class="cm"> *	features implemented in hardware</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_nic_type</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dimension_resources</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fini</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">monitor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">reset_type</span> <span class="p">(</span><span class="o">*</span><span class="n">map_reset_reason</span><span class="p">)(</span><span class="k">enum</span> <span class="n">reset_type</span> <span class="n">reason</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">map_reset_flags</span><span class="p">)(</span><span class="n">u32</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">reset_type</span> <span class="n">method</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">handle_global_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">prepare_flush</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">update_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">start_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">stop_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_id_led</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">efx_led_mode</span> <span class="n">mode</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">push_irq_moderation</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reconfigure_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reconfigure_mac</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">check_mac_fault</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_wol</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_wol</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">type</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resume_wol</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test_registers</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test_nvram</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">revision</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mem_map_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">txd_ptr_tbl_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxd_ptr_tbl_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buf_tbl_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evq_ptr_tbl_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evq_rptr_tbl_base</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">max_dma_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_buffer_hash_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_buffer_padding</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_interrupt_mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">phys_addr_channels</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_period_max</span><span class="p">;</span>
	<span class="n">netdev_features_t</span> <span class="n">offload_features</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Prototypes and inline functions</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span>
<span class="nf">efx_get_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Iterate over all used channels */</span>
<span class="cp">#define efx_for_each_channel(_channel, _efx)				\</span>
<span class="cp">	for (_channel = (_efx)-&gt;channel[0];				\</span>
<span class="cp">	     _channel;							\</span>
<span class="cp">	     _channel = (_channel-&gt;channel + 1 &lt; (_efx)-&gt;n_channels) ?	\</span>
<span class="cp">		     (_efx)-&gt;channel[_channel-&gt;channel + 1] : NULL)</span>

<span class="cm">/* Iterate over all used channels in reverse */</span>
<span class="cp">#define efx_for_each_channel_rev(_channel, _efx)			\</span>
<span class="cp">	for (_channel = (_efx)-&gt;channel[(_efx)-&gt;n_channels - 1];	\</span>
<span class="cp">	     _channel;							\</span>
<span class="cp">	     _channel = _channel-&gt;channel ?				\</span>
<span class="cp">		     (_efx)-&gt;channel[_channel-&gt;channel - 1] : NULL)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span>
<span class="nf">efx_get_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span> <span class="o">||</span>
			    <span class="n">type</span> <span class="o">&gt;=</span> <span class="n">EFX_TXQ_TYPES</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_channel_offset</span> <span class="o">+</span> <span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">efx_channel_has_tx_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">-</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_channel_offset</span> <span class="o">&lt;</span>
		<span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span>
<span class="nf">efx_channel_get_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="o">!</span><span class="n">efx_channel_has_tx_queues</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">type</span> <span class="o">&gt;=</span> <span class="n">EFX_TXQ_TYPES</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">efx_tx_queue_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">num_tc</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
		 <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">&amp;</span> <span class="n">EFX_TXQ_TYPE_HIGHPRI</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Iterate over all TX queues belonging to a channel */</span>
<span class="cp">#define efx_for_each_channel_tx_queue(_tx_queue, _channel)		\</span>
<span class="cp">	if (!efx_channel_has_tx_queues(_channel))			\</span>
<span class="cp">		;							\</span>
<span class="cp">	else								\</span>
<span class="cp">		for (_tx_queue = (_channel)-&gt;tx_queue;			\</span>
<span class="cp">		     _tx_queue &lt; (_channel)-&gt;tx_queue + EFX_TXQ_TYPES &amp;&amp; \</span>
<span class="cp">			     efx_tx_queue_used(_tx_queue);		\</span>
<span class="cp">		     _tx_queue++)</span>

<span class="cm">/* Iterate over all possible TX queues belonging to a channel */</span>
<span class="cp">#define efx_for_each_possible_channel_tx_queue(_tx_queue, _channel)	\</span>
<span class="cp">	if (!efx_channel_has_tx_queues(_channel))			\</span>
<span class="cp">		;							\</span>
<span class="cp">	else								\</span>
<span class="cp">		for (_tx_queue = (_channel)-&gt;tx_queue;			\</span>
<span class="cp">		     _tx_queue &lt; (_channel)-&gt;tx_queue + EFX_TXQ_TYPES;	\</span>
<span class="cp">		     _tx_queue++)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">efx_channel_has_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_channels</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span>
<span class="nf">efx_channel_get_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="o">!</span><span class="n">efx_channel_has_rx_queue</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Iterate over all RX queues belonging to a channel */</span>
<span class="cp">#define efx_for_each_channel_rx_queue(_rx_queue, _channel)		\</span>
<span class="cp">	if (!efx_channel_has_rx_queue(_channel))			\</span>
<span class="cp">		;							\</span>
<span class="cp">	else								\</span>
<span class="cp">		for (_rx_queue = &amp;(_channel)-&gt;rx_queue;			\</span>
<span class="cp">		     _rx_queue;						\</span>
<span class="cp">		     _rx_queue = NULL)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span>
<span class="nf">efx_rx_queue_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_channel</span><span class="p">,</span> <span class="n">rx_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">efx_rx_queue_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">efx_rx_queue_channel</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns a pointer to the specified receive buffer in the RX</span>
<span class="cm"> * descriptor queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">efx_rx_buffer</span> <span class="o">*</span><span class="nf">efx_rx_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">,</span>
						  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Set bit in a little-endian bitfield */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_bit_le</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">addr</span><span class="p">[</span><span class="n">nr</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">%</span> <span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Clear bit in a little-endian bitfield */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_bit_le</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">addr</span><span class="p">[</span><span class="n">nr</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">%</span> <span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * EFX_MAX_FRAME_LEN - calculate maximum frame length</span>
<span class="cm"> *</span>
<span class="cm"> * This calculates the maximum frame length that will be used for a</span>
<span class="cm"> * given MTU.  The frame length will be equal to the MTU plus a</span>
<span class="cm"> * constant amount of header space and padding.  This is the quantity</span>
<span class="cm"> * that the net driver will program into the MAC as the maximum frame</span>
<span class="cm"> * length.</span>
<span class="cm"> *</span>
<span class="cm"> * The 10G MAC requires 8-byte alignment on the frame</span>
<span class="cm"> * length, so we round up to the nearest 8.</span>
<span class="cm"> *</span>
<span class="cm"> * Re-clocking by the XGXS on RX can reduce an IPG to 32 bits (half an</span>
<span class="cm"> * XGMII cycle).  If the frame length reaches the maximum value in the</span>
<span class="cm"> * same cycle, the XMAC can miss the IPG altogether.  We work around</span>
<span class="cm"> * this by adding a further 16 bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_MAX_FRAME_LEN(mtu) \</span>
<span class="cp">	((((mtu) + ETH_HLEN + VLAN_HLEN + 4</span><span class="cm">/* FCS */</span><span class="cp"> + 7) &amp; ~7) + 16)</span>


<span class="cp">#endif </span><span class="cm">/* EFX_NET_DRIVER_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
