<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › efx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>efx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2005-2006 Fen Systems Ltd.</span>
<span class="cm"> * Copyright 2005-2011 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/topology.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/cpu_rmap.h&gt;</span>
<span class="cp">#include &quot;net_driver.h&quot;</span>
<span class="cp">#include &quot;efx.h&quot;</span>
<span class="cp">#include &quot;nic.h&quot;</span>
<span class="cp">#include &quot;selftest.h&quot;</span>

<span class="cp">#include &quot;mcdi.h&quot;</span>
<span class="cp">#include &quot;workarounds.h&quot;</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Type name strings</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="cm">/* Loopback mode names (see LOOPBACK_MODE()) */</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">efx_loopback_mode_max</span> <span class="o">=</span> <span class="n">LOOPBACK_MAX</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">efx_loopback_mode_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">LOOPBACK_NONE</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;NONE&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_DATA</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;DATAPATH&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_GMAC</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;GMAC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XGMII</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;XGMII&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XGXS</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;XGXS&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XAUI</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;XAUI&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_GMII</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;GMII&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_SGMII</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;SGMII&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XGBR</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;XGBR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XFI</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;XFI&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XAUI_FAR</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;XAUI_FAR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_GMII_FAR</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;GMII_FAR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_SGMII_FAR</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;SGMII_FAR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XFI_FAR</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;XFI_FAR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_GPHY</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;GPHY&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_PHYXS</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;PHYXS&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_PCS</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;PCS&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_PMAPMD</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;PMA/PMD&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XPORT</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;XPORT&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XGMII_WS</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;XGMII_WS&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XAUI_WS</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;XAUI_WS&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XAUI_WS_FAR</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;XAUI_WS_FAR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XAUI_WS_NEAR</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;XAUI_WS_NEAR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_GMII_WS</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;GMII_WS&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XFI_WS</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;XFI_WS&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_XFI_WS_FAR</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;XFI_WS_FAR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">LOOPBACK_PHYXS_WS</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;PHYXS_WS&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">efx_reset_type_max</span> <span class="o">=</span> <span class="n">RESET_TYPE_MAX</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">efx_reset_type_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">RESET_TYPE_INVISIBLE</span><span class="p">]</span>     <span class="o">=</span> <span class="s">&quot;INVISIBLE&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RESET_TYPE_ALL</span><span class="p">]</span>           <span class="o">=</span> <span class="s">&quot;ALL&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RESET_TYPE_WORLD</span><span class="p">]</span>         <span class="o">=</span> <span class="s">&quot;WORLD&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RESET_TYPE_DISABLE</span><span class="p">]</span>       <span class="o">=</span> <span class="s">&quot;DISABLE&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RESET_TYPE_TX_WATCHDOG</span><span class="p">]</span>   <span class="o">=</span> <span class="s">&quot;TX_WATCHDOG&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RESET_TYPE_INT_ERROR</span><span class="p">]</span>     <span class="o">=</span> <span class="s">&quot;INT_ERROR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RESET_TYPE_RX_RECOVERY</span><span class="p">]</span>   <span class="o">=</span> <span class="s">&quot;RX_RECOVERY&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RESET_TYPE_RX_DESC_FETCH</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;RX_DESC_FETCH&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RESET_TYPE_TX_DESC_FETCH</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;TX_DESC_FETCH&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RESET_TYPE_TX_SKIP</span><span class="p">]</span>       <span class="o">=</span> <span class="s">&quot;TX_SKIP&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RESET_TYPE_MC_FAILURE</span><span class="p">]</span>    <span class="o">=</span> <span class="s">&quot;MC_FAILURE&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define EFX_MAX_MTU (9 * 1024)</span>

<span class="cm">/* Reset workqueue. If any NIC has a hardware failure then a reset will be</span>
<span class="cm"> * queued onto this work queue. This is not a per-nic work queue, because</span>
<span class="cm"> * efx_reset_work() acquires the rtnl lock, so resets are naturally serialised.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">reset_workqueue</span><span class="p">;</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Configurable values</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Use separate channels for TX and RX events</span>
<span class="cm"> *</span>
<span class="cm"> * Set this to 1 to use separate channels for TX and RX. It allows us</span>
<span class="cm"> * to control interrupt affinity separately for TX and RX.</span>
<span class="cm"> *</span>
<span class="cm"> * This is only used in MSI-X interrupt mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">separate_tx_channels</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">separate_tx_channels</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">separate_tx_channels</span><span class="p">,</span>
		 <span class="s">&quot;Use separate channels for TX and RX&quot;</span><span class="p">);</span>

<span class="cm">/* This is the weight assigned to each of the (per-channel) virtual</span>
<span class="cm"> * NAPI devices.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">napi_weight</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

<span class="cm">/* This is the time (in jiffies) between invocations of the hardware</span>
<span class="cm"> * monitor.  On Falcon-based NICs, this will:</span>
<span class="cm"> * - Check the on-board hardware monitor;</span>
<span class="cm"> * - Poll the link state and reconfigure the hardware as necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">efx_monitor_interval</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

<span class="cm">/* Initial interrupt moderation settings.  They can be modified after</span>
<span class="cm"> * module load with ethtool.</span>
<span class="cm"> *</span>
<span class="cm"> * The default for RX should strike a balance between increasing the</span>
<span class="cm"> * round-trip latency and reducing overhead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_irq_mod_usec</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>

<span class="cm">/* Initial interrupt moderation settings.  They can be modified after</span>
<span class="cm"> * module load with ethtool.</span>
<span class="cm"> *</span>
<span class="cm"> * This default is chosen to ensure that a 10G link does not go idle</span>
<span class="cm"> * while a TX queue is stopped after it has become full.  A queue is</span>
<span class="cm"> * restarted when it drops below half full.  The time this takes (assuming</span>
<span class="cm"> * worst case 3 descriptors per packet and 1024 descriptors) is</span>
<span class="cm"> *   512 / 3 * 1.2 = 205 usec.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_irq_mod_usec</span> <span class="o">=</span> <span class="mi">150</span><span class="p">;</span>

<span class="cm">/* This is the first interrupt mode to try out of:</span>
<span class="cm"> * 0 =&gt; MSI-X</span>
<span class="cm"> * 1 =&gt; MSI</span>
<span class="cm"> * 2 =&gt; legacy</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interrupt_mode</span><span class="p">;</span>

<span class="cm">/* This is the requested number of CPUs to use for Receive-Side Scaling (RSS),</span>
<span class="cm"> * i.e. the number of CPUs among which we may distribute simultaneous</span>
<span class="cm"> * interrupt handling.</span>
<span class="cm"> *</span>
<span class="cm"> * Cards without MSI-X will only target one CPU via legacy or MSI interrupt.</span>
<span class="cm"> * The default (0) means to assign an interrupt to each core.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rss_cpus</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">rss_cpus</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">rss_cpus</span><span class="p">,</span> <span class="s">&quot;Number of CPUs to use for Receive-Side Scaling&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">phy_flash_cfg</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">phy_flash_cfg</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">phy_flash_cfg</span><span class="p">,</span> <span class="s">&quot;Set PHYs into reflash mode initially&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">irq_adapt_low_thresh</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">irq_adapt_low_thresh</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irq_adapt_low_thresh</span><span class="p">,</span>
		 <span class="s">&quot;Threshold score for reducing IRQ moderation&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">irq_adapt_high_thresh</span> <span class="o">=</span> <span class="mi">16000</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">irq_adapt_high_thresh</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irq_adapt_high_thresh</span><span class="p">,</span>
		 <span class="s">&quot;Threshold score for increasing IRQ moderation&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">debug</span> <span class="o">=</span> <span class="p">(</span><span class="n">NETIF_MSG_DRV</span> <span class="o">|</span> <span class="n">NETIF_MSG_PROBE</span> <span class="o">|</span>
			 <span class="n">NETIF_MSG_LINK</span> <span class="o">|</span> <span class="n">NETIF_MSG_IFDOWN</span> <span class="o">|</span>
			 <span class="n">NETIF_MSG_IFUP</span> <span class="o">|</span> <span class="n">NETIF_MSG_RX_ERR</span> <span class="o">|</span>
			 <span class="n">NETIF_MSG_TX_ERR</span> <span class="o">|</span> <span class="n">NETIF_MSG_HW</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;Bitmapped debugging message enable value&quot;</span><span class="p">);</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Utility functions and prototypes</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_start_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">may_keep_eventq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_stop_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">may_keep_eventq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_remove_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_remove_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_channel_type</span> <span class="n">efx_default_channel_type</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_remove_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_init_napi_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_fini_napi</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_fini_napi_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_fini_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_start_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_stop_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>

<span class="cp">#define EFX_ASSERT_RESET_SERIALISED(efx)		\</span>
<span class="cp">	do {						\</span>
<span class="cp">		if ((efx-&gt;state == STATE_RUNNING) ||	\</span>
<span class="cp">		    (efx-&gt;state == STATE_DISABLED))	\</span>
<span class="cp">			ASSERT_RTNL();			\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Event queue processing</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="cm">/* Process channel&#39;s event queue</span>
<span class="cm"> *</span>
<span class="cm"> * This function is responsible for processing the event queue of a</span>
<span class="cm"> * single channel.  The caller must guarantee that this function will</span>
<span class="cm"> * never be concurrently called more than once on the same channel,</span>
<span class="cm"> * though different channels may be being processed concurrently.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_process_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">spent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spent</span> <span class="o">=</span> <span class="n">efx_nic_process_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spent</span> <span class="o">&amp;&amp;</span> <span class="n">efx_channel_has_rx_queue</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span> <span class="o">=</span>
			<span class="n">efx_channel_get_rx_queue</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

		<span class="cm">/* Deliver last RX packet. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">rx_pkt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__efx_rx_packet</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">rx_pkt</span><span class="p">);</span>
			<span class="n">channel</span><span class="o">-&gt;</span><span class="n">rx_pkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx_rx_strategy</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
			<span class="n">efx_fast_push_rx_descriptors</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">spent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Mark channel as finished processing</span>
<span class="cm"> *</span>
<span class="cm"> * Note that since we will not receive further interrupts for this</span>
<span class="cm"> * channel before we finish processing and call the eventq_read_ack()</span>
<span class="cm"> * method, there is no need to use the interrupt hold-off timers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_channel_processed</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The interrupt handler for this channel may set work_pending</span>
<span class="cm">	 * as soon as we acknowledge the events we&#39;ve seen.  Make sure</span>
<span class="cm">	 * it&#39;s cleared before then. */</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">work_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">efx_nic_eventq_read_ack</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* NAPI poll handler</span>
<span class="cm"> *</span>
<span class="cm"> * NAPI guarantees serialisation of polls of the same device, which</span>
<span class="cm"> * provides the guarantee required by efx_process_channel().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_channel</span><span class="p">,</span> <span class="n">napi_str</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spent</span><span class="p">;</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;channel %d NAPI poll executing on CPU %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">());</span>

	<span class="n">spent</span> <span class="o">=</span> <span class="n">efx_process_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spent</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx_channel_has_rx_queue</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_rx_adaptive</span> <span class="o">&amp;&amp;</span>
		    <span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_count</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_mod_score</span> <span class="o">&lt;</span>
				     <span class="n">irq_adapt_low_thresh</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_moderation</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_moderation</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">push_irq_moderation</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_mod_score</span> <span class="o">&gt;</span>
					    <span class="n">irq_adapt_high_thresh</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_moderation</span> <span class="o">&lt;</span>
				    <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_rx_moderation</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_moderation</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">push_irq_moderation</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_mod_score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">efx_filter_rfs_expire</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

		<span class="cm">/* There is no race here; although napi_disable() will</span>
<span class="cm">		 * only wait for napi_complete(), this isn&#39;t a problem</span>
<span class="cm">		 * since efx_channel_processed() will have no effect if</span>
<span class="cm">		 * interrupts have already been disabled.</span>
<span class="cm">		 */</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">efx_channel_processed</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">spent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Process the eventq of the specified channel immediately on this CPU</span>
<span class="cm"> *</span>
<span class="cm"> * Disable hardware generated interrupts, wait for any existing</span>
<span class="cm"> * processing to finish, then directly poll (and ack ) the eventq.</span>
<span class="cm"> * Finally reenable NAPI and interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * This is for use only during a loopback self-test.  It must not</span>
<span class="cm"> * deliver any packets up the stack as this can result in deadlock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">efx_process_channel_now</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">loopback_selftest</span><span class="p">);</span>

	<span class="cm">/* Disable interrupts and wait for ISRs to complete */</span>
	<span class="n">efx_nic_disable_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq</span><span class="p">);</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="cm">/* Wait for any NAPI processing to complete */</span>
	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">napi_str</span><span class="p">);</span>

	<span class="cm">/* Poll the channel */</span>
	<span class="n">efx_process_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Ack the eventq. This may cause an interrupt to be generated</span>
<span class="cm">	 * when they are reenabled */</span>
	<span class="n">efx_channel_processed</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">napi_str</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq</span><span class="p">)</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">efx_nic_enable_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Create event queue</span>
<span class="cm"> * Event queue memory allocations are done only once.  If the channel</span>
<span class="cm"> * is reset, the memory buffer will be reused; this guards against</span>
<span class="cm"> * errors during channel reset and also simplifies interrupt handling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_probe_eventq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entries</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;chan %d create event queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="cm">/* Build an event queue with room for one event per tx and rx buffer,</span>
<span class="cm">	 * plus some extra for link state events and MCDI completions. */</span>
	<span class="n">entries</span> <span class="o">=</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_entries</span> <span class="o">+</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">txq_entries</span> <span class="o">+</span> <span class="mi">128</span><span class="p">);</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="n">entries</span> <span class="o">&gt;</span> <span class="n">EFX_MAX_EVQ_SIZE</span><span class="p">);</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq_mask</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">EFX_MIN_EVQ_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">efx_nic_probe_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Prepare channel&#39;s event queue */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_init_eventq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;chan %d init event queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq_read_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">efx_nic_init_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Enable event queue processing and NAPI */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_start_eventq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;chan %d start event queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="cm">/* The interrupt handler for this channel may set work_pending</span>
<span class="cm">	 * as soon as we enable it.  Make sure it&#39;s cleared before</span>
<span class="cm">	 * then.  Similarly, make sure it sees the enabled flag set.</span>
<span class="cm">	 */</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">work_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">napi_str</span><span class="p">);</span>
	<span class="n">efx_nic_eventq_read_ack</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Disable event queue processing and NAPI */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_stop_eventq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">napi_str</span><span class="p">);</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_fini_eventq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;chan %d fini event queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="n">efx_nic_fini_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_remove_eventq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;chan %d remove event queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="n">efx_nic_remove_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Channel handling</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="cm">/* Allocate and initialise a channel structure. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span>
<span class="nf">efx_alloc_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">old_channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">channel</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">channel</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span> <span class="o">=</span> <span class="n">efx</span><span class="p">;</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx_default_channel_type</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">EFX_TXQ_TYPES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">efx</span> <span class="o">=</span> <span class="n">efx</span><span class="p">;</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">EFX_TXQ_TYPES</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rx_queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">;</span>
	<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">efx</span> <span class="o">=</span> <span class="n">efx</span><span class="p">;</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">slow_fill</span><span class="p">,</span> <span class="n">efx_rx_slow_fill</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">rx_queue</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">channel</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate and initialise a channel structure, copying parameters</span>
<span class="cm"> * (but not resources) from an old channel structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span>
<span class="nf">efx_copy_channel</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">old_channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">channel</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">channel</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="o">*</span><span class="n">old_channel</span><span class="p">;</span>

	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">napi_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">EFX_TXQ_TYPES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">)</span>
			<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">rx_queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">;</span>
	<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">));</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">slow_fill</span><span class="p">,</span> <span class="n">efx_rx_slow_fill</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">rx_queue</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">channel</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_probe_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;creating channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">pre_probe</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_probe_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">efx_for_each_channel_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_probe_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">efx_for_each_channel_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_probe_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">n_rx_frm_trunc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">efx_remove_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_get_channel_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">number</span><span class="p">;</span>

	<span class="n">number</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_channel_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_channel_offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;-rx&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;-tx&quot;</span><span class="p">;</span>
		<span class="n">number</span> <span class="o">-=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_channel_offset</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%s%s-%d&quot;</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_set_channel_names</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span>
		<span class="n">channel</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">get_name</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span>
					<span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel_name</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">],</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_probe_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Restart special buffer allocation */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">next_buffer_table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Probe channels in reverse, so that any &#39;extra&#39; channels</span>
<span class="cm">	 * use the start of the buffer table. This allows the traffic</span>
<span class="cm">	 * channels to be resized without moving them or wasting the</span>
<span class="cm">	 * entries before them.</span>
<span class="cm">	 */</span>
	<span class="n">efx_for_each_channel_rev</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_probe_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;failed to create channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">efx_set_channel_names</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">efx_remove_channels</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Channels are shutdown and reinitialised whilst the NIC is running</span>
<span class="cm"> * to propagate configuration changes (mtu, checksum offload), or</span>
<span class="cm"> * to clear hardware error conditions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_start_datapath</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="cm">/* Calculate the rx buffer allocation parameters required to</span>
<span class="cm">	 * support the current MTU, including padding for header</span>
<span class="cm">	 * alignment and overruns.</span>
<span class="cm">	 */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">EFX_PAGE_IP_ALIGN</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">EFX_MAX_FRAME_LEN</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">rx_buffer_hash_size</span> <span class="o">+</span>
			      <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">rx_buffer_padding</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_buffer_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">+</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_page_state</span><span class="p">));</span>

	<span class="cm">/* Initialise the channels */</span>
	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_for_each_channel_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
			<span class="n">efx_init_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>

		<span class="cm">/* The rx buffer allocation strategy is MTU dependent */</span>
		<span class="n">efx_rx_strategy</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

		<span class="n">efx_for_each_channel_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx_init_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">);</span>
			<span class="n">efx_nic_generate_fill_event</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">rx_pkt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">efx_rx_strategy</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">))</span>
		<span class="n">netif_tx_wake_all_queues</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_stop_datapath</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">EFX_ASSERT_RESET_SERIALISED</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">);</span>

	<span class="cm">/* Only perform flush if dma is enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">is_busmaster</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_nic_flush_queues</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">EFX_WORKAROUND_7803</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Schedule a reset to recover from the flush failure. The</span>
<span class="cm">			 * descriptor caches reference memory we&#39;re about to free,</span>
<span class="cm">			 * but falcon_reconfigure_mac_wrapper() won&#39;t reconnect</span>
<span class="cm">			 * the MACs because of the pending reset. */</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;Resetting to recover from flush failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_ALL</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;failed to flush queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;successfully flushed all queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* RX packet processing is pipelined, so wait for the</span>
<span class="cm">		 * NAPI handler to complete.  At least event queue 0</span>
<span class="cm">		 * might be kept active by non-data events, so don&#39;t</span>
<span class="cm">		 * use napi_synchronize() but actually disable NAPI</span>
<span class="cm">		 * temporarily.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx_channel_has_rx_queue</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">efx_stop_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
			<span class="n">efx_start_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">efx_for_each_channel_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
			<span class="n">efx_fini_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">);</span>
		<span class="n">efx_for_each_possible_channel_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
			<span class="n">efx_fini_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_remove_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;destroy chan %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="n">efx_for_each_channel_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
		<span class="n">efx_remove_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">);</span>
	<span class="n">efx_for_each_possible_channel_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
		<span class="n">efx_remove_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>
	<span class="n">efx_remove_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_remove_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span>
		<span class="n">efx_remove_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">efx_realloc_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rxq_entries</span><span class="p">,</span> <span class="n">u32</span> <span class="n">txq_entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">other_channel</span><span class="p">[</span><span class="n">EFX_MAX_CHANNELS</span><span class="p">],</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">old_rxq_entries</span><span class="p">,</span> <span class="n">old_txq_entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">next_buffer_table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Not all channels should be reallocated. We must avoid</span>
<span class="cm">	 * reallocating their buffer table entries.</span>
<span class="cm">	 */</span>
	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">copy</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">next_buffer_table</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">next_buffer_table</span><span class="p">,</span>
					<span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">.</span><span class="n">index</span> <span class="o">+</span>
					<span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">.</span><span class="n">entries</span><span class="p">);</span>
		<span class="n">efx_for_each_channel_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
			<span class="n">next_buffer_table</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">next_buffer_table</span><span class="p">,</span>
						<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">.</span><span class="n">index</span> <span class="o">+</span>
						<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">.</span><span class="n">entries</span><span class="p">);</span>
		<span class="n">efx_for_each_channel_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
			<span class="n">next_buffer_table</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">next_buffer_table</span><span class="p">,</span>
						<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">index</span> <span class="o">+</span>
						<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">entries</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx_stop_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_stop_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* Clone channels (where possible) */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">other_channel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">other_channel</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">copy</span><span class="p">)</span>
			<span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">copy</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">other_channel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Swap entry counts and channel pointers */</span>
	<span class="n">old_rxq_entries</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_entries</span><span class="p">;</span>
	<span class="n">old_txq_entries</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">txq_entries</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_entries</span> <span class="o">=</span> <span class="n">rxq_entries</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">txq_entries</span> <span class="o">=</span> <span class="n">txq_entries</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_channel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">other_channel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Restart buffer table allocation */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">next_buffer_table</span> <span class="o">=</span> <span class="n">next_buffer_table</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">copy</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_probe_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">rollback</span><span class="p">;</span>
		<span class="n">efx_init_napi_channel</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="cm">/* Destroy unused channel structures */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">other_channel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&amp;&amp;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">copy</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx_fini_napi_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
			<span class="n">efx_remove_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">efx_start_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">efx_start_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">rollback:</span>
	<span class="cm">/* Swap back */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_entries</span> <span class="o">=</span> <span class="n">old_rxq_entries</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">txq_entries</span> <span class="o">=</span> <span class="n">old_txq_entries</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_channel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">other_channel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_schedule_slow_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">slow_fill</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_channel_type</span> <span class="n">efx_default_channel_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pre_probe</span>		<span class="o">=</span> <span class="n">efx_channel_dummy_op_int</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_name</span>		<span class="o">=</span> <span class="n">efx_get_channel_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">copy</span>			<span class="o">=</span> <span class="n">efx_copy_channel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">keep_eventq</span>		<span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">efx_channel_dummy_op_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Port handling</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* This ensures that the kernel is kept informed (via</span>
<span class="cm"> * netif_carrier_on/off) of the link status, and also maintains the</span>
<span class="cm"> * link status&#39;s stop on the port&#39;s TX queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">efx_link_status_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_link_state</span> <span class="o">*</span><span class="n">link_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">;</span>

	<span class="cm">/* SFC Bug 5356: A net_dev notifier is registered, so we must ensure</span>
<span class="cm">	 * that no events are triggered between unregister_netdev() and the</span>
<span class="cm">	 * driver unloading. A more general condition is that NETDEV_CHANGE</span>
<span class="cm">	 * can only be generated between NETDEV_UP and NETDEV_DOWN */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link_state</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">!=</span> <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_link_state_changes</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">link_state</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">)</span>
			<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Status message for kernel log */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">link_state</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">)</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;link up at %uMbps %s-duplex (MTU %d)%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">link_state</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span> <span class="n">link_state</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">?</span> <span class="s">&quot;full&quot;</span> <span class="o">:</span> <span class="s">&quot;half&quot;</span><span class="p">,</span>
			   <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">promiscuous</span> <span class="o">?</span> <span class="s">&quot; [PROMISC]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;link down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_link_set_advertising</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">advertising</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_advertising</span> <span class="o">=</span> <span class="n">advertising</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">advertising</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISED_Pause</span><span class="p">)</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">wanted_fc</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EFX_FC_TX</span> <span class="o">|</span> <span class="n">EFX_FC_RX</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">wanted_fc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">EFX_FC_TX</span> <span class="o">|</span> <span class="n">EFX_FC_RX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISED_Asym_Pause</span><span class="p">)</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">wanted_fc</span> <span class="o">^=</span> <span class="n">EFX_FC_TX</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_link_set_wanted_fc</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">u8</span> <span class="n">wanted_fc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">wanted_fc</span> <span class="o">=</span> <span class="n">wanted_fc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_advertising</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wanted_fc</span> <span class="o">&amp;</span> <span class="n">EFX_FC_RX</span><span class="p">)</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_advertising</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ADVERTISED_Pause</span> <span class="o">|</span>
						  <span class="n">ADVERTISED_Asym_Pause</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_advertising</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ADVERTISED_Pause</span> <span class="o">|</span>
						   <span class="n">ADVERTISED_Asym_Pause</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wanted_fc</span> <span class="o">&amp;</span> <span class="n">EFX_FC_TX</span><span class="p">)</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_advertising</span> <span class="o">^=</span> <span class="n">ADVERTISED_Asym_Pause</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">efx_fini_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>

<span class="cm">/* Push loopback/power/transmit disable settings to the PHY, and reconfigure</span>
<span class="cm"> * the MAC appropriately. All other PHY configuration changes are pushed</span>
<span class="cm"> * through phy_op-&gt;set_settings(), and pushed asynchronously to the MAC</span>
<span class="cm"> * through efx_monitor().</span>
<span class="cm"> *</span>
<span class="cm"> * Callers must hold the mac_lock</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__efx_reconfigure_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">efx_phy_mode</span> <span class="n">phy_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">));</span>

	<span class="cm">/* Serialise the promiscuous flag with efx_set_rx_mode. */</span>
	<span class="n">netif_addr_lock_bh</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">netif_addr_unlock_bh</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="cm">/* Disable PHY transmit in mac level loopbacks */</span>
	<span class="n">phy_mode</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">LOOPBACK_INTERNAL</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">|=</span> <span class="n">PHY_MODE_TX_DISABLED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PHY_MODE_TX_DISABLED</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">reconfigure_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">=</span> <span class="n">phy_mode</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reinitialise the MAC to pick up new PHY settings, even if the port is</span>
<span class="cm"> * disabled. */</span>
<span class="kt">int</span> <span class="nf">efx_reconfigure_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">EFX_ASSERT_RESET_SERIALISED</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">__efx_reconfigure_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Asynchronous work item for changing MAC promiscuity and multicast</span>
<span class="cm"> * hash.  Avoid a drain/rx_ingress enable by reconfiguring the current</span>
<span class="cm"> * MAC directly. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_mac_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_nic</span><span class="p">,</span> <span class="n">mac_work</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">)</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">reconfigure_mac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_probe_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;create port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy_flash_cfg</span><span class="p">)</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">=</span> <span class="n">PHY_MODE_SPECIAL</span><span class="p">;</span>

	<span class="cm">/* Connect up MAC/PHY operations table */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">probe_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Initialise MAC address to permanent address */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_init_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;init port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Reconfigure the MAC before creating dma queues (required for</span>
<span class="cm">	 * Falcon/A1 where RX_INGR_EN/TX_DRAIN_EN isn&#39;t supported) */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">reconfigure_mac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Ensure the PHY advertises the correct flow control settings */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">reconfigure</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail2:</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="nl">fail1:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_start_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;start port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* efx_mac_work() might have been scheduled after efx_stop_port(),</span>
<span class="cm">	 * and then cancelled by efx_flush_all() */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">reconfigure_mac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Prevent efx_mac_work() and efx_monitor() from working */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_stop_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;stop port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>

	<span class="cm">/* Serialise against efx_set_multicast_list() */</span>
	<span class="n">netif_addr_lock_bh</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">netif_addr_unlock_bh</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_fini_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;shut down port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_initialized</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_initialized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">efx_link_status_changed</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_remove_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;destroying port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">remove_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * NIC handling</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* This configures the PCI device to enable I/O and DMA. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_init_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_mask</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">max_dma_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;initialising I/O</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;failed to enable PCI device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="cm">/* Set the PCI DMA mask.  Try all possibilities from our</span>
<span class="cm">	 * genuine mask down to 32 bits, because some architectures</span>
<span class="cm">	 * (e.g. x86_64 with iommu_sac_force set) will allow 40 bit</span>
<span class="cm">	 * masks event though they reject 46 bit masks.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dma_mask</span> <span class="o">&gt;</span> <span class="mh">0x7fffffffUL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_dma_supported</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">dma_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">dma_mask</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dma_mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;could not find a suitable DMA mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;using DMA mask %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dma_mask</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">dma_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* pci_set_consistent_dma_mask() is not *allowed* to</span>
<span class="cm">		 * fail with a mask that pci_set_dma_mask() accepted,</span>
<span class="cm">		 * but just in case...</span>
<span class="cm">		 */</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;failed to set consistent DMA mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase_phys</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">EFX_MEM_BAR</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_request_region</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">EFX_MEM_BAR</span><span class="p">,</span> <span class="s">&quot;sfc&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;request for memory BAR failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase_phys</span><span class="p">,</span>
				       <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">mem_map_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;could not map memory BAR at %llx+%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase_phys</span><span class="p">,</span>
			  <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">mem_map_size</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;memory BAR at %llx+%x (virtual %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase_phys</span><span class="p">,</span>
		  <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">mem_map_size</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail4:</span>
	<span class="n">pci_release_region</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">EFX_MEM_BAR</span><span class="p">);</span>
 <span class="nl">fail3:</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">fail2:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
 <span class="nl">fail1:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_fini_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;shutting down I/O</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span><span class="p">);</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase_phys</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_release_region</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">EFX_MEM_BAR</span><span class="p">);</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">efx_wanted_parallelism</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">thread_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rss_cpus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">rss_cpus</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">netif_warn</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				   <span class="s">&quot;RSS disabled due to allocation failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">thread_mask</span><span class="p">))</span> <span class="p">{</span>
				<span class="o">++</span><span class="n">count</span><span class="p">;</span>
				<span class="n">cpumask_or</span><span class="p">(</span><span class="n">thread_mask</span><span class="p">,</span> <span class="n">thread_mask</span><span class="p">,</span>
					   <span class="n">topology_thread_cpumask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">thread_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If RSS is requested for the PF *and* VFs then we can&#39;t write RSS</span>
<span class="cm">	 * table entries that are inaccessible to VFs</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_sriov_wanted</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">count</span> <span class="o">&gt;</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_warn</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;Reducing number of RSS channels from %u to %u for &quot;</span>
			   <span class="s">&quot;VF support. Increase vf-msix-limit to use more &quot;</span>
			   <span class="s">&quot;channels on the PF.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">count</span><span class="p">,</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">));</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">efx_init_rx_cpu_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msix_entry</span> <span class="o">*</span><span class="n">xentries</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">rx_cpu_rmap</span> <span class="o">=</span> <span class="n">alloc_irq_cpu_rmap</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_channels</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">rx_cpu_rmap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">irq_cpu_rmap_add</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">rx_cpu_rmap</span><span class="p">,</span>
				      <span class="n">xentries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_irq_cpu_rmap</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">rx_cpu_rmap</span><span class="p">);</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">rx_cpu_rmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Probe the number and type of interrupts we are able to obtain, and</span>
<span class="cm"> * the resulting numbers of channels and RX queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_probe_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_channels</span> <span class="o">=</span>
		<span class="n">min</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">phys_addr_channels</span><span class="p">,</span> <span class="n">EFX_MAX_CHANNELS</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">extra_channels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EFX_MAX_EXTRA_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">extra_channel_type</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="o">++</span><span class="n">extra_channels</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span> <span class="o">==</span> <span class="n">EFX_INT_MODE_MSIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">msix_entry</span> <span class="n">xentries</span><span class="p">[</span><span class="n">EFX_MAX_CHANNELS</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_channels</span><span class="p">;</span>

		<span class="n">n_channels</span> <span class="o">=</span> <span class="n">efx_wanted_parallelism</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">separate_tx_channels</span><span class="p">)</span>
			<span class="n">n_channels</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">n_channels</span> <span class="o">+=</span> <span class="n">extra_channels</span><span class="p">;</span>
		<span class="n">n_channels</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">max_channels</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">xentries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">xentries</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;WARNING: Insufficient MSI-X vectors&quot;</span>
				  <span class="s">&quot; available (%d &lt; %u).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">);</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;WARNING: Performance may be reduced.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="n">rc</span> <span class="o">&gt;=</span> <span class="n">n_channels</span><span class="p">);</span>
			<span class="n">n_channels</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">xentries</span><span class="p">,</span>
					     <span class="n">n_channels</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span> <span class="o">=</span> <span class="n">n_channels</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n_channels</span> <span class="o">&gt;</span> <span class="n">extra_channels</span><span class="p">)</span>
				<span class="n">n_channels</span> <span class="o">-=</span> <span class="n">extra_channels</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">separate_tx_channels</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">n_channels</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1U</span><span class="p">);</span>
				<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_channels</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">n_channels</span> <span class="o">-</span>
							 <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span><span class="p">,</span>
							 <span class="mi">1U</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span> <span class="o">=</span> <span class="n">n_channels</span><span class="p">;</span>
				<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_channels</span> <span class="o">=</span> <span class="n">n_channels</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_init_rx_cpu_rmap</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">xentries</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">efx_get_channel</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span>
					<span class="n">xentries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Fall back to single channel MSI */</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span> <span class="o">=</span> <span class="n">EFX_INT_MODE_MSI</span><span class="p">;</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;could not enable MSI-X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Try single interrupt MSI */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span> <span class="o">==</span> <span class="n">EFX_INT_MODE_MSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx_get_channel</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;could not enable MSI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span> <span class="o">=</span> <span class="n">EFX_INT_MODE_LEGACY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Assume legacy interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span> <span class="o">==</span> <span class="n">EFX_INT_MODE_LEGACY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">separate_tx_channels</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Assign extra channels if possible */</span>
	<span class="n">j</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EFX_MAX_EXTRA_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">extra_channel_type</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span> <span class="o">!=</span> <span class="n">EFX_INT_MODE_MSIX</span> <span class="o">||</span>
		    <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span> <span class="o">&lt;=</span> <span class="n">extra_channels</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">extra_channel_type</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">handle_no_channel</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">--</span><span class="n">j</span><span class="p">;</span>
			<span class="n">efx_get_channel</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span>
				<span class="n">efx</span><span class="o">-&gt;</span><span class="n">extra_channel_type</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* RSS might be usable on VFs even if it is disabled on the PF */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">rss_spread</span> <span class="o">=</span> <span class="p">((</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_channels</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">efx_sriov_wanted</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span> <span class="o">?</span>
			   <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_channels</span> <span class="o">:</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Enable interrupts, then probe and start the event queues */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_start_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">may_keep_eventq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq</span><span class="p">)</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">efx_nic_enable_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">keep_eventq</span> <span class="o">||</span> <span class="o">!</span><span class="n">may_keep_eventq</span><span class="p">)</span>
			<span class="n">efx_init_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
		<span class="n">efx_start_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx_mcdi_mode_event</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_stop_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">may_keep_eventq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="n">efx_mcdi_mode_poll</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx_nic_disable_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq</span><span class="p">);</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
			<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

		<span class="n">efx_stop_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">keep_eventq</span> <span class="o">||</span> <span class="o">!</span><span class="n">may_keep_eventq</span><span class="p">)</span>
			<span class="n">efx_fini_eventq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_remove_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="cm">/* Remove MSI/MSI-X interrupts */</span>
	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span>
		<span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="cm">/* Remove legacy interrupt */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_set_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_channel_offset</span> <span class="o">=</span>
		<span class="n">separate_tx_channels</span> <span class="o">?</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span> <span class="o">-</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We need to adjust the TX queue numbers if we have separate</span>
<span class="cm">	 * RX-only and TX-only channels.</span>
<span class="cm">	 */</span>
	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_for_each_channel_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
			<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">-=</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_channel_offset</span> <span class="o">*</span>
					    <span class="n">EFX_TXQ_TYPES</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_probe_nic</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;creating NIC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Carry out hardware-type specific initialisation */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Determine the number of channels and queues by trying to hook</span>
<span class="cm">	 * in MSI-X interrupts. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_probe_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">dimension_resources</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_hash_key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_hash_key</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_indir_table</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_indir_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">ethtool_rxfh_indir_default</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">rss_spread</span><span class="p">);</span>

	<span class="n">efx_set_channels</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">netif_set_real_num_tx_queues</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span><span class="p">);</span>
	<span class="n">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_channels</span><span class="p">);</span>

	<span class="cm">/* Initialise the interrupt moderation settings */</span>
	<span class="n">efx_init_irq_moderation</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">tx_irq_mod_usec</span><span class="p">,</span> <span class="n">rx_irq_mod_usec</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
				<span class="nb">true</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_remove_nic</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;destroying NIC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">efx_remove_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * NIC startup/shutdown</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_probe_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_probe_nic</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;failed to create NIC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_probe_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;failed to create port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_entries</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">txq_entries</span> <span class="o">=</span> <span class="n">EFX_DEFAULT_DMAQ_SIZE</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_probe_filters</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;failed to create filter tables</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_probe_channels</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail4</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail4:</span>
	<span class="n">efx_remove_filters</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
 <span class="nl">fail3:</span>
	<span class="n">efx_remove_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
 <span class="nl">fail2:</span>
	<span class="n">efx_remove_nic</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
 <span class="nl">fail1:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called after previous invocation(s) of efx_stop_all, restarts the port,</span>
<span class="cm"> * kernel transmit queues and NAPI processing, and ensures that the port is</span>
<span class="cm"> * scheduled to be reconfigured. This function is safe to call multiple</span>
<span class="cm"> * times when the NIC is in any state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_start_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_ASSERT_RESET_SERIALISED</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Check that it is appropriate to restart the interface. All</span>
<span class="cm">	 * of these flags are safe to read under just the rtnl lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">STATE_RUNNING</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">STATE_INIT</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">efx_start_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_start_datapath</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Start the hardware monitor if there is one. Otherwise (we&#39;re link</span>
<span class="cm">	 * event driven), we have to poll the PHY because after an event queue</span>
<span class="cm">	 * flush, we could have a missed a link state change */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">monitor</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">monitor_work</span><span class="p">,</span>
				   <span class="n">efx_monitor_interval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
			<span class="n">efx_link_status_changed</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">start_stats</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Flush all delayed work. Should only be called when no more delayed work</span>
<span class="cm"> * will be scheduled. This doesn&#39;t flush pending online resets (efx_reset),</span>
<span class="cm"> * since we&#39;re holding the rtnl_lock at this point. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_flush_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Make sure the hardware monitor and event self-test are stopped */</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">monitor_work</span><span class="p">);</span>
	<span class="n">efx_selftest_async_cancel</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="cm">/* Stop scheduled port reconfigurations */</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Quiesce hardware and software without bringing the link down.</span>
<span class="cm"> * Safe to call multiple times, when the nic and interface is in any</span>
<span class="cm"> * state. The caller is guaranteed to subsequently be in a position</span>
<span class="cm"> * to modify any hardware and software state they see fit without</span>
<span class="cm"> * taking locks. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_stop_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_ASSERT_RESET_SERIALISED</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* port_enabled can be read safely under the rtnl lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">stop_stats</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_stop_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Flush efx_mac_work(), refill_workqueue, monitor_work */</span>
	<span class="n">efx_flush_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Stop the kernel transmit interface late, so the watchdog</span>
<span class="cm">	 * timer isn&#39;t ticking over the flush */</span>
	<span class="n">netif_tx_disable</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">efx_stop_datapath</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_remove_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_remove_channels</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_remove_filters</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_remove_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_remove_nic</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupt moderation</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">irq_mod_ticks</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">usecs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">quantum_ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usecs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usecs</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">&lt;</span> <span class="n">quantum_ns</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* never round down to 0 */</span>
	<span class="k">return</span> <span class="n">usecs</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">quantum_ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set interrupt moderation parameters */</span>
<span class="kt">int</span> <span class="nf">efx_init_irq_moderation</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_usecs</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_usecs</span><span class="p">,</span> <span class="n">bool</span> <span class="n">rx_adaptive</span><span class="p">,</span>
			    <span class="n">bool</span> <span class="n">rx_may_override_tx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_mod_max</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">timer_period_max</span> <span class="o">*</span>
						<span class="n">efx</span><span class="o">-&gt;</span><span class="n">timer_quantum_ns</span><span class="p">,</span>
						<span class="mi">1000</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_ticks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_ticks</span><span class="p">;</span>

	<span class="n">EFX_ASSERT_RESET_SERIALISED</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_usecs</span> <span class="o">&gt;</span> <span class="n">irq_mod_max</span> <span class="o">||</span> <span class="n">rx_usecs</span> <span class="o">&gt;</span> <span class="n">irq_mod_max</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">tx_ticks</span> <span class="o">=</span> <span class="n">irq_mod_ticks</span><span class="p">(</span><span class="n">tx_usecs</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">timer_quantum_ns</span><span class="p">);</span>
	<span class="n">rx_ticks</span> <span class="o">=</span> <span class="n">irq_mod_ticks</span><span class="p">(</span><span class="n">rx_usecs</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">timer_quantum_ns</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_ticks</span> <span class="o">!=</span> <span class="n">rx_ticks</span> <span class="o">&amp;&amp;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_channel_offset</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">rx_may_override_tx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Channels are shared. &quot;</span>
			  <span class="s">&quot;RX and TX IRQ moderation must be equal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_rx_adaptive</span> <span class="o">=</span> <span class="n">rx_adaptive</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_rx_moderation</span> <span class="o">=</span> <span class="n">rx_ticks</span><span class="p">;</span>
	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx_channel_has_rx_queue</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
			<span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_moderation</span> <span class="o">=</span> <span class="n">rx_ticks</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">efx_channel_has_tx_queues</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
			<span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_moderation</span> <span class="o">=</span> <span class="n">tx_ticks</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_get_irq_moderation</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tx_usecs</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rx_usecs</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">rx_adaptive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We must round up when converting ticks to microseconds</span>
<span class="cm">	 * because we round down when converting the other way.</span>
<span class="cm">	 */</span>

	<span class="o">*</span><span class="n">rx_adaptive</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_rx_adaptive</span><span class="p">;</span>
	<span class="o">*</span><span class="n">rx_usecs</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_rx_moderation</span> <span class="o">*</span>
				 <span class="n">efx</span><span class="o">-&gt;</span><span class="n">timer_quantum_ns</span><span class="p">,</span>
				 <span class="mi">1000</span><span class="p">);</span>

	<span class="cm">/* If channels are shared between RX and TX, so is IRQ</span>
<span class="cm">	 * moderation.  Otherwise, IRQ moderation is the same for all</span>
<span class="cm">	 * TX channels and is not adaptive.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_channel_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">tx_usecs</span> <span class="o">=</span> <span class="o">*</span><span class="n">rx_usecs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">tx_usecs</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_channel_offset</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">irq_moderation</span> <span class="o">*</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">timer_quantum_ns</span><span class="p">,</span>
			<span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Hardware monitor</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* Run periodically off the general workqueue */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_nic</span><span class="p">,</span>
					   <span class="n">monitor_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">timer</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;hardware monitor executing on CPU %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">raw_smp_processor_id</span><span class="p">());</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">monitor</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* If the mac_lock is already held then it is likely a port</span>
<span class="cm">	 * reconfiguration is already in place, which will likely do</span>
<span class="cm">	 * most of the work of monitor() anyway. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">)</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">monitor</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">monitor_work</span><span class="p">,</span>
			   <span class="n">efx_monitor_interval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * ioctls</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="cm">/* Net device ioctl</span>
<span class="cm"> * Context: process, rtnl_lock() held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mii_ioctl_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">ifr</span><span class="p">);</span>

	<span class="n">EFX_ASSERT_RESET_SERIALISED</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Convert phy_id from older PRTAD/DEVAD format */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCGMIIREG</span> <span class="o">||</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCSMIIREG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0xfc00</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0400</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">^=</span> <span class="n">MDIO_PHY_ID_C45</span> <span class="o">|</span> <span class="mh">0x0400</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mdio_mii_ioctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * NAPI interface</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_init_napi_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>

	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">napi_dev</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">napi_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">napi_str</span><span class="p">,</span>
		       <span class="n">efx_poll</span><span class="p">,</span> <span class="n">napi_weight</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_init_napi</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span>
		<span class="n">efx_init_napi_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_fini_napi_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">napi_dev</span><span class="p">)</span>
		<span class="n">netif_napi_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">napi_str</span><span class="p">);</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">napi_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_fini_napi</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span>
		<span class="n">efx_fini_napi_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Kernel netpoll interface</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>

<span class="cm">/* Although in the common case interrupts will be disabled, this is not</span>
<span class="cm"> * guaranteed. However, all our work happens inside the NAPI callback,</span>
<span class="cm"> * so no locking is required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span>
		<span class="n">efx_schedule_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Kernel net device interface</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="cm">/* Context: process, rtnl_lock() held. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">EFX_ASSERT_RESET_SERIALISED</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;opening device on CPU %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">raw_smp_processor_id</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">STATE_DISABLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">&amp;</span> <span class="n">PHY_MODE_SPECIAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_mcdi_poll_reboot</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">efx_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_ALL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Notify the kernel of the link state polled during driver load,</span>
<span class="cm">	 * before the monitor starts running */</span>
	<span class="n">efx_link_status_changed</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx_start_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_selftest_async_start</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Context: process, rtnl_lock() held.</span>
<span class="cm"> * Note that the kernel will ignore our return code; this method</span>
<span class="cm"> * should really be a void.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_net_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;closing on CPU %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">raw_smp_processor_id</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">STATE_DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Stop the device and flush all the channels */</span>
		<span class="n">efx_stop_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Context: process, dev_base_lock or RTNL held, non-blocking. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="nf">efx_net_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_mac_stats</span> <span class="o">*</span><span class="n">mac_stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_stats</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">update_stats</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span> <span class="o">=</span> <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span> <span class="o">=</span> <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_dropped</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_nodesc_drop_cnt</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">multicast</span> <span class="o">=</span> <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_multicast</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">collisions</span> <span class="o">=</span> <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_collision</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_length_errors</span> <span class="o">=</span> <span class="p">(</span><span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_gtjumbo</span> <span class="o">+</span>
				   <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_length_error</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span> <span class="o">=</span> <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_bad</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_frame_errors</span> <span class="o">=</span> <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_align_error</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_fifo_errors</span> <span class="o">=</span> <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_overflow</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_missed_errors</span> <span class="o">=</span> <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_missed</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_window_errors</span> <span class="o">=</span> <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_late_collision</span><span class="p">;</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_errors</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_length_errors</span> <span class="o">+</span>
			    <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span> <span class="o">+</span>
			    <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_frame_errors</span> <span class="o">+</span>
			    <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_symbol_error</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_errors</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_window_errors</span> <span class="o">+</span>
			    <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_bad</span><span class="p">);</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Context: netif_tx_lock held, BHs disabled. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;TX stuck with port_enabled=%d: resetting channels</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">);</span>

	<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_TX_WATCHDOG</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Context: process, rtnl_lock() held. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">EFX_ASSERT_RESET_SERIALISED</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="n">EFX_MAX_MTU</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">efx_stop_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;changing MTU to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="cm">/* Reconfigure the MAC before enabling the dma queues so that</span>
<span class="cm">	 * the RX buffers don&#39;t overflow */</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">reconfigure_mac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>

	<span class="n">efx_start_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">new_addr</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">;</span>

	<span class="n">EFX_ASSERT_RESET_SERIALISED</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">new_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;invalid ethernet MAC address requested: %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">new_addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">new_addr</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">efx_sriov_mac_address_changed</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Reconfigure the MAC */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">reconfigure_mac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Context: netif_addr_lock held, BHs disabled. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">efx_multicast_hash</span> <span class="o">*</span><span class="n">mc_hash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">multicast_hash</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">crc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">promiscuous</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">);</span>

	<span class="cm">/* Build multicast hash table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">promiscuous</span> <span class="o">||</span> <span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">mc_hash</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mc_hash</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">mc_hash</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mc_hash</span><span class="p">));</span>
		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">crc</span> <span class="o">=</span> <span class="n">ether_crc_le</span><span class="p">(</span><span class="n">ETH_ALEN</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">bit</span> <span class="o">=</span> <span class="n">crc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EFX_MCAST_HASH_ENTRIES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">set_bit_le</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">mc_hash</span><span class="o">-&gt;</span><span class="n">byte</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Broadcast packets go through the multicast hash filter.</span>
<span class="cm">		 * ether_crc_le() of the broadcast address is 0xbe2612ff</span>
<span class="cm">		 * so we always add bit 0xff to the mask.</span>
<span class="cm">		 */</span>
		<span class="n">set_bit_le</span><span class="p">(</span><span class="mh">0xff</span><span class="p">,</span> <span class="n">mc_hash</span><span class="o">-&gt;</span><span class="n">byte</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">)</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_work</span><span class="p">);</span>
	<span class="cm">/* Otherwise efx_start_port() will do this */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_set_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="cm">/* If disabling RX n-tuple filtering, clear existing filters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">NETIF_F_NTUPLE</span><span class="p">)</span>
		<span class="n">efx_filter_clear_rx</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">EFX_FILTER_PRI_MANUAL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">efx_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">efx_net_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">efx_net_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats64</span>	<span class="o">=</span> <span class="n">efx_net_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">efx_watchdog</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">efx_hard_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">efx_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">efx_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">efx_set_mac_address</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">efx_set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_features</span>	<span class="o">=</span> <span class="n">efx_set_features</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SFC_SRIOV</span>
	<span class="p">.</span><span class="n">ndo_set_vf_mac</span>		<span class="o">=</span> <span class="n">efx_sriov_set_vf_mac</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_vf_vlan</span>	<span class="o">=</span> <span class="n">efx_sriov_set_vf_vlan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_vf_spoofchk</span>	<span class="o">=</span> <span class="n">efx_sriov_set_vf_spoofchk</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_vf_config</span>	<span class="o">=</span> <span class="n">efx_sriov_get_vf_config</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span> <span class="o">=</span> <span class="n">efx_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">ndo_setup_tc</span>		<span class="o">=</span> <span class="n">efx_setup_tc</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>
	<span class="p">.</span><span class="n">ndo_rx_flow_steer</span>	<span class="o">=</span> <span class="n">efx_filter_rfs</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_update_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">efx_mtd_rename</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_set_channel_names</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_netdev_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">efx_netdev_ops</span> <span class="o">&amp;&amp;</span>
	    <span class="n">event</span> <span class="o">==</span> <span class="n">NETDEV_CHANGENAME</span><span class="p">)</span>
		<span class="n">efx_update_name</span><span class="p">(</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">efx_netdev_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">efx_netdev_event</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_phy_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">phy_type</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">show_phy_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_register_netdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx_netdev_ops</span><span class="p">;</span>
	<span class="n">SET_ETHTOOL_OPS</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx_ethtool_ops</span><span class="p">);</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">dev_alloc_name</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_locked</span><span class="p">;</span>
	<span class="n">efx_update_name</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_netdevice</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_locked</span><span class="p">;</span>

	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>
		<span class="n">efx_for_each_channel_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
			<span class="n">efx_init_tx_queue_core_txq</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Always start with carrier off; PHY events will detect the link */</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_phy_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;failed to init net dev attributes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_registered</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_locked:</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;could not register net dev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">fail_registered:</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_unregister_netdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Free up any skbs still remaining. This has to happen before</span>
<span class="cm">	 * we try to unregister the netdev as running their destructors</span>
<span class="cm">	 * may be needed to get the device ref. count to 0. */</span>
	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_for_each_channel_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
			<span class="n">efx_release_tx_buffers</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_phy_type</span><span class="p">);</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Device reset and suspend</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* Tears down the entire software state and most of the hardware state</span>
<span class="cm"> * before reset.  */</span>
<span class="kt">void</span> <span class="nf">efx_reset_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">reset_type</span> <span class="n">method</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_ASSERT_RESET_SERIALISED</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx_stop_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>

	<span class="n">efx_stop_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_initialized</span> <span class="o">&amp;&amp;</span> <span class="n">method</span> <span class="o">!=</span> <span class="n">RESET_TYPE_INVISIBLE</span><span class="p">)</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This function will always ensure that the locks acquired in</span>
<span class="cm"> * efx_reset_down() are released. A failure return code indicates</span>
<span class="cm"> * that we were unable to reinitialise the hardware, and the</span>
<span class="cm"> * driver should be disabled. If ok is false, then the rx and tx</span>
<span class="cm"> * engines are not restarted, pending a RESET_DISABLE. */</span>
<span class="kt">int</span> <span class="nf">efx_reset_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">reset_type</span> <span class="n">method</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">EFX_ASSERT_RESET_SERIALISED</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;failed to initialise NIC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_initialized</span> <span class="o">&amp;&amp;</span> <span class="n">method</span> <span class="o">!=</span> <span class="n">RESET_TYPE_INVISIBLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">reconfigure</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;could not restore PHY settings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">reconfigure_mac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx_start_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">efx_restore_filters</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_sriov_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>

	<span class="n">efx_start_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">port_initialized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reset the NIC using the specified method.  Note that the reset may</span>
<span class="cm"> * fail, in which case the card will be left in an unusable state.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold the rtnl_lock.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">efx_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">reset_type</span> <span class="n">method</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rc2</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">disabled</span><span class="p">;</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;resetting (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">RESET_TYPE</span><span class="p">(</span><span class="n">method</span><span class="p">));</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">efx_reset_down</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">method</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">method</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;failed to reset hardware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear flags for the scopes we covered.  We assume the NIC and</span>
<span class="cm">	 * driver are now quiescent so that there is no race here.</span>
<span class="cm">	 */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_pending</span> <span class="o">&amp;=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">method</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* Reinitialise bus-mastering, which may have been turned off before</span>
<span class="cm">	 * the reset was scheduled. This is still appropriate, even in the</span>
<span class="cm">	 * RESET_TYPE_DISABLE since this driver generally assumes the hardware</span>
<span class="cm">	 * can respond to requests. */</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="cm">/* Leave device stopped if necessary */</span>
	<span class="n">disabled</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">||</span> <span class="n">method</span> <span class="o">==</span> <span class="n">RESET_TYPE_DISABLE</span><span class="p">;</span>
	<span class="n">rc2</span> <span class="o">=</span> <span class="n">efx_reset_up</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">!</span><span class="n">disabled</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">disabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">rc2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_close</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;has been disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_DISABLED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;reset complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The worker thread exists so that code that cannot sleep can</span>
<span class="cm"> * schedule a reset for later.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_reset_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_nic</span><span class="p">,</span> <span class="n">reset_work</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_pending</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pending</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* If we&#39;re not RUNNING then don&#39;t reset. Leave the reset_pending</span>
<span class="cm">	 * flags set so that efx_pci_probe_main will be retried */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">STATE_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;scheduled reset quenched. NIC not RUNNING</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">efx_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">fls</span><span class="p">(</span><span class="n">pending</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_schedule_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">reset_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">reset_type</span> <span class="n">method</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RESET_TYPE_INVISIBLE</span>:
	<span class="k">case</span> <span class="n">RESET_TYPE_ALL</span>:
	<span class="k">case</span> <span class="n">RESET_TYPE_WORLD</span>:
	<span class="k">case</span> <span class="n">RESET_TYPE_DISABLE</span>:
		<span class="n">method</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;scheduling %s reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">RESET_TYPE</span><span class="p">(</span><span class="n">method</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">method</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">map_reset_reason</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;scheduling %s reset for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">RESET_TYPE</span><span class="p">(</span><span class="n">method</span><span class="p">),</span> <span class="n">RESET_TYPE</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_pending</span><span class="p">);</span>

	<span class="cm">/* efx_process_channel() will no longer read events once a</span>
<span class="cm">	 * reset is scheduled. So switch back to poll&#39;d MCDI completions. */</span>
	<span class="n">efx_mcdi_mode_poll</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">queue_work</span><span class="p">(</span><span class="n">reset_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * List of NICs we support</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* PCI device ID table */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">efx_pci_table</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SOLARFLARE</span><span class="p">,</span>
		    <span class="n">PCI_DEVICE_ID_SOLARFLARE_SFC4000A_0</span><span class="p">),</span>
	 <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">falcon_a1_nic_type</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SOLARFLARE</span><span class="p">,</span>
		    <span class="n">PCI_DEVICE_ID_SOLARFLARE_SFC4000B</span><span class="p">),</span>
	 <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">falcon_b0_nic_type</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SOLARFLARE</span><span class="p">,</span> <span class="mh">0x0803</span><span class="p">),</span>	<span class="cm">/* SFC9020 */</span>
	 <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">siena_a0_nic_type</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SOLARFLARE</span><span class="p">,</span> <span class="mh">0x0813</span><span class="p">),</span>	<span class="cm">/* SFL9021 */</span>
	 <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">siena_a0_nic_type</span><span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">}</span>			<span class="cm">/* end of list */</span>
<span class="p">};</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Dummy PHY/MAC operations</span>
<span class="cm"> *</span>
<span class="cm"> * Can be used for some unimplemented operations</span>
<span class="cm"> * Needed so all function pointers are valid and do not have to be tested</span>
<span class="cm"> * before use</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>
<span class="kt">int</span> <span class="nf">efx_port_dummy_op_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">efx_port_dummy_op_void</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">efx_port_dummy_op_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_phy_operations</span> <span class="n">efx_dummy_phy_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		 <span class="o">=</span> <span class="n">efx_port_dummy_op_int</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reconfigure</span>	 <span class="o">=</span> <span class="n">efx_port_dummy_op_int</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		 <span class="o">=</span> <span class="n">efx_port_dummy_op_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fini</span>		 <span class="o">=</span> <span class="n">efx_port_dummy_op_void</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Data housekeeping</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* This zeroes out and then fills in the invariants in a struct</span>
<span class="cm"> * efx_nic (including all sub-structures).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_init_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Initialise common structures */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">efx</span><span class="p">));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">biu_lock</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SFC_MTD</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mtd_list</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_work</span><span class="p">,</span> <span class="n">efx_reset_work</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">monitor_work</span><span class="p">,</span> <span class="n">efx_monitor</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">selftest_work</span><span class="p">,</span> <span class="n">efx_selftest_async_work</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">debug</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_INIT</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">net_dev</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx_dummy_phy_operations</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">net_dev</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_work</span><span class="p">,</span> <span class="n">efx_mac_work</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">flush_wq</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EFX_MAX_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">efx_alloc_channel</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">phys_addr_channels</span> <span class="o">&gt;</span> <span class="n">EFX_MAX_CHANNELS</span><span class="p">);</span>

	<span class="cm">/* Higher numbered interrupt modes are less capable! */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">max_interrupt_mode</span><span class="p">,</span>
				  <span class="n">interrupt_mode</span><span class="p">);</span>

	<span class="cm">/* Would be good to use the net_dev name, but we&#39;re too early */</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">workqueue_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">workqueue_name</span><span class="p">),</span> <span class="s">&quot;sfc%s&quot;</span><span class="p">,</span>
		 <span class="n">pci_name</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">));</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">workqueue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">workqueue_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">efx_fini_struct</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_fini_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EFX_MAX_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">);</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">workqueue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * PCI interface</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* Main body of final NIC shutdown code</span>
<span class="cm"> * This is called only at module unload (or hotplug removal).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_pci_remove_main</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>
	<span class="n">free_irq_cpu_rmap</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">rx_cpu_rmap</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">rx_cpu_rmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">efx_stop_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">efx_nic_fini_interrupt</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_fini_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_fini_napi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_remove_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Final NIC shutdown</span>
<span class="cm"> * This is called only at module unload (or hotplug removal).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">;</span>

	<span class="n">efx</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Mark the NIC as fini, then stop the interface */</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_FINI</span><span class="p">;</span>
	<span class="n">dev_close</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="cm">/* Allow any queued efx_resets() to complete */</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="n">efx_stop_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">efx_sriov_fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_unregister_netdev</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx_mtd_remove</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Wait for any scheduled resets to complete. No more will be</span>
<span class="cm">	 * scheduled from this point because efx_stop_all() has been</span>
<span class="cm">	 * called, we are no longer registered with driverlink, and</span>
<span class="cm">	 * the net_device&#39;s have been removed. */</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_work</span><span class="p">);</span>

	<span class="n">efx_pci_remove_main</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx_fini_io</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;shutdown successful</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">efx_fini_struct</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* NIC VPD information</span>
<span class="cm"> * Called during probe to display the part number of the</span>
<span class="cm"> * installed NIC.  VPD is potentially very large but this should</span>
<span class="cm"> * always appear within the first 512 bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define SFC_VPD_LEN 512</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_print_product_vpd</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">vpd_data</span><span class="p">[</span><span class="n">SFC_VPD_LEN</span><span class="p">];</span>
	<span class="kt">ssize_t</span> <span class="n">vpd_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* Get the vpd data from the device */</span>
	<span class="n">vpd_size</span> <span class="o">=</span> <span class="n">pci_read_vpd</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vpd_data</span><span class="p">),</span> <span class="n">vpd_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vpd_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Unable to read VPD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the Read only section */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">pci_vpd_find_tag</span><span class="p">(</span><span class="n">vpd_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vpd_size</span><span class="p">,</span> <span class="n">PCI_VPD_LRDT_RO_DATA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;VPD Read-only not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">j</span> <span class="o">=</span> <span class="n">pci_vpd_lrdt_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpd_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">i</span> <span class="o">+=</span> <span class="n">PCI_VPD_LRDT_TAG_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">vpd_size</span><span class="p">)</span>
		<span class="n">j</span> <span class="o">=</span> <span class="n">vpd_size</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Get the Part number */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">pci_vpd_find_info_keyword</span><span class="p">(</span><span class="n">vpd_data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="s">&quot;PN&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Part number not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">j</span> <span class="o">=</span> <span class="n">pci_vpd_info_field_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpd_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">i</span> <span class="o">+=</span> <span class="n">PCI_VPD_INFO_FLD_HDR_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">vpd_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Incomplete part number</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;Part Number : %.*s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpd_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>


<span class="cm">/* Main body of NIC initialisation</span>
<span class="cm"> * This is called at module load (or hotplug insertion, theoretically).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_pci_probe_main</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Do start-of-day initialisation */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_probe_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>

	<span class="n">efx_init_napi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;failed to initialise NIC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_init_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;failed to initialise port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_nic_init_interrupt</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail5</span><span class="p">;</span>
	<span class="n">efx_start_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail5:</span>
	<span class="n">efx_fini_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
 <span class="nl">fail4:</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
 <span class="nl">fail3:</span>
	<span class="n">efx_fini_napi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_remove_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
 <span class="nl">fail1:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* NIC initialisation</span>
<span class="cm"> *</span>
<span class="cm"> * This is called at module load (or hotplug insertion,</span>
<span class="cm"> * theoretically).  It sets up PCI mappings, resets the NIC,</span>
<span class="cm"> * sets up and registers the network devices with the kernel and hooks</span>
<span class="cm"> * the interrupt service routine.  It does not prepare the device for</span>
<span class="cm"> * transmission; this is left to the first time one of the network</span>
<span class="cm"> * interfaces is brought up (i.e. efx_net_open).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">efx_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_type</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_type</span> <span class="o">*</span><span class="p">)</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Allocate and initialise a struct net_device and struct efx_nic */</span>
	<span class="n">net_dev</span> <span class="o">=</span> <span class="n">alloc_etherdev_mqs</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">efx</span><span class="p">),</span> <span class="n">EFX_MAX_CORE_TX_QUEUES</span><span class="p">,</span>
				     <span class="n">EFX_MAX_RX_QUEUES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">offload_features</span> <span class="o">|</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span>
			      <span class="n">NETIF_F_HIGHDMA</span> <span class="o">|</span> <span class="n">NETIF_F_TSO</span> <span class="o">|</span>
			      <span class="n">NETIF_F_RXCSUM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">offload_features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_V6_CSUM</span><span class="p">)</span>
		<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO6</span><span class="p">;</span>
	<span class="cm">/* Mask for features that also apply to VLAN devices */</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="p">(</span><span class="n">NETIF_F_ALL_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span>
				   <span class="n">NETIF_F_HIGHDMA</span> <span class="o">|</span> <span class="n">NETIF_F_ALL_TSO</span> <span class="o">|</span>
				   <span class="n">NETIF_F_RXCSUM</span><span class="p">);</span>
	<span class="cm">/* All offloads can be toggled */</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">=</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>
	<span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">efx</span><span class="p">);</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_init_struct</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;Solarflare NIC detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">efx_print_product_vpd</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Set up basic I/O (BAR mappings etc) */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_init_io</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_pci_probe_main</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Serialise against efx_reset(). No more resets will be</span>
<span class="cm">	 * scheduled since efx_stop_all() has been called, and we have</span>
<span class="cm">	 * not and never have been registered.</span>
<span class="cm">	 */</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail3</span><span class="p">;</span>

	<span class="cm">/* If there was a scheduled reset during probe, the NIC is</span>
<span class="cm">	 * probably hosed anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Switch to the running state before we expose the device to the OS,</span>
<span class="cm">	 * so that dev_open()|efx_start_all() will actually start the device */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_RUNNING</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_register_netdev</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail4</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_sriov_init</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;SR-IOV can&#39;t be enabled rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;initialisation successful</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Try to create MTDs, but allow this to fail */</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mtd_probe</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">netif_warn</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;failed to create MTDs (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail4:</span>
	<span class="n">efx_pci_remove_main</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
 <span class="nl">fail3:</span>
	<span class="n">efx_fini_io</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
 <span class="nl">fail2:</span>
	<span class="n">efx_fini_struct</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
 <span class="nl">fail1:</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;initialisation failed. rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_pm_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_FINI</span><span class="p">;</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">efx_stop_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_stop_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_pm_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_INIT</span><span class="p">;</span>

	<span class="n">efx_start_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">reconfigure</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">);</span>

	<span class="n">efx_start_all</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_RUNNING</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">resume_wol</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Reschedule any quenched resets scheduled during efx_pm_freeze() */</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">reset_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_pm_poweroff</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used for both resume and restore */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_pm_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_ALL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">efx_pm_thaw</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_pm_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">efx_pm_freeze</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_pm_poweroff</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">efx_pm_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">efx_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">efx_pm_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">efx_pm_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze</span>		<span class="o">=</span> <span class="n">efx_pm_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span>		<span class="o">=</span> <span class="n">efx_pm_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poweroff</span>	<span class="o">=</span> <span class="n">efx_pm_poweroff</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore</span>	<span class="o">=</span> <span class="n">efx_pm_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">efx_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">efx_pci_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">efx_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">efx_pci_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">pm</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">efx_pm_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Kernel module interface</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">interrupt_mode</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">interrupt_mode</span><span class="p">,</span>
		 <span class="s">&quot;Interrupt mode (0=&gt;MSIX 1=&gt;MSI 2=&gt;legacy)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">efx_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Solarflare NET driver v&quot;</span> <span class="n">EFX_DRIVER_VERSION</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx_netdev_notifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_notifier</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_init_sriov</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_sriov</span><span class="p">;</span>

	<span class="n">reset_workqueue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;sfc_reset&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reset_workqueue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx_pci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_pci</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_pci:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">reset_workqueue</span><span class="p">);</span>
 <span class="nl">err_reset:</span>
	<span class="n">efx_fini_sriov</span><span class="p">();</span>
 <span class="nl">err_sriov:</span>
	<span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx_netdev_notifier</span><span class="p">);</span>
 <span class="nl">err_notifier:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">efx_exit_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Solarflare NET driver unloading</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx_pci_driver</span><span class="p">);</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">reset_workqueue</span><span class="p">);</span>
	<span class="n">efx_fini_sriov</span><span class="p">();</span>
	<span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx_netdev_notifier</span><span class="p">);</span>

<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">efx_init_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">efx_exit_module</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Solarflare Communications and &quot;</span>
	      <span class="s">&quot;Michael Brown &lt;mbrown@fensystems.co.uk&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Solarflare Communications network driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">efx_pci_table</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
