<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › falcon.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>falcon.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2005-2006 Fen Systems Ltd.</span>
<span class="cm"> * Copyright 2006-2010 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;net_driver.h&quot;</span>
<span class="cp">#include &quot;bitfield.h&quot;</span>
<span class="cp">#include &quot;efx.h&quot;</span>
<span class="cp">#include &quot;spi.h&quot;</span>
<span class="cp">#include &quot;nic.h&quot;</span>
<span class="cp">#include &quot;regs.h&quot;</span>
<span class="cp">#include &quot;io.h&quot;</span>
<span class="cp">#include &quot;phy.h&quot;</span>
<span class="cp">#include &quot;workarounds.h&quot;</span>

<span class="cm">/* Hardware control for SFC4000 (aka Falcon). */</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="cm">/* &quot;Large&quot; EEPROM device: Atmel AT25640 or similar</span>
<span class="cm"> * 8 KB, 16-bit address, 32 B write block */</span>
<span class="n">large_eeprom_type</span> <span class="o">=</span> <span class="p">((</span><span class="mi">13</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_DEV_TYPE_SIZE_LBN</span><span class="p">)</span>
		     <span class="o">|</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_DEV_TYPE_ADDR_LEN_LBN</span><span class="p">)</span>
		     <span class="o">|</span> <span class="p">(</span><span class="mi">5</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_DEV_TYPE_BLOCK_SIZE_LBN</span><span class="p">)),</span>
<span class="cm">/* Default flash device: Atmel AT25F1024</span>
<span class="cm"> * 128 KB, 24-bit address, 32 KB erase block, 256 B write block */</span>
<span class="n">default_flash_type</span> <span class="o">=</span> <span class="p">((</span><span class="mi">17</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_DEV_TYPE_SIZE_LBN</span><span class="p">)</span>
		      <span class="o">|</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_DEV_TYPE_ADDR_LEN_LBN</span><span class="p">)</span>
		      <span class="o">|</span> <span class="p">(</span><span class="mh">0x52</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_DEV_TYPE_ERASE_CMD_LBN</span><span class="p">)</span>
		      <span class="o">|</span> <span class="p">(</span><span class="mi">15</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_DEV_TYPE_ERASE_SIZE_LBN</span><span class="p">)</span>
		      <span class="o">|</span> <span class="p">(</span><span class="mi">8</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_DEV_TYPE_BLOCK_SIZE_LBN</span><span class="p">));</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * I2C bus - this is a bit-bashing interface using GPIO pins</span>
<span class="cm"> * Note that it uses the output enables to tristate the outputs</span>
<span class="cm"> * SDA is the data pin and SCL is the clock</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_setsda</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_GPIO_CTL</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_GPIO3_OEN</span><span class="p">,</span> <span class="o">!</span><span class="n">state</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_GPIO_CTL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_setscl</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_GPIO_CTL</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_GPIO0_OEN</span><span class="p">,</span> <span class="o">!</span><span class="n">state</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_GPIO_CTL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_getsda</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_GPIO_CTL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_GPIO3_IN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_getscl</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_GPIO_CTL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_GPIO0_IN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_algo_bit_data</span> <span class="n">falcon_i2c_bit_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">setsda</span>		<span class="o">=</span> <span class="n">falcon_setsda</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setscl</span>		<span class="o">=</span> <span class="n">falcon_setscl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsda</span>		<span class="o">=</span> <span class="n">falcon_getsda</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getscl</span>		<span class="o">=</span> <span class="n">falcon_getscl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">udelay</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="cm">/* Wait up to 50 ms for slave to let us pull SCL high */</span>
	<span class="p">.</span><span class="n">timeout</span>	<span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">HZ</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_push_irq_moderation</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_dword_t</span> <span class="n">timer_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>

	<span class="cm">/* Set timer register */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_moderation</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EFX_POPULATE_DWORD_2</span><span class="p">(</span><span class="n">timer_cmd</span><span class="p">,</span>
				     <span class="n">FRF_AB_TC_TIMER_MODE</span><span class="p">,</span>
				     <span class="n">FFE_BB_TIMER_MODE_INT_HLDOFF</span><span class="p">,</span>
				     <span class="n">FRF_AB_TC_TIMER_VAL</span><span class="p">,</span>
				     <span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_moderation</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">EFX_POPULATE_DWORD_2</span><span class="p">(</span><span class="n">timer_cmd</span><span class="p">,</span>
				     <span class="n">FRF_AB_TC_TIMER_MODE</span><span class="p">,</span>
				     <span class="n">FFE_BB_TIMER_MODE_DIS</span><span class="p">,</span>
				     <span class="n">FRF_AB_TC_TIMER_VAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FR_AA_TIMER_COMMAND_KER</span> <span class="o">!=</span> <span class="n">FR_BZ_TIMER_COMMAND_P0</span><span class="p">);</span>
	<span class="n">efx_writed_page_locked</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_cmd</span><span class="p">,</span> <span class="n">FR_BZ_TIMER_COMMAND_P0</span><span class="p">,</span>
			       <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">falcon_deconfigure_mac_wrapper</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_prepare_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">falcon_deconfigure_mac_wrapper</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Wait for the tx and rx fifo&#39;s to get to the next packet boundary</span>
<span class="cm">	 * (~1ms without back-pressure), then to drain the remainder of the</span>
<span class="cm">	 * fifo&#39;s at data path speeds (negligible), with a healthy margin. */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Acknowledge a legacy interrupt from Falcon</span>
<span class="cm"> *</span>
<span class="cm"> * This acknowledges a legacy (not MSI) interrupt via INT_ACK_KER_REG.</span>
<span class="cm"> *</span>
<span class="cm"> * Due to SFC bug 3706 (silicon revision &lt;=A1) reads can be duplicated in the</span>
<span class="cm"> * BIU. Interrupt acknowledge is read sensitive so must write instead</span>
<span class="cm"> * (then read to ensure the BIU collector is flushed)</span>
<span class="cm"> *</span>
<span class="cm"> * NB most hardware supports MSI interrupts</span>
<span class="cm"> */</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">falcon_irq_ack_a1</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_dword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">EFX_POPULATE_DWORD_1</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AA_INT_ACK_KER_FIELD</span><span class="p">,</span> <span class="mh">0xb7eb7e</span><span class="p">);</span>
	<span class="n">efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AA_INT_ACK_KER</span><span class="p">);</span>
	<span class="n">efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AA_WORK_AROUND_BROKEN_PCI_READS</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">irqreturn_t</span> <span class="nf">falcon_legacy_interrupt_a1</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">int_ker</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">syserr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">queues</span><span class="p">;</span>

	<span class="cm">/* Check to see if this is our interrupt.  If it isn&#39;t, we</span>
<span class="cm">	 * exit without having touched the hardware.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">EFX_OWORD_IS_ZERO</span><span class="p">(</span><span class="o">*</span><span class="n">int_ker</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;IRQ %d on CPU %d not for me</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span>
			   <span class="n">raw_smp_processor_id</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">last_irq_cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;IRQ %d on CPU %d status &quot;</span> <span class="n">EFX_OWORD_FMT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">irq</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">(),</span> <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">int_ker</span><span class="p">));</span>

	<span class="cm">/* Check to see if we have a serious error condition */</span>
	<span class="n">syserr</span> <span class="o">=</span> <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">int_ker</span><span class="p">,</span> <span class="n">FSF_AZ_NET_IVEC_FATAL_INT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">syserr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">efx_nic_fatal_interrupt</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Determine interrupting queues, clear interrupt status</span>
<span class="cm">	 * register and acknowledge the device interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FSF_AZ_NET_IVEC_INT_Q_WIDTH</span> <span class="o">&gt;</span> <span class="n">EFX_MAX_CHANNELS</span><span class="p">);</span>
	<span class="n">queues</span> <span class="o">=</span> <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">int_ker</span><span class="p">,</span> <span class="n">FSF_AZ_NET_IVEC_INT_Q</span><span class="p">);</span>
	<span class="n">EFX_ZERO_OWORD</span><span class="p">(</span><span class="o">*</span><span class="n">int_ker</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span> <span class="cm">/* Ensure the vector is cleared before interrupt ack */</span>
	<span class="n">falcon_irq_ack_a1</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queues</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">efx_schedule_channel_irq</span><span class="p">(</span><span class="n">efx_get_channel</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queues</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">efx_schedule_channel_irq</span><span class="p">(</span><span class="n">efx_get_channel</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * EEPROM/flash</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="cp">#define FALCON_SPI_MAX_LEN sizeof(efx_oword_t)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_spi_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_EE_SPI_HCMD</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_EE_SPI_HCMD_CMD_EN</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EBUSY</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Wait for SPI command completion */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_spi_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Most commands will finish quickly, so we start polling at</span>
<span class="cm">	 * very short intervals.  Sometimes the command may have to</span>
<span class="cm">	 * wait for VPD or expansion ROM access outside of our</span>
<span class="cm">	 * control, so we allow up to 100 ms. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">HZ</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">falcon_spi_poll</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">falcon_spi_poll</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;timed out waiting for SPI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">falcon_spi_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span> <span class="kt">int</span> <span class="n">address</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">addressed</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">reading</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Input validation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">FALCON_SPI_MAX_LEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Check that previous command is not still running */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_spi_poll</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Program address register, if we have an address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addressed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_EE_SPI_HADR_ADR</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_EE_SPI_HADR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Program data register, if we have data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_EE_SPI_HDATA</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Issue read/write command */</span>
	<span class="n">EFX_POPULATE_OWORD_7</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_AB_EE_SPI_HCMD_CMD_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AB_EE_SPI_HCMD_SF_SEL</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">,</span>
			     <span class="n">FRF_AB_EE_SPI_HCMD_DABCNT</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
			     <span class="n">FRF_AB_EE_SPI_HCMD_READ</span><span class="p">,</span> <span class="n">reading</span><span class="p">,</span>
			     <span class="n">FRF_AB_EE_SPI_HCMD_DUBCNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">FRF_AB_EE_SPI_HCMD_ADBCNT</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">addressed</span> <span class="o">?</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">addr_len</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
			     <span class="n">FRF_AB_EE_SPI_HCMD_ENC</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_EE_SPI_HCMD</span><span class="p">);</span>

	<span class="cm">/* Wait for read/write to complete */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_spi_wait</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Read data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_EE_SPI_HDATA</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span>
<span class="nf">falcon_spi_write_limit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">FALCON_SPI_MAX_LEN</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">-</span> <span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">efx_spi_munge_command</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span>
		      <span class="k">const</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">command</span> <span class="o">|</span> <span class="p">(((</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">munge_address</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Wait up to 10 ms for buffered write completion */</span>
<span class="kt">int</span>
<span class="nf">falcon_spi_wait_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">HZ</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_spi_cmd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">spi</span><span class="p">,</span> <span class="n">SPI_RDSR</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SPI_STATUS_NRDY</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;SPI write timeout on device %d&quot;</span>
				  <span class="s">&quot; last status=0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">spi</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">falcon_spi_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span>
		    <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">block_len</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="n">FALCON_SPI_MAX_LEN</span><span class="p">);</span>

		<span class="n">command</span> <span class="o">=</span> <span class="n">efx_spi_munge_command</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">SPI_READ</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">pos</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_spi_cmd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">spi</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">buffer</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">block_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">block_len</span><span class="p">;</span>

		<span class="cm">/* Avoid locking up the system */</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span><span class="p">)</span>
		<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">falcon_spi_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span>
		 <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">verify_buffer</span><span class="p">[</span><span class="n">FALCON_SPI_MAX_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">block_len</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_spi_cmd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">spi</span><span class="p">,</span> <span class="n">SPI_WREN</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">block_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span>
				<span class="n">falcon_spi_write_limit</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">pos</span><span class="p">));</span>
		<span class="n">command</span> <span class="o">=</span> <span class="n">efx_spi_munge_command</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">SPI_WRITE</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">pos</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_spi_cmd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">spi</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span>
				    <span class="n">buffer</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">block_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_spi_wait_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">spi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">command</span> <span class="o">=</span> <span class="n">efx_spi_munge_command</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">SPI_READ</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">pos</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_spi_cmd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">spi</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span>
				    <span class="nb">NULL</span><span class="p">,</span> <span class="n">verify_buffer</span><span class="p">,</span> <span class="n">block_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">verify_buffer</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">block_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pos</span> <span class="o">+=</span> <span class="n">block_len</span><span class="p">;</span>

		<span class="cm">/* Avoid locking up the system */</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span><span class="p">)</span>
		<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * MAC wrapper</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_push_multicast_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">efx_multicast_hash</span> <span class="o">*</span><span class="n">mc_hash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">multicast_hash</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">));</span>

	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc_hash</span><span class="o">-&gt;</span><span class="n">oword</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FR_AB_MAC_MC_HASH_REG0</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc_hash</span><span class="o">-&gt;</span><span class="n">oword</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">FR_AB_MAC_MC_HASH_REG1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_reset_macs</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">,</span> <span class="n">mac_ctrl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* It&#39;s not safe to use GLB_CTL_REG to reset the</span>
<span class="cm">		 * macs, so instead use the internal MAC resets</span>
<span class="cm">		 */</span>
		<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_XM_CORE_RST</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_XM_GLB_CFG</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_XM_GLB_CFG</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_XM_CORE_RST</span><span class="p">)</span> <span class="o">==</span>
			    <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;timed out waiting for XMAC core reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Mac stats will fail whist the TX fifo is draining */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_disable_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac_ctrl</span><span class="p">,</span> <span class="n">FR_AB_MAC_CTRL</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">mac_ctrl</span><span class="p">,</span> <span class="n">FRF_BB_TXFIFO_DRAIN_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac_ctrl</span><span class="p">,</span> <span class="n">FR_AB_MAC_CTRL</span><span class="p">);</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_GLB_CTL</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_RST_XGTX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_RST_XGRX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_RST_EM</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_GLB_CTL</span><span class="p">);</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_GLB_CTL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_RST_XGTX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_RST_XGRX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_RST_EM</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;Completed MAC reset after %d loops</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">count</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;MAC reset failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Ensure the correct MAC is selected before statistics</span>
<span class="cm">	 * are re-enabled by the caller */</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac_ctrl</span><span class="p">,</span> <span class="n">FR_AB_MAC_CTRL</span><span class="p">);</span>

	<span class="n">falcon_setup_xaui</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">falcon_drain_tx_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">loopback_mode</span> <span class="o">!=</span> <span class="n">LOOPBACK_NONE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MAC_CTRL</span><span class="p">);</span>
	<span class="cm">/* There is no point in draining more than once */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BB_TXFIFO_DRAIN_EN</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">falcon_reset_macs</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_deconfigure_mac_wrapper</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Isolate the MAC -&gt; RX */</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AZ_RX_CFG</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_INGR_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AZ_RX_CFG</span><span class="p">);</span>

	<span class="cm">/* Isolate TX -&gt; MAC */</span>
	<span class="n">falcon_drain_tx_fifo</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">falcon_reconfigure_mac_wrapper</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_link_state</span> <span class="o">*</span><span class="n">link_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">link_speed</span><span class="p">,</span> <span class="n">isolate</span><span class="p">;</span>

	<span class="n">isolate</span> <span class="o">=</span> <span class="o">!!</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_pending</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">link_state</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">10000</span>: <span class="n">link_speed</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1000</span>:  <span class="n">link_speed</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">100</span>:   <span class="n">link_speed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>    <span class="n">link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* MAC_LINK_STATUS controls MAC backpressure but doesn&#39;t work</span>
<span class="cm">	 * as advertised.  Disable to ensure packets are not</span>
<span class="cm">	 * indefinitely held and TX queue can be flushed at any point</span>
<span class="cm">	 * while the link is down. */</span>
	<span class="n">EFX_POPULATE_OWORD_5</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_AB_MAC_XOFF_VAL</span><span class="p">,</span> <span class="mh">0xffff</span> <span class="cm">/* max pause time */</span><span class="p">,</span>
			     <span class="n">FRF_AB_MAC_BCAD_ACPT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AB_MAC_UC_PROM</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">promiscuous</span><span class="p">,</span>
			     <span class="n">FRF_AB_MAC_LINK_STATUS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* always set */</span>
			     <span class="n">FRF_AB_MAC_SPEED</span><span class="p">,</span> <span class="n">link_speed</span><span class="p">);</span>
	<span class="cm">/* On B0, MAC backpressure can be disabled and packets get</span>
<span class="cm">	 * discarded. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BB_TXFIFO_DRAIN_EN</span><span class="p">,</span>
				    <span class="o">!</span><span class="n">link_state</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">||</span> <span class="n">isolate</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MAC_CTRL</span><span class="p">);</span>

	<span class="cm">/* Restore the multicast hash registers. */</span>
	<span class="n">falcon_push_multicast_hash</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AZ_RX_CFG</span><span class="p">);</span>
	<span class="cm">/* Enable XOFF signal from RX FIFO (we enabled it during NIC</span>
<span class="cm">	 * initialisation but it may read back as 0) */</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AZ_RX_XOFF_MAC_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* Unisolate the MAC -&gt; RX */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_INGR_EN</span><span class="p">,</span> <span class="o">!</span><span class="n">isolate</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AZ_RX_CFG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_stats_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_pending</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_disable_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_dma_done</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>	<span class="cm">/* no mac selected */</span>

	<span class="o">*</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_dma_done</span> <span class="o">=</span> <span class="n">FALCON_STATS_NOT_DONE</span><span class="p">;</span>
	<span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_pending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span> <span class="cm">/* ensure done flag is clear */</span>

	<span class="cm">/* Initiate DMA transfer of stats */</span>
	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_AB_MAC_STAT_DMA_CMD</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AB_MAC_STAT_DMA_ADR</span><span class="p">,</span>
			     <span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MAC_STAT_DMA</span><span class="p">);</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_timer</span><span class="p">,</span> <span class="n">round_jiffies_up</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_stats_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_pending</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_dma_done</span> <span class="o">==</span> <span class="n">FALCON_STATS_DONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rmb</span><span class="p">();</span> <span class="cm">/* read the done flag before the stats */</span>
		<span class="n">falcon_update_stats_xmac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;timed out waiting for statistics</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_stats_timer_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="p">)</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>

	<span class="n">falcon_stats_complete</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_disable_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">falcon_stats_request</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">falcon_loopback_link_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_link_state</span> <span class="n">old_state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">LOOPBACK_INTERNAL</span><span class="p">(</span><span class="n">efx</span><span class="p">));</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">wanted_fc</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">up</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">efx_link_state_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_reconfigure_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">);</span>

	<span class="cm">/* Poll the PHY link state *before* reconfiguring it. This means we</span>
<span class="cm">	 * will pick up the correct speed (in loopback) to select the correct</span>
<span class="cm">	 * MAC.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">LOOPBACK_INTERNAL</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
		<span class="n">falcon_loopback_link_poll</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">falcon_stop_nic_stats</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">falcon_deconfigure_mac_wrapper</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">falcon_reset_macs</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">reconfigure</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_reconfigure_xmac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>

	<span class="n">falcon_start_nic_stats</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Synchronise efx-&gt;link_state with the kernel */</span>
	<span class="n">efx_link_status_changed</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * PHY access via GMII</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="cm">/* Wait for GMII access to complete */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_gmii_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">md_stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* wait up to 50ms - taken max from datasheet */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">md_stat</span><span class="p">,</span> <span class="n">FR_AB_MD_STAT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">md_stat</span><span class="p">,</span> <span class="n">FRF_AB_MD_BSY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">md_stat</span><span class="p">,</span> <span class="n">FRF_AB_MD_LNFL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
			    <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">md_stat</span><span class="p">,</span> <span class="n">FRF_AB_MD_BSERR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
					  <span class="s">&quot;error from GMII access &quot;</span>
					  <span class="n">EFX_OWORD_FMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="n">md_stat</span><span class="p">));</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;timed out waiting for GMII</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Write an MDIO register of a PHY connected to Falcon. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">prtad</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devad</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;writing MDIO %d register %d.%d with 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">prtad</span><span class="p">,</span> <span class="n">devad</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">mdio_lock</span><span class="p">);</span>

	<span class="cm">/* Check MDIO not currently being accessed */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_gmii_wait</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Write the address/ID register */</span>
	<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_MD_PHY_ADR</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MD_PHY_ADR</span><span class="p">);</span>

	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_MD_PRT_ADR</span><span class="p">,</span> <span class="n">prtad</span><span class="p">,</span>
			     <span class="n">FRF_AB_MD_DEV_ADR</span><span class="p">,</span> <span class="n">devad</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MD_ID</span><span class="p">);</span>

	<span class="cm">/* Write data */</span>
	<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_MD_TXD</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MD_TXD</span><span class="p">);</span>

	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_AB_MD_WRC</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AB_MD_GC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MD_CS</span><span class="p">);</span>

	<span class="cm">/* Wait for data to be written */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_gmii_wait</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Abort the write operation */</span>
		<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
				     <span class="n">FRF_AB_MD_WRC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">FRF_AB_MD_GC</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MD_CS</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">mdio_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Read an MDIO register of a PHY connected to Falcon. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">prtad</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devad</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">mdio_lock</span><span class="p">);</span>

	<span class="cm">/* Check MDIO not currently being accessed */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_gmii_wait</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_MD_PHY_ADR</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MD_PHY_ADR</span><span class="p">);</span>

	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_MD_PRT_ADR</span><span class="p">,</span> <span class="n">prtad</span><span class="p">,</span>
			     <span class="n">FRF_AB_MD_DEV_ADR</span><span class="p">,</span> <span class="n">devad</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MD_ID</span><span class="p">);</span>

	<span class="cm">/* Request data to be read */</span>
	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_MD_RDC</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">FRF_AB_MD_GC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MD_CS</span><span class="p">);</span>

	<span class="cm">/* Wait for data to become available */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_gmii_wait</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MD_RXD</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AB_MD_RXD</span><span class="p">);</span>
		<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;read from MDIO %d register %d.%d, got %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">prtad</span><span class="p">,</span> <span class="n">devad</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Abort the read operation */</span>
		<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
				     <span class="n">FRF_AB_MD_RIC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">FRF_AB_MD_GC</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AB_MD_CS</span><span class="p">);</span>

		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;read from MDIO %d register %d.%d, got error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">prtad</span><span class="p">,</span> <span class="n">devad</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">mdio_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This call is responsible for hooking in the MAC and PHY operations */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_probe_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PHY_TYPE_SFX7101</span>:
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">falcon_sfx7101_phy_ops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PHY_TYPE_QT2022C2</span>:
	<span class="k">case</span> <span class="n">PHY_TYPE_QT2025C</span>:
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">falcon_qt202x_phy_ops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PHY_TYPE_TXC43128</span>:
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">falcon_txc_phy_ops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Unknown PHY type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill out MDIO structure and loopback modes */</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">mdio_lock</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">mdio_read</span> <span class="o">=</span> <span class="n">falcon_mdio_read</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">mdio_write</span> <span class="o">=</span> <span class="n">falcon_mdio_write</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Initial assumption */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Hardware flow ctrl. FalconA RX FIFO too small for pause generation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">wanted_fc</span> <span class="o">=</span> <span class="n">EFX_FC_RX</span> <span class="o">|</span> <span class="n">EFX_FC_TX</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">wanted_fc</span> <span class="o">=</span> <span class="n">EFX_FC_RX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">mmds</span> <span class="o">&amp;</span> <span class="n">MDIO_DEVS_AN</span><span class="p">)</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">wanted_fc</span> <span class="o">|=</span> <span class="n">EFX_FC_AUTO</span><span class="p">;</span>

	<span class="cm">/* Allocate buffer for stats */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_nic_alloc_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">,</span>
				  <span class="n">FALCON_MAC_STATS_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;stats buffer at %llx (virt %p phys %llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span>
		  <span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">addr</span><span class="p">));</span>
	<span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_dma_done</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XgDmaDone_offset</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_remove_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_nic_free_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Global events are basically PHY events */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">falcon_handle_global_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AB_GLB_EV_G_PHY0_INTR</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AB_GLB_EV_XG_PHY0_INTR</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AB_GLB_EV_XFP_PHY0_INTR</span><span class="p">))</span>
		<span class="cm">/* Ignored */</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">==</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_BB_GLB_EV_XG_MGT_INTR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">xmac_poll_required</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">EFX_REV_FALCON_A1</span> <span class="o">?</span>
	    <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AA_GLB_EV_RX_RECOVERY</span><span class="p">)</span> <span class="o">:</span>
	    <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_BB_GLB_EV_RX_RECOVERY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;channel %d seen global RX_RESET event. Resetting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_reset</span><span class="p">);</span>
		<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">EFX_WORKAROUND_6555</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">?</span>
				   <span class="n">RESET_TYPE_RX_RECOVERY</span> <span class="o">:</span> <span class="n">RESET_TYPE_DISABLE</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Falcon test code</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">falcon_read_nvram</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">falcon_nvconfig</span> <span class="o">*</span><span class="n">nvconfig_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">falcon_nvconfig</span> <span class="o">*</span><span class="n">nvconfig</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">region</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">magic_num</span><span class="p">,</span> <span class="n">struct_ver</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">word</span><span class="p">,</span> <span class="o">*</span><span class="n">limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_spi_present</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_flash</span><span class="p">))</span>
		<span class="n">spi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_flash</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">efx_spi_present</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_eeprom</span><span class="p">))</span>
		<span class="n">spi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_eeprom</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">region</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">FALCON_NVCONFIG_END</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">region</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">nvconfig</span> <span class="o">=</span> <span class="n">region</span> <span class="o">+</span> <span class="n">FALCON_NVCONFIG_OFFSET</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_spi_read</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">spi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FALCON_NVCONFIG_END</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Failed to read %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">efx_spi_present</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_flash</span><span class="p">)</span> <span class="o">?</span>
			  <span class="s">&quot;flash&quot;</span> <span class="o">:</span> <span class="s">&quot;EEPROM&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">magic_num</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">nvconfig</span><span class="o">-&gt;</span><span class="n">board_magic_num</span><span class="p">);</span>
	<span class="n">struct_ver</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">nvconfig</span><span class="o">-&gt;</span><span class="n">board_struct_ver</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">magic_num</span> <span class="o">!=</span> <span class="n">FALCON_NVCONFIG_BOARD_MAGIC_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;NVRAM bad magic 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">magic_num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">struct_ver</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;NVRAM has ancient version 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">struct_ver</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">struct_ver</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nvconfig</span><span class="o">-&gt;</span><span class="n">board_magic_num</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">nvconfig</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">region</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">region</span> <span class="o">+</span> <span class="n">FALCON_NVCONFIG_END</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">csum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">word</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="o">++</span><span class="n">word</span><span class="p">)</span>
		<span class="n">csum</span> <span class="o">+=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">word</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">csum</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;NVRAM has incorrect checksum</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nvconfig_out</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">nvconfig_out</span><span class="p">,</span> <span class="n">nvconfig</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nvconfig</span><span class="p">));</span>

 <span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_test_nvram</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">falcon_read_nvram</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_register_test</span> <span class="n">falcon_b0_register_tests</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FR_AZ_ADR_REGION</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x0003FFFF</span><span class="p">,</span> <span class="mh">0x0003FFFF</span><span class="p">,</span> <span class="mh">0x0003FFFF</span><span class="p">,</span> <span class="mh">0x0003FFFF</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_RX_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0xFFFFFFFE</span><span class="p">,</span> <span class="mh">0x00017FFF</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_TX_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x7FFF0037</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_TX_RESERVED</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0xFFFEFE80</span><span class="p">,</span> <span class="mh">0x1FFFFFFF</span><span class="p">,</span> <span class="mh">0x020000FE</span><span class="p">,</span> <span class="mh">0x007FFFFF</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AB_MAC_CTRL</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0xFFFF0000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_SRM_TX_DC_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x001FFFFF</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_RX_DC_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x0000000F</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_RX_DC_PF_WM</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x000003FF</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_BZ_DP_CTRL</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x00000FFF</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AB_GM_CFG2</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x00007337</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AB_GMF_CFG0</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x00001F1F</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AB_XM_GLB_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x00000C68</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AB_XM_TX_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x00080164</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AB_XM_RX_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x07100A0C</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AB_XM_RX_PARAM</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x00001FF8</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AB_XM_FC</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0xFFFF0001</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AB_XM_ADR_LO</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AB_XX_SD_CTL</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x0003FF0F</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_b0_test_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">efx_nic_test_registers</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">falcon_b0_register_tests</span><span class="p">,</span>
				      <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">falcon_b0_register_tests</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Device reset</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">reset_type</span> <span class="nf">falcon_map_reset_reason</span><span class="p">(</span><span class="k">enum</span> <span class="n">reset_type</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RESET_TYPE_RX_RECOVERY</span>:
	<span class="k">case</span> <span class="n">RESET_TYPE_RX_DESC_FETCH</span>:
	<span class="k">case</span> <span class="n">RESET_TYPE_TX_DESC_FETCH</span>:
	<span class="k">case</span> <span class="n">RESET_TYPE_TX_SKIP</span>:
		<span class="cm">/* These can occasionally occur due to hardware bugs.</span>
<span class="cm">		 * We try to reset without disrupting the link.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">RESET_TYPE_INVISIBLE</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">RESET_TYPE_ALL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_map_reset_flags</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">FALCON_RESET_INVISIBLE</span> <span class="o">=</span> <span class="p">(</span><span class="n">ETH_RESET_DMA</span> <span class="o">|</span> <span class="n">ETH_RESET_FILTER</span> <span class="o">|</span>
					  <span class="n">ETH_RESET_OFFLOAD</span> <span class="o">|</span> <span class="n">ETH_RESET_MAC</span><span class="p">),</span>
		<span class="n">FALCON_RESET_ALL</span> <span class="o">=</span> <span class="n">FALCON_RESET_INVISIBLE</span> <span class="o">|</span> <span class="n">ETH_RESET_PHY</span><span class="p">,</span>
		<span class="n">FALCON_RESET_WORLD</span> <span class="o">=</span> <span class="n">FALCON_RESET_ALL</span> <span class="o">|</span> <span class="n">ETH_RESET_IRQ</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FALCON_RESET_WORLD</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALCON_RESET_WORLD</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FALCON_RESET_WORLD</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">RESET_TYPE_WORLD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FALCON_RESET_ALL</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALCON_RESET_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FALCON_RESET_ALL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">RESET_TYPE_ALL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FALCON_RESET_INVISIBLE</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALCON_RESET_INVISIBLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FALCON_RESET_INVISIBLE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">RESET_TYPE_INVISIBLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Resets NIC to known state.  This routine must be called in process</span>
<span class="cm"> * context and is allowed to sleep. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__falcon_reset_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">reset_type</span> <span class="n">method</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">glb_ctl_reg_ker</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;performing %s hardware reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">RESET_TYPE</span><span class="p">(</span><span class="n">method</span><span class="p">));</span>

	<span class="cm">/* Initiate device reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="n">RESET_TYPE_WORLD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;failed to backup PCI state of primary &quot;</span>
				  <span class="s">&quot;function prior to hardware reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_is_dual_func</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">pci_dev2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
					  <span class="s">&quot;failed to backup PCI state of &quot;</span>
					  <span class="s">&quot;secondary function prior to &quot;</span>
					  <span class="s">&quot;hardware reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">glb_ctl_reg_ker</span><span class="p">,</span>
				     <span class="n">FRF_AB_EXT_PHY_RST_DUR</span><span class="p">,</span>
				     <span class="n">FFE_AB_EXT_PHY_RST_DUR_10240US</span><span class="p">,</span>
				     <span class="n">FRF_AB_SWRST</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">EFX_POPULATE_OWORD_7</span><span class="p">(</span><span class="n">glb_ctl_reg_ker</span><span class="p">,</span>
				     <span class="cm">/* exclude PHY from &quot;invisible&quot; reset */</span>
				     <span class="n">FRF_AB_EXT_PHY_RST_CTL</span><span class="p">,</span>
				     <span class="n">method</span> <span class="o">==</span> <span class="n">RESET_TYPE_INVISIBLE</span><span class="p">,</span>
				     <span class="cm">/* exclude EEPROM/flash and PCIe */</span>
				     <span class="n">FRF_AB_PCIE_CORE_RST_CTL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				     <span class="n">FRF_AB_PCIE_NSTKY_RST_CTL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				     <span class="n">FRF_AB_PCIE_SD_RST_CTL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				     <span class="n">FRF_AB_EE_RST_CTL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				     <span class="n">FRF_AB_EXT_PHY_RST_DUR</span><span class="p">,</span>
				     <span class="n">FFE_AB_EXT_PHY_RST_DUR_10240US</span><span class="p">,</span>
				     <span class="n">FRF_AB_SWRST</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">glb_ctl_reg_ker</span><span class="p">,</span> <span class="n">FR_AB_GLB_CTL</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;waiting for hardware reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="mi">20</span><span class="p">);</span>

	<span class="cm">/* Restore PCI configuration if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="n">RESET_TYPE_WORLD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_is_dual_func</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
			<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">pci_dev2</span><span class="p">);</span>
		<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;successfully restored PCI config</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Assert that reset complete */</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">glb_ctl_reg_ker</span><span class="p">,</span> <span class="n">FR_AB_GLB_CTL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">glb_ctl_reg_ker</span><span class="p">,</span> <span class="n">FRF_AB_SWRST</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;timed out waiting for hardware reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;hardware reset complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* pci_save_state() and pci_restore_state() MUST be called in pairs */</span>
<span class="nl">fail2:</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
<span class="nl">fail1:</span>
<span class="nl">fail3:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_reset_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">reset_type</span> <span class="n">method</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">__falcon_reset_hw</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">method</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">link_changed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_lock</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_board</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">monitor</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;Board sensor %s; shutting down PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;reported fault&quot;</span> <span class="o">:</span> <span class="s">&quot;failed&quot;</span><span class="p">);</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">|=</span> <span class="n">PHY_MODE_LOW_POWER</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">__efx_reconfigure_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">LOOPBACK_INTERNAL</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
		<span class="n">link_changed</span> <span class="o">=</span> <span class="n">falcon_loopback_link_poll</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">link_changed</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link_changed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">falcon_stop_nic_stats</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="n">falcon_deconfigure_mac_wrapper</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

		<span class="n">falcon_reset_macs</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_reconfigure_xmac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>

		<span class="n">falcon_start_nic_stats</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

		<span class="n">efx_link_status_changed</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">falcon_poll_xmac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Zeroes out the SRAM contents.  This routine must be called in</span>
<span class="cm"> * process context and is allowed to sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_reset_sram</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">srm_cfg_reg_ker</span><span class="p">,</span> <span class="n">gpio_cfg_reg_ker</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* Set the SRAM wake/sleep GPIO appropriately. */</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_cfg_reg_ker</span><span class="p">,</span> <span class="n">FR_AB_GPIO_CTL</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">gpio_cfg_reg_ker</span><span class="p">,</span> <span class="n">FRF_AB_GPIO1_OEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">gpio_cfg_reg_ker</span><span class="p">,</span> <span class="n">FRF_AB_GPIO1_OUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_cfg_reg_ker</span><span class="p">,</span> <span class="n">FR_AB_GPIO_CTL</span><span class="p">);</span>

	<span class="cm">/* Initiate SRAM reset */</span>
	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">srm_cfg_reg_ker</span><span class="p">,</span>
			     <span class="n">FRF_AZ_SRM_INIT_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AZ_SRM_NB_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srm_cfg_reg_ker</span><span class="p">,</span> <span class="n">FR_AZ_SRM_CFG</span><span class="p">);</span>

	<span class="cm">/* Wait for SRAM reset to complete */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;waiting for SRAM reset (attempt %d)...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

		<span class="cm">/* SRAM reset is slow; expect around 16ms */</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="mi">50</span><span class="p">);</span>

		<span class="cm">/* Check for reset complete */</span>
		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srm_cfg_reg_ker</span><span class="p">,</span> <span class="n">FR_AZ_SRM_CFG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">srm_cfg_reg_ker</span><span class="p">,</span> <span class="n">FRF_AZ_SRM_INIT_EN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;SRAM reset complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">);</span>	<span class="cm">/* wait up to 0.4 sec */</span>

	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;timed out waiting for SRAM reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_spi_device_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi_device</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">device_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_type</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spi_device</span><span class="o">-&gt;</span><span class="n">device_id</span> <span class="o">=</span> <span class="n">device_id</span><span class="p">;</span>
		<span class="n">spi_device</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span>
			<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_DEV_TYPE_FIELD</span><span class="p">(</span><span class="n">device_type</span><span class="p">,</span> <span class="n">SPI_DEV_TYPE_SIZE</span><span class="p">);</span>
		<span class="n">spi_device</span><span class="o">-&gt;</span><span class="n">addr_len</span> <span class="o">=</span>
			<span class="n">SPI_DEV_TYPE_FIELD</span><span class="p">(</span><span class="n">device_type</span><span class="p">,</span> <span class="n">SPI_DEV_TYPE_ADDR_LEN</span><span class="p">);</span>
		<span class="n">spi_device</span><span class="o">-&gt;</span><span class="n">munge_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">spi_device</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span> <span class="o">&amp;&amp;</span>
					     <span class="n">spi_device</span><span class="o">-&gt;</span><span class="n">addr_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spi_device</span><span class="o">-&gt;</span><span class="n">erase_command</span> <span class="o">=</span>
			<span class="n">SPI_DEV_TYPE_FIELD</span><span class="p">(</span><span class="n">device_type</span><span class="p">,</span> <span class="n">SPI_DEV_TYPE_ERASE_CMD</span><span class="p">);</span>
		<span class="n">spi_device</span><span class="o">-&gt;</span><span class="n">erase_size</span> <span class="o">=</span>
			<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_DEV_TYPE_FIELD</span><span class="p">(</span><span class="n">device_type</span><span class="p">,</span>
						<span class="n">SPI_DEV_TYPE_ERASE_SIZE</span><span class="p">);</span>
		<span class="n">spi_device</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">=</span>
			<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_DEV_TYPE_FIELD</span><span class="p">(</span><span class="n">device_type</span><span class="p">,</span>
						<span class="n">SPI_DEV_TYPE_BLOCK_SIZE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spi_device</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Extract non-volatile configuration */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_probe_nvconfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">falcon_nvconfig</span> <span class="o">*</span><span class="n">nvconfig</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">nvconfig</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nvconfig</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nvconfig</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_read_nvram</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">nvconfig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">nvconfig</span><span class="o">-&gt;</span><span class="n">board_v2</span><span class="p">.</span><span class="n">port0_phy_type</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">prtad</span> <span class="o">=</span> <span class="n">nvconfig</span><span class="o">-&gt;</span><span class="n">board_v2</span><span class="p">.</span><span class="n">port0_phy_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">nvconfig</span><span class="o">-&gt;</span><span class="n">board_struct_ver</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">falcon_spi_device_init</span><span class="p">(</span>
			<span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_flash</span><span class="p">,</span> <span class="n">FFE_AB_SPI_DEVICE_FLASH</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">nvconfig</span><span class="o">-&gt;</span><span class="n">board_v3</span>
				    <span class="p">.</span><span class="n">spi_device_type</span><span class="p">[</span><span class="n">FFE_AB_SPI_DEVICE_FLASH</span><span class="p">]));</span>
		<span class="n">falcon_spi_device_init</span><span class="p">(</span>
			<span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_eeprom</span><span class="p">,</span> <span class="n">FFE_AB_SPI_DEVICE_EEPROM</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">nvconfig</span><span class="o">-&gt;</span><span class="n">board_v3</span>
				    <span class="p">.</span><span class="n">spi_device_type</span><span class="p">[</span><span class="n">FFE_AB_SPI_DEVICE_EEPROM</span><span class="p">]));</span>
	<span class="p">}</span>

	<span class="cm">/* Read the MAC addresses */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">nvconfig</span><span class="o">-&gt;</span><span class="n">mac_address</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;PHY is %d phy_id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">prtad</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_probe_board</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span>
				<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">nvconfig</span><span class="o">-&gt;</span><span class="n">board_v2</span><span class="p">.</span><span class="n">board_revision</span><span class="p">));</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">nvconfig</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_dimension_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_dc_base</span> <span class="o">=</span> <span class="mh">0x20000</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_dc_base</span> <span class="o">=</span> <span class="mh">0x26000</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Probe all SPI devices on the NIC */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_probe_spi_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">nic_stat</span><span class="p">,</span> <span class="n">gpio_ctl</span><span class="p">,</span> <span class="n">ee_vpd_cfg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">boot_dev</span><span class="p">;</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_ctl</span><span class="p">,</span> <span class="n">FR_AB_GPIO_CTL</span><span class="p">);</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nic_stat</span><span class="p">,</span> <span class="n">FR_AB_NIC_STAT</span><span class="p">);</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ee_vpd_cfg</span><span class="p">,</span> <span class="n">FR_AB_EE_VPD_CFG0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">gpio_ctl</span><span class="p">,</span> <span class="n">FRF_AB_GPIO3_PWRUP_VALUE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">boot_dev</span> <span class="o">=</span> <span class="p">(</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">nic_stat</span><span class="p">,</span> <span class="n">FRF_AB_SF_PRST</span><span class="p">)</span> <span class="o">?</span>
			    <span class="n">FFE_AB_SPI_DEVICE_FLASH</span> <span class="o">:</span> <span class="n">FFE_AB_SPI_DEVICE_EEPROM</span><span class="p">);</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Booted from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">boot_dev</span> <span class="o">==</span> <span class="n">FFE_AB_SPI_DEVICE_FLASH</span> <span class="o">?</span>
			  <span class="s">&quot;flash&quot;</span> <span class="o">:</span> <span class="s">&quot;EEPROM&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Disable VPD and set clock dividers to safe</span>
<span class="cm">		 * values for initial programming. */</span>
		<span class="n">boot_dev</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;Booted from internal ASIC settings;&quot;</span>
			  <span class="s">&quot; setting SPI config</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">EFX_POPULATE_OWORD_3</span><span class="p">(</span><span class="n">ee_vpd_cfg</span><span class="p">,</span> <span class="n">FRF_AB_EE_VPD_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="cm">/* 125 MHz / 7 ~= 20 MHz */</span>
				     <span class="n">FRF_AB_EE_SF_CLOCK_DIV</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span>
				     <span class="cm">/* 125 MHz / 63 ~= 2 MHz */</span>
				     <span class="n">FRF_AB_EE_EE_CLOCK_DIV</span><span class="p">,</span> <span class="mi">63</span><span class="p">);</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ee_vpd_cfg</span><span class="p">,</span> <span class="n">FR_AB_EE_VPD_CFG0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_dev</span> <span class="o">==</span> <span class="n">FFE_AB_SPI_DEVICE_FLASH</span><span class="p">)</span>
		<span class="n">falcon_spi_device_init</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_flash</span><span class="p">,</span>
				       <span class="n">FFE_AB_SPI_DEVICE_FLASH</span><span class="p">,</span>
				       <span class="n">default_flash_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_dev</span> <span class="o">==</span> <span class="n">FFE_AB_SPI_DEVICE_EEPROM</span><span class="p">)</span>
		<span class="n">falcon_spi_device_init</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">spi_eeprom</span><span class="p">,</span>
				       <span class="n">FFE_AB_SPI_DEVICE_EEPROM</span><span class="p">,</span>
				       <span class="n">large_eeprom_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_probe_nic</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">falcon_board</span> <span class="o">*</span><span class="n">board</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Allocate storage for hardware specific data */</span>
	<span class="n">nic_data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nic_data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nic_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">nic_data</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_fpga_ver</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;Falcon FPGA not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">EFX_REV_FALCON_A1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_oword_t</span> <span class="n">nic_stat</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">pci_rev</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">pci_rev</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">pci_rev</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;Falcon rev A0 not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nic_stat</span><span class="p">,</span> <span class="n">FR_AB_NIC_STAT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">nic_stat</span><span class="p">,</span> <span class="n">FRF_AB_STRAP_10G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;Falcon rev A1 1G not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">nic_stat</span><span class="p">,</span> <span class="n">FRF_AA_STRAP_PCIE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;Falcon rev A1 PCI-X not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev</span> <span class="o">=</span> <span class="n">pci_dev_get</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SOLARFLARE</span><span class="p">,</span>
					     <span class="n">PCI_DEVICE_ID_SOLARFLARE_SFC4000A_1</span><span class="p">,</span>
					     <span class="n">dev</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">&amp;&amp;</span>
			    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">==</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">pci_dev2</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">pci_dev2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;failed to find secondary function</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Now we can reset the NIC */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">__falcon_reset_hw</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_ALL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;failed to reset NIC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate memory for INT_KER */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_nic_alloc_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_oword_t</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail4</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;INT_KER at %llx (virt %p phys %llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span>
		  <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">addr</span><span class="p">));</span>

	<span class="n">falcon_probe_spi_devices</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Read in the non-volatile configuration */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_probe_nvconfig</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;NVRAM is invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">timer_quantum_ns</span> <span class="o">=</span> <span class="mi">4968</span><span class="p">;</span> <span class="cm">/* 621 cycles */</span>

	<span class="cm">/* Initialise I2C adapter */</span>
	<span class="n">board</span> <span class="o">=</span> <span class="n">falcon_board</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_data</span> <span class="o">=</span> <span class="n">falcon_i2c_bit_operations</span><span class="p">;</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_data</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">efx</span><span class="p">;</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">.</span><span class="n">algo_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_data</span><span class="p">;</span>
	<span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;SFC4000 GPIO&quot;</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">.</span><span class="n">name</span><span class="p">));</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">i2c_bit_add_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail5</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_board</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;failed to initialise board</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail6</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_disable_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">falcon_stats_timer_func</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail6:</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i2c_del_adapter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">));</span>
 <span class="nl">fail5:</span>
	<span class="n">efx_nic_free_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">);</span>
 <span class="nl">fail4:</span>
 <span class="nl">fail3:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">pci_dev2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">pci_dev2</span><span class="p">);</span>
		<span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">pci_dev2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">fail2:</span>
 <span class="nl">fail1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_init_rx_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Prior to Siena the RX DMA engine will split each frame at</span>
<span class="cm">	 * intervals of RX_USR_BUF_SIZE (32-byte units). We set it to</span>
<span class="cm">	 * be so large that that never happens. */</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">huge_buf_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">4096</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>
	<span class="cm">/* RX control FIFO thresholds (32 entries) */</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">ctrl_xon_thr</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">ctrl_xoff_thr</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AZ_RX_CFG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">EFX_REV_FALCON_A1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Data FIFO size is 5.5K */</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AA_RX_DESC_PUSH_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AA_RX_USR_BUF_SIZE</span><span class="p">,</span>
				    <span class="n">huge_buf_size</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AA_RX_XON_MAC_TH</span><span class="p">,</span> <span class="mi">512</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AA_RX_XOFF_MAC_TH</span><span class="p">,</span> <span class="mi">2048</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AA_RX_XON_TX_TH</span><span class="p">,</span> <span class="n">ctrl_xon_thr</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AA_RX_XOFF_TX_TH</span><span class="p">,</span> <span class="n">ctrl_xoff_thr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Data FIFO size is 80K; register fields moved */</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_DESC_PUSH_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_USR_BUF_SIZE</span><span class="p">,</span>
				    <span class="n">huge_buf_size</span><span class="p">);</span>
		<span class="cm">/* Send XON and XOFF at ~3 * max MTU away from empty/full */</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_XON_MAC_TH</span><span class="p">,</span> <span class="mi">27648</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_XOFF_MAC_TH</span><span class="p">,</span> <span class="mi">54272</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_XON_TX_TH</span><span class="p">,</span> <span class="n">ctrl_xon_thr</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_XOFF_TX_TH</span><span class="p">,</span> <span class="n">ctrl_xoff_thr</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_INGR_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Enable hash insertion. This is broken for the</span>
<span class="cm">		 * &#39;Falcon&#39; hash so also select Toeplitz TCP/IPv4 and</span>
<span class="cm">		 * IPv4 hashes. */</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_HASH_INSRT_HDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_HASH_ALG</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_RX_IP_HASH</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Always enable XOFF signal from RX FIFO.  We enable</span>
<span class="cm">	 * or disable transmission of pause frames at the MAC. */</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AZ_RX_XOFF_MAC_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AZ_RX_CFG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This call performs hardware-specific global initialisation, such as</span>
<span class="cm"> * defining the descriptor cache sizes and number of RSS channels.</span>
<span class="cm"> * It does not set up any buffers, descriptor rings or event queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_init_nic</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Use on-chip SRAM */</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AB_NIC_STAT</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AB_ONCHIP_SRAM</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AB_NIC_STAT</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">falcon_reset_sram</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Clear the parity enables on the TX data fifos as</span>
<span class="cm">	 * they produce false parity errors because of timing issues</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EFX_WORKAROUND_5129</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_CSR_SPARE</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AB_MEM_PERR_EN_TX_DATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_CSR_SPARE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EFX_WORKAROUND_7244</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_BZ_RX_FILTER_CTL</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_UDP_FULL_SRCH_LIMIT</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_UDP_WILD_SRCH_LIMIT</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_TCP_FULL_SRCH_LIMIT</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_TCP_WILD_SRCH_LIMIT</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_BZ_RX_FILTER_CTL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* XXX This is documented only for Falcon A0/A1 */</span>
	<span class="cm">/* Setup RX.  Wait for descriptor is broken and must</span>
<span class="cm">	 * be disabled.  RXDP recovery shouldn&#39;t be needed, but is.</span>
<span class="cm">	 */</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AA_RX_SELF_RST</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AA_RX_NODESC_WAIT_DIS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AA_RX_SELF_RST_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EFX_WORKAROUND_5583</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AA_RX_ISCSI_DIS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AA_RX_SELF_RST</span><span class="p">);</span>

	<span class="cm">/* Do not enable TX_NO_EOP_DISC_EN, since it limits packets to 16</span>
<span class="cm">	 * descriptors (which is bad).</span>
<span class="cm">	 */</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_TX_CFG</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_TX_NO_EOP_DISC_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_TX_CFG</span><span class="p">);</span>

	<span class="n">falcon_init_rx_cfg</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set hash key for IPv4 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_hash_key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_BZ_RX_RSS_TKEY</span><span class="p">);</span>

		<span class="cm">/* Set destination of both TX and RX Flush events */</span>
		<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_FLS_EVQ_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_BZ_DP_CTRL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx_nic_init_common</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_remove_nic</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">falcon_board</span> <span class="o">*</span><span class="n">board</span> <span class="o">=</span> <span class="n">falcon_board</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">board</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Remove I2C adapter and clear it in preparation for a retry */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">i2c_del_adapter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">));</span>

	<span class="n">efx_nic_free_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">);</span>

	<span class="n">__falcon_reset_hw</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_ALL</span><span class="p">);</span>

	<span class="cm">/* Release the second function after the reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">pci_dev2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">pci_dev2</span><span class="p">);</span>
		<span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">pci_dev2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Tear down the private nic state */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_update_nic_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_disable_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="n">FR_AZ_RX_NODESC_DROP</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_nodesc_drop_cnt</span> <span class="o">+=</span>
		<span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">FRF_AB_RX_NODESC_DROP_CNT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_pending</span> <span class="o">&amp;&amp;</span>
	    <span class="o">*</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_dma_done</span> <span class="o">==</span> <span class="n">FALCON_STATS_DONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span> <span class="cm">/* read the done flag before the stats */</span>
		<span class="n">falcon_update_stats_xmac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">falcon_start_nic_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_disable_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">falcon_stats_request</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">falcon_stop_nic_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>
	<span class="o">++</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_disable_count</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_timer</span><span class="p">);</span>

	<span class="cm">/* Wait enough time for the most recent transfer to</span>
<span class="cm">	 * complete. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_pending</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">stats_dma_done</span> <span class="o">==</span> <span class="n">FALCON_STATS_DONE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>
	<span class="n">falcon_stats_complete</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_set_id_led</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">efx_led_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">falcon_board</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">set_id_led</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Wake on LAN</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">falcon_get_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wol</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">sopass</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">sopass</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">falcon_set_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Revision-dependent attributes used by efx.c and nic.c</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_type</span> <span class="n">falcon_a1_nic_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">falcon_probe_nic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">falcon_remove_nic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">falcon_init_nic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dimension_resources</span> <span class="o">=</span> <span class="n">falcon_dimension_resources</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fini</span> <span class="o">=</span> <span class="n">efx_port_dummy_op_void</span><span class="p">,</span>
	<span class="p">.</span><span class="n">monitor</span> <span class="o">=</span> <span class="n">falcon_monitor</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_reset_reason</span> <span class="o">=</span> <span class="n">falcon_map_reset_reason</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_reset_flags</span> <span class="o">=</span> <span class="n">falcon_map_reset_flags</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span> <span class="o">=</span> <span class="n">falcon_reset_hw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe_port</span> <span class="o">=</span> <span class="n">falcon_probe_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove_port</span> <span class="o">=</span> <span class="n">falcon_remove_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">handle_global_event</span> <span class="o">=</span> <span class="n">falcon_handle_global_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare_flush</span> <span class="o">=</span> <span class="n">falcon_prepare_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_stats</span> <span class="o">=</span> <span class="n">falcon_update_nic_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_stats</span> <span class="o">=</span> <span class="n">falcon_start_nic_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_stats</span> <span class="o">=</span> <span class="n">falcon_stop_nic_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_id_led</span> <span class="o">=</span> <span class="n">falcon_set_id_led</span><span class="p">,</span>
	<span class="p">.</span><span class="n">push_irq_moderation</span> <span class="o">=</span> <span class="n">falcon_push_irq_moderation</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reconfigure_port</span> <span class="o">=</span> <span class="n">falcon_reconfigure_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reconfigure_mac</span> <span class="o">=</span> <span class="n">falcon_reconfigure_xmac</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_mac_fault</span> <span class="o">=</span> <span class="n">falcon_xmac_check_fault</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_wol</span> <span class="o">=</span> <span class="n">falcon_get_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_wol</span> <span class="o">=</span> <span class="n">falcon_set_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume_wol</span> <span class="o">=</span> <span class="n">efx_port_dummy_op_void</span><span class="p">,</span>
	<span class="p">.</span><span class="n">test_nvram</span> <span class="o">=</span> <span class="n">falcon_test_nvram</span><span class="p">,</span>

	<span class="p">.</span><span class="n">revision</span> <span class="o">=</span> <span class="n">EFX_REV_FALCON_A1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mem_map_size</span> <span class="o">=</span> <span class="mh">0x20000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">txd_ptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_AA_TX_DESC_PTR_TBL_KER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rxd_ptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_AA_RX_DESC_PTR_TBL_KER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_tbl_base</span> <span class="o">=</span> <span class="n">FR_AA_BUF_FULL_TBL_KER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">evq_ptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_AA_EVQ_PTR_TBL_KER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">evq_rptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_AA_EVQ_RPTR_KER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_dma_mask</span> <span class="o">=</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="n">FSF_AZ_TX_KER_BUF_ADDR_WIDTH</span><span class="p">),</span>
	<span class="p">.</span><span class="n">rx_buffer_padding</span> <span class="o">=</span> <span class="mh">0x24</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_interrupt_mode</span> <span class="o">=</span> <span class="n">EFX_INT_MODE_MSI</span><span class="p">,</span>
	<span class="p">.</span><span class="n">phys_addr_channels</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="p">.</span><span class="n">timer_period_max</span> <span class="o">=</span>  <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">FRF_AB_TC_TIMER_VAL_WIDTH</span><span class="p">,</span>
	<span class="p">.</span><span class="n">offload_features</span> <span class="o">=</span> <span class="n">NETIF_F_IP_CSUM</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_type</span> <span class="n">falcon_b0_nic_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">falcon_probe_nic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">falcon_remove_nic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">falcon_init_nic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dimension_resources</span> <span class="o">=</span> <span class="n">falcon_dimension_resources</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fini</span> <span class="o">=</span> <span class="n">efx_port_dummy_op_void</span><span class="p">,</span>
	<span class="p">.</span><span class="n">monitor</span> <span class="o">=</span> <span class="n">falcon_monitor</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_reset_reason</span> <span class="o">=</span> <span class="n">falcon_map_reset_reason</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_reset_flags</span> <span class="o">=</span> <span class="n">falcon_map_reset_flags</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span> <span class="o">=</span> <span class="n">falcon_reset_hw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe_port</span> <span class="o">=</span> <span class="n">falcon_probe_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove_port</span> <span class="o">=</span> <span class="n">falcon_remove_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">handle_global_event</span> <span class="o">=</span> <span class="n">falcon_handle_global_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare_flush</span> <span class="o">=</span> <span class="n">falcon_prepare_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_stats</span> <span class="o">=</span> <span class="n">falcon_update_nic_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_stats</span> <span class="o">=</span> <span class="n">falcon_start_nic_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_stats</span> <span class="o">=</span> <span class="n">falcon_stop_nic_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_id_led</span> <span class="o">=</span> <span class="n">falcon_set_id_led</span><span class="p">,</span>
	<span class="p">.</span><span class="n">push_irq_moderation</span> <span class="o">=</span> <span class="n">falcon_push_irq_moderation</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reconfigure_port</span> <span class="o">=</span> <span class="n">falcon_reconfigure_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reconfigure_mac</span> <span class="o">=</span> <span class="n">falcon_reconfigure_xmac</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_mac_fault</span> <span class="o">=</span> <span class="n">falcon_xmac_check_fault</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_wol</span> <span class="o">=</span> <span class="n">falcon_get_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_wol</span> <span class="o">=</span> <span class="n">falcon_set_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume_wol</span> <span class="o">=</span> <span class="n">efx_port_dummy_op_void</span><span class="p">,</span>
	<span class="p">.</span><span class="n">test_registers</span> <span class="o">=</span> <span class="n">falcon_b0_test_registers</span><span class="p">,</span>
	<span class="p">.</span><span class="n">test_nvram</span> <span class="o">=</span> <span class="n">falcon_test_nvram</span><span class="p">,</span>

	<span class="p">.</span><span class="n">revision</span> <span class="o">=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">,</span>
	<span class="cm">/* Map everything up to and including the RSS indirection</span>
<span class="cm">	 * table.  Don&#39;t map MSI-X table, MSI-X PBA since Linux</span>
<span class="cm">	 * requires that they not be mapped.  */</span>
	<span class="p">.</span><span class="n">mem_map_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">FR_BZ_RX_INDIRECTION_TBL</span> <span class="o">+</span>
			 <span class="n">FR_BZ_RX_INDIRECTION_TBL_STEP</span> <span class="o">*</span>
			 <span class="n">FR_BZ_RX_INDIRECTION_TBL_ROWS</span><span class="p">),</span>
	<span class="p">.</span><span class="n">txd_ptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_BZ_TX_DESC_PTR_TBL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rxd_ptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_BZ_RX_DESC_PTR_TBL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_tbl_base</span> <span class="o">=</span> <span class="n">FR_BZ_BUF_FULL_TBL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">evq_ptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_BZ_EVQ_PTR_TBL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">evq_rptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_BZ_EVQ_RPTR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_dma_mask</span> <span class="o">=</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="n">FSF_AZ_TX_KER_BUF_ADDR_WIDTH</span><span class="p">),</span>
	<span class="p">.</span><span class="n">rx_buffer_hash_size</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rx_buffer_padding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_interrupt_mode</span> <span class="o">=</span> <span class="n">EFX_INT_MODE_MSIX</span><span class="p">,</span>
	<span class="p">.</span><span class="n">phys_addr_channels</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="cm">/* Hardware limit is 64, but the legacy</span>
<span class="cm">				   * interrupt handler only supports 32</span>
<span class="cm">				   * channels */</span>
	<span class="p">.</span><span class="n">timer_period_max</span> <span class="o">=</span>  <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">FRF_AB_TC_TIMER_VAL_WIDTH</span><span class="p">,</span>
	<span class="p">.</span><span class="n">offload_features</span> <span class="o">=</span> <span class="n">NETIF_F_IP_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_RXHASH</span> <span class="o">|</span> <span class="n">NETIF_F_NTUPLE</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
