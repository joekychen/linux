<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › io.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>io.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2005-2006 Fen Systems Ltd.</span>
<span class="cm"> * Copyright 2006-2010 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef EFX_IO_H</span>
<span class="cp">#define EFX_IO_H</span>

<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * NIC register I/O</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Notes on locking strategy:</span>
<span class="cm"> *</span>
<span class="cm"> * Most CSRs are 128-bit (oword) and therefore cannot be read or</span>
<span class="cm"> * written atomically.  Access from the host is buffered by the Bus</span>
<span class="cm"> * Interface Unit (BIU).  Whenever the host reads from the lowest</span>
<span class="cm"> * address of such a register, or from the address of a different such</span>
<span class="cm"> * register, the BIU latches the register&#39;s value.  Subsequent reads</span>
<span class="cm"> * from higher addresses of the same register will read the latched</span>
<span class="cm"> * value.  Whenever the host writes part of such a register, the BIU</span>
<span class="cm"> * collects the written value and does not write to the underlying</span>
<span class="cm"> * register until all 4 dwords have been written.  A similar buffering</span>
<span class="cm"> * scheme applies to host access to the NIC&#39;s 64-bit SRAM.</span>
<span class="cm"> *</span>
<span class="cm"> * Access to different CSRs and 64-bit SRAM words must be serialised,</span>
<span class="cm"> * since interleaved access can result in lost writes or lost</span>
<span class="cm"> * information from read-to-clear fields.  We use efx_nic::biu_lock</span>
<span class="cm"> * for this.  (We could use separate locks for read and write, but</span>
<span class="cm"> * this is not normally a performance bottleneck.)</span>
<span class="cm"> *</span>
<span class="cm"> * The DMA descriptor pointers (RX_DESC_UPD and TX_DESC_UPD) are</span>
<span class="cm"> * 128-bit but are special-cased in the BIU to avoid the need for</span>
<span class="cm"> * locking in the host:</span>
<span class="cm"> *</span>
<span class="cm"> * - They are write-only.</span>
<span class="cm"> * - The semantics of writing to these registers are such that</span>
<span class="cm"> *   replacing the low 96 bits with zero does not affect functionality.</span>
<span class="cm"> * - If the host writes to the last dword address of such a register</span>
<span class="cm"> *   (i.e. the high 32 bits) the underlying register will always be</span>
<span class="cm"> *   written.  If the collector and the current write together do not</span>
<span class="cm"> *   provide values for all 128 bits of the register, the low 96 bits</span>
<span class="cm"> *   will be written as zero.</span>
<span class="cm"> * - If the host writes to the address of any other part of such a</span>
<span class="cm"> *   register while the collector already holds values for some other</span>
<span class="cm"> *   register, the write is discarded and the collector maintains its</span>
<span class="cm"> *   current state.</span>
<span class="cm"> */</span>

<span class="cp">#if BITS_PER_LONG == 64</span>
<span class="cp">#define EFX_USE_QWORD_IO 1</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef EFX_USE_QWORD_IO</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_efx_writeq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">__le64</span> <span class="n">value</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writeq</span><span class="p">((</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span><span class="n">value</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__le64</span> <span class="nf">_efx_readq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__le64</span><span class="p">)</span><span class="n">__raw_readq</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_efx_writed</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">value</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writel</span><span class="p">((</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">value</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__le32</span> <span class="nf">_efx_readd</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__le32</span><span class="p">)</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Write a normal 128-bit CSR, locking as appropriate. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_writeo</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">unused</span><span class="p">));</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;writing register %x with &quot;</span> <span class="n">EFX_OWORD_FMT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span>
		   <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">biu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#ifdef EFX_USE_QWORD_IO</span>
	<span class="n">_efx_writeq</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">_efx_writeq</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">_efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">_efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">_efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">_efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">mmiowb</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">biu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Write 64-bit SRAM through the supplied mapping, locking as appropriate. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_sram_writeq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">membase</span><span class="p">,</span>
				   <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">unused</span><span class="p">));</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;writing SRAM address %x with &quot;</span> <span class="n">EFX_QWORD_FMT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">addr</span><span class="p">,</span> <span class="n">EFX_QWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">biu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#ifdef EFX_USE_QWORD_IO</span>
	<span class="n">__raw_writeq</span><span class="p">((</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span><span class="n">value</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">membase</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">__raw_writel</span><span class="p">((</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">membase</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">((</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">membase</span> <span class="o">+</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">mmiowb</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">biu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Write a 32-bit CSR or the last dword of a special 128-bit CSR */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_writed</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_dword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;writing register %x with &quot;</span><span class="n">EFX_DWORD_FMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">reg</span><span class="p">,</span> <span class="n">EFX_DWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">));</span>

	<span class="cm">/* No lock required */</span>
	<span class="n">_efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Read a 128-bit CSR, locking as appropriate. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_reado</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">unused</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">biu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">_efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">_efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">biu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;read from register %x, got &quot;</span> <span class="n">EFX_OWORD_FMT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span>
		   <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Read 64-bit SRAM through the supplied mapping, locking as appropriate. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_sram_readq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">membase</span><span class="p">,</span>
				  <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">unused</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">biu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#ifdef EFX_USE_QWORD_IO</span>
	<span class="n">value</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__le64</span><span class="p">)</span><span class="n">__raw_readq</span><span class="p">(</span><span class="n">membase</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__le32</span><span class="p">)</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">membase</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__le32</span><span class="p">)</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">membase</span> <span class="o">+</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">biu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;read from SRAM address %x, got &quot;</span><span class="n">EFX_QWORD_FMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">addr</span><span class="p">,</span> <span class="n">EFX_QWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Read a 32-bit CSR or SRAM */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_readd</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_dword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;read from register %x, got &quot;</span><span class="n">EFX_DWORD_FMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">reg</span><span class="p">,</span> <span class="n">EFX_DWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Write a 128-bit CSR forming part of a table */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_writeo_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_oword_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Read a 128-bit CSR forming part of a table */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_reado_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_oword_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Write a 32-bit CSR forming part of a table, or 32-bit SRAM */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_writed_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_dword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_oword_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Read a 32-bit CSR forming part of a table, or 32-bit SRAM */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_readd_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_dword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_dword_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Page-mapped register block size */</span>
<span class="cp">#define EFX_PAGE_BLOCK_SIZE 0x2000</span>

<span class="cm">/* Calculate offset to page-mapped register block */</span>
<span class="cp">#define EFX_PAGED_REG(page, reg) \</span>
<span class="cp">	((page) * EFX_PAGE_BLOCK_SIZE + (reg))</span>

<span class="cm">/* Write the whole of RX_DESC_UPD or TX_DESC_UPD */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_efx_writeo_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">EFX_PAGED_REG</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;writing register %x with &quot;</span> <span class="n">EFX_OWORD_FMT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span>
		   <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">));</span>

<span class="cp">#ifdef EFX_USE_QWORD_IO</span>
	<span class="n">_efx_writeq</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">_efx_writeq</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">_efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">_efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">_efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">_efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#define efx_writeo_page(efx, value, reg, page)				\</span>
<span class="cp">	_efx_writeo_page(efx, value,					\</span>
<span class="cp">			 reg +						\</span>
<span class="cp">			 BUILD_BUG_ON_ZERO((reg) != 0x830 &amp;&amp; (reg) != 0xa10), \</span>
<span class="cp">			 page)</span>

<span class="cm">/* Write a page-mapped 32-bit CSR (EVQ_RPTR or the high bits of</span>
<span class="cm"> * RX_DESC_UPD or TX_DESC_UPD)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_efx_writed_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_dword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">EFX_PAGED_REG</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">reg</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#define efx_writed_page(efx, value, reg, page)				\</span>
<span class="cp">	_efx_writed_page(efx, value,					\</span>
<span class="cp">			 reg +						\</span>
<span class="cp">			 BUILD_BUG_ON_ZERO((reg) != 0x400 &amp;&amp; (reg) != 0x83c \</span>
<span class="cp">					   &amp;&amp; (reg) != 0xa1c),		\</span>
<span class="cp">			 page)</span>

<span class="cm">/* Write TIMER_COMMAND.  This is a page-mapped 32-bit CSR, but a bug</span>
<span class="cm"> * in the BIU means that writes to TIMER_COMMAND[0] invalidate the</span>
<span class="cm"> * collector register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_efx_writed_page_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
					   <span class="n">efx_dword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">unused</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">biu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">EFX_PAGED_REG</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">reg</span><span class="p">));</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">biu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">EFX_PAGED_REG</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">reg</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#define efx_writed_page_locked(efx, value, reg, page)			\</span>
<span class="cp">	_efx_writed_page_locked(efx, value,				\</span>
<span class="cp">				reg + BUILD_BUG_ON_ZERO((reg) != 0x420), \</span>
<span class="cp">				page)</span>

<span class="cp">#endif </span><span class="cm">/* EFX_IO_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
