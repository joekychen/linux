<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › nic.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>nic.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2005-2006 Fen Systems Ltd.</span>
<span class="cm"> * Copyright 2006-2011 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &quot;net_driver.h&quot;</span>
<span class="cp">#include &quot;bitfield.h&quot;</span>
<span class="cp">#include &quot;efx.h&quot;</span>
<span class="cp">#include &quot;nic.h&quot;</span>
<span class="cp">#include &quot;regs.h&quot;</span>
<span class="cp">#include &quot;io.h&quot;</span>
<span class="cp">#include &quot;workarounds.h&quot;</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Configurable values</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="cm">/* This is set to 16 for a good reason.  In summary, if larger than</span>
<span class="cm"> * 16, the descriptor cache holds more than a default socket</span>
<span class="cm"> * buffer&#39;s worth of packets (for UDP we can only have at most one</span>
<span class="cm"> * socket buffer&#39;s worth outstanding).  This combined with the fact</span>
<span class="cm"> * that we only get 1 TX event per descriptor cache means the NIC</span>
<span class="cm"> * goes idle.</span>
<span class="cm"> */</span>
<span class="cp">#define TX_DC_ENTRIES 16</span>
<span class="cp">#define TX_DC_ENTRIES_ORDER 1</span>

<span class="cp">#define RX_DC_ENTRIES 64</span>
<span class="cp">#define RX_DC_ENTRIES_ORDER 3</span>

<span class="cm">/* If EFX_MAX_INT_ERRORS internal errors occur within</span>
<span class="cm"> * EFX_INT_ERROR_EXPIRE seconds, we consider the NIC broken and</span>
<span class="cm"> * disable it.</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_INT_ERROR_EXPIRE 3600</span>
<span class="cp">#define EFX_MAX_INT_ERRORS 5</span>

<span class="cm">/* Depth of RX flush request fifo */</span>
<span class="cp">#define EFX_RX_FLUSH_COUNT 4</span>

<span class="cm">/* Driver generated events */</span>
<span class="cp">#define _EFX_CHANNEL_MAGIC_TEST		0x000101</span>
<span class="cp">#define _EFX_CHANNEL_MAGIC_FILL		0x000102</span>
<span class="cp">#define _EFX_CHANNEL_MAGIC_RX_DRAIN	0x000103</span>
<span class="cp">#define _EFX_CHANNEL_MAGIC_TX_DRAIN	0x000104</span>

<span class="cp">#define _EFX_CHANNEL_MAGIC(_code, _data)	((_code) &lt;&lt; 8 | (_data))</span>
<span class="cp">#define _EFX_CHANNEL_MAGIC_CODE(_magic)		((_magic) &gt;&gt; 8)</span>

<span class="cp">#define EFX_CHANNEL_MAGIC_TEST(_channel)				\</span>
<span class="cp">	_EFX_CHANNEL_MAGIC(_EFX_CHANNEL_MAGIC_TEST, (_channel)-&gt;channel)</span>
<span class="cp">#define EFX_CHANNEL_MAGIC_FILL(_rx_queue)				\</span>
<span class="cp">	_EFX_CHANNEL_MAGIC(_EFX_CHANNEL_MAGIC_FILL,			\</span>
<span class="cp">			   efx_rx_queue_index(_rx_queue))</span>
<span class="cp">#define EFX_CHANNEL_MAGIC_RX_DRAIN(_rx_queue)				\</span>
<span class="cp">	_EFX_CHANNEL_MAGIC(_EFX_CHANNEL_MAGIC_RX_DRAIN,			\</span>
<span class="cp">			   efx_rx_queue_index(_rx_queue))</span>
<span class="cp">#define EFX_CHANNEL_MAGIC_TX_DRAIN(_tx_queue)				\</span>
<span class="cp">	_EFX_CHANNEL_MAGIC(_EFX_CHANNEL_MAGIC_TX_DRAIN,			\</span>
<span class="cp">			   (_tx_queue)-&gt;queue)</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Solarstorm hardware access</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_write_buf_tbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_sram_writeq</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">+</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">buf_tbl_base</span><span class="p">,</span>
			<span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Read the current event from the event queue */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="nf">efx_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">efx_qword_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">.</span><span class="n">addr</span><span class="p">))</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* See if an event is present</span>
<span class="cm"> *</span>
<span class="cm"> * We check both the high and low dword of the event for all ones.  We</span>
<span class="cm"> * wrote all ones when we cleared the event, and no valid event can</span>
<span class="cm"> * have all ones in either its high or low dwords.  This approach is</span>
<span class="cm"> * robust against reordering.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that using a single 64-bit comparison is incorrect; even</span>
<span class="cm"> * though the CPU read will be atomic, the DMA write may not be.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">efx_event_present</span><span class="p">(</span><span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">EFX_DWORD_IS_ALL_ONES</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span>
		  <span class="n">EFX_DWORD_IS_ALL_ONES</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">dword</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">efx_masked_compare_oword</span><span class="p">(</span><span class="k">const</span> <span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span>
		<span class="p">((</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">u64</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_nic_test_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_register_test</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">n_regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">mask</span><span class="p">,</span> <span class="n">imask</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* Falcon should be in loopback to isolate the XMAC from the PHY */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">LOOPBACK_INTERNAL</span><span class="p">(</span><span class="n">efx</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_regs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">address</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">imask</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">EFX_INVERT_OWORD</span><span class="p">(</span><span class="n">imask</span><span class="p">);</span>

		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">original</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

		<span class="cm">/* bit sweep on and off */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EFX_EXTRACT_OWORD32</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* Test this testable bit can be set in isolation */</span>
			<span class="n">EFX_AND_OWORD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
			<span class="n">EFX_SET_OWORD32</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
			<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">efx_masked_compare_oword</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

			<span class="cm">/* Test this testable bit can be cleared in isolation */</span>
			<span class="n">EFX_OR_OWORD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
			<span class="n">EFX_SET_OWORD32</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
			<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">efx_masked_compare_oword</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">original</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;wrote &quot;</span><span class="n">EFX_OWORD_FMT</span><span class="s">&quot; read &quot;</span><span class="n">EFX_OWORD_FMT</span>
		  <span class="s">&quot; at address 0x%x mask &quot;</span><span class="n">EFX_OWORD_FMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
		  <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">address</span><span class="p">,</span> <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="n">mask</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Special buffer handling</span>
<span class="cm"> * Special buffers are used for event queues and the TX and RX</span>
<span class="cm"> * descriptor rings.</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise a special buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This will define a buffer (previously allocated via</span>
<span class="cm"> * efx_alloc_special_buffer()) in the buffer table, allowing</span>
<span class="cm"> * it to be used for event queues, descriptor rings etc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_init_special_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_special_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_qword_t</span> <span class="n">buf_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="cm">/* Write buffer descriptors to NIC */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">EFX_BUF_SIZE</span><span class="p">);</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;mapping special buffer %d at %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="n">EFX_POPULATE_QWORD_3</span><span class="p">(</span><span class="n">buf_desc</span><span class="p">,</span>
				     <span class="n">FRF_AZ_BUF_ADR_REGION</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">FRF_AZ_BUF_ADR_FBUF</span><span class="p">,</span> <span class="n">dma_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">,</span>
				     <span class="n">FRF_AZ_BUF_OWNER_ID_FBUF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">efx_write_buf_tbl</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_desc</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Unmaps a buffer and clears the buffer table entries */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_fini_special_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_special_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">buf_tbl_upd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;unmapping special buffers %d-%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">EFX_POPULATE_OWORD_4</span><span class="p">(</span><span class="n">buf_tbl_upd</span><span class="p">,</span>
			     <span class="n">FRF_AZ_BUF_UPD_CMD</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">FRF_AZ_BUF_CLR_CMD</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AZ_BUF_CLR_END_ID</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
			     <span class="n">FRF_AZ_BUF_CLR_START_ID</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_tbl_upd</span><span class="p">,</span> <span class="n">FR_AZ_BUF_TBL_UPD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new special buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This allocates memory for a new buffer, clears it and allocates a</span>
<span class="cm"> * new buffer ID range.  It does not write into the buffer table.</span>
<span class="cm"> *</span>
<span class="cm"> * This call will allocate 4KB buffers, since 8KB buffers can&#39;t be</span>
<span class="cm"> * used for event queues and descriptor rings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_alloc_special_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">efx_special_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">EFX_BUF_SIZE</span><span class="p">);</span>

	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">EFX_BUF_SIZE</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EFX_BUF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* All zeros is a potentially valid event so memset to 0xff */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Select new buffer ID */</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">next_buffer_table</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">next_buffer_table</span> <span class="o">+=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SFC_SRIOV</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">efx_sriov_enabled</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_buftbl_base</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">next_buffer_table</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;allocating special buffers %d-%d at %llx+%x &quot;</span>
		  <span class="s">&quot;(virt %p phys %llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
		  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_free_special_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_special_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;deallocating special buffers %d-%d at %llx+%x &quot;</span>
		  <span class="s">&quot;(virt %p phys %llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
		  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
		  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">));</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
			  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Generic buffer handling</span>
<span class="cm"> * These buffers are used for interrupt status and MAC stats</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="kt">int</span> <span class="nf">efx_nic_alloc_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_free_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				    <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * TX path</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* Returns a pointer to the specified transmit descriptor in the TX</span>
<span class="cm"> * descriptor queue belonging to the specified channel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">efx_qword_t</span> <span class="o">*</span>
<span class="nf">efx_tx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">efx_qword_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">addr</span><span class="p">))</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This writes to the TX_DESC_WPTR; write pointer for TX descriptor ring */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_notify_tx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">write_ptr</span><span class="p">;</span>
	<span class="n">efx_dword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">write_ptr</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">write_count</span> <span class="o">&amp;</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span><span class="p">;</span>
	<span class="n">EFX_POPULATE_DWORD_1</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AZ_TX_DESC_WPTR_DWORD</span><span class="p">,</span> <span class="n">write_ptr</span><span class="p">);</span>
	<span class="n">efx_writed_page</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span>
			<span class="n">FR_AZ_TX_DESC_UPD_DWORD_P0</span><span class="p">,</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Write pointer and first descriptor for TX descriptor ring */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_push_tx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">write_ptr</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FRF_AZ_TX_DESC_LBN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FR_AA_TX_DESC_UPD_KER</span> <span class="o">!=</span> <span class="n">FR_BZ_TX_DESC_UPD_P0</span><span class="p">);</span>

	<span class="n">write_ptr</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">write_count</span> <span class="o">&amp;</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span><span class="p">;</span>
	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AZ_TX_DESC_PUSH_CMD</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
			     <span class="n">FRF_AZ_TX_DESC_WPTR</span><span class="p">,</span> <span class="n">write_ptr</span><span class="p">);</span>
	<span class="n">reg</span><span class="p">.</span><span class="n">qword</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">txd</span><span class="p">;</span>
	<span class="n">efx_writeo_page</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span>
			<span class="n">FR_BZ_TX_DESC_UPD_P0</span><span class="p">,</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">efx_may_push_tx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">write_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">empty_read_count</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">empty_read_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">empty_read_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">empty_read_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">empty_read_count</span> <span class="o">^</span> <span class="n">write_count</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EFX_EMPTY_COUNT_VALID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* For each entry inserted into the software descriptor ring, create a</span>
<span class="cm"> * descriptor in the hardware TX descriptor ring (in host memory), and</span>
<span class="cm"> * write a doorbell.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">efx_nic_push_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">efx_tx_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">txd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">write_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">old_write_count</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">write_count</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">write_count</span> <span class="o">==</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">insert_count</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">write_ptr</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">write_count</span> <span class="o">&amp;</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span><span class="p">;</span>
		<span class="n">buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">write_ptr</span><span class="p">];</span>
		<span class="n">txd</span> <span class="o">=</span> <span class="n">efx_tx_desc</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">write_ptr</span><span class="p">);</span>
		<span class="o">++</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">write_count</span><span class="p">;</span>

		<span class="cm">/* Create TX descriptor ring entry */</span>
		<span class="n">EFX_POPULATE_QWORD_4</span><span class="p">(</span><span class="o">*</span><span class="n">txd</span><span class="p">,</span>
				     <span class="n">FSF_AZ_TX_KER_CONT</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">continuation</span><span class="p">,</span>
				     <span class="n">FSF_AZ_TX_KER_BYTE_COUNT</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				     <span class="n">FSF_AZ_TX_KER_BUF_REGION</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">FSF_AZ_TX_KER_BUF_ADDR</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">write_count</span> <span class="o">!=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">insert_count</span><span class="p">);</span>

	<span class="n">wmb</span><span class="p">();</span> <span class="cm">/* Ensure descriptors are written before they are fetched */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_may_push_tx_desc</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">old_write_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">txd</span> <span class="o">=</span> <span class="n">efx_tx_desc</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span>
				  <span class="n">old_write_count</span> <span class="o">&amp;</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span><span class="p">);</span>
		<span class="n">efx_push_tx_desc</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">txd</span><span class="p">);</span>
		<span class="o">++</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">pushes</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">efx_notify_tx_desc</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Allocate hardware resources for a TX queue */</span>
<span class="kt">int</span> <span class="nf">efx_nic_probe_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">entries</span><span class="p">;</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">efx_alloc_special_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">,</span>
					<span class="n">entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_qword_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_init_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="cm">/* Pin TX descriptor ring */</span>
	<span class="n">efx_init_special_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">);</span>

	<span class="cm">/* Push TX descriptor ring to card */</span>
	<span class="n">EFX_POPULATE_OWORD_10</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			      <span class="n">FRF_AZ_TX_DESCQ_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			      <span class="n">FRF_AZ_TX_ISCSI_DDIG_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="n">FRF_AZ_TX_ISCSI_HDIG_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="n">FRF_AZ_TX_DESCQ_BUF_BASE_ID</span><span class="p">,</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">index</span><span class="p">,</span>
			      <span class="n">FRF_AZ_TX_DESCQ_EVQ_ID</span><span class="p">,</span>
			      <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
			      <span class="n">FRF_AZ_TX_DESCQ_OWNER_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="n">FRF_AZ_TX_DESCQ_LABEL</span><span class="p">,</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span>
			      <span class="n">FRF_AZ_TX_DESCQ_SIZE</span><span class="p">,</span>
			      <span class="n">__ffs</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">.</span><span class="n">entries</span><span class="p">),</span>
			      <span class="n">FRF_AZ_TX_DESCQ_TYPE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="n">FRF_BZ_TX_NON_IP_DROP_DIS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">csum</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">&amp;</span> <span class="n">EFX_TXQ_TYPE_OFFLOAD</span><span class="p">;</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_TX_IP_CHKSM_DIS</span><span class="p">,</span> <span class="o">!</span><span class="n">csum</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_BZ_TX_TCP_CHKSM_DIS</span><span class="p">,</span>
				    <span class="o">!</span><span class="n">csum</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">txd_ptr_tbl_base</span><span class="p">,</span>
			 <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Only 128 bits in this register */</span>
		<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_MAX_TX_QUEUES</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">);</span>

		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AA_TX_CHKSM_CFG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">&amp;</span> <span class="n">EFX_TXQ_TYPE_OFFLOAD</span><span class="p">)</span>
			<span class="n">clear_bit_le</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">set_bit_le</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AA_TX_CHKSM_CFG</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
				     <span class="n">FRF_BZ_TX_PACE</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">&amp;</span> <span class="n">EFX_TXQ_TYPE_HIGHPRI</span><span class="p">)</span> <span class="o">?</span>
				     <span class="n">FFE_BZ_TX_PACE_OFF</span> <span class="o">:</span>
				     <span class="n">FFE_BZ_TX_PACE_RESERVED</span><span class="p">);</span>
		<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_TX_PACE_TBL</span><span class="p">,</span>
				 <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_flush_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">tx_flush_descq</span><span class="p">;</span>

	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">tx_flush_descq</span><span class="p">,</span>
			     <span class="n">FRF_AZ_TX_FLUSH_DESCQ_CMD</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AZ_TX_FLUSH_DESCQ</span><span class="p">,</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_flush_descq</span><span class="p">,</span> <span class="n">FR_AZ_TX_FLUSH_DESCQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_fini_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">tx_desc_ptr</span><span class="p">;</span>

	<span class="cm">/* Remove TX descriptor ring from card */</span>
	<span class="n">EFX_ZERO_OWORD</span><span class="p">(</span><span class="n">tx_desc_ptr</span><span class="p">);</span>
	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_desc_ptr</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">txd_ptr_tbl_base</span><span class="p">,</span>
			 <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* Unpin TX descriptor ring */</span>
	<span class="n">efx_fini_special_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Free buffers backing TX queue */</span>
<span class="kt">void</span> <span class="nf">efx_nic_remove_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_free_special_buffer</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * RX path</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* Returns a pointer to the specified descriptor in the RX descriptor queue */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">efx_qword_t</span> <span class="o">*</span>
<span class="nf">efx_rx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">efx_qword_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">.</span><span class="n">addr</span><span class="p">))</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This creates an entry in the RX descriptor queue */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">efx_build_rx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_rx_buffer</span> <span class="o">*</span><span class="n">rx_buf</span><span class="p">;</span>
	<span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">rxd</span><span class="p">;</span>

	<span class="n">rxd</span> <span class="o">=</span> <span class="n">efx_rx_desc</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">rx_buf</span> <span class="o">=</span> <span class="n">efx_rx_buffer</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">EFX_POPULATE_QWORD_3</span><span class="p">(</span><span class="o">*</span><span class="n">rxd</span><span class="p">,</span>
			     <span class="n">FSF_AZ_RX_KER_BUF_SIZE</span><span class="p">,</span>
			     <span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span>
			     <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">rx_buffer_padding</span><span class="p">,</span>
			     <span class="n">FSF_AZ_RX_KER_BUF_REGION</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">FSF_AZ_RX_KER_BUF_ADDR</span><span class="p">,</span> <span class="n">rx_buf</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This writes to the RX_DESC_WPTR register for the specified receive</span>
<span class="cm"> * descriptor ring.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">efx_nic_notify_rx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="n">efx_dword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">write_ptr</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">notified_count</span> <span class="o">!=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">added_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_build_rx_desc</span><span class="p">(</span>
			<span class="n">rx_queue</span><span class="p">,</span>
			<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">notified_count</span> <span class="o">&amp;</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span><span class="p">);</span>
		<span class="o">++</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">notified_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">write_ptr</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">added_count</span> <span class="o">&amp;</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span><span class="p">;</span>
	<span class="n">EFX_POPULATE_DWORD_1</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AZ_RX_DESC_WPTR_DWORD</span><span class="p">,</span> <span class="n">write_ptr</span><span class="p">);</span>
	<span class="n">efx_writed_page</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AZ_RX_DESC_UPD_DWORD_P0</span><span class="p">,</span>
			<span class="n">efx_rx_queue_index</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_nic_probe_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">entries</span><span class="p">;</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">efx_alloc_special_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">,</span>
					<span class="n">entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_qword_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_init_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">rx_desc_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_b0</span> <span class="o">=</span> <span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">iscsi_digest_en</span> <span class="o">=</span> <span class="n">is_b0</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;RX queue %d ring in special buffers %d-%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">efx_rx_queue_index</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">),</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">.</span><span class="n">index</span><span class="p">,</span>
		  <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">.</span><span class="n">index</span> <span class="o">+</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">.</span><span class="n">entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Pin RX descriptor ring */</span>
	<span class="n">efx_init_special_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">);</span>

	<span class="cm">/* Push RX descriptor ring to card */</span>
	<span class="n">EFX_POPULATE_OWORD_10</span><span class="p">(</span><span class="n">rx_desc_ptr</span><span class="p">,</span>
			      <span class="n">FRF_AZ_RX_ISCSI_DDIG_EN</span><span class="p">,</span> <span class="n">iscsi_digest_en</span><span class="p">,</span>
			      <span class="n">FRF_AZ_RX_ISCSI_HDIG_EN</span><span class="p">,</span> <span class="n">iscsi_digest_en</span><span class="p">,</span>
			      <span class="n">FRF_AZ_RX_DESCQ_BUF_BASE_ID</span><span class="p">,</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">.</span><span class="n">index</span><span class="p">,</span>
			      <span class="n">FRF_AZ_RX_DESCQ_EVQ_ID</span><span class="p">,</span>
			      <span class="n">efx_rx_queue_channel</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
			      <span class="n">FRF_AZ_RX_DESCQ_OWNER_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="n">FRF_AZ_RX_DESCQ_LABEL</span><span class="p">,</span>
			      <span class="n">efx_rx_queue_index</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">),</span>
			      <span class="n">FRF_AZ_RX_DESCQ_SIZE</span><span class="p">,</span>
			      <span class="n">__ffs</span><span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">.</span><span class="n">entries</span><span class="p">),</span>
			      <span class="n">FRF_AZ_RX_DESCQ_TYPE</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/* kernel queue */</span> <span class="p">,</span>
			      <span class="cm">/* For &gt;=B0 this is scatter so disable */</span>
			      <span class="n">FRF_AZ_RX_DESCQ_JUMBO</span><span class="p">,</span> <span class="o">!</span><span class="n">is_b0</span><span class="p">,</span>
			      <span class="n">FRF_AZ_RX_DESCQ_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc_ptr</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">rxd_ptr_tbl_base</span><span class="p">,</span>
			 <span class="n">efx_rx_queue_index</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_flush_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">rx_flush_descq</span><span class="p">;</span>

	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">rx_flush_descq</span><span class="p">,</span>
			     <span class="n">FRF_AZ_RX_FLUSH_DESCQ_CMD</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AZ_RX_FLUSH_DESCQ</span><span class="p">,</span>
			     <span class="n">efx_rx_queue_index</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">));</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_flush_descq</span><span class="p">,</span> <span class="n">FR_AZ_RX_FLUSH_DESCQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_fini_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">rx_desc_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>

	<span class="cm">/* Remove RX descriptor ring from card */</span>
	<span class="n">EFX_ZERO_OWORD</span><span class="p">(</span><span class="n">rx_desc_ptr</span><span class="p">);</span>
	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc_ptr</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">rxd_ptr_tbl_base</span><span class="p">,</span>
			 <span class="n">efx_rx_queue_index</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">));</span>

	<span class="cm">/* Unpin RX descriptor ring */</span>
	<span class="n">efx_fini_special_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Free buffers backing RX queue */</span>
<span class="kt">void</span> <span class="nf">efx_nic_remove_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_free_special_buffer</span><span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rxd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Flush handling</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* efx_nic_flush_queues() must be woken up when all flushes are completed,</span>
<span class="cm"> * or more RX flushes can be kicked off.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">efx_flush_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Ensure that all updates are visible to efx_nic_flush_queues() */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">drain_pending</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_outstanding</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_RX_FLUSH_COUNT</span>
		 <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_pending</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Flush all the transmit queues, and continue flushing receive queues until</span>
<span class="cm"> * they&#39;re all flushed. Wait for the DRAIN events to be recieved so that there</span>
<span class="cm"> * are no more RX and TX events left on any channel. */</span>
<span class="kt">int</span> <span class="nf">efx_nic_flush_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span> <span class="cm">/* 5s for all flushes and drains */</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">fc_disable</span><span class="o">++</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">prepare_flush</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_for_each_channel_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">drain_pending</span><span class="p">);</span>
			<span class="n">efx_flush_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">efx_for_each_channel_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">drain_pending</span><span class="p">);</span>
			<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">flush_pending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_pending</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">drain_pending</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If SRIOV is enabled, then offload receive queue flushing to</span>
<span class="cm">		 * the firmware (though we will still have to poll for</span>
<span class="cm">		 * completion). If that fails, fall back to the old scheme.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx_sriov_enabled</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_flush_rxqs</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">wait</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* The hardware supports four concurrent rx flushes, each of</span>
<span class="cm">		 * which may need to be retried if there is an outstanding</span>
<span class="cm">		 * descriptor fetch</span>
<span class="cm">		 */</span>
		<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx_for_each_channel_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_outstanding</span><span class="p">)</span> <span class="o">&gt;=</span>
				    <span class="n">EFX_RX_FLUSH_COUNT</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">flush_pending</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">flush_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
					<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_pending</span><span class="p">);</span>
					<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_outstanding</span><span class="p">);</span>
					<span class="n">efx_flush_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="nl">wait:</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">flush_wq</span><span class="p">,</span> <span class="n">efx_flush_wake</span><span class="p">(</span><span class="n">efx</span><span class="p">),</span>
					     <span class="n">timeout</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">drain_pending</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;failed to flush %d queues &quot;</span>
			  <span class="s">&quot;(rx %d+%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">drain_pending</span><span class="p">),</span>
			  <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_outstanding</span><span class="p">),</span>
			  <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_pending</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">drain_pending</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_pending</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_outstanding</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">fc_disable</span><span class="o">--</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Event queue processing</span>
<span class="cm"> * Event queues are processed by per-channel tasklets.</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* Update a channel&#39;s event queue&#39;s read pointer (RPTR) register</span>
<span class="cm"> *</span>
<span class="cm"> * This writes the EVQ_RPTR_REG register for the specified channel&#39;s</span>
<span class="cm"> * event queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">efx_nic_eventq_read_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_dword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>

	<span class="n">EFX_POPULATE_DWORD_1</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_AZ_EVQ_RPTR</span><span class="p">,</span>
			     <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq_read_ptr</span> <span class="o">&amp;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq_mask</span><span class="p">);</span>
	<span class="n">efx_writed_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">evq_rptr_tbl_base</span><span class="p">,</span>
			 <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Use HW to insert a SW defined event */</span>
<span class="kt">void</span> <span class="nf">efx_generate_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evq</span><span class="p">,</span>
			<span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">drv_ev_reg</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FRF_AZ_DRV_EV_DATA_LBN</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		     <span class="n">FRF_AZ_DRV_EV_DATA_WIDTH</span> <span class="o">!=</span> <span class="mi">64</span><span class="p">);</span>
	<span class="n">drv_ev_reg</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">drv_ev_reg</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">drv_ev_reg</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">drv_ev_reg</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">drv_ev_reg</span><span class="p">,</span> <span class="n">FRF_AZ_DRV_EV_QID</span><span class="p">,</span> <span class="n">evq</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drv_ev_reg</span><span class="p">,</span> <span class="n">FR_AZ_DRV_EV</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_magic_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="n">u32</span> <span class="n">magic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_qword_t</span> <span class="n">event</span><span class="p">;</span>

	<span class="n">EFX_POPULATE_QWORD_2</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_EV_CODE</span><span class="p">,</span>
			     <span class="n">FSE_AZ_EV_CODE_DRV_GEN_EV</span><span class="p">,</span>
			     <span class="n">FSF_AZ_DRV_GEN_EV_MAGIC</span><span class="p">,</span> <span class="n">magic</span><span class="p">);</span>
	<span class="n">efx_generate_event</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle a transmit completion event</span>
<span class="cm"> *</span>
<span class="cm"> * The NIC batches TX completion events; the message we receive is of</span>
<span class="cm"> * the form &quot;complete all TX events up to this index&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">efx_handle_tx_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_ev_desc_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_ev_q_label</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_pending</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_TX_EV_COMP</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Transmit completion */</span>
		<span class="n">tx_ev_desc_ptr</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_TX_EV_DESC_PTR</span><span class="p">);</span>
		<span class="n">tx_ev_q_label</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_TX_EV_Q_LABEL</span><span class="p">);</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">efx_channel_get_tx_queue</span><span class="p">(</span>
			<span class="n">channel</span><span class="p">,</span> <span class="n">tx_ev_q_label</span> <span class="o">%</span> <span class="n">EFX_TXQ_TYPES</span><span class="p">);</span>
		<span class="n">tx_packets</span> <span class="o">=</span> <span class="p">((</span><span class="n">tx_ev_desc_ptr</span> <span class="o">-</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">read_count</span><span class="p">)</span> <span class="o">&amp;</span>
			      <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span><span class="p">);</span>
		<span class="n">efx_xmit_done</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">tx_ev_desc_ptr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_TX_EV_WQ_FF_FULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Rewrite the FIFO write pointer */</span>
		<span class="n">tx_ev_q_label</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_TX_EV_Q_LABEL</span><span class="p">);</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">efx_channel_get_tx_queue</span><span class="p">(</span>
			<span class="n">channel</span><span class="p">,</span> <span class="n">tx_ev_q_label</span> <span class="o">%</span> <span class="n">EFX_TXQ_TYPES</span><span class="p">);</span>

		<span class="n">netif_tx_lock</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="n">efx_notify_tx_desc</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>
		<span class="n">netif_tx_unlock</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_TX_EV_PKT_ERR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="n">EFX_WORKAROUND_10727</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_TX_DESC_FETCH</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;channel %d unexpected TX event &quot;</span>
			  <span class="n">EFX_QWORD_FMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
			  <span class="n">EFX_QWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">tx_packets</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Detect errors included in the rx_evt_pkt_ok bit. */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">efx_handle_rx_not_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">efx_rx_queue_channel</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rx_ev_buf_owner_id_err</span><span class="p">,</span> <span class="n">rx_ev_ip_hdr_chksum_err</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rx_ev_tcp_udp_chksum_err</span><span class="p">,</span> <span class="n">rx_ev_eth_crc_err</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rx_ev_frm_trunc</span><span class="p">,</span> <span class="n">rx_ev_drib_nib</span><span class="p">,</span> <span class="n">rx_ev_tobe_disc</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rx_ev_other_err</span><span class="p">,</span> <span class="n">rx_ev_pause_frm</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rx_ev_hdr_type</span><span class="p">,</span> <span class="n">rx_ev_mcast_pkt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rx_ev_pkt_type</span><span class="p">;</span>

	<span class="n">rx_ev_hdr_type</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_HDR_TYPE</span><span class="p">);</span>
	<span class="n">rx_ev_mcast_pkt</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_MCAST_PKT</span><span class="p">);</span>
	<span class="n">rx_ev_tobe_disc</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_TOBE_DISC</span><span class="p">);</span>
	<span class="n">rx_ev_pkt_type</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_PKT_TYPE</span><span class="p">);</span>
	<span class="n">rx_ev_buf_owner_id_err</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span>
						 <span class="n">FSF_AZ_RX_EV_BUF_OWNER_ID_ERR</span><span class="p">);</span>
	<span class="n">rx_ev_ip_hdr_chksum_err</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span>
						  <span class="n">FSF_AZ_RX_EV_IP_HDR_CHKSUM_ERR</span><span class="p">);</span>
	<span class="n">rx_ev_tcp_udp_chksum_err</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span>
						   <span class="n">FSF_AZ_RX_EV_TCP_UDP_CHKSUM_ERR</span><span class="p">);</span>
	<span class="n">rx_ev_eth_crc_err</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_ETH_CRC_ERR</span><span class="p">);</span>
	<span class="n">rx_ev_frm_trunc</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_FRM_TRUNC</span><span class="p">);</span>
	<span class="n">rx_ev_drib_nib</span> <span class="o">=</span> <span class="p">((</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span> <span class="o">?</span>
			  <span class="mi">0</span> <span class="o">:</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AA_RX_EV_DRIB_NIB</span><span class="p">));</span>
	<span class="n">rx_ev_pause_frm</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_PAUSE_FRM_ERR</span><span class="p">);</span>

	<span class="cm">/* Every error apart from tobe_disc and pause_frm */</span>
	<span class="n">rx_ev_other_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx_ev_drib_nib</span> <span class="o">|</span> <span class="n">rx_ev_tcp_udp_chksum_err</span> <span class="o">|</span>
			   <span class="n">rx_ev_buf_owner_id_err</span> <span class="o">|</span> <span class="n">rx_ev_eth_crc_err</span> <span class="o">|</span>
			   <span class="n">rx_ev_frm_trunc</span> <span class="o">|</span> <span class="n">rx_ev_ip_hdr_chksum_err</span><span class="p">);</span>

	<span class="cm">/* Count errors that are not in MAC stats.  Ignore expected</span>
<span class="cm">	 * checksum errors during self-test. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ev_frm_trunc</span><span class="p">)</span>
		<span class="o">++</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">n_rx_frm_trunc</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rx_ev_tobe_disc</span><span class="p">)</span>
		<span class="o">++</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">n_rx_tobe_disc</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">loopback_selftest</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_ev_ip_hdr_chksum_err</span><span class="p">)</span>
			<span class="o">++</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">n_rx_ip_hdr_chksum_err</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rx_ev_tcp_udp_chksum_err</span><span class="p">)</span>
			<span class="o">++</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">n_rx_tcp_udp_chksum_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* TOBE_DISC is expected on unicast mismatches; don&#39;t print out an</span>
<span class="cm">	 * error message.  FRM_TRUNC indicates RXDP dropped the packet due</span>
<span class="cm">	 * to a FIFO overflow.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ev_other_err</span> <span class="o">&amp;&amp;</span> <span class="n">net_ratelimit</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot; RX queue %d unexpected RX event &quot;</span>
			  <span class="n">EFX_QWORD_FMT</span> <span class="s">&quot;%s%s%s%s%s%s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">efx_rx_queue_index</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">),</span> <span class="n">EFX_QWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">),</span>
			  <span class="n">rx_ev_buf_owner_id_err</span> <span class="o">?</span> <span class="s">&quot; [OWNER_ID_ERR]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			  <span class="n">rx_ev_ip_hdr_chksum_err</span> <span class="o">?</span>
			  <span class="s">&quot; [IP_HDR_CHKSUM_ERR]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			  <span class="n">rx_ev_tcp_udp_chksum_err</span> <span class="o">?</span>
			  <span class="s">&quot; [TCP_UDP_CHKSUM_ERR]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			  <span class="n">rx_ev_eth_crc_err</span> <span class="o">?</span> <span class="s">&quot; [ETH_CRC_ERR]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			  <span class="n">rx_ev_frm_trunc</span> <span class="o">?</span> <span class="s">&quot; [FRM_TRUNC]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			  <span class="n">rx_ev_drib_nib</span> <span class="o">?</span> <span class="s">&quot; [DRIB_NIB]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			  <span class="n">rx_ev_tobe_disc</span> <span class="o">?</span> <span class="s">&quot; [TOBE_DISC]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			  <span class="n">rx_ev_pause_frm</span> <span class="o">?</span> <span class="s">&quot; [PAUSE]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* The frame must be discarded if any of these are true. */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">rx_ev_eth_crc_err</span> <span class="o">|</span> <span class="n">rx_ev_frm_trunc</span> <span class="o">|</span> <span class="n">rx_ev_drib_nib</span> <span class="o">|</span>
		<span class="n">rx_ev_tobe_disc</span> <span class="o">|</span> <span class="n">rx_ev_pause_frm</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">EFX_RX_PKT_DISCARD</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle receive events that are not in-order. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_handle_rx_bad_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">expected</span><span class="p">,</span> <span class="n">dropped</span><span class="p">;</span>

	<span class="n">expected</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">removed_count</span> <span class="o">&amp;</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span><span class="p">;</span>
	<span class="n">dropped</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="n">expected</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span><span class="p">;</span>
	<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;dropped %d events (index=%d expected=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">dropped</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">expected</span><span class="p">);</span>

	<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">EFX_WORKAROUND_5676</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">?</span>
			   <span class="n">RESET_TYPE_RX_RECOVERY</span> <span class="o">:</span> <span class="n">RESET_TYPE_DISABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle a packet received event</span>
<span class="cm"> *</span>
<span class="cm"> * The NIC gives a &quot;discard&quot; flag if it&#39;s a unicast packet with the</span>
<span class="cm"> * wrong destination address</span>
<span class="cm"> * Also &quot;is multicast&quot; and &quot;matches multicast filter&quot; flags can be used to</span>
<span class="cm"> * discard non-matching multicast packets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_handle_rx_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="k">const</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_ev_desc_ptr</span><span class="p">,</span> <span class="n">rx_ev_byte_cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_ev_hdr_type</span><span class="p">,</span> <span class="n">rx_ev_mcast_pkt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">expected_ptr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rx_ev_pkt_ok</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">reset_pending</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Basic packet information */</span>
	<span class="n">rx_ev_byte_cnt</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_BYTE_CNT</span><span class="p">);</span>
	<span class="n">rx_ev_pkt_ok</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_PKT_OK</span><span class="p">);</span>
	<span class="n">rx_ev_hdr_type</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_HDR_TYPE</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_JUMBO_CONT</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_SOP</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_Q_LABEL</span><span class="p">)</span> <span class="o">!=</span>
		<span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="n">rx_queue</span> <span class="o">=</span> <span class="n">efx_channel_get_rx_queue</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

	<span class="n">rx_ev_desc_ptr</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_DESC_PTR</span><span class="p">);</span>
	<span class="n">expected_ptr</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">removed_count</span> <span class="o">&amp;</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">ptr_mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rx_ev_desc_ptr</span> <span class="o">!=</span> <span class="n">expected_ptr</span><span class="p">))</span>
		<span class="n">efx_handle_rx_bad_index</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">rx_ev_desc_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rx_ev_pkt_ok</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If packet is marked as OK and packet type is TCP/IP or</span>
<span class="cm">		 * UDP/IP, then we can rely on the hardware checksum.</span>
<span class="cm">		 */</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx_ev_hdr_type</span> <span class="o">==</span> <span class="n">FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_TCP</span> <span class="o">||</span>
			 <span class="n">rx_ev_hdr_type</span> <span class="o">==</span> <span class="n">FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_UDP</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">EFX_RX_PKT_CSUMMED</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">efx_handle_rx_not_ok</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Detect multicast packets that didn&#39;t match the filter */</span>
	<span class="n">rx_ev_mcast_pkt</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_MCAST_PKT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ev_mcast_pkt</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_ev_mcast_hash_match</span> <span class="o">=</span>
			<span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_RX_EV_MCAST_HASH_MATCH</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rx_ev_mcast_hash_match</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">n_rx_mcast_mismatch</span><span class="p">;</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">EFX_RX_PKT_DISCARD</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_mod_score</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Handle received packet */</span>
	<span class="n">efx_rx_packet</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">rx_ev_desc_ptr</span><span class="p">,</span> <span class="n">rx_ev_byte_cnt</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* If this flush done event corresponds to a &amp;struct efx_tx_queue, then</span>
<span class="cm"> * send an %EFX_CHANNEL_MAGIC_TX_DRAIN event to drain the event queue</span>
<span class="cm"> * of all transmit completions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_handle_tx_flush_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_tx_queue</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">qid</span><span class="p">;</span>

	<span class="n">qid</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_DRIVER_EV_SUBDATA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qid</span> <span class="o">&lt;</span> <span class="n">EFX_TXQ_TYPES</span> <span class="o">*</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">efx_get_tx_queue</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">qid</span> <span class="o">/</span> <span class="n">EFX_TXQ_TYPES</span><span class="p">,</span>
					    <span class="n">qid</span> <span class="o">%</span> <span class="n">EFX_TXQ_TYPES</span><span class="p">);</span>

		<span class="n">efx_magic_event</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
				<span class="n">EFX_CHANNEL_MAGIC_TX_DRAIN</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* If this flush done event corresponds to a &amp;struct efx_rx_queue: If the flush</span>
<span class="cm"> * was succesful then send an %EFX_CHANNEL_MAGIC_RX_DRAIN, otherwise add</span>
<span class="cm"> * the RX queue back to the mask of RX queues in need of flushing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_handle_rx_flush_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">qid</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">failed</span><span class="p">;</span>

	<span class="n">qid</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_DRIVER_EV_RX_DESCQ_ID</span><span class="p">);</span>
	<span class="n">failed</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qid</span> <span class="o">&gt;=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">efx_get_channel</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">qid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx_channel_has_rx_queue</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">rx_queue</span> <span class="o">=</span> <span class="n">efx_channel_get_rx_queue</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;RXQ %d flush retry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qid</span><span class="p">);</span>
		<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">flush_pending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_pending</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">efx_magic_event</span><span class="p">(</span><span class="n">efx_rx_queue_channel</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">),</span>
				<span class="n">EFX_CHANNEL_MAGIC_RX_DRAIN</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_outstanding</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_flush_wake</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">flush_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_handle_drain_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">drain_pending</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">drain_pending</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_flush_wake</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">flush_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_handle_generated_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span> <span class="o">=</span>
		<span class="n">efx_channel_has_rx_queue</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">efx_channel_get_rx_queue</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">magic</span><span class="p">,</span> <span class="n">code</span><span class="p">;</span>

	<span class="n">magic</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_DRV_GEN_EV_MAGIC</span><span class="p">);</span>
	<span class="n">code</span> <span class="o">=</span> <span class="n">_EFX_CHANNEL_MAGIC_CODE</span><span class="p">(</span><span class="n">magic</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">magic</span> <span class="o">==</span> <span class="n">EFX_CHANNEL_MAGIC_TEST</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">channel</span><span class="o">-&gt;</span><span class="n">event_test_cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rx_queue</span> <span class="o">&amp;&amp;</span> <span class="n">magic</span> <span class="o">==</span> <span class="n">EFX_CHANNEL_MAGIC_FILL</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* The queue must be empty, so we won&#39;t receive any rx</span>
<span class="cm">		 * events, so efx_process_channel() won&#39;t refill the</span>
<span class="cm">		 * queue. Refill it here */</span>
		<span class="n">efx_fast_push_rx_descriptors</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rx_queue</span> <span class="o">&amp;&amp;</span> <span class="n">magic</span> <span class="o">==</span> <span class="n">EFX_CHANNEL_MAGIC_RX_DRAIN</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">efx_handle_drain_event</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="n">_EFX_CHANNEL_MAGIC_TX_DRAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_handle_drain_event</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;channel %d received &quot;</span>
			  <span class="s">&quot;generated event &quot;</span><span class="n">EFX_QWORD_FMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">EFX_QWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_handle_driver_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ev_sub_code</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ev_sub_data</span><span class="p">;</span>

	<span class="n">ev_sub_code</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_DRIVER_EV_SUBCODE</span><span class="p">);</span>
	<span class="n">ev_sub_data</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_DRIVER_EV_SUBDATA</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ev_sub_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FSE_AZ_TX_DESCQ_FLS_DONE_EV</span>:
		<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;channel %d TXQ %d flushed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">ev_sub_data</span><span class="p">);</span>
		<span class="n">efx_handle_tx_flush_done</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="n">efx_sriov_tx_flush_done</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSE_AZ_RX_DESCQ_FLS_DONE_EV</span>:
		<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;channel %d RXQ %d flushed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">ev_sub_data</span><span class="p">);</span>
		<span class="n">efx_handle_rx_flush_done</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="n">efx_sriov_rx_flush_done</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSE_AZ_EVQ_INIT_DONE_EV</span>:
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;channel %d EVQ %d initialised</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">ev_sub_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSE_AZ_SRM_UPD_DONE_EV</span>:
		<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;channel %d SRAM update done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSE_AZ_WAKE_UP_EV</span>:
		<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;channel %d RXQ %d wakeup event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">ev_sub_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSE_AZ_TIMER_EV</span>:
		<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;channel %d RX queue %d timer expired</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">ev_sub_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSE_AA_RX_RECOVER_EV</span>:
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;channel %d seen DRIVER RX_RESET event. &quot;</span>
			<span class="s">&quot;Resetting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_reset</span><span class="p">);</span>
		<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span>
				   <span class="n">EFX_WORKAROUND_6555</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">?</span>
				   <span class="n">RESET_TYPE_RX_RECOVERY</span> <span class="o">:</span>
				   <span class="n">RESET_TYPE_DISABLE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSE_BZ_RX_DSC_ERROR_EV</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ev_sub_data</span> <span class="o">&lt;</span> <span class="n">EFX_VI_BASE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;RX DMA Q %d reports descriptor fetch error.&quot;</span>
				  <span class="s">&quot; RX Q %d is disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ev_sub_data</span><span class="p">,</span>
				  <span class="n">ev_sub_data</span><span class="p">);</span>
			<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_RX_DESC_FETCH</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">efx_sriov_desc_fetch_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">ev_sub_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSE_BZ_TX_DSC_ERROR_EV</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ev_sub_data</span> <span class="o">&lt;</span> <span class="n">EFX_VI_BASE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;TX DMA Q %d reports descriptor fetch error.&quot;</span>
				  <span class="s">&quot; TX Q %d is disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ev_sub_data</span><span class="p">,</span>
				  <span class="n">ev_sub_data</span><span class="p">);</span>
			<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_TX_DESC_FETCH</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">efx_sriov_desc_fetch_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">ev_sub_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;channel %d unknown driver event code %d &quot;</span>
			   <span class="s">&quot;data %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">ev_sub_code</span><span class="p">,</span>
			   <span class="n">ev_sub_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_nic_process_eventq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">read_ptr</span><span class="p">;</span>
	<span class="n">efx_qword_t</span> <span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">p_event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ev_code</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_ptr</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq_read_ptr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">p_event</span> <span class="o">=</span> <span class="n">efx_event</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">read_ptr</span><span class="p">);</span>
		<span class="n">event</span> <span class="o">=</span> <span class="o">*</span><span class="n">p_event</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx_event_present</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">))</span>
			<span class="cm">/* End of events */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;channel %d event is &quot;</span><span class="n">EFX_QWORD_FMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">EFX_QWORD_VAL</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>

		<span class="cm">/* Clear this event by marking it all ones */</span>
		<span class="n">EFX_SET_QWORD</span><span class="p">(</span><span class="o">*</span><span class="n">p_event</span><span class="p">);</span>

		<span class="o">++</span><span class="n">read_ptr</span><span class="p">;</span>

		<span class="n">ev_code</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_EV_CODE</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ev_code</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FSE_AZ_EV_CODE_RX_EV</span>:
			<span class="n">efx_handle_rx_event</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">spent</span> <span class="o">==</span> <span class="n">budget</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FSE_AZ_EV_CODE_TX_EV</span>:
			<span class="n">tx_packets</span> <span class="o">+=</span> <span class="n">efx_handle_tx_event</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_packets</span> <span class="o">&gt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">txq_entries</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spent</span> <span class="o">=</span> <span class="n">budget</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FSE_AZ_EV_CODE_DRV_GEN_EV</span>:
			<span class="n">efx_handle_generated_event</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FSE_AZ_EV_CODE_DRIVER_EV</span>:
			<span class="n">efx_handle_driver_event</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FSE_CZ_EV_CODE_USER_EV</span>:
			<span class="n">efx_sriov_event</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FSE_CZ_EV_CODE_MCDI_EV</span>:
			<span class="n">efx_mcdi_process_event</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FSE_AZ_EV_CODE_GLOBAL_EV</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">handle_global_event</span> <span class="o">&amp;&amp;</span>
			    <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">handle_global_event</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* else fall through */</span>
		<span class="nl">default:</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;channel %d unknown event type %d (data &quot;</span>
				  <span class="n">EFX_QWORD_FMT</span> <span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
				  <span class="n">ev_code</span><span class="p">,</span> <span class="n">EFX_QWORD_VAL</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq_read_ptr</span> <span class="o">=</span> <span class="n">read_ptr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">spent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check whether an event is present in the eventq at the current</span>
<span class="cm"> * read pointer.  Only useful for self-test.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">efx_nic_event_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">efx_event_present</span><span class="p">(</span><span class="n">efx_event</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq_read_ptr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Allocate buffer table entries for event queue */</span>
<span class="kt">int</span> <span class="nf">efx_nic_probe_eventq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">entries</span><span class="p">;</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">efx_alloc_special_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">,</span>
					<span class="n">entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_qword_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_init_eventq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;channel %d event queue in special buffers %d-%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">.</span><span class="n">index</span><span class="p">,</span>
		  <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">.</span><span class="n">index</span> <span class="o">+</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">.</span><span class="n">entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_SIENA_A0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EFX_POPULATE_OWORD_3</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
				     <span class="n">FRF_CZ_TIMER_Q_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				     <span class="n">FRF_CZ_HOST_NOTIFY_MODE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">FRF_CZ_TIMER_MODE</span><span class="p">,</span> <span class="n">FFE_CZ_TIMER_MODE_DIS</span><span class="p">);</span>
		<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_TIMER_TBL</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Pin event queue buffer */</span>
	<span class="n">efx_init_special_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">);</span>

	<span class="cm">/* Fill event queue with all ones (i.e. empty events) */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Push event queue to card */</span>
	<span class="n">EFX_POPULATE_OWORD_3</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_AZ_EVQ_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AZ_EVQ_SIZE</span><span class="p">,</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">.</span><span class="n">entries</span><span class="p">),</span>
			     <span class="n">FRF_AZ_EVQ_BUF_BASE_ID</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">evq_ptr_tbl_base</span><span class="p">,</span>
			 <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">push_irq_moderation</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_fini_eventq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>

	<span class="cm">/* Remove event queue from card */</span>
	<span class="n">EFX_ZERO_OWORD</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">evq_ptr_tbl_base</span><span class="p">,</span>
			 <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_SIENA_A0</span><span class="p">)</span>
		<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_TIMER_TBL</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

	<span class="cm">/* Unpin event queue */</span>
	<span class="n">efx_fini_special_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Free buffers backing event queue */</span>
<span class="kt">void</span> <span class="nf">efx_nic_remove_eventq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_free_special_buffer</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">efx_nic_event_test_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">event_test_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">efx_magic_event</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">EFX_CHANNEL_MAGIC_TEST</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_generate_fill_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_magic_event</span><span class="p">(</span><span class="n">efx_rx_queue_channel</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">),</span>
			<span class="n">EFX_CHANNEL_MAGIC_FILL</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Hardware interrupts</span>
<span class="cm"> * The hardware interrupt handler does very little work; all the event</span>
<span class="cm"> * queue processing is carried out by per-channel tasklets.</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* Enable/disable/generate interrupts */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">efx_nic_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
				      <span class="n">bool</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">int_en_reg_ker</span><span class="p">;</span>

	<span class="n">EFX_POPULATE_OWORD_3</span><span class="p">(</span><span class="n">int_en_reg_ker</span><span class="p">,</span>
			     <span class="n">FRF_AZ_KER_INT_LEVE_SEL</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">,</span>
			     <span class="n">FRF_AZ_KER_INT_KER</span><span class="p">,</span> <span class="n">force</span><span class="p">,</span>
			     <span class="n">FRF_AZ_DRV_INT_EN_KER</span><span class="p">,</span> <span class="n">enabled</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">int_en_reg_ker</span><span class="p">,</span> <span class="n">FR_AZ_INT_EN_KER</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_enable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_ZERO_OWORD</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">efx_oword_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">addr</span><span class="p">));</span>
	<span class="n">wmb</span><span class="p">();</span> <span class="cm">/* Ensure interrupt vector is clear before interrupts enabled */</span>

	<span class="n">efx_nic_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_disable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable interrupts */</span>
	<span class="n">efx_nic_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Generate a test interrupt</span>
<span class="cm"> * Interrupt must already have been enabled, otherwise nasty things</span>
<span class="cm"> * may happen.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">efx_nic_irq_test_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">last_irq_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">efx_nic_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Process a fatal interrupt</span>
<span class="cm"> * Disable bus mastering ASAP and schedule a reset</span>
<span class="cm"> */</span>
<span class="n">irqreturn_t</span> <span class="nf">efx_nic_fatal_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">falcon_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">int_ker</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">fatal_intr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">mem_perr</span><span class="p">;</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fatal_intr</span><span class="p">,</span> <span class="n">FR_AZ_FATAL_INTR_KER</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">fatal_intr</span><span class="p">,</span> <span class="n">FRF_AZ_FATAL_INTR</span><span class="p">);</span>

	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;SYSTEM ERROR &quot;</span><span class="n">EFX_OWORD_FMT</span><span class="s">&quot; status &quot;</span>
		  <span class="n">EFX_OWORD_FMT</span> <span class="s">&quot;: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">int_ker</span><span class="p">),</span>
		  <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="n">fatal_intr</span><span class="p">),</span>
		  <span class="n">error</span> <span class="o">?</span> <span class="s">&quot;disabling bus mastering&quot;</span> <span class="o">:</span> <span class="s">&quot;no recognised error&quot;</span><span class="p">);</span>

	<span class="cm">/* If this is a memory parity error dump which blocks are offending */</span>
	<span class="n">mem_perr</span> <span class="o">=</span> <span class="p">(</span><span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">fatal_intr</span><span class="p">,</span> <span class="n">FRF_AZ_MEM_PERR_INT_KER</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">fatal_intr</span><span class="p">,</span> <span class="n">FRF_AZ_SRM_PERR_INT_KER</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_perr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>
		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AZ_MEM_STAT</span><span class="p">);</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;SYSTEM ERROR: memory parity error &quot;</span><span class="n">EFX_OWORD_FMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="n">reg</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Disable both devices */</span>
	<span class="n">pci_clear_master</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_is_dual_func</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
		<span class="n">pci_clear_master</span><span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">pci_dev2</span><span class="p">);</span>
	<span class="n">efx_nic_disable_interrupts</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Count errors and reset or disable the NIC accordingly */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">int_error_count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">int_error_expire</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">int_error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">int_error_expire</span> <span class="o">=</span>
			<span class="n">jiffies</span> <span class="o">+</span> <span class="n">EFX_INT_ERROR_EXPIRE</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">int_error_count</span> <span class="o">&lt;</span> <span class="n">EFX_MAX_INT_ERRORS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;SYSTEM ERROR - reset scheduled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_INT_ERROR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;SYSTEM ERROR - max number of errors seen.&quot;</span>
			  <span class="s">&quot;NIC will be disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_DISABLE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle a legacy interrupt</span>
<span class="cm"> * Acknowledges the interrupt and schedule event queue processing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">efx_legacy_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">int_ker</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">result</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="n">efx_dword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">queues</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">syserr</span><span class="p">;</span>

	<span class="cm">/* Could this be ours?  If interrupts are disabled then the</span>
<span class="cm">	 * channel state may not be valid.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Read the ISR which also ACKs the interrupts */</span>
	<span class="n">efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_INT_ISR0</span><span class="p">);</span>
	<span class="n">queues</span> <span class="o">=</span> <span class="n">EFX_EXTRACT_DWORD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>

	<span class="cm">/* Handle non-event-queue sources */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queues</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">syserr</span> <span class="o">=</span> <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">int_ker</span><span class="p">,</span> <span class="n">FSF_AZ_NET_IVEC_FATAL_INT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">syserr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">efx_nic_fatal_interrupt</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">last_irq_cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queues</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EFX_WORKAROUND_15783</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_zero_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Schedule processing of any interrupting queues */</span>
		<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">queues</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">efx_schedule_channel_irq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
			<span class="n">queues</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">EFX_WORKAROUND_15783</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

		<span class="cm">/* We can&#39;t return IRQ_HANDLED more than once on seeing ISR=0</span>
<span class="cm">		 * because this might be a shared interrupt. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_zero_count</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

		<span class="cm">/* Ensure we schedule or rearm all event queues */</span>
		<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">event</span> <span class="o">=</span> <span class="n">efx_event</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">eventq_read_ptr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">efx_event_present</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
				<span class="n">efx_schedule_channel_irq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">efx_nic_eventq_read_ack</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">IRQ_HANDLED</span><span class="p">)</span>
		<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;IRQ %d on CPU %d status &quot;</span> <span class="n">EFX_DWORD_FMT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">irq</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">(),</span> <span class="n">EFX_DWORD_VAL</span><span class="p">(</span><span class="n">reg</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle an MSI interrupt</span>
<span class="cm"> *</span>
<span class="cm"> * Handle an MSI hardware interrupt.  This routine schedules event</span>
<span class="cm"> * queue processing.  No interrupt acknowledgement cycle is necessary.</span>
<span class="cm"> * Also, we never need to check that the interrupt is for us, since</span>
<span class="cm"> * MSI interrupts cannot be shared.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">efx_msi_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">**</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">int_ker</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">syserr</span><span class="p">;</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;IRQ %d on CPU %d status &quot;</span> <span class="n">EFX_OWORD_FMT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">irq</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">(),</span> <span class="n">EFX_OWORD_VAL</span><span class="p">(</span><span class="o">*</span><span class="n">int_ker</span><span class="p">));</span>

	<span class="cm">/* Handle non-event-queue sources */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">syserr</span> <span class="o">=</span> <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">int_ker</span><span class="p">,</span> <span class="n">FSF_AZ_NET_IVEC_FATAL_INT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">syserr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">efx_nic_fatal_interrupt</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">last_irq_cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Schedule processing of the channel */</span>
	<span class="n">efx_schedule_channel_irq</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Setup RSS indirection table.</span>
<span class="cm"> * This maps from the hash value of the packet to RXQ</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">efx_nic_push_rx_indir_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">efx_dword_t</span> <span class="n">dword</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_indir_table</span><span class="p">)</span> <span class="o">!=</span>
		     <span class="n">FR_BZ_RX_INDIRECTION_TBL_ROWS</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FR_BZ_RX_INDIRECTION_TBL_ROWS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EFX_POPULATE_DWORD_1</span><span class="p">(</span><span class="n">dword</span><span class="p">,</span> <span class="n">FRF_BZ_IT_QUEUE</span><span class="p">,</span>
				     <span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_indir_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">efx_writed_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dword</span><span class="p">,</span> <span class="n">FR_BZ_RX_INDIRECTION_TBL</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Hook interrupt handler(s)</span>
<span class="cm"> * Try MSI and then legacy interrupts.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">efx_nic_init_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EFX_INT_MODE_USE_MSI</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span>
			<span class="n">handler</span> <span class="o">=</span> <span class="n">efx_legacy_interrupt</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">handler</span> <span class="o">=</span> <span class="n">falcon_legacy_interrupt_a1</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
				 <span class="n">efx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">efx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;failed to hook legacy IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Hook MSI or MSI-X interrupt */</span>
	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">efx_msi_interrupt</span><span class="p">,</span>
				 <span class="n">IRQF_PROBE_SHARED</span><span class="p">,</span> <span class="cm">/* Not shared */</span>
				 <span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel_name</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">],</span>
				 <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;failed to hook IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail2:</span>
	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">]);</span>
 <span class="nl">fail1:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_fini_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="cm">/* Disable MSI/MSI-X interrupts */</span>
	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* ACK legacy interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span>
		<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_INT_ISR0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">falcon_irq_ack_a1</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Disable legacy interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">legacy_irq</span><span class="p">,</span> <span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Looks at available SRAM resources and works out how many queues we</span>
<span class="cm"> * can support, and where things like descriptor caches should live.</span>
<span class="cm"> *</span>
<span class="cm"> * SRAM is split up as follows:</span>
<span class="cm"> * 0                          buftbl entries for channels</span>
<span class="cm"> * efx-&gt;vf_buftbl_base        buftbl entries for SR-IOV</span>
<span class="cm"> * efx-&gt;rx_dc_base            RX descriptor caches</span>
<span class="cm"> * efx-&gt;tx_dc_base            TX descriptor caches</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">efx_nic_dimension_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">sram_lim_qw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">vi_count</span><span class="p">,</span> <span class="n">buftbl_min</span><span class="p">;</span>

	<span class="cm">/* Account for the buffer table entries backing the datapath channels</span>
<span class="cm">	 * and the descriptor caches for those channels.</span>
<span class="cm">	 */</span>
	<span class="n">buftbl_min</span> <span class="o">=</span> <span class="p">((</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_channels</span> <span class="o">*</span> <span class="n">EFX_MAX_DMAQ_SIZE</span> <span class="o">+</span>
		       <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span> <span class="o">*</span> <span class="n">EFX_TXQ_TYPES</span> <span class="o">*</span> <span class="n">EFX_MAX_DMAQ_SIZE</span> <span class="o">+</span>
		       <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span> <span class="o">*</span> <span class="n">EFX_MAX_EVQ_SIZE</span><span class="p">)</span>
		      <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_qword_t</span><span class="p">)</span> <span class="o">/</span> <span class="n">EFX_BUF_SIZE</span><span class="p">);</span>
	<span class="n">vi_count</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_tx_channels</span> <span class="o">*</span> <span class="n">EFX_TXQ_TYPES</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SFC_SRIOV</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_sriov_wanted</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">vi_dc_entries</span><span class="p">,</span> <span class="n">buftbl_free</span><span class="p">,</span> <span class="n">entries_per_vf</span><span class="p">,</span> <span class="n">vf_limit</span><span class="p">;</span>

		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_buftbl_base</span> <span class="o">=</span> <span class="n">buftbl_min</span><span class="p">;</span>

		<span class="n">vi_dc_entries</span> <span class="o">=</span> <span class="n">RX_DC_ENTRIES</span> <span class="o">+</span> <span class="n">TX_DC_ENTRIES</span><span class="p">;</span>
		<span class="n">vi_count</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">vi_count</span><span class="p">,</span> <span class="n">EFX_VI_BASE</span><span class="p">);</span>
		<span class="n">buftbl_free</span> <span class="o">=</span> <span class="p">(</span><span class="n">sram_lim_qw</span> <span class="o">-</span> <span class="n">buftbl_min</span> <span class="o">-</span>
			       <span class="n">vi_count</span> <span class="o">*</span> <span class="n">vi_dc_entries</span><span class="p">);</span>

		<span class="n">entries_per_vf</span> <span class="o">=</span> <span class="p">((</span><span class="n">vi_dc_entries</span> <span class="o">+</span> <span class="n">EFX_VF_BUFTBL_PER_VI</span><span class="p">)</span> <span class="o">*</span>
				  <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">));</span>
		<span class="n">vf_limit</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">buftbl_free</span> <span class="o">/</span> <span class="n">entries_per_vf</span><span class="p">,</span>
			       <span class="p">(</span><span class="mi">1024U</span> <span class="o">-</span> <span class="n">EFX_VI_BASE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vi_scale</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span> <span class="o">&gt;</span> <span class="n">vf_limit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;Reducing VF count from from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">,</span> <span class="n">vf_limit</span><span class="p">);</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span> <span class="o">=</span> <span class="n">vf_limit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vi_count</span> <span class="o">+=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span> <span class="o">*</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_dc_base</span> <span class="o">=</span> <span class="n">sram_lim_qw</span> <span class="o">-</span> <span class="n">vi_count</span> <span class="o">*</span> <span class="n">TX_DC_ENTRIES</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_dc_base</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_dc_base</span> <span class="o">-</span> <span class="n">vi_count</span> <span class="o">*</span> <span class="n">RX_DC_ENTRIES</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u32</span> <span class="nf">efx_nic_fpga_ver</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">altera_build</span><span class="p">;</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">altera_build</span><span class="p">,</span> <span class="n">FR_AZ_ALTERA_BUILD</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">altera_build</span><span class="p">,</span> <span class="n">FRF_AZ_ALTERA_BUILD_VER</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_init_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">temp</span><span class="p">;</span>

	<span class="cm">/* Set positions of descriptor caches in SRAM. */</span>
	<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_SRM_TX_DC_BASE_ADR</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">tx_dc_base</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_SRM_TX_DC_CFG</span><span class="p">);</span>
	<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_SRM_RX_DC_BASE_ADR</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_dc_base</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_SRM_RX_DC_CFG</span><span class="p">);</span>

	<span class="cm">/* Set TX descriptor cache size. */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">TX_DC_ENTRIES</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">8</span> <span class="o">&lt;&lt;</span> <span class="n">TX_DC_ENTRIES_ORDER</span><span class="p">));</span>
	<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_TX_DC_SIZE</span><span class="p">,</span> <span class="n">TX_DC_ENTRIES_ORDER</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_TX_DC_CFG</span><span class="p">);</span>

	<span class="cm">/* Set RX descriptor cache size.  Set low watermark to size-8, as</span>
<span class="cm">	 * this allows most efficient prefetching.</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">RX_DC_ENTRIES</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">8</span> <span class="o">&lt;&lt;</span> <span class="n">RX_DC_ENTRIES_ORDER</span><span class="p">));</span>
	<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_RX_DC_SIZE</span><span class="p">,</span> <span class="n">RX_DC_ENTRIES_ORDER</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_RX_DC_CFG</span><span class="p">);</span>
	<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_RX_DC_PF_LWM</span><span class="p">,</span> <span class="n">RX_DC_ENTRIES</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_RX_DC_PF_WM</span><span class="p">);</span>

	<span class="cm">/* Program INT_KER address */</span>
	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span>
			     <span class="n">FRF_AZ_NORM_INT_VEC_DIS_KER</span><span class="p">,</span>
			     <span class="n">EFX_INT_MODE_USE_MSI</span><span class="p">(</span><span class="n">efx</span><span class="p">),</span>
			     <span class="n">FRF_AZ_INT_ADR_KER</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_INT_ADR_KER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EFX_WORKAROUND_17213</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">EFX_INT_MODE_USE_MSI</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
		<span class="cm">/* Use an interrupt level unused by event queues */</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_level</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* Use a valid MSI-X vector */</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Enable all the genuinely fatal interrupts.  (They are still</span>
<span class="cm">	 * masked by the overall interrupt mask, controlled by</span>
<span class="cm">	 * falcon_interrupts()).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: All other fatal interrupts are enabled</span>
<span class="cm">	 */</span>
	<span class="n">EFX_POPULATE_OWORD_3</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span>
			     <span class="n">FRF_AZ_ILL_ADR_INT_KER_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AZ_RBUF_OWN_INT_KER_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AZ_TBUF_OWN_INT_KER_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_SIENA_A0</span><span class="p">)</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_CZ_SRAM_PERR_INT_P_KER_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">EFX_INVERT_OWORD</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_FATAL_INTR_KER</span><span class="p">);</span>

	<span class="n">efx_nic_push_rx_indir_table</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Disable the ugly timer-based TX DMA backoff and allow TX DMA to be</span>
<span class="cm">	 * controlled by the RX FIFO fill level. Set arbitration to one pkt/Q.</span>
<span class="cm">	 */</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_TX_RESERVED</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_TX_RX_SPACER</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_TX_RX_SPACER_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_TX_ONE_PKT_PER_Q</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_TX_PUSH_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_TX_DIS_NON_IP_EV</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* Enable SW_EV to inherit in char driver - assume harmless here */</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_TX_SOFT_EVT_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* Prefetch threshold 2 =&gt; fetch when descriptor cache half empty */</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_TX_PREF_THRESHOLD</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="cm">/* Disable hardware watchdog which can misfire */</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_TX_PREF_WD_TMR</span><span class="p">,</span> <span class="mh">0x3fffff</span><span class="p">);</span>
	<span class="cm">/* Squash TX of packets of 16 bytes or less */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_TX_FLUSH_MIN_LEN_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_TX_RESERVED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EFX_POPULATE_OWORD_4</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span>
				     <span class="cm">/* Default values */</span>
				     <span class="n">FRF_BZ_TX_PACE_SB_NOT_AF</span><span class="p">,</span> <span class="mh">0x15</span><span class="p">,</span>
				     <span class="n">FRF_BZ_TX_PACE_SB_AF</span><span class="p">,</span> <span class="mh">0xb</span><span class="p">,</span>
				     <span class="n">FRF_BZ_TX_PACE_FB_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="cm">/* Allow large pace values in the</span>
<span class="cm">				      * fast bin. */</span>
				     <span class="n">FRF_BZ_TX_PACE_BIN_TH</span><span class="p">,</span>
				     <span class="n">FFE_BZ_TX_PACE_RESERVED</span><span class="p">);</span>
		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_BZ_TX_PACE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Register dump */</span>

<span class="cp">#define REGISTER_REVISION_A	1</span>
<span class="cp">#define REGISTER_REVISION_B	2</span>
<span class="cp">#define REGISTER_REVISION_C	3</span>
<span class="cp">#define REGISTER_REVISION_Z	3	</span><span class="cm">/* latest revision */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">efx_nic_reg</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">min_revision</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_revision</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define REGISTER(name, min_rev, max_rev) {				\</span>
<span class="cp">	FR_ ## min_rev ## max_rev ## _ ## name,				\</span>
<span class="cp">	REGISTER_REVISION_ ## min_rev, REGISTER_REVISION_ ## max_rev	\</span>
<span class="cp">}</span>
<span class="cp">#define REGISTER_AA(name) REGISTER(name, A, A)</span>
<span class="cp">#define REGISTER_AB(name) REGISTER(name, A, B)</span>
<span class="cp">#define REGISTER_AZ(name) REGISTER(name, A, Z)</span>
<span class="cp">#define REGISTER_BB(name) REGISTER(name, B, B)</span>
<span class="cp">#define REGISTER_BZ(name) REGISTER(name, B, Z)</span>
<span class="cp">#define REGISTER_CZ(name) REGISTER(name, C, Z)</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_reg</span> <span class="n">efx_nic_regs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">ADR_REGION</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">INT_EN_KER</span><span class="p">),</span>
	<span class="n">REGISTER_BZ</span><span class="p">(</span><span class="n">INT_EN_CHAR</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">INT_ADR_KER</span><span class="p">),</span>
	<span class="n">REGISTER_BZ</span><span class="p">(</span><span class="n">INT_ADR_CHAR</span><span class="p">),</span>
	<span class="cm">/* INT_ACK_KER is WO */</span>
	<span class="cm">/* INT_ISR0 is RC */</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">HW_INIT</span><span class="p">),</span>
	<span class="n">REGISTER_CZ</span><span class="p">(</span><span class="n">USR_EV_CFG</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">EE_SPI_HCMD</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">EE_SPI_HADR</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">EE_SPI_HDATA</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">EE_BASE_PAGE</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">EE_VPD_CFG0</span><span class="p">),</span>
	<span class="cm">/* EE_VPD_SW_CNTL and EE_VPD_SW_DATA are not used */</span>
	<span class="cm">/* PMBX_DBG_IADDR and PBMX_DBG_IDATA are indirect */</span>
	<span class="cm">/* PCIE_CORE_INDIRECT is indirect */</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">NIC_STAT</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GPIO_CTL</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GLB_CTL</span><span class="p">),</span>
	<span class="cm">/* FATAL_INTR_KER and FATAL_INTR_CHAR are partly RC */</span>
	<span class="n">REGISTER_BZ</span><span class="p">(</span><span class="n">DP_CTRL</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">MEM_STAT</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">CS_DEBUG</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">ALTERA_BUILD</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">CSR_SPARE</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">PCIE_SD_CTL0123</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">PCIE_SD_CTL45</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">PCIE_PCS_CTL_STAT</span><span class="p">),</span>
	<span class="cm">/* DEBUG_DATA_OUT is not used */</span>
	<span class="cm">/* DRV_EV is WO */</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">EVQ_CTL</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">EVQ_CNT1</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">EVQ_CNT2</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">BUF_TBL_CFG</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">SRM_RX_DC_CFG</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">SRM_TX_DC_CFG</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">SRM_CFG</span><span class="p">),</span>
	<span class="cm">/* BUF_TBL_UPD is WO */</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">SRM_UPD_EVQ</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">SRAM_PARITY</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">RX_CFG</span><span class="p">),</span>
	<span class="n">REGISTER_BZ</span><span class="p">(</span><span class="n">RX_FILTER_CTL</span><span class="p">),</span>
	<span class="cm">/* RX_FLUSH_DESCQ is WO */</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">RX_DC_CFG</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">RX_DC_PF_WM</span><span class="p">),</span>
	<span class="n">REGISTER_BZ</span><span class="p">(</span><span class="n">RX_RSS_TKEY</span><span class="p">),</span>
	<span class="cm">/* RX_NODESC_DROP is RC */</span>
	<span class="n">REGISTER_AA</span><span class="p">(</span><span class="n">RX_SELF_RST</span><span class="p">),</span>
	<span class="cm">/* RX_DEBUG, RX_PUSH_DROP are not used */</span>
	<span class="n">REGISTER_CZ</span><span class="p">(</span><span class="n">RX_RSS_IPV6_REG1</span><span class="p">),</span>
	<span class="n">REGISTER_CZ</span><span class="p">(</span><span class="n">RX_RSS_IPV6_REG2</span><span class="p">),</span>
	<span class="n">REGISTER_CZ</span><span class="p">(</span><span class="n">RX_RSS_IPV6_REG3</span><span class="p">),</span>
	<span class="cm">/* TX_FLUSH_DESCQ is WO */</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">TX_DC_CFG</span><span class="p">),</span>
	<span class="n">REGISTER_AA</span><span class="p">(</span><span class="n">TX_CHKSM_CFG</span><span class="p">),</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">TX_CFG</span><span class="p">),</span>
	<span class="cm">/* TX_PUSH_DROP is not used */</span>
	<span class="n">REGISTER_AZ</span><span class="p">(</span><span class="n">TX_RESERVED</span><span class="p">),</span>
	<span class="n">REGISTER_BZ</span><span class="p">(</span><span class="n">TX_PACE</span><span class="p">),</span>
	<span class="cm">/* TX_PACE_DROP_QID is RC */</span>
	<span class="n">REGISTER_BB</span><span class="p">(</span><span class="n">TX_VLAN</span><span class="p">),</span>
	<span class="n">REGISTER_BZ</span><span class="p">(</span><span class="n">TX_IPFIL_PORTEN</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">MD_TXD</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">MD_RXD</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">MD_CS</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">MD_PHY_ADR</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">MD_ID</span><span class="p">),</span>
	<span class="cm">/* MD_STAT is RC */</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">MAC_STAT_DMA</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">MAC_CTRL</span><span class="p">),</span>
	<span class="n">REGISTER_BB</span><span class="p">(</span><span class="n">GEN_MODE</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">MAC_MC_HASH_REG0</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">MAC_MC_HASH_REG1</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GM_CFG1</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GM_CFG2</span><span class="p">),</span>
	<span class="cm">/* GM_IPG and GM_HD are not used */</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GM_MAX_FLEN</span><span class="p">),</span>
	<span class="cm">/* GM_TEST is not used */</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GM_ADR1</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GM_ADR2</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GMF_CFG0</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GMF_CFG1</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GMF_CFG2</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GMF_CFG3</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GMF_CFG4</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">GMF_CFG5</span><span class="p">),</span>
	<span class="n">REGISTER_BB</span><span class="p">(</span><span class="n">TX_SRC_MAC_CTL</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XM_ADR_LO</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XM_ADR_HI</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XM_GLB_CFG</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XM_TX_CFG</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XM_RX_CFG</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XM_MGT_INT_MASK</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XM_FC</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XM_PAUSE_TIME</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XM_TX_PARAM</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XM_RX_PARAM</span><span class="p">),</span>
	<span class="cm">/* XM_MGT_INT_MSK (note no &#39;A&#39;) is RC */</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XX_PWR_RST</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XX_SD_CTL</span><span class="p">),</span>
	<span class="n">REGISTER_AB</span><span class="p">(</span><span class="n">XX_TXDRV_CTL</span><span class="p">),</span>
	<span class="cm">/* XX_PRBS_CTL, XX_PRBS_CHK and XX_PRBS_ERR are not used */</span>
	<span class="cm">/* XX_CORE_STAT is partly RC */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">efx_nic_reg_table</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">min_revision</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_revision</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">step</span><span class="o">:</span><span class="mi">6</span><span class="p">,</span> <span class="n">rows</span><span class="o">:</span><span class="mi">21</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define REGISTER_TABLE_DIMENSIONS(_, offset, min_rev, max_rev, step, rows) { \</span>
<span class="cp">	offset,								\</span>
<span class="cp">	REGISTER_REVISION_ ## min_rev, REGISTER_REVISION_ ## max_rev,	\</span>
<span class="cp">	step, rows							\</span>
<span class="cp">}</span>
<span class="cp">#define REGISTER_TABLE(name, min_rev, max_rev)				\</span>
<span class="cp">	REGISTER_TABLE_DIMENSIONS(					\</span>
<span class="cp">		name, FR_ ## min_rev ## max_rev ## _ ## name,		\</span>
<span class="cp">		min_rev, max_rev,					\</span>
<span class="cp">		FR_ ## min_rev ## max_rev ## _ ## name ## _STEP,	\</span>
<span class="cp">		FR_ ## min_rev ## max_rev ## _ ## name ## _ROWS)</span>
<span class="cp">#define REGISTER_TABLE_AA(name) REGISTER_TABLE(name, A, A)</span>
<span class="cp">#define REGISTER_TABLE_AZ(name) REGISTER_TABLE(name, A, Z)</span>
<span class="cp">#define REGISTER_TABLE_BB(name) REGISTER_TABLE(name, B, B)</span>
<span class="cp">#define REGISTER_TABLE_BZ(name) REGISTER_TABLE(name, B, Z)</span>
<span class="cp">#define REGISTER_TABLE_BB_CZ(name)					\</span>
<span class="cp">	REGISTER_TABLE_DIMENSIONS(name, FR_BZ_ ## name, B, B,		\</span>
<span class="cp">				  FR_BZ_ ## name ## _STEP,		\</span>
<span class="cp">				  FR_BB_ ## name ## _ROWS),		\</span>
<span class="cp">	REGISTER_TABLE_DIMENSIONS(name, FR_BZ_ ## name, C, Z,		\</span>
<span class="cp">				  FR_BZ_ ## name ## _STEP,		\</span>
<span class="cp">				  FR_CZ_ ## name ## _ROWS)</span>
<span class="cp">#define REGISTER_TABLE_CZ(name) REGISTER_TABLE(name, C, Z)</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_reg_table</span> <span class="n">efx_nic_reg_tables</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* DRIVER is not used */</span>
	<span class="cm">/* EVQ_RPTR, TIMER_COMMAND, USR_EV and {RX,TX}_DESC_UPD are WO */</span>
	<span class="n">REGISTER_TABLE_BB</span><span class="p">(</span><span class="n">TX_IPFIL_TBL</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_BB</span><span class="p">(</span><span class="n">TX_SRC_MAC_TBL</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_AA</span><span class="p">(</span><span class="n">RX_DESC_PTR_TBL_KER</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_BB_CZ</span><span class="p">(</span><span class="n">RX_DESC_PTR_TBL</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_AA</span><span class="p">(</span><span class="n">TX_DESC_PTR_TBL_KER</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_BB_CZ</span><span class="p">(</span><span class="n">TX_DESC_PTR_TBL</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_AA</span><span class="p">(</span><span class="n">EVQ_PTR_TBL_KER</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_BB_CZ</span><span class="p">(</span><span class="n">EVQ_PTR_TBL</span><span class="p">),</span>
	<span class="cm">/* We can&#39;t reasonably read all of the buffer table (up to 8MB!).</span>
<span class="cm">	 * However this driver will only use a few entries.  Reading</span>
<span class="cm">	 * 1K entries allows for some expansion of queue count and</span>
<span class="cm">	 * size before we need to change the version. */</span>
	<span class="n">REGISTER_TABLE_DIMENSIONS</span><span class="p">(</span><span class="n">BUF_FULL_TBL_KER</span><span class="p">,</span> <span class="n">FR_AA_BUF_FULL_TBL_KER</span><span class="p">,</span>
				  <span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1024</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_DIMENSIONS</span><span class="p">(</span><span class="n">BUF_FULL_TBL</span><span class="p">,</span> <span class="n">FR_BZ_BUF_FULL_TBL</span><span class="p">,</span>
				  <span class="n">B</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1024</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_CZ</span><span class="p">(</span><span class="n">RX_MAC_FILTER_TBL0</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_BB_CZ</span><span class="p">(</span><span class="n">TIMER_TBL</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_BB_CZ</span><span class="p">(</span><span class="n">TX_PACE_TBL</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_BZ</span><span class="p">(</span><span class="n">RX_INDIRECTION_TBL</span><span class="p">),</span>
	<span class="cm">/* TX_FILTER_TBL0 is huge and not used by this driver */</span>
	<span class="n">REGISTER_TABLE_CZ</span><span class="p">(</span><span class="n">TX_MAC_FILTER_TBL0</span><span class="p">),</span>
	<span class="n">REGISTER_TABLE_CZ</span><span class="p">(</span><span class="n">MC_TREG_SMEM</span><span class="p">),</span>
	<span class="cm">/* MSIX_PBA_TABLE is not mapped */</span>
	<span class="cm">/* SRM_DBG is not mapped (and is redundant with BUF_FLL_TBL) */</span>
	<span class="n">REGISTER_TABLE_BZ</span><span class="p">(</span><span class="n">RX_FILTER_TBL0</span><span class="p">),</span>
<span class="p">};</span>

<span class="kt">size_t</span> <span class="nf">efx_nic_get_regs_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_reg</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_reg_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">reg</span> <span class="o">=</span> <span class="n">efx_nic_regs</span><span class="p">;</span>
	     <span class="n">reg</span> <span class="o">&lt;</span> <span class="n">efx_nic_regs</span> <span class="o">+</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">efx_nic_regs</span><span class="p">);</span>
	     <span class="n">reg</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">min_revision</span> <span class="o">&amp;&amp;</span>
		    <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">max_revision</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_oword_t</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">table</span> <span class="o">=</span> <span class="n">efx_nic_reg_tables</span><span class="p">;</span>
	     <span class="n">table</span> <span class="o">&lt;</span> <span class="n">efx_nic_reg_tables</span> <span class="o">+</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">efx_nic_reg_tables</span><span class="p">);</span>
	     <span class="n">table</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">min_revision</span> <span class="o">&amp;&amp;</span>
		    <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">max_revision</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">rows</span> <span class="o">*</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">step</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_nic_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_reg</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_reg_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">reg</span> <span class="o">=</span> <span class="n">efx_nic_regs</span><span class="p">;</span>
	     <span class="n">reg</span> <span class="o">&lt;</span> <span class="n">efx_nic_regs</span> <span class="o">+</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">efx_nic_regs</span><span class="p">);</span>
	     <span class="n">reg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">min_revision</span> <span class="o">&amp;&amp;</span>
		    <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">max_revision</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="p">(</span><span class="n">efx_oword_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_oword_t</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">table</span> <span class="o">=</span> <span class="n">efx_nic_reg_tables</span><span class="p">;</span>
	     <span class="n">table</span> <span class="o">&lt;</span> <span class="n">efx_nic_reg_tables</span> <span class="o">+</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">efx_nic_reg_tables</span><span class="p">);</span>
	     <span class="n">table</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">min_revision</span> <span class="o">&amp;&amp;</span>
		      <span class="n">efx</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">max_revision</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">step</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">step</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">4</span>: <span class="cm">/* 32-bit register or SRAM */</span>
				<span class="n">efx_readd_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">8</span>: <span class="cm">/* 64-bit SRAM */</span>
				<span class="n">efx_sram_readq</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span>
					       <span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">+</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
					       <span class="n">buf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">16</span>: <span class="cm">/* 128-bit register */</span>
				<span class="n">efx_reado_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">32</span>: <span class="cm">/* 128-bit register, interleaved */</span>
				<span class="n">efx_reado_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
