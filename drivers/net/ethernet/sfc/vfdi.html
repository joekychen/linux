<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › vfdi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>vfdi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2010-2012 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _VFDI_H</span>
<span class="cp">#define _VFDI_H</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Virtual Function Driver Interface</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains software structures used to form a two way</span>
<span class="cm"> * communication channel between the VF driver and the PF driver,</span>
<span class="cm"> * named Virtual Function Driver Interface (VFDI).</span>
<span class="cm"> *</span>
<span class="cm"> * For the purposes of VFDI, a page is a memory region with size and</span>
<span class="cm"> * alignment of 4K.  All addresses are DMA addresses to be used within</span>
<span class="cm"> * the domain of the relevant VF.</span>
<span class="cm"> *</span>
<span class="cm"> * The only hardware-defined channels for a VF driver to communicate</span>
<span class="cm"> * with the PF driver are the event mailboxes (%FR_CZ_USR_EV</span>
<span class="cm"> * registers).  Writing to these registers generates an event with</span>
<span class="cm"> * EV_CODE = EV_CODE_USR_EV, USER_QID set to the index of the mailbox</span>
<span class="cm"> * and USER_EV_REG_VALUE set to the value written.  The PF driver may</span>
<span class="cm"> * direct or disable delivery of these events by setting</span>
<span class="cm"> * %FR_CZ_USR_EV_CFG.</span>
<span class="cm"> *</span>
<span class="cm"> * The PF driver can send arbitrary events to arbitrary event queues.</span>
<span class="cm"> * However, for consistency, VFDI events from the PF are defined to</span>
<span class="cm"> * follow the same form and be sent to the first event queue assigned</span>
<span class="cm"> * to the VF while that queue is enabled by the VF driver.</span>
<span class="cm"> *</span>
<span class="cm"> * The general form of the variable bits of VFDI events is:</span>
<span class="cm"> *</span>
<span class="cm"> *       0             16                       24   31</span>
<span class="cm"> *      | DATA        | TYPE                   | SEQ   |</span>
<span class="cm"> *</span>
<span class="cm"> * SEQ is a sequence number which should be incremented by 1 (modulo</span>
<span class="cm"> * 256) for each event.  The sequence numbers used in each direction</span>
<span class="cm"> * are independent.</span>
<span class="cm"> *</span>
<span class="cm"> * The VF submits requests of type &amp;struct vfdi_req by sending the</span>
<span class="cm"> * address of the request (ADDR) in a series of 4 events:</span>
<span class="cm"> *</span>
<span class="cm"> *       0             16                       24   31</span>
<span class="cm"> *      | ADDR[0:15]  | VFDI_EV_TYPE_REQ_WORD0 | SEQ   |</span>
<span class="cm"> *      | ADDR[16:31] | VFDI_EV_TYPE_REQ_WORD1 | SEQ+1 |</span>
<span class="cm"> *      | ADDR[32:47] | VFDI_EV_TYPE_REQ_WORD2 | SEQ+2 |</span>
<span class="cm"> *      | ADDR[48:63] | VFDI_EV_TYPE_REQ_WORD3 | SEQ+3 |</span>
<span class="cm"> *</span>
<span class="cm"> * The address must be page-aligned.  After receiving such a valid</span>
<span class="cm"> * series of events, the PF driver will attempt to read the request</span>
<span class="cm"> * and write a response to the same address.  In case of an invalid</span>
<span class="cm"> * sequence of events or a DMA error, there will be no response.</span>
<span class="cm"> *</span>
<span class="cm"> * The VF driver may request that the PF driver writes status</span>
<span class="cm"> * information into its domain asynchronously.  After writing the</span>
<span class="cm"> * status, the PF driver will send an event of the form:</span>
<span class="cm"> *</span>
<span class="cm"> *       0             16                       24   31</span>
<span class="cm"> *      | reserved    | VFDI_EV_TYPE_STATUS    | SEQ   |</span>
<span class="cm"> *</span>
<span class="cm"> * In case the VF must be reset for any reason, the PF driver will</span>
<span class="cm"> * send an event of the form:</span>
<span class="cm"> *</span>
<span class="cm"> *       0             16                       24   31</span>
<span class="cm"> *      | reserved    | VFDI_EV_TYPE_RESET     | SEQ   |</span>
<span class="cm"> *</span>
<span class="cm"> * It is then the responsibility of the VF driver to request</span>
<span class="cm"> * reinitialisation of its queues.</span>
<span class="cm"> */</span>
<span class="cp">#define VFDI_EV_SEQ_LBN 24</span>
<span class="cp">#define VFDI_EV_SEQ_WIDTH 8</span>
<span class="cp">#define VFDI_EV_TYPE_LBN 16</span>
<span class="cp">#define VFDI_EV_TYPE_WIDTH 8</span>
<span class="cp">#define VFDI_EV_TYPE_REQ_WORD0 0</span>
<span class="cp">#define VFDI_EV_TYPE_REQ_WORD1 1</span>
<span class="cp">#define VFDI_EV_TYPE_REQ_WORD2 2</span>
<span class="cp">#define VFDI_EV_TYPE_REQ_WORD3 3</span>
<span class="cp">#define VFDI_EV_TYPE_STATUS 4</span>
<span class="cp">#define VFDI_EV_TYPE_RESET 5</span>
<span class="cp">#define VFDI_EV_DATA_LBN 0</span>
<span class="cp">#define VFDI_EV_DATA_WIDTH 16</span>

<span class="k">struct</span> <span class="n">vfdi_endpoint</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">mac_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">__be16</span> <span class="n">tci</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum vfdi_op - VFDI operation enumeration</span>
<span class="cm"> * @VFDI_OP_RESPONSE: Indicates a response to the request.</span>
<span class="cm"> * @VFDI_OP_INIT_EVQ: Initialize SRAM entries and initialize an EVQ.</span>
<span class="cm"> * @VFDI_OP_INIT_RXQ: Initialize SRAM entries and initialize an RXQ.</span>
<span class="cm"> * @VFDI_OP_INIT_TXQ: Initialize SRAM entries and initialize a TXQ.</span>
<span class="cm"> * @VFDI_OP_FINI_ALL_QUEUES: Flush all queues, finalize all queues, then</span>
<span class="cm"> *	finalize the SRAM entries.</span>
<span class="cm"> * @VFDI_OP_INSERT_FILTER: Insert a MAC filter targetting the given RXQ.</span>
<span class="cm"> * @VFDI_OP_REMOVE_ALL_FILTERS: Remove all filters.</span>
<span class="cm"> * @VFDI_OP_SET_STATUS_PAGE: Set the DMA page(s) used for status updates</span>
<span class="cm"> *	from PF and write the initial status.</span>
<span class="cm"> * @VFDI_OP_CLEAR_STATUS_PAGE: Clear the DMA page(s) used for status</span>
<span class="cm"> *	updates from PF.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vfdi_op</span> <span class="p">{</span>
	<span class="n">VFDI_OP_RESPONSE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VFDI_OP_INIT_EVQ</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VFDI_OP_INIT_RXQ</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VFDI_OP_INIT_TXQ</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">VFDI_OP_FINI_ALL_QUEUES</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">VFDI_OP_INSERT_FILTER</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">VFDI_OP_REMOVE_ALL_FILTERS</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">VFDI_OP_SET_STATUS_PAGE</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">VFDI_OP_CLEAR_STATUS_PAGE</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">VFDI_OP_LIMIT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Response codes for VFDI operations. Other values may be used in future. */</span>
<span class="cp">#define VFDI_RC_SUCCESS		0</span>
<span class="cp">#define VFDI_RC_ENOMEM		(-12)</span>
<span class="cp">#define VFDI_RC_EINVAL		(-22)</span>
<span class="cp">#define VFDI_RC_EOPNOTSUPP	(-95)</span>
<span class="cp">#define VFDI_RC_ETIMEDOUT	(-110)</span>

<span class="cm">/**</span>
<span class="cm"> * struct vfdi_req - Request from VF driver to PF driver</span>
<span class="cm"> * @op: Operation code or response indicator, taken from &amp;enum vfdi_op.</span>
<span class="cm"> * @rc: Response code.  Set to 0 on success or a negative error code on failure.</span>
<span class="cm"> * @u.init_evq.index: Index of event queue to create.</span>
<span class="cm"> * @u.init_evq.buf_count: Number of 4k buffers backing event queue.</span>
<span class="cm"> * @u.init_evq.addr: Array of length %u.init_evq.buf_count containing DMA</span>
<span class="cm"> *	address of each page backing the event queue.</span>
<span class="cm"> * @u.init_rxq.index: Index of receive queue to create.</span>
<span class="cm"> * @u.init_rxq.buf_count: Number of 4k buffers backing receive queue.</span>
<span class="cm"> * @u.init_rxq.evq: Instance of event queue to target receive events at.</span>
<span class="cm"> * @u.init_rxq.label: Label used in receive events.</span>
<span class="cm"> * @u.init_rxq.flags: Unused.</span>
<span class="cm"> * @u.init_rxq.addr: Array of length %u.init_rxq.buf_count containing DMA</span>
<span class="cm"> *	address of each page backing the receive queue.</span>
<span class="cm"> * @u.init_txq.index: Index of transmit queue to create.</span>
<span class="cm"> * @u.init_txq.buf_count: Number of 4k buffers backing transmit queue.</span>
<span class="cm"> * @u.init_txq.evq: Instance of event queue to target transmit completion</span>
<span class="cm"> *	events at.</span>
<span class="cm"> * @u.init_txq.label: Label used in transmit completion events.</span>
<span class="cm"> * @u.init_txq.flags: Checksum offload flags.</span>
<span class="cm"> * @u.init_txq.addr: Array of length %u.init_txq.buf_count containing DMA</span>
<span class="cm"> *	address of each page backing the transmit queue.</span>
<span class="cm"> * @u.mac_filter.rxq: Insert MAC filter at VF local address/VLAN targetting</span>
<span class="cm"> *	all traffic at this receive queue.</span>
<span class="cm"> * @u.mac_filter.flags: MAC filter flags.</span>
<span class="cm"> * @u.set_status_page.dma_addr: Base address for the &amp;struct vfdi_status.</span>
<span class="cm"> *	This address must be page-aligned and the PF may write up to a</span>
<span class="cm"> *	whole page (allowing for extension of the structure).</span>
<span class="cm"> * @u.set_status_page.peer_page_count: Number of additional pages the VF</span>
<span class="cm"> *	has provided into which peer addresses may be DMAd.</span>
<span class="cm"> * @u.set_status_page.peer_page_addr: Array of DMA addresses of pages.</span>
<span class="cm"> *	If the number of peers exceeds 256, then the VF must provide</span>
<span class="cm"> *	additional pages in this array. The PF will then DMA up to</span>
<span class="cm"> *	512 vfdi_endpoint structures into each page.  These addresses</span>
<span class="cm"> *	must be page-aligned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vfdi_req</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">buf_count</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">addr</span><span class="p">[];</span>
		<span class="p">}</span> <span class="n">init_evq</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">buf_count</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">evq</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">label</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define VFDI_RXQ_FLAG_SCATTER_EN 1</span>
			<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">addr</span><span class="p">[];</span>
		<span class="p">}</span> <span class="n">init_rxq</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">buf_count</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">evq</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">label</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define VFDI_TXQ_FLAG_IP_CSUM_DIS 1</span>
<span class="cp">#define VFDI_TXQ_FLAG_TCPUDP_CSUM_DIS 2</span>
			<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">addr</span><span class="p">[];</span>
		<span class="p">}</span> <span class="n">init_txq</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">rxq</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define VFDI_MAC_FILTER_FLAG_RSS 1</span>
<span class="cp">#define VFDI_MAC_FILTER_FLAG_SCATTER 2</span>
		<span class="p">}</span> <span class="n">mac_filter</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">dma_addr</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">peer_page_count</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">peer_page_addr</span><span class="p">[];</span>
		<span class="p">}</span> <span class="n">set_status_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vfdi_status - Status provided by PF driver to VF driver</span>
<span class="cm"> * @generation_start: A generation count DMA&#39;d to VF *before* the</span>
<span class="cm"> *	rest of the structure.</span>
<span class="cm"> * @generation_end: A generation count DMA&#39;d to VF *after* the</span>
<span class="cm"> *	rest of the structure.</span>
<span class="cm"> * @version: Version of this structure; currently set to 1.  Later</span>
<span class="cm"> *	versions must either be layout-compatible or only be sent to VFs</span>
<span class="cm"> *	that specifically request them.</span>
<span class="cm"> * @length: Total length of this structure including embedded tables</span>
<span class="cm"> * @vi_scale: log2 the number of VIs available on this VF. This quantity</span>
<span class="cm"> *	is used by the hardware for register decoding.</span>
<span class="cm"> * @max_tx_channels: The maximum number of transmit queues the VF can use.</span>
<span class="cm"> * @rss_rxq_count: The number of receive queues present in the shared RSS</span>
<span class="cm"> *	indirection table.</span>
<span class="cm"> * @peer_count: Total number of peers in the complete peer list. If larger</span>
<span class="cm"> *	than ARRAY_SIZE(%peers), then the VF must provide sufficient</span>
<span class="cm"> *	additional pages each of which is filled with vfdi_endpoint structures.</span>
<span class="cm"> * @local: The MAC address and outer VLAN tag of *this* VF</span>
<span class="cm"> * @peers: Table of peer addresses.  The @tci fields in these structures</span>
<span class="cm"> *	are currently unused and must be ignored.  Additional peers are</span>
<span class="cm"> *	written into any additional pages provided by the VF.</span>
<span class="cm"> * @timer_quantum_ns: Timer quantum (nominal period between timer ticks)</span>
<span class="cm"> *	for interrupt moderation timers, in nanoseconds. This member is only</span>
<span class="cm"> *	present if @length is sufficiently large.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vfdi_status</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">generation_start</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">generation_end</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">vi_scale</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_tx_channels</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rss_rxq_count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">peer_count</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_endpoint</span> <span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_endpoint</span> <span class="n">peers</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

	<span class="cm">/* Members below here extend version 1 of this structure */</span>
	<span class="n">u32</span> <span class="n">timer_quantum_ns</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
