<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › siena_sriov.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>siena_sriov.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2010-2011 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &quot;net_driver.h&quot;</span>
<span class="cp">#include &quot;efx.h&quot;</span>
<span class="cp">#include &quot;nic.h&quot;</span>
<span class="cp">#include &quot;io.h&quot;</span>
<span class="cp">#include &quot;mcdi.h&quot;</span>
<span class="cp">#include &quot;filter.h&quot;</span>
<span class="cp">#include &quot;mcdi_pcol.h&quot;</span>
<span class="cp">#include &quot;regs.h&quot;</span>
<span class="cp">#include &quot;vfdi.h&quot;</span>

<span class="cm">/* Number of longs required to track all the VIs in a VF */</span>
<span class="cp">#define VI_MASK_LENGTH BITS_TO_LONGS(1 &lt;&lt; EFX_VI_SCALE_MAX)</span>

<span class="cm">/**</span>
<span class="cm"> * enum efx_vf_tx_filter_mode - TX MAC filtering behaviour</span>
<span class="cm"> * @VF_TX_FILTER_OFF: Disabled</span>
<span class="cm"> * @VF_TX_FILTER_AUTO: Enabled if MAC address assigned to VF and only</span>
<span class="cm"> *	2 TX queues allowed per VF.</span>
<span class="cm"> * @VF_TX_FILTER_ON: Enabled</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">efx_vf_tx_filter_mode</span> <span class="p">{</span>
	<span class="n">VF_TX_FILTER_OFF</span><span class="p">,</span>
	<span class="n">VF_TX_FILTER_AUTO</span><span class="p">,</span>
	<span class="n">VF_TX_FILTER_ON</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_vf - Back-end resource and protocol state for a PCI VF</span>
<span class="cm"> * @efx: The Efx NIC owning this VF</span>
<span class="cm"> * @pci_rid: The PCI requester ID for this VF</span>
<span class="cm"> * @pci_name: The PCI name (formatted address) of this VF</span>
<span class="cm"> * @index: Index of VF within its port and PF.</span>
<span class="cm"> * @req: VFDI incoming request work item. Incoming USR_EV events are received</span>
<span class="cm"> *	by the NAPI handler, but must be handled by executing MCDI requests</span>
<span class="cm"> *	inside a work item.</span>
<span class="cm"> * @req_addr: VFDI incoming request DMA address (in VF&#39;s PCI address space).</span>
<span class="cm"> * @req_type: Expected next incoming (from VF) %VFDI_EV_TYPE member.</span>
<span class="cm"> * @req_seqno: Expected next incoming (from VF) %VFDI_EV_SEQ member.</span>
<span class="cm"> * @msg_seqno: Next %VFDI_EV_SEQ member to reply to VF. Protected by</span>
<span class="cm"> *	@status_lock</span>
<span class="cm"> * @busy: VFDI request queued to be processed or being processed. Receiving</span>
<span class="cm"> *	a VFDI request when @busy is set is an error condition.</span>
<span class="cm"> * @buf: Incoming VFDI requests are DMA from the VF into this buffer.</span>
<span class="cm"> * @buftbl_base: Buffer table entries for this VF start at this index.</span>
<span class="cm"> * @rx_filtering: Receive filtering has been requested by the VF driver.</span>
<span class="cm"> * @rx_filter_flags: The flags sent in the %VFDI_OP_INSERT_FILTER request.</span>
<span class="cm"> * @rx_filter_qid: VF relative qid for RX filter requested by VF.</span>
<span class="cm"> * @rx_filter_id: Receive MAC filter ID. Only one filter per VF is supported.</span>
<span class="cm"> * @tx_filter_mode: Transmit MAC filtering mode.</span>
<span class="cm"> * @tx_filter_id: Transmit MAC filter ID.</span>
<span class="cm"> * @addr: The MAC address and outer vlan tag of the VF.</span>
<span class="cm"> * @status_addr: VF DMA address of page for &amp;struct vfdi_status updates.</span>
<span class="cm"> * @status_lock: Mutex protecting @msg_seqno, @status_addr, @addr,</span>
<span class="cm"> *	@peer_page_addrs and @peer_page_count from simultaneous</span>
<span class="cm"> *	updates by the VM and consumption by</span>
<span class="cm"> *	efx_sriov_update_vf_addr()</span>
<span class="cm"> * @peer_page_addrs: Pointer to an array of guest pages for local addresses.</span>
<span class="cm"> * @peer_page_count: Number of entries in @peer_page_count.</span>
<span class="cm"> * @evq0_addrs: Array of guest pages backing evq0.</span>
<span class="cm"> * @evq0_count: Number of entries in @evq0_addrs.</span>
<span class="cm"> * @flush_waitq: wait queue used by %VFDI_OP_FINI_ALL_QUEUES handler</span>
<span class="cm"> *	to wait for flush completions.</span>
<span class="cm"> * @txq_lock: Mutex for TX queue allocation.</span>
<span class="cm"> * @txq_mask: Mask of initialized transmit queues.</span>
<span class="cm"> * @txq_count: Number of initialized transmit queues.</span>
<span class="cm"> * @rxq_mask: Mask of initialized receive queues.</span>
<span class="cm"> * @rxq_count: Number of initialized receive queues.</span>
<span class="cm"> * @rxq_retry_mask: Mask or receive queues that need to be flushed again</span>
<span class="cm"> *	due to flush failure.</span>
<span class="cm"> * @rxq_retry_count: Number of receive queues in @rxq_retry_mask.</span>
<span class="cm"> * @reset_work: Work item to schedule a VF reset.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_vf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pci_rid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">pci_name</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span> <span class="cm">/* dddd:bb:dd.f */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">req_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">req_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">req_seqno</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">msg_seqno</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">busy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_buffer</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">buftbl_base</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rx_filtering</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">efx_filter_flags</span> <span class="n">rx_filter_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rx_filter_qid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_filter_id</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">efx_vf_tx_filter_mode</span> <span class="n">tx_filter_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_filter_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_endpoint</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">status_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">status_lock</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">peer_page_addrs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">peer_page_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">evq0_addrs</span><span class="p">[</span><span class="n">EFX_MAX_VF_EVQ_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_qword_t</span><span class="p">)</span> <span class="o">/</span>
		       <span class="n">EFX_BUF_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">evq0_count</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">flush_waitq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">txq_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">txq_mask</span><span class="p">[</span><span class="n">VI_MASK_LENGTH</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">txq_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rxq_mask</span><span class="p">[</span><span class="n">VI_MASK_LENGTH</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">rxq_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rxq_retry_mask</span><span class="p">[</span><span class="n">VI_MASK_LENGTH</span><span class="p">];</span>
	<span class="n">atomic_t</span> <span class="n">rxq_retry_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reset_work</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">efx_memcpy_req</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">from_rid</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">from_buf</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">from_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">to_rid</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">to_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_local_addr - A MAC address on the vswitch without a VF.</span>
<span class="cm"> *</span>
<span class="cm"> * Siena does not have a switch, so VFs can&#39;t transmit data to each</span>
<span class="cm"> * other. Instead the VFs must be made aware of the local addresses</span>
<span class="cm"> * on the vswitch, so that they can arrange for an alternative</span>
<span class="cm"> * software datapath to be used.</span>
<span class="cm"> *</span>
<span class="cm"> * @link: List head for insertion into efx-&gt;local_addr_list.</span>
<span class="cm"> * @addr: Ethernet address</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_local_addr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_endpoint_page - Page of vfdi_endpoint structures</span>
<span class="cm"> *</span>
<span class="cm"> * @link: List head for insertion into efx-&gt;local_page_list.</span>
<span class="cm"> * @ptr: Pointer to page.</span>
<span class="cm"> * @addr: DMA address of page.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_endpoint_page</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Buffer table entries are reserved txq0,rxq0,evq0,txq1,rxq1,evq1 */</span>
<span class="cp">#define EFX_BUFTBL_TXQ_BASE(_vf, _qid)					\</span>
<span class="cp">	((_vf)-&gt;buftbl_base + EFX_VF_BUFTBL_PER_VI * (_qid))</span>
<span class="cp">#define EFX_BUFTBL_RXQ_BASE(_vf, _qid)					\</span>
<span class="cp">	(EFX_BUFTBL_TXQ_BASE(_vf, _qid) +				\</span>
<span class="cp">	 (EFX_MAX_DMAQ_SIZE * sizeof(efx_qword_t) / EFX_BUF_SIZE))</span>
<span class="cp">#define EFX_BUFTBL_EVQ_BASE(_vf, _qid)					\</span>
<span class="cp">	(EFX_BUFTBL_TXQ_BASE(_vf, _qid) +				\</span>
<span class="cp">	 (2 * EFX_MAX_DMAQ_SIZE * sizeof(efx_qword_t) / EFX_BUF_SIZE))</span>

<span class="cp">#define EFX_FIELD_MASK(_field)			\</span>
<span class="cp">	((1 &lt;&lt; _field ## _WIDTH) - 1)</span>

<span class="cm">/* VFs can only use this many transmit channels */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vf_max_tx_channels</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">vf_max_tx_channels</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">vf_max_tx_channels</span><span class="p">,</span>
		 <span class="s">&quot;Limit the number of TX channels VFs can use&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">max_vfs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_vfs</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_vfs</span><span class="p">,</span>
		 <span class="s">&quot;Reduce the number of VFs initialized by the driver&quot;</span><span class="p">);</span>

<span class="cm">/* Workqueue used by VFDI communication.  We can&#39;t use the global</span>
<span class="cm"> * workqueue because it may be running the VF driver&#39;s probe()</span>
<span class="cm"> * routine, which will be blocked there waiting for a VFDI response.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">vfdi_workqueue</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">abs_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">EFX_VI_BASE</span> <span class="o">+</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_sriov_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="o">*</span><span class="n">vi_scale_out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">vf_total_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_SRIOV_IN_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">MC_CMD_SRIOV_OUT_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">vi_scale</span><span class="p">,</span> <span class="n">vf_total</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">outlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">SRIOV_IN_ENABLE</span><span class="p">,</span> <span class="n">enable</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">SRIOV_IN_VI_BASE</span><span class="p">,</span> <span class="n">EFX_VI_BASE</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">SRIOV_IN_VF_COUNT</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_SRIOV</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="n">MC_CMD_SRIOV_IN_LEN</span><span class="p">,</span>
			  <span class="n">outbuf</span><span class="p">,</span> <span class="n">MC_CMD_SRIOV_OUT_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">outlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">outlen</span> <span class="o">&lt;</span> <span class="n">MC_CMD_SRIOV_OUT_LEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">vf_total</span> <span class="o">=</span> <span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">SRIOV_OUT_VF_TOTAL</span><span class="p">);</span>
	<span class="n">vi_scale</span> <span class="o">=</span> <span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">SRIOV_OUT_VI_SCALE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vi_scale</span> <span class="o">&gt;</span> <span class="n">EFX_VI_SCALE_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vi_scale_out</span><span class="p">)</span>
		<span class="o">*</span><span class="n">vi_scale_out</span> <span class="o">=</span> <span class="n">vi_scale</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vf_total_out</span><span class="p">)</span>
		<span class="o">*</span><span class="n">vf_total_out</span> <span class="o">=</span> <span class="n">vf_total</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_sriov_usrev</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enabled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_CZ_USREV_DIS</span><span class="p">,</span> <span class="n">enabled</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_CZ_DFLT_EVQ</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vfdi_channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_CZ_USR_EV_CFG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_sriov_memcpy</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_memcpy_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">,</span> <span class="o">*</span><span class="n">record</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">used</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">from_rid</span><span class="p">,</span> <span class="n">from_hi</span><span class="p">,</span> <span class="n">from_lo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mb</span><span class="p">();</span>	<span class="cm">/* Finish writing source/reading dest before DMA starts */</span>

	<span class="n">used</span> <span class="o">=</span> <span class="n">MC_CMD_MEMCPY_IN_LEN</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">used</span> <span class="o">&gt;</span> <span class="n">MCDI_CTL_SDU_LEN_MAX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="cm">/* Allocate room for the largest request */</span>
	<span class="n">inbuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">MCDI_CTL_SDU_LEN_MAX</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">record</span> <span class="o">=</span> <span class="n">inbuf</span><span class="p">;</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">MEMCPY_IN_RECORD</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">MEMCPY_RECORD_TYPEDEF_TO_RID</span><span class="p">,</span>
			       <span class="n">req</span><span class="o">-&gt;</span><span class="n">to_rid</span><span class="p">);</span>
		<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">MEMCPY_RECORD_TYPEDEF_TO_ADDR_LO</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">to_addr</span><span class="p">);</span>
		<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">MEMCPY_RECORD_TYPEDEF_TO_ADDR_HI</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">to_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">from_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">from_rid</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">from_rid</span><span class="p">;</span>
			<span class="n">from_lo</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">from_addr</span><span class="p">;</span>
			<span class="n">from_hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">from_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">used</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">MCDI_CTL_SDU_LEN_MAX</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">from_rid</span> <span class="o">=</span> <span class="n">MC_CMD_MEMCPY_RECORD_TYPEDEF_RID_INLINE</span><span class="p">;</span>
			<span class="n">from_lo</span> <span class="o">=</span> <span class="n">used</span><span class="p">;</span>
			<span class="n">from_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">inbuf</span> <span class="o">+</span> <span class="n">used</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">from_buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
			<span class="n">used</span> <span class="o">+=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">MEMCPY_RECORD_TYPEDEF_FROM_RID</span><span class="p">,</span> <span class="n">from_rid</span><span class="p">);</span>
		<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">MEMCPY_RECORD_TYPEDEF_FROM_ADDR_LO</span><span class="p">,</span>
			       <span class="n">from_lo</span><span class="p">);</span>
		<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">MEMCPY_RECORD_TYPEDEF_FROM_ADDR_HI</span><span class="p">,</span>
			       <span class="n">from_hi</span><span class="p">);</span>
		<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">MEMCPY_RECORD_TYPEDEF_LENGTH</span><span class="p">,</span>
			       <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

		<span class="o">++</span><span class="n">req</span><span class="p">;</span>
		<span class="n">record</span> <span class="o">+=</span> <span class="n">MC_CMD_MEMCPY_IN_RECORD_LEN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_MEMCPY</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">inbuf</span><span class="p">);</span>

	<span class="n">mb</span><span class="p">();</span>	<span class="cm">/* Don&#39;t write source/read dest before DMA is complete */</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The TX filter is entirely controlled by this driver, and is modified</span>
<span class="cm"> * underneath the feet of the VF</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_sriov_reset_tx_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="n">filter</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vlan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_filter_remove_id_safe</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">EFX_FILTER_PRI_REQUIRED</span><span class="p">,</span>
					  <span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_id</span><span class="p">);</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Removed vf %s tx filter %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_id</span><span class="p">);</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">mac_addr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Turn on TX filtering automatically if not explicitly</span>
<span class="cm">	 * enabled or disabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_mode</span> <span class="o">==</span> <span class="n">VF_TX_FILTER_AUTO</span> <span class="o">&amp;&amp;</span> <span class="n">vf_max_tx_channels</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_mode</span> <span class="o">=</span> <span class="n">VF_TX_FILTER_ON</span><span class="p">;</span>

	<span class="n">vlan</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">tci</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">VLAN_VID_MASK</span><span class="p">;</span>
	<span class="n">efx_filter_init_tx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span> <span class="n">abs_index</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_filter_set_eth_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span>
				      <span class="n">vlan</span> <span class="o">?</span> <span class="n">vlan</span> <span class="o">:</span> <span class="n">EFX_FILTER_VID_UNSPEC</span><span class="p">,</span>
				      <span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">mac_addr</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_filter_insert_filter</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_warn</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;Unable to migrate tx filter for vf %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Inserted vf %s tx filter %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_id</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* The RX filter is managed here on behalf of the VF driver */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_sriov_reset_rx_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="n">filter</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vlan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filter_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_filter_remove_id_safe</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">EFX_FILTER_PRI_REQUIRED</span><span class="p">,</span>
					  <span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filter_id</span><span class="p">);</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Removed vf %s rx filter %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filter_id</span><span class="p">);</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filter_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filtering</span> <span class="o">||</span> <span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">mac_addr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vlan</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">tci</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">VLAN_VID_MASK</span><span class="p">;</span>
	<span class="n">efx_filter_init_rx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span> <span class="n">EFX_FILTER_PRI_REQUIRED</span><span class="p">,</span>
			   <span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filter_flags</span><span class="p">,</span>
			   <span class="n">abs_index</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filter_qid</span><span class="p">));</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_filter_set_eth_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span>
				      <span class="n">vlan</span> <span class="o">?</span> <span class="n">vlan</span> <span class="o">:</span> <span class="n">EFX_FILTER_VID_UNSPEC</span><span class="p">,</span>
				      <span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">mac_addr</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_filter_insert_filter</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_warn</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;Unable to insert rx filter for vf %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Inserted vf %s rx filter %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filter_id</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__efx_sriov_update_vf_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_sriov_reset_tx_filter</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
	<span class="n">efx_sriov_reset_rx_filter</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">vfdi_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">peer_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Push the peer list to this VF. The caller must hold status_lock to interlock</span>
<span class="cm"> * with VFDI requests, and they must be serialised against manipulation of</span>
<span class="cm"> * local_page_list, either by acquiring local_lock or by running from</span>
<span class="cm"> * efx_sriov_peer_work()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__efx_sriov_push_vf_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_status</span> <span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vfdi_status</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_memcpy_req</span> <span class="n">copy</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">efx_endpoint_page</span> <span class="o">*</span><span class="n">epp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">data_offset</span><span class="p">;</span>
	<span class="n">efx_qword_t</span> <span class="n">event</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_addr</span><span class="p">);</span>

	<span class="n">status</span><span class="o">-&gt;</span><span class="n">local</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">generation_end</span> <span class="o">=</span> <span class="o">++</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">generation_start</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">copy</span><span class="p">));</span>
	<span class="cm">/* Write generation_start */</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">from_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">generation_start</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">to_rid</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_rid</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">to_addr</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_addr</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfdi_status</span><span class="p">,</span>
						     <span class="n">generation_start</span><span class="p">);</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">generation_start</span><span class="p">);</span>
	<span class="cm">/* DMA the rest of the structure (excluding the generations). This</span>
<span class="cm">	 * assumes that the non-generation portion of vfdi_status is in</span>
<span class="cm">	 * one chunk starting at the version member.</span>
<span class="cm">	 */</span>
	<span class="n">data_offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfdi_status</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">from_rid</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">from_addr</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vfdi_status</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="n">data_offset</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">to_rid</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_rid</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">to_addr</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_addr</span> <span class="o">+</span> <span class="n">data_offset</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span>  <span class="n">status</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">data_offset</span><span class="p">;</span>

	<span class="cm">/* Copy the peer pages */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">epp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_page_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The VF driver will know they need to provide more</span>
<span class="cm">			 * pages because peer_addr_count is too large.</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">copy</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">from_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">copy</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">from_rid</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
		<span class="n">copy</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">from_addr</span> <span class="o">=</span> <span class="n">epp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">copy</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">to_rid</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_rid</span><span class="p">;</span>
		<span class="n">copy</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">to_addr</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_addrs</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
		<span class="n">copy</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">EFX_PAGE_SIZE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pos</span> <span class="o">==</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">copy</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">efx_sriov_memcpy</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">copy</span><span class="p">));</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Write generation_end */</span>
	<span class="n">copy</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">from_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">generation_end</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">to_rid</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_rid</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">to_addr</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_addr</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfdi_status</span><span class="p">,</span>
						       <span class="n">generation_end</span><span class="p">);</span>
	<span class="n">copy</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">generation_end</span><span class="p">);</span>
	<span class="n">efx_sriov_memcpy</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Notify the guest */</span>
	<span class="n">EFX_POPULATE_QWORD_3</span><span class="p">(</span><span class="n">event</span><span class="p">,</span>
			     <span class="n">FSF_AZ_EV_CODE</span><span class="p">,</span> <span class="n">FSE_CZ_EV_CODE_USER_EV</span><span class="p">,</span>
			     <span class="n">VFDI_EV_SEQ</span><span class="p">,</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">msg_seqno</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">),</span>
			     <span class="n">VFDI_EV_TYPE</span><span class="p">,</span> <span class="n">VFDI_EV_TYPE_STATUS</span><span class="p">);</span>
	<span class="o">++</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">msg_seqno</span><span class="p">;</span>
	<span class="n">efx_generate_event</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">EFX_VI_BASE</span> <span class="o">+</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">),</span>
			      <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_sriov_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_qword_t</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">pos</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EFX_POPULATE_QWORD_3</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span>
				     <span class="n">FRF_AZ_BUF_ADR_REGION</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">FRF_AZ_BUF_ADR_FBUF</span><span class="p">,</span>
				     <span class="n">addr</span> <span class="o">?</span> <span class="n">addr</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">FRF_AZ_BUF_OWNER_ID_FBUF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">efx_sram_writeq</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">+</span> <span class="n">FR_BZ_BUF_FULL_TBL</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">bad_vf_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">bad_buf_count</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">buf_count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">max_entry_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">max_buf_count</span> <span class="o">=</span> <span class="n">max_entry_count</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">efx_qword_t</span><span class="p">)</span> <span class="o">/</span> <span class="n">EFX_BUF_SIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">((</span><span class="n">buf_count</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">buf_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span> <span class="n">buf_count</span> <span class="o">&gt;</span> <span class="n">max_buf_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check that VI specified by per-port index belongs to a VF.</span>
<span class="cm"> * Optionally set VF index and VI index within the VF.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">map_vi_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">abs_index</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">**</span><span class="n">vf_out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">rel_index_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">vf_i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">abs_index</span> <span class="o">&lt;</span> <span class="n">EFX_VI_BASE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">vf_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">abs_index</span> <span class="o">-</span> <span class="n">EFX_VI_BASE</span><span class="p">)</span> <span class="o">/</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vf_i</span> <span class="o">&gt;=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vf_out</span><span class="p">)</span>
		<span class="o">*</span><span class="n">vf_out</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">vf_i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rel_index_out</span><span class="p">)</span>
		<span class="o">*</span><span class="n">rel_index_out</span> <span class="o">=</span> <span class="n">abs_index</span> <span class="o">%</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_vfdi_init_evq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vf_evq</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_evq</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">buf_count</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_evq</span><span class="p">.</span><span class="n">buf_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">abs_evq</span> <span class="o">=</span> <span class="n">abs_index</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">vf_evq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">buftbl</span> <span class="o">=</span> <span class="n">EFX_BUFTBL_EVQ_BASE</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">vf_evq</span><span class="p">);</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bad_vf_index</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">vf_evq</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">bad_buf_count</span><span class="p">(</span><span class="n">buf_count</span><span class="p">,</span> <span class="n">EFX_MAX_VF_EVQ_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;ERROR: Invalid INIT_EVQ from %s: evq %d bufs %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span> <span class="n">vf_evq</span><span class="p">,</span> <span class="n">buf_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">VFDI_RC_EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">efx_sriov_bufs</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">buftbl</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_evq</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">buf_count</span><span class="p">);</span>

	<span class="n">EFX_POPULATE_OWORD_3</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_CZ_TIMER_Q_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_CZ_HOST_NOTIFY_MODE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">FRF_CZ_TIMER_MODE</span><span class="p">,</span> <span class="n">FFE_CZ_TIMER_MODE_DIS</span><span class="p">);</span>
	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_TIMER_TBL</span><span class="p">,</span> <span class="n">abs_evq</span><span class="p">);</span>
	<span class="n">EFX_POPULATE_OWORD_3</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_AZ_EVQ_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AZ_EVQ_SIZE</span><span class="p">,</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">buf_count</span><span class="p">),</span>
			     <span class="n">FRF_AZ_EVQ_BUF_BASE_ID</span><span class="p">,</span> <span class="n">buftbl</span><span class="p">);</span>
	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_EVQ_PTR_TBL</span><span class="p">,</span> <span class="n">abs_evq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vf_evq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_addrs</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_evq</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
		       <span class="n">buf_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_count</span> <span class="o">=</span> <span class="n">buf_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">VFDI_RC_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_vfdi_init_rxq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vf_rxq</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_rxq</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vf_evq</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_rxq</span><span class="p">.</span><span class="n">evq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">buf_count</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_rxq</span><span class="p">.</span><span class="n">buf_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">buftbl</span> <span class="o">=</span> <span class="n">EFX_BUFTBL_RXQ_BASE</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">vf_rxq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">label</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bad_vf_index</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">vf_evq</span><span class="p">)</span> <span class="o">||</span> <span class="n">bad_vf_index</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">vf_rxq</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">bad_buf_count</span><span class="p">(</span><span class="n">buf_count</span><span class="p">,</span> <span class="n">EFX_MAX_DMAQ_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;ERROR: Invalid INIT_RXQ from %s: rxq %d evq %d &quot;</span>
				  <span class="s">&quot;buf_count %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span> <span class="n">vf_rxq</span><span class="p">,</span>
				  <span class="n">vf_evq</span><span class="p">,</span> <span class="n">buf_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">VFDI_RC_EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__test_and_set_bit</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_rxq</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_mask</span><span class="p">))</span>
		<span class="o">++</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_count</span><span class="p">;</span>
	<span class="n">efx_sriov_bufs</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">buftbl</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_rxq</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">buf_count</span><span class="p">);</span>

	<span class="n">label</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_rxq</span><span class="p">.</span><span class="n">label</span> <span class="o">&amp;</span> <span class="n">EFX_FIELD_MASK</span><span class="p">(</span><span class="n">FRF_AZ_RX_DESCQ_LABEL</span><span class="p">);</span>
	<span class="n">EFX_POPULATE_OWORD_6</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_AZ_RX_DESCQ_BUF_BASE_ID</span><span class="p">,</span> <span class="n">buftbl</span><span class="p">,</span>
			     <span class="n">FRF_AZ_RX_DESCQ_EVQ_ID</span><span class="p">,</span> <span class="n">abs_index</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">vf_evq</span><span class="p">),</span>
			     <span class="n">FRF_AZ_RX_DESCQ_LABEL</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span>
			     <span class="n">FRF_AZ_RX_DESCQ_SIZE</span><span class="p">,</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">buf_count</span><span class="p">),</span>
			     <span class="n">FRF_AZ_RX_DESCQ_JUMBO</span><span class="p">,</span>
			     <span class="o">!!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_rxq</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span>
				<span class="n">VFDI_RXQ_FLAG_SCATTER_EN</span><span class="p">),</span>
			     <span class="n">FRF_AZ_RX_DESCQ_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_RX_DESC_PTR_TBL</span><span class="p">,</span>
			 <span class="n">abs_index</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">vf_rxq</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">VFDI_RC_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_vfdi_init_txq</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vf_txq</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_txq</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vf_evq</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_txq</span><span class="p">.</span><span class="n">evq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">buf_count</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_txq</span><span class="p">.</span><span class="n">buf_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">buftbl</span> <span class="o">=</span> <span class="n">EFX_BUFTBL_TXQ_BASE</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">vf_txq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">label</span><span class="p">,</span> <span class="n">eth_filt_en</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bad_vf_index</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">vf_evq</span><span class="p">)</span> <span class="o">||</span> <span class="n">bad_vf_index</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">vf_txq</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">vf_txq</span> <span class="o">&gt;=</span> <span class="n">vf_max_tx_channels</span> <span class="o">||</span>
	    <span class="n">bad_buf_count</span><span class="p">(</span><span class="n">buf_count</span><span class="p">,</span> <span class="n">EFX_MAX_DMAQ_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;ERROR: Invalid INIT_TXQ from %s: txq %d evq %d &quot;</span>
				  <span class="s">&quot;buf_count %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span> <span class="n">vf_txq</span><span class="p">,</span>
				  <span class="n">vf_evq</span><span class="p">,</span> <span class="n">buf_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">VFDI_RC_EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__test_and_set_bit</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_txq</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_mask</span><span class="p">))</span>
		<span class="o">++</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_count</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_lock</span><span class="p">);</span>
	<span class="n">efx_sriov_bufs</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">buftbl</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_txq</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">buf_count</span><span class="p">);</span>

	<span class="n">eth_filt_en</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_mode</span> <span class="o">==</span> <span class="n">VF_TX_FILTER_ON</span><span class="p">;</span>

	<span class="n">label</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">init_txq</span><span class="p">.</span><span class="n">label</span> <span class="o">&amp;</span> <span class="n">EFX_FIELD_MASK</span><span class="p">(</span><span class="n">FRF_AZ_TX_DESCQ_LABEL</span><span class="p">);</span>
	<span class="n">EFX_POPULATE_OWORD_8</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_CZ_TX_DPT_Q_MASK_WIDTH</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vi_scale</span><span class="p">,</span> <span class="mi">1U</span><span class="p">),</span>
			     <span class="n">FRF_CZ_TX_DPT_ETH_FILT_EN</span><span class="p">,</span> <span class="n">eth_filt_en</span><span class="p">,</span>
			     <span class="n">FRF_AZ_TX_DESCQ_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AZ_TX_DESCQ_BUF_BASE_ID</span><span class="p">,</span> <span class="n">buftbl</span><span class="p">,</span>
			     <span class="n">FRF_AZ_TX_DESCQ_EVQ_ID</span><span class="p">,</span> <span class="n">abs_index</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">vf_evq</span><span class="p">),</span>
			     <span class="n">FRF_AZ_TX_DESCQ_LABEL</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span>
			     <span class="n">FRF_AZ_TX_DESCQ_SIZE</span><span class="p">,</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">buf_count</span><span class="p">),</span>
			     <span class="n">FRF_BZ_TX_NON_IP_DROP_DIS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_TX_DESC_PTR_TBL</span><span class="p">,</span>
			 <span class="n">abs_index</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">vf_txq</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">VFDI_RC_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns true when efx_vfdi_fini_all_queues should wake */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">efx_vfdi_flush_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Ensure that all updates are visible to efx_vfdi_fini_all_queues() */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_count</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_retry_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_vfdi_flush_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_mask</span><span class="p">));</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_mask</span><span class="p">));</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_retry_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_retry_mask</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_retry_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_vfdi_fini_all_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span> <span class="o">=</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">vf_offset</span> <span class="o">=</span> <span class="n">EFX_VI_BASE</span> <span class="o">+</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">*</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span> <span class="n">rxqs_count</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">rxqs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rxqs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rxqs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rxqs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VFDI_RC_ENOMEM</span><span class="p">;</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">fc_disable</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">efx_mcdi_set_mac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="cm">/* Flush all the initialized queues */</span>
	<span class="n">rxqs_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
					     <span class="n">FRF_AZ_TX_FLUSH_DESCQ_CMD</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					     <span class="n">FRF_AZ_TX_FLUSH_DESCQ</span><span class="p">,</span>
					     <span class="n">vf_offset</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AZ_TX_FLUSH_DESCQ</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_mask</span><span class="p">))</span>
			<span class="n">rxqs</span><span class="p">[</span><span class="n">rxqs_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">vf_offset</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_retry_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_count</span> <span class="o">||</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_FLUSH_RX_QUEUES</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">rxqs</span><span class="p">,</span>
				  <span class="n">rxqs_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rxqs</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">timeout</span> <span class="o">=</span> <span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">flush_waitq</span><span class="p">,</span>
					     <span class="n">efx_vfdi_flush_wake</span><span class="p">(</span><span class="n">vf</span><span class="p">),</span>
					     <span class="n">timeout</span><span class="p">);</span>
		<span class="n">rxqs_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_retry_mask</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_retry_count</span><span class="p">);</span>
				<span class="n">rxqs</span><span class="p">[</span><span class="n">rxqs_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">vf_offset</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">fc_disable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">efx_mcdi_set_mac</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="cm">/* Irrespective of success/failure, fini the queues */</span>
	<span class="n">EFX_ZERO_OWORD</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_RX_DESC_PTR_TBL</span><span class="p">,</span>
				 <span class="n">vf_offset</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_TX_DESC_PTR_TBL</span><span class="p">,</span>
				 <span class="n">vf_offset</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_EVQ_PTR_TBL</span><span class="p">,</span>
				 <span class="n">vf_offset</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_TIMER_TBL</span><span class="p">,</span>
				 <span class="n">vf_offset</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">efx_sriov_bufs</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">buftbl_base</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		       <span class="n">EFX_VF_BUFTBL_PER_VI</span> <span class="o">*</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rxqs</span><span class="p">);</span>
	<span class="n">efx_vfdi_flush_clear</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>

	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">timeout</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">VFDI_RC_ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_vfdi_insert_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vf_rxq</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mac_filter</span><span class="p">.</span><span class="n">rxq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bad_vf_index</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">vf_rxq</span><span class="p">)</span> <span class="o">||</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filtering</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;ERROR: Invalid INSERT_FILTER from %s: rxq %d &quot;</span>
				  <span class="s">&quot;flags 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span> <span class="n">vf_rxq</span><span class="p">,</span>
				  <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mac_filter</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">VFDI_RC_EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mac_filter</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VFDI_MAC_FILTER_FLAG_RSS</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">EFX_FILTER_FLAG_RX_RSS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mac_filter</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VFDI_MAC_FILTER_FLAG_SCATTER</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">EFX_FILTER_FLAG_RX_SCATTER</span><span class="p">;</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filter_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filter_qid</span> <span class="o">=</span> <span class="n">vf_rxq</span><span class="p">;</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filtering</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">efx_sriov_reset_rx_filter</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">vfdi_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">peer_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">VFDI_RC_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_vfdi_remove_all_filters</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filtering</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">efx_sriov_reset_rx_filter</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">vfdi_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">peer_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">VFDI_RC_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_vfdi_set_status_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">page_count</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">set_status_page</span><span class="p">.</span><span class="n">peer_page_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">max_page_count</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">EFX_PAGE_SIZE</span> <span class="o">-</span>
		 <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfdi_req</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">set_status_page</span><span class="p">.</span><span class="n">peer_page_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">set_status_page</span><span class="p">.</span><span class="n">peer_page_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">set_status_page</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">||</span> <span class="n">page_count</span> <span class="o">&gt;</span> <span class="n">max_page_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;ERROR: Invalid SET_STATUS_PAGE from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">VFDI_RC_EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_lock</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_addr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">set_status_page</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_addrs</span><span class="p">);</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_addrs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_addrs</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">page_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span>
					      <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_addrs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_addrs</span><span class="p">,</span>
			       <span class="n">req</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">set_status_page</span><span class="p">.</span><span class="n">peer_page_addr</span><span class="p">,</span>
			       <span class="n">page_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
			<span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_count</span> <span class="o">=</span> <span class="n">page_count</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">__efx_sriov_push_vf_status</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">VFDI_RC_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_vfdi_clear_status_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">VFDI_RC_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">efx_vfdi_op_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">efx_vfdi_op_t</span> <span class="n">vfdi_ops</span><span class="p">[</span><span class="n">VFDI_OP_LIMIT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">VFDI_OP_INIT_EVQ</span><span class="p">]</span> <span class="o">=</span> <span class="n">efx_vfdi_init_evq</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VFDI_OP_INIT_TXQ</span><span class="p">]</span> <span class="o">=</span> <span class="n">efx_vfdi_init_txq</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VFDI_OP_INIT_RXQ</span><span class="p">]</span> <span class="o">=</span> <span class="n">efx_vfdi_init_rxq</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VFDI_OP_FINI_ALL_QUEUES</span><span class="p">]</span> <span class="o">=</span> <span class="n">efx_vfdi_fini_all_queues</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VFDI_OP_INSERT_FILTER</span><span class="p">]</span> <span class="o">=</span> <span class="n">efx_vfdi_insert_filter</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VFDI_OP_REMOVE_ALL_FILTERS</span><span class="p">]</span> <span class="o">=</span> <span class="n">efx_vfdi_remove_all_filters</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VFDI_OP_SET_STATUS_PAGE</span><span class="p">]</span> <span class="o">=</span> <span class="n">efx_vfdi_set_status_page</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VFDI_OP_CLEAR_STATUS_PAGE</span><span class="p">]</span> <span class="o">=</span> <span class="n">efx_vfdi_clear_status_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_sriov_vfdi</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_vf</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_memcpy_req</span> <span class="n">copy</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Copy this page into the local address space */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">copy</span><span class="p">));</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">from_rid</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_rid</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">from_addr</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_addr</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">to_rid</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">to_addr</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">EFX_PAGE_SIZE</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_sriov_memcpy</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we can&#39;t get the request, we can&#39;t reply to the caller */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;ERROR: Unable to fetch VFDI request from %s rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span> <span class="o">-</span><span class="n">rc</span><span class="p">);</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">&lt;</span> <span class="n">VFDI_OP_LIMIT</span> <span class="o">&amp;&amp;</span> <span class="n">vfdi_ops</span><span class="p">[</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">vfdi_ops</span><span class="p">[</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">](</span><span class="n">vf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;vfdi request %d from %s ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">req</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;ERROR: Unrecognised request %d from VF %s addr &quot;</span>
			  <span class="s">&quot;%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_addr</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">VFDI_RC_EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allow subsequent VF requests */</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="cm">/* Respond to the request */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rc</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">VFDI_OP_RESPONSE</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">copy</span><span class="p">));</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">from_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">to_rid</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_rid</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">to_addr</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_addr</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfdi_req</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">);</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">from_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">to_rid</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_rid</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">to_addr</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_addr</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfdi_req</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
	<span class="n">copy</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">efx_sriov_memcpy</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">copy</span><span class="p">));</span>
<span class="p">}</span>



<span class="cm">/* After a reset the event queues inside the guests no longer exist. Fill the</span>
<span class="cm"> * event ring in guest memory with VFDI reset events, then (re-initialise) the</span>
<span class="cm"> * event queue to raise an interrupt. The guest driver will then recover.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_sriov_reset_vf</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_memcpy_req</span> <span class="n">copy_req</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">efx_qword_t</span> <span class="n">event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">buftbl</span><span class="p">,</span> <span class="n">abs_evq</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">efx_dword_t</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">EFX_PAGE_SIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_count</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
	<span class="n">EFX_POPULATE_QWORD_3</span><span class="p">(</span><span class="n">event</span><span class="p">,</span>
			     <span class="n">FSF_AZ_EV_CODE</span><span class="p">,</span> <span class="n">FSE_CZ_EV_CODE_USER_EV</span><span class="p">,</span>
			     <span class="n">VFDI_EV_SEQ</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">msg_seqno</span><span class="p">,</span>
			     <span class="n">VFDI_EV_TYPE</span><span class="p">,</span> <span class="n">VFDI_EV_TYPE_RESET</span><span class="p">);</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">msg_seqno</span><span class="o">++</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">EFX_PAGE_SIZE</span><span class="p">;</span> <span class="n">pos</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_count</span><span class="p">;</span> <span class="n">pos</span> <span class="o">+=</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_count</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span>
			      <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">copy_req</span><span class="p">));</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">copy_req</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">from_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">copy_req</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">from_rid</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
			<span class="n">copy_req</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">from_addr</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">;</span>
			<span class="n">copy_req</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">to_rid</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_rid</span><span class="p">;</span>
			<span class="n">copy_req</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">to_addr</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_addrs</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
			<span class="n">copy_req</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">EFX_PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_sriov_memcpy</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">copy_req</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
				<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
					  <span class="s">&quot;ERROR: Unable to notify %s of reset&quot;</span>
					  <span class="s">&quot;: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span> <span class="o">-</span><span class="n">rc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Reinitialise, arm and trigger evq0 */</span>
	<span class="n">abs_evq</span> <span class="o">=</span> <span class="n">abs_index</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">buftbl</span> <span class="o">=</span> <span class="n">EFX_BUFTBL_EVQ_BASE</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">efx_sriov_bufs</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">buftbl</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_addrs</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_count</span><span class="p">);</span>

	<span class="n">EFX_POPULATE_OWORD_3</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_CZ_TIMER_Q_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_CZ_HOST_NOTIFY_MODE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">FRF_CZ_TIMER_MODE</span><span class="p">,</span> <span class="n">FFE_CZ_TIMER_MODE_DIS</span><span class="p">);</span>
	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_TIMER_TBL</span><span class="p">,</span> <span class="n">abs_evq</span><span class="p">);</span>
	<span class="n">EFX_POPULATE_OWORD_3</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span>
			     <span class="n">FRF_AZ_EVQ_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_AZ_EVQ_SIZE</span><span class="p">,</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_count</span><span class="p">),</span>
			     <span class="n">FRF_AZ_EVQ_BUF_BASE_ID</span><span class="p">,</span> <span class="n">buftbl</span><span class="p">);</span>
	<span class="n">efx_writeo_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_BZ_EVQ_PTR_TBL</span><span class="p">,</span> <span class="n">abs_evq</span><span class="p">);</span>
	<span class="n">EFX_POPULATE_DWORD_1</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">FRF_AZ_EVQ_RPTR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">efx_writed_table</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">FR_BZ_EVQ_RPTR</span><span class="p">,</span> <span class="n">abs_evq</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_sriov_reset_vf_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_vf</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_buffer</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx_nic_alloc_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">EFX_PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">efx_sriov_reset_vf</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">efx_nic_free_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_sriov_handle_no_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;ERROR: IOV requires MSI-X and 1 additional interrupt&quot;</span>
		  <span class="s">&quot;vector. IOV disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_sriov_probe_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vfdi_channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">efx_sriov_get_channel_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%s-iov&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_channel_type</span> <span class="n">efx_sriov_channel_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handle_no_channel</span>	<span class="o">=</span> <span class="n">efx_sriov_handle_no_channel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_probe</span>		<span class="o">=</span> <span class="n">efx_sriov_probe_channel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_name</span>		<span class="o">=</span> <span class="n">efx_sriov_get_channel_name</span><span class="p">,</span>
	<span class="cm">/* no copy operation; channel must not be reallocated */</span>
	<span class="p">.</span><span class="n">keep_eventq</span>		<span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">efx_sriov_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_vfs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_sriov_cmd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vi_scale</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">max_vfs</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">max_vfs</span><span class="p">;</span>

	<span class="cm">/* efx_nic_dimension_resources() will reduce vf_count as appopriate */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">extra_channel_type</span><span class="p">[</span><span class="n">EFX_EXTRA_CHANNEL_IOV</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx_sriov_channel_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Copy the list of individual addresses into the vfdi_status.peers</span>
<span class="cm"> * array and auxillary pages, protected by %local_lock. Drop that lock</span>
<span class="cm"> * and then broadcast the address list to every VF.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_sriov_peer_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_nic</span><span class="p">,</span> <span class="n">peer_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vfdi_status</span> <span class="o">*</span><span class="n">vfdi_status</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vfdi_status</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_local_addr</span> <span class="o">*</span><span class="n">local_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_endpoint</span> <span class="o">*</span><span class="n">peer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_endpoint_page</span> <span class="o">*</span><span class="n">epp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">peer_space</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">peer_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_lock</span><span class="p">);</span>

	<span class="cm">/* Move the existing peer pages off %local_page_list */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_page_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>

	<span class="cm">/* Populate the VF addresses starting from entry 1 (entry 0 is</span>
<span class="cm">	 * the PF address)</span>
<span class="cm">	 */</span>
	<span class="n">peer</span> <span class="o">=</span> <span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">peers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">peer_space</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">peer_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filtering</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">mac_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">peer</span><span class="o">++</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
			<span class="o">++</span><span class="n">peer_count</span><span class="p">;</span>
			<span class="o">--</span><span class="n">peer_space</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">peer_space</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Fill the remaining addresses */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">local_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_addr_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">local_addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">peer</span><span class="o">-&gt;</span><span class="n">tci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">++</span><span class="n">peer</span><span class="p">;</span>
		<span class="o">++</span><span class="n">peer_count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">peer_space</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pages</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">epp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">epp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epp</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">epp</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span>
					<span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">EFX_PAGE_SIZE</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">epp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epp</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">epp</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">epp</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span>
					<span class="o">&amp;</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_endpoint_page</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_page_list</span><span class="p">);</span>
			<span class="n">peer</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vfdi_endpoint</span> <span class="o">*</span><span class="p">)</span><span class="n">epp</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
			<span class="n">peer_space</span> <span class="o">=</span> <span class="n">EFX_PAGE_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfdi_endpoint</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">peer_count</span> <span class="o">=</span> <span class="n">peer_count</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_lock</span><span class="p">);</span>

	<span class="cm">/* Free any now unused endpoint pages */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">epp</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span>
			<span class="o">&amp;</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_endpoint_page</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">EFX_PAGE_SIZE</span><span class="p">,</span>
				  <span class="n">epp</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">epp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">epp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Finally, push the pages */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_addr</span><span class="p">)</span>
			<span class="n">__efx_sriov_push_vf_status</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_sriov_free_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_local_addr</span> <span class="o">*</span><span class="n">local_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_endpoint_page</span> <span class="o">*</span><span class="n">epp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_addr_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_addr</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_addr_list</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">efx_local_addr</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local_addr</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">local_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_page_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">epp</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_page_list</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">efx_endpoint_page</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">EFX_PAGE_SIZE</span><span class="p">,</span>
				  <span class="n">epp</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">epp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">epp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_sriov_vf_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_vf</span><span class="p">)</span> <span class="o">*</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>

		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">efx</span> <span class="o">=</span> <span class="n">efx</span><span class="p">;</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">rx_filter_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_mode</span> <span class="o">=</span> <span class="n">VF_TX_FILTER_AUTO</span><span class="p">;</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">efx_sriov_vfdi</span><span class="p">);</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">reset_work</span><span class="p">,</span> <span class="n">efx_sriov_reset_vf_work</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">flush_waitq</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_sriov_vfs_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">;</span>

		<span class="n">efx_nic_free_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_addrs</span><span class="p">);</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_addrs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">peer_page_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_sriov_vfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">sriov</span><span class="p">,</span> <span class="n">buftbl_base</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">stride</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">sriov</span> <span class="o">=</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_EXT_CAP_ID_SRIOV</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sriov</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">sriov</span> <span class="o">+</span> <span class="n">PCI_SRIOV_VF_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">sriov</span> <span class="o">+</span> <span class="n">PCI_SRIOV_VF_STRIDE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stride</span><span class="p">);</span>

	<span class="n">buftbl_base</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_buftbl_base</span><span class="p">;</span>
	<span class="n">devfn</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>

		<span class="cm">/* Reserve buffer entries */</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">buftbl_base</span> <span class="o">=</span> <span class="n">buftbl_base</span><span class="p">;</span>
		<span class="n">buftbl_base</span> <span class="o">+=</span> <span class="n">EFX_VF_BUFTBL_PER_VI</span> <span class="o">*</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_rid</span> <span class="o">=</span> <span class="n">devfn</span><span class="p">;</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">),</span>
			 <span class="s">&quot;%04x:%02x:%02x.%d&quot;</span><span class="p">,</span>
			 <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
			 <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">devfn</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">devfn</span><span class="p">));</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_nic_alloc_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">EFX_PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">devfn</span> <span class="o">+=</span> <span class="n">stride</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">efx_sriov_vfs_fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_sriov_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfdi_status</span> <span class="o">*</span><span class="n">vfdi_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Ensure there&#39;s room for vf_channel */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_MAX_CHANNELS</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">EFX_VI_BASE</span><span class="p">);</span>
	<span class="cm">/* Ensure that VI_BASE is aligned on VI_SCALE */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_VI_BASE</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">EFX_VI_SCALE_MAX</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_sriov_cmd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_cmd</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_nic_alloc_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vfdi_status</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vfdi_status</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_status</span><span class="p">;</span>
	<span class="n">vfdi_status</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vfdi_status</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vfdi_status</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vfdi_status</span><span class="p">));</span>
	<span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vfdi_status</span><span class="p">);</span>
	<span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">max_tx_channels</span> <span class="o">=</span> <span class="n">vf_max_tx_channels</span><span class="p">;</span>
	<span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">vi_scale</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vi_scale</span><span class="p">;</span>
	<span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">rss_rxq_count</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">rss_spread</span><span class="p">;</span>
	<span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">peer_count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">;</span>
	<span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">timer_quantum_ns</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">timer_quantum_ns</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_sriov_vf_alloc</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_alloc</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_lock</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">peer_work</span><span class="p">,</span> <span class="n">efx_sriov_peer_work</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_addr_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">local_page_list</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_sriov_vfs_init</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_vfs</span><span class="p">;</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mac_addr</span><span class="p">,</span>
	       <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">;</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="n">efx_sriov_usrev</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* At this point we must be ready to accept VFDI requests */</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_sriov</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_pci</span><span class="p">;</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;enabled SR-IOV for %d VFs, %d VI per VF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">,</span> <span class="n">efx_vf_size</span><span class="p">(</span><span class="n">efx</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_pci:</span>
	<span class="n">efx_sriov_usrev</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="n">efx_sriov_vfs_fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="nl">fail_vfs:</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">peer_work</span><span class="p">);</span>
	<span class="n">efx_sriov_free_local</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span><span class="p">);</span>
<span class="nl">fail_alloc:</span>
	<span class="n">efx_nic_free_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vfdi_status</span><span class="p">);</span>
<span class="nl">fail_status:</span>
	<span class="n">efx_sriov_cmd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">fail_cmd:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_sriov_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Disable all interfaces to reconfiguration */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vfdi_channel</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">);</span>
	<span class="n">efx_sriov_usrev</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="cm">/* Flush all reconfiguration work */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_count</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">;</span>
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">reset_work</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">peer_work</span><span class="p">);</span>

	<span class="n">pci_disable_sriov</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="cm">/* Tear down back-end state */</span>
	<span class="n">efx_sriov_vfs_fini</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_sriov_free_local</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span><span class="p">);</span>
	<span class="n">efx_nic_free_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vfdi_status</span><span class="p">);</span>
	<span class="n">efx_sriov_cmd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_sriov_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">qid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">qid</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_CZ_USER_QID</span><span class="p">);</span>

	<span class="cm">/* USR_EV_REG_VALUE is dword0, so access the VFDI_EV fields directly */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FSF_CZ_USER_EV_REG_VALUE_LBN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">VFDI_EV_SEQ</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">VFDI_EV_TYPE</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">VFDI_EV_DATA</span><span class="p">);</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;USR_EV event from qid %d seq 0x%x type %d data 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">qid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_vi_index</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">qid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">VFDI_EV_TYPE_REQ_WORD0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Resynchronise */</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_type</span> <span class="o">=</span> <span class="n">VFDI_EV_TYPE_REQ_WORD0</span><span class="p">;</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_seqno</span> <span class="o">=</span> <span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">!=</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_seqno</span><span class="o">++</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">||</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_type</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VFDI_EV_TYPE_REQ_WORD0</span>:
	<span class="k">case</span> <span class="n">VFDI_EV_TYPE_REQ_WORD1</span>:
	<span class="k">case</span> <span class="n">VFDI_EV_TYPE_REQ_WORD2</span>:
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_addr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_type</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="o">++</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_type</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">VFDI_EV_TYPE_REQ_WORD3</span>:
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_addr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span><span class="p">;</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_type</span> <span class="o">=</span> <span class="n">VFDI_EV_TYPE_REQ_WORD0</span><span class="p">;</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">vfdi_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;ERROR: Screaming VFDI request from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">);</span>
	<span class="cm">/* Reset the request and sequence number */</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_type</span> <span class="o">=</span> <span class="n">VFDI_EV_TYPE_REQ_WORD0</span><span class="p">;</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">req_seqno</span> <span class="o">=</span> <span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_sriov_flr</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">vf_i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vf_i</span> <span class="o">&gt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">vf_i</span><span class="p">;</span>
	<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;FLR on VF %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">pci_name</span><span class="p">);</span>

	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">efx_vfdi_remove_all_filters</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
	<span class="n">efx_vfdi_flush_clear</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>

	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">evq0_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_sriov_mac_address_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfdi_status</span> <span class="o">*</span><span class="n">vfdi_status</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vfdi_status</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">vfdi_status</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mac_addr</span><span class="p">,</span>
	       <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">vfdi_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">peer_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_sriov_tx_flush_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">queue</span><span class="p">,</span> <span class="n">qid</span><span class="p">;</span>

	<span class="n">queue</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span>  <span class="n">FSF_AZ_DRIVER_EV_SUBDATA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map_vi_index</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qid</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* Ignore flush completions triggered by an FLR */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_mask</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_mask</span><span class="p">);</span>
	<span class="o">--</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_vfdi_flush_wake</span><span class="p">(</span><span class="n">vf</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">flush_waitq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_sriov_rx_flush_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ev_failed</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">qid</span><span class="p">;</span>

	<span class="n">queue</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FSF_AZ_DRIVER_EV_RX_DESCQ_ID</span><span class="p">);</span>
	<span class="n">ev_failed</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span>
				    <span class="n">FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map_vi_index</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qid</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_mask</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ev_failed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_retry_mask</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_retry_count</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_mask</span><span class="p">);</span>
		<span class="o">--</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">rxq_count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_vfdi_flush_wake</span><span class="p">(</span><span class="n">vf</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">flush_waitq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called from napi. Schedule the reset work item */</span>
<span class="kt">void</span> <span class="nf">efx_sriov_desc_fetch_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">dmaq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rel</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_vi_index</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">dmaq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rel</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;VF %d DMA Q %d reports descriptor fetch error.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">vf</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">rel</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">vfdi_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">reset_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Reset all VFs */</span>
<span class="kt">void</span> <span class="nf">efx_sriov_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vf_i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_buffer</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">efx_sriov_usrev</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">efx_sriov_cmd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_alloc_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">EFX_PAGE_SIZE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vf_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vf_i</span> <span class="o">&lt;</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span><span class="p">;</span> <span class="o">++</span><span class="n">vf_i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">vf_i</span><span class="p">;</span>
		<span class="n">efx_sriov_reset_vf</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx_nic_free_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_init_sriov</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* A single threaded workqueue is sufficient. efx_sriov_vfdi() and</span>
<span class="cm">	 * efx_sriov_peer_work() spend almost all their time sleeping for</span>
<span class="cm">	 * MCDI to complete anyway</span>
<span class="cm">	 */</span>
	<span class="n">vfdi_workqueue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;sfc_vfdi&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vfdi_workqueue</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_fini_sriov</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">vfdi_workqueue</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_sriov_set_vf_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf_i</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vf_i</span> <span class="o">&gt;=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">vf_i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">mac</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">__efx_sriov_update_vf_addr</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_sriov_set_vf_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf_i</span><span class="p">,</span>
			  <span class="n">u16</span> <span class="n">vlan</span><span class="p">,</span> <span class="n">u8</span> <span class="n">qos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tci</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vf_i</span> <span class="o">&gt;=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">vf_i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>
	<span class="n">tci</span> <span class="o">=</span> <span class="p">(</span><span class="n">vlan</span> <span class="o">&amp;</span> <span class="n">VLAN_VID_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">qos</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">VLAN_PRIO_SHIFT</span><span class="p">);</span>
	<span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">tci</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">tci</span><span class="p">);</span>
	<span class="n">__efx_sriov_update_vf_addr</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">status_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_sriov_set_vf_spoofchk</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf_i</span><span class="p">,</span>
			      <span class="n">bool</span> <span class="n">spoofchk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vf_i</span> <span class="o">&gt;=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">vf_i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_mode</span> <span class="o">=</span>
			<span class="n">spoofchk</span> <span class="o">?</span> <span class="n">VF_TX_FILTER_ON</span> <span class="o">:</span> <span class="n">VF_TX_FILTER_OFF</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* This cannot be changed while TX queues are running */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">txq_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_sriov_get_vf_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf_i</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ifla_vf_info</span> <span class="o">*</span><span class="n">ivi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_vf</span> <span class="o">*</span><span class="n">vf</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tci</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vf_i</span> <span class="o">&gt;=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf_init_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">vf</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">+</span> <span class="n">vf_i</span><span class="p">;</span>

	<span class="n">ivi</span><span class="o">-&gt;</span><span class="n">vf</span> <span class="o">=</span> <span class="n">vf_i</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ivi</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">,</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">ivi</span><span class="o">-&gt;</span><span class="n">tx_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tci</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">vf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">tci</span><span class="p">);</span>
	<span class="n">ivi</span><span class="o">-&gt;</span><span class="n">vlan</span> <span class="o">=</span> <span class="n">tci</span> <span class="o">&amp;</span> <span class="n">VLAN_VID_MASK</span><span class="p">;</span>
	<span class="n">ivi</span><span class="o">-&gt;</span><span class="n">qos</span> <span class="o">=</span> <span class="p">(</span><span class="n">tci</span> <span class="o">&gt;&gt;</span> <span class="n">VLAN_PRIO_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="n">ivi</span><span class="o">-&gt;</span><span class="n">spoofchk</span> <span class="o">=</span> <span class="n">vf</span><span class="o">-&gt;</span><span class="n">tx_filter_mode</span> <span class="o">==</span> <span class="n">VF_TX_FILTER_ON</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
