<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › spi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>spi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2005 Fen Systems Ltd.</span>
<span class="cm"> * Copyright 2006-2010 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef EFX_SPI_H</span>
<span class="cp">#define EFX_SPI_H</span>

<span class="cp">#include &quot;net_driver.h&quot;</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Basic SPI command set and bit definitions</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************/</span>

<span class="cp">#define SPI_WRSR 0x01		</span><span class="cm">/* Write status register */</span><span class="cp"></span>
<span class="cp">#define SPI_WRITE 0x02		</span><span class="cm">/* Write data to memory array */</span><span class="cp"></span>
<span class="cp">#define SPI_READ 0x03		</span><span class="cm">/* Read data from memory array */</span><span class="cp"></span>
<span class="cp">#define SPI_WRDI 0x04		</span><span class="cm">/* Reset write enable latch */</span><span class="cp"></span>
<span class="cp">#define SPI_RDSR 0x05		</span><span class="cm">/* Read status register */</span><span class="cp"></span>
<span class="cp">#define SPI_WREN 0x06		</span><span class="cm">/* Set write enable latch */</span><span class="cp"></span>
<span class="cp">#define SPI_SST_EWSR 0x50	</span><span class="cm">/* SST: Enable write to status register */</span><span class="cp"></span>

<span class="cp">#define SPI_STATUS_WPEN 0x80	</span><span class="cm">/* Write-protect pin enabled */</span><span class="cp"></span>
<span class="cp">#define SPI_STATUS_BP2 0x10	</span><span class="cm">/* Block protection bit 2 */</span><span class="cp"></span>
<span class="cp">#define SPI_STATUS_BP1 0x08	</span><span class="cm">/* Block protection bit 1 */</span><span class="cp"></span>
<span class="cp">#define SPI_STATUS_BP0 0x04	</span><span class="cm">/* Block protection bit 0 */</span><span class="cp"></span>
<span class="cp">#define SPI_STATUS_WEN 0x02	</span><span class="cm">/* State of the write enable latch */</span><span class="cp"></span>
<span class="cp">#define SPI_STATUS_NRDY 0x01	</span><span class="cm">/* Device busy flag */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct efx_spi_device - an Efx SPI (Serial Peripheral Interface) device</span>
<span class="cm"> * @device_id:		Controller&#39;s id for the device</span>
<span class="cm"> * @size:		Size (in bytes)</span>
<span class="cm"> * @addr_len:		Number of address bytes in read/write commands</span>
<span class="cm"> * @munge_address:	Flag whether addresses should be munged.</span>
<span class="cm"> *	Some devices with 9-bit addresses (e.g. AT25040A EEPROM)</span>
<span class="cm"> *	use bit 3 of the command byte as address bit A8, rather</span>
<span class="cm"> *	than having a two-byte address.  If this flag is set, then</span>
<span class="cm"> *	commands should be munged in this way.</span>
<span class="cm"> * @erase_command:	Erase command (or 0 if sector erase not needed).</span>
<span class="cm"> * @erase_size:		Erase sector size (in bytes)</span>
<span class="cm"> *	Erase commands affect sectors with this size and alignment.</span>
<span class="cm"> *	This must be a power of two.</span>
<span class="cm"> * @block_size:		Write block size (in bytes).</span>
<span class="cm"> *	Write commands are limited to blocks with this size and alignment.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">device_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">munge_address</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">erase_command</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">erase_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">efx_spi_present</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">falcon_spi_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
		   <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">address</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">falcon_spi_wait_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">falcon_spi_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
		    <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span>
		    <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">falcon_spi_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SFC4000 flash is partitioned into:</span>
<span class="cm"> *     0-0x400       chip and board config (see falcon_hwdefs.h)</span>
<span class="cm"> *     0x400-0x8000  unused (or may contain VPD if EEPROM not present)</span>
<span class="cm"> *     0x8000-end    boot code (mapped to PCI expansion ROM)</span>
<span class="cm"> * SFC4000 small EEPROM (size &lt; 0x400) is used for VPD only.</span>
<span class="cm"> * SFC4000 large EEPROM (size &gt;= 0x400) is partitioned into:</span>
<span class="cm"> *     0-0x400       chip and board config</span>
<span class="cm"> *     configurable  VPD</span>
<span class="cm"> *     0x800-0x1800  boot config</span>
<span class="cm"> * Aside from the chip and board config, all of these are optional and may</span>
<span class="cm"> * be absent or truncated depending on the devices used.</span>
<span class="cm"> */</span>
<span class="cp">#define FALCON_NVCONFIG_END 0x400U</span>
<span class="cp">#define FALCON_FLASH_BOOTCODE_START 0x8000U</span>
<span class="cp">#define EFX_EEPROM_BOOTCONFIG_START 0x800U</span>
<span class="cp">#define EFX_EEPROM_BOOTCONFIG_END 0x1800U</span>

<span class="cp">#endif </span><span class="cm">/* EFX_SPI_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
