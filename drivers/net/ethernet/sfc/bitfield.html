<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › bitfield.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>bitfield.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2005-2006 Fen Systems Ltd.</span>
<span class="cm"> * Copyright 2006-2009 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef EFX_BITFIELD_H</span>
<span class="cp">#define EFX_BITFIELD_H</span>

<span class="cm">/*</span>
<span class="cm"> * Efx bitfield access</span>
<span class="cm"> *</span>
<span class="cm"> * Efx NICs make extensive use of bitfields up to 128 bits</span>
<span class="cm"> * wide.  Since there is no native 128-bit datatype on most systems,</span>
<span class="cm"> * and since 64-bit datatypes are inefficient on 32-bit systems and</span>
<span class="cm"> * vice versa, we wrap accesses in a way that uses the most efficient</span>
<span class="cm"> * datatype.</span>
<span class="cm"> *</span>
<span class="cm"> * The NICs are PCI devices and therefore little-endian.  Since most</span>
<span class="cm"> * of the quantities that we deal with are DMAed to/from host memory,</span>
<span class="cm"> * we define our datatypes (efx_oword_t, efx_qword_t and</span>
<span class="cm"> * efx_dword_t) to be little-endian.</span>
<span class="cm"> */</span>

<span class="cm">/* Lowest bit numbers and widths */</span>
<span class="cp">#define EFX_DUMMY_FIELD_LBN 0</span>
<span class="cp">#define EFX_DUMMY_FIELD_WIDTH 0</span>
<span class="cp">#define EFX_DWORD_0_LBN 0</span>
<span class="cp">#define EFX_DWORD_0_WIDTH 32</span>
<span class="cp">#define EFX_DWORD_1_LBN 32</span>
<span class="cp">#define EFX_DWORD_1_WIDTH 32</span>
<span class="cp">#define EFX_DWORD_2_LBN 64</span>
<span class="cp">#define EFX_DWORD_2_WIDTH 32</span>
<span class="cp">#define EFX_DWORD_3_LBN 96</span>
<span class="cp">#define EFX_DWORD_3_WIDTH 32</span>
<span class="cp">#define EFX_QWORD_0_LBN 0</span>
<span class="cp">#define EFX_QWORD_0_WIDTH 64</span>

<span class="cm">/* Specified attribute (e.g. LBN) of the specified field */</span>
<span class="cp">#define EFX_VAL(field, attribute) field ## _ ## attribute</span>
<span class="cm">/* Low bit number of the specified field */</span>
<span class="cp">#define EFX_LOW_BIT(field) EFX_VAL(field, LBN)</span>
<span class="cm">/* Bit width of the specified field */</span>
<span class="cp">#define EFX_WIDTH(field) EFX_VAL(field, WIDTH)</span>
<span class="cm">/* High bit number of the specified field */</span>
<span class="cp">#define EFX_HIGH_BIT(field) (EFX_LOW_BIT(field) + EFX_WIDTH(field) - 1)</span>
<span class="cm">/* Mask equal in width to the specified field.</span>
<span class="cm"> *</span>
<span class="cm"> * For example, a field with width 5 would have a mask of 0x1f.</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum width mask that can be generated is 64 bits.</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_MASK64(width)			\</span>
<span class="cp">	((width) == 64 ? ~((u64) 0) :		\</span>
<span class="cp">	 (((((u64) 1) &lt;&lt; (width))) - 1))</span>

<span class="cm">/* Mask equal in width to the specified field.</span>
<span class="cm"> *</span>
<span class="cm"> * For example, a field with width 5 would have a mask of 0x1f.</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum width mask that can be generated is 32 bits.  Use</span>
<span class="cm"> * EFX_MASK64 for higher width fields.</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_MASK32(width)			\</span>
<span class="cp">	((width) == 32 ? ~((u32) 0) :		\</span>
<span class="cp">	 (((((u32) 1) &lt;&lt; (width))) - 1))</span>

<span class="cm">/* A doubleword (i.e. 4 byte) datatype - little-endian in HW */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">efx_dword</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">u32</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">efx_dword_t</span><span class="p">;</span>

<span class="cm">/* A quadword (i.e. 8 byte) datatype - little-endian in HW */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">efx_qword</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">u64</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">u32</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">efx_dword_t</span> <span class="n">dword</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="n">efx_qword_t</span><span class="p">;</span>

<span class="cm">/* An octword (eight-word, i.e. 16 byte) datatype - little-endian in HW */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">efx_oword</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">u64</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">efx_qword_t</span> <span class="n">qword</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">u32</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">efx_dword_t</span> <span class="n">dword</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">efx_oword_t</span><span class="p">;</span>

<span class="cm">/* Format string and value expanders for printk */</span>
<span class="cp">#define EFX_DWORD_FMT &quot;%08x&quot;</span>
<span class="cp">#define EFX_QWORD_FMT &quot;%08x:%08x&quot;</span>
<span class="cp">#define EFX_OWORD_FMT &quot;%08x:%08x:%08x:%08x&quot;</span>
<span class="cp">#define EFX_DWORD_VAL(dword)				\</span>
<span class="cp">	((unsigned int) le32_to_cpu((dword).u32[0]))</span>
<span class="cp">#define EFX_QWORD_VAL(qword)				\</span>
<span class="cp">	((unsigned int) le32_to_cpu((qword).u32[1])),	\</span>
<span class="cp">	((unsigned int) le32_to_cpu((qword).u32[0]))</span>
<span class="cp">#define EFX_OWORD_VAL(oword)				\</span>
<span class="cp">	((unsigned int) le32_to_cpu((oword).u32[3])),	\</span>
<span class="cp">	((unsigned int) le32_to_cpu((oword).u32[2])),	\</span>
<span class="cp">	((unsigned int) le32_to_cpu((oword).u32[1])),	\</span>
<span class="cp">	((unsigned int) le32_to_cpu((oword).u32[0]))</span>

<span class="cm">/*</span>
<span class="cm"> * Extract bit field portion [low,high) from the native-endian element</span>
<span class="cm"> * which contains bits [min,max).</span>
<span class="cm"> *</span>
<span class="cm"> * For example, suppose &quot;element&quot; represents the high 32 bits of a</span>
<span class="cm"> * 64-bit value, and we wish to extract the bits belonging to the bit</span>
<span class="cm"> * field occupying bits 28-45 of this 64-bit value.</span>
<span class="cm"> *</span>
<span class="cm"> * Then EFX_EXTRACT ( element, 32, 63, 28, 45 ) would give</span>
<span class="cm"> *</span>
<span class="cm"> *   ( element ) &lt;&lt; 4</span>
<span class="cm"> *</span>
<span class="cm"> * The result will contain the relevant bits filled in in the range</span>
<span class="cm"> * [0,high-low), with garbage in bits [high-low+1,...).</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_EXTRACT_NATIVE(native_element, min, max, low, high)		\</span>
<span class="cp">	(((low &gt; max) || (high &lt; min)) ? 0 :				\</span>
<span class="cp">	 ((low &gt; min) ?							\</span>
<span class="cp">	  ((native_element) &gt;&gt; (low - min)) :				\</span>
<span class="cp">	  ((native_element) &lt;&lt; (min - low))))</span>

<span class="cm">/*</span>
<span class="cm"> * Extract bit field portion [low,high) from the 64-bit little-endian</span>
<span class="cm"> * element which contains bits [min,max)</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_EXTRACT64(element, min, max, low, high)			\</span>
<span class="cp">	EFX_EXTRACT_NATIVE(le64_to_cpu(element), min, max, low, high)</span>

<span class="cm">/*</span>
<span class="cm"> * Extract bit field portion [low,high) from the 32-bit little-endian</span>
<span class="cm"> * element which contains bits [min,max)</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_EXTRACT32(element, min, max, low, high)			\</span>
<span class="cp">	EFX_EXTRACT_NATIVE(le32_to_cpu(element), min, max, low, high)</span>

<span class="cp">#define EFX_EXTRACT_OWORD64(oword, low, high)				\</span>
<span class="cp">	((EFX_EXTRACT64((oword).u64[0], 0, 63, low, high) |		\</span>
<span class="cp">	  EFX_EXTRACT64((oword).u64[1], 64, 127, low, high)) &amp;		\</span>
<span class="cp">	 EFX_MASK64(high + 1 - low))</span>

<span class="cp">#define EFX_EXTRACT_QWORD64(qword, low, high)				\</span>
<span class="cp">	(EFX_EXTRACT64((qword).u64[0], 0, 63, low, high) &amp;		\</span>
<span class="cp">	 EFX_MASK64(high + 1 - low))</span>

<span class="cp">#define EFX_EXTRACT_OWORD32(oword, low, high)				\</span>
<span class="cp">	((EFX_EXTRACT32((oword).u32[0], 0, 31, low, high) |		\</span>
<span class="cp">	  EFX_EXTRACT32((oword).u32[1], 32, 63, low, high) |		\</span>
<span class="cp">	  EFX_EXTRACT32((oword).u32[2], 64, 95, low, high) |		\</span>
<span class="cp">	  EFX_EXTRACT32((oword).u32[3], 96, 127, low, high)) &amp;		\</span>
<span class="cp">	 EFX_MASK32(high + 1 - low))</span>

<span class="cp">#define EFX_EXTRACT_QWORD32(qword, low, high)				\</span>
<span class="cp">	((EFX_EXTRACT32((qword).u32[0], 0, 31, low, high) |		\</span>
<span class="cp">	  EFX_EXTRACT32((qword).u32[1], 32, 63, low, high)) &amp;		\</span>
<span class="cp">	 EFX_MASK32(high + 1 - low))</span>

<span class="cp">#define EFX_EXTRACT_DWORD(dword, low, high)			\</span>
<span class="cp">	(EFX_EXTRACT32((dword).u32[0], 0, 31, low, high) &amp;	\</span>
<span class="cp">	 EFX_MASK32(high + 1 - low))</span>

<span class="cp">#define EFX_OWORD_FIELD64(oword, field)				\</span>
<span class="cp">	EFX_EXTRACT_OWORD64(oword, EFX_LOW_BIT(field),		\</span>
<span class="cp">			    EFX_HIGH_BIT(field))</span>

<span class="cp">#define EFX_QWORD_FIELD64(qword, field)				\</span>
<span class="cp">	EFX_EXTRACT_QWORD64(qword, EFX_LOW_BIT(field),		\</span>
<span class="cp">			    EFX_HIGH_BIT(field))</span>

<span class="cp">#define EFX_OWORD_FIELD32(oword, field)				\</span>
<span class="cp">	EFX_EXTRACT_OWORD32(oword, EFX_LOW_BIT(field),		\</span>
<span class="cp">			    EFX_HIGH_BIT(field))</span>

<span class="cp">#define EFX_QWORD_FIELD32(qword, field)				\</span>
<span class="cp">	EFX_EXTRACT_QWORD32(qword, EFX_LOW_BIT(field),		\</span>
<span class="cp">			    EFX_HIGH_BIT(field))</span>

<span class="cp">#define EFX_DWORD_FIELD(dword, field)				\</span>
<span class="cp">	EFX_EXTRACT_DWORD(dword, EFX_LOW_BIT(field),		\</span>
<span class="cp">			  EFX_HIGH_BIT(field))</span>

<span class="cp">#define EFX_OWORD_IS_ZERO64(oword)					\</span>
<span class="cp">	(((oword).u64[0] | (oword).u64[1]) == (__force __le64) 0)</span>

<span class="cp">#define EFX_QWORD_IS_ZERO64(qword)					\</span>
<span class="cp">	(((qword).u64[0]) == (__force __le64) 0)</span>

<span class="cp">#define EFX_OWORD_IS_ZERO32(oword)					     \</span>
<span class="cp">	(((oword).u32[0] | (oword).u32[1] | (oword).u32[2] | (oword).u32[3]) \</span>
<span class="cp">	 == (__force __le32) 0)</span>

<span class="cp">#define EFX_QWORD_IS_ZERO32(qword)					\</span>
<span class="cp">	(((qword).u32[0] | (qword).u32[1]) == (__force __le32) 0)</span>

<span class="cp">#define EFX_DWORD_IS_ZERO(dword)					\</span>
<span class="cp">	(((dword).u32[0]) == (__force __le32) 0)</span>

<span class="cp">#define EFX_OWORD_IS_ALL_ONES64(oword)					\</span>
<span class="cp">	(((oword).u64[0] &amp; (oword).u64[1]) == ~((__force __le64) 0))</span>

<span class="cp">#define EFX_QWORD_IS_ALL_ONES64(qword)					\</span>
<span class="cp">	((qword).u64[0] == ~((__force __le64) 0))</span>

<span class="cp">#define EFX_OWORD_IS_ALL_ONES32(oword)					\</span>
<span class="cp">	(((oword).u32[0] &amp; (oword).u32[1] &amp; (oword).u32[2] &amp; (oword).u32[3]) \</span>
<span class="cp">	 == ~((__force __le32) 0))</span>

<span class="cp">#define EFX_QWORD_IS_ALL_ONES32(qword)					\</span>
<span class="cp">	(((qword).u32[0] &amp; (qword).u32[1]) == ~((__force __le32) 0))</span>

<span class="cp">#define EFX_DWORD_IS_ALL_ONES(dword)					\</span>
<span class="cp">	((dword).u32[0] == ~((__force __le32) 0))</span>

<span class="cp">#if BITS_PER_LONG == 64</span>
<span class="cp">#define EFX_OWORD_FIELD		EFX_OWORD_FIELD64</span>
<span class="cp">#define EFX_QWORD_FIELD		EFX_QWORD_FIELD64</span>
<span class="cp">#define EFX_OWORD_IS_ZERO	EFX_OWORD_IS_ZERO64</span>
<span class="cp">#define EFX_QWORD_IS_ZERO	EFX_QWORD_IS_ZERO64</span>
<span class="cp">#define EFX_OWORD_IS_ALL_ONES	EFX_OWORD_IS_ALL_ONES64</span>
<span class="cp">#define EFX_QWORD_IS_ALL_ONES	EFX_QWORD_IS_ALL_ONES64</span>
<span class="cp">#else</span>
<span class="cp">#define EFX_OWORD_FIELD		EFX_OWORD_FIELD32</span>
<span class="cp">#define EFX_QWORD_FIELD		EFX_QWORD_FIELD32</span>
<span class="cp">#define EFX_OWORD_IS_ZERO	EFX_OWORD_IS_ZERO32</span>
<span class="cp">#define EFX_QWORD_IS_ZERO	EFX_QWORD_IS_ZERO32</span>
<span class="cp">#define EFX_OWORD_IS_ALL_ONES	EFX_OWORD_IS_ALL_ONES32</span>
<span class="cp">#define EFX_QWORD_IS_ALL_ONES	EFX_QWORD_IS_ALL_ONES32</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Construct bit field portion</span>
<span class="cm"> *</span>
<span class="cm"> * Creates the portion of the bit field [low,high) that lies within</span>
<span class="cm"> * the range [min,max).</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_INSERT_NATIVE64(min, max, low, high, value)		\</span>
<span class="cp">	(((low &gt; max) || (high &lt; min)) ? 0 :			\</span>
<span class="cp">	 ((low &gt; min) ?						\</span>
<span class="cp">	  (((u64) (value)) &lt;&lt; (low - min)) :		\</span>
<span class="cp">	  (((u64) (value)) &gt;&gt; (min - low))))</span>

<span class="cp">#define EFX_INSERT_NATIVE32(min, max, low, high, value)		\</span>
<span class="cp">	(((low &gt; max) || (high &lt; min)) ? 0 :			\</span>
<span class="cp">	 ((low &gt; min) ?						\</span>
<span class="cp">	  (((u32) (value)) &lt;&lt; (low - min)) :		\</span>
<span class="cp">	  (((u32) (value)) &gt;&gt; (min - low))))</span>

<span class="cp">#define EFX_INSERT_NATIVE(min, max, low, high, value)		\</span>
<span class="cp">	((((max - min) &gt;= 32) || ((high - low) &gt;= 32)) ?	\</span>
<span class="cp">	 EFX_INSERT_NATIVE64(min, max, low, high, value) :	\</span>
<span class="cp">	 EFX_INSERT_NATIVE32(min, max, low, high, value))</span>

<span class="cm">/*</span>
<span class="cm"> * Construct bit field portion</span>
<span class="cm"> *</span>
<span class="cm"> * Creates the portion of the named bit field that lies within the</span>
<span class="cm"> * range [min,max).</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_INSERT_FIELD_NATIVE(min, max, field, value)		\</span>
<span class="cp">	EFX_INSERT_NATIVE(min, max, EFX_LOW_BIT(field),		\</span>
<span class="cp">			  EFX_HIGH_BIT(field), value)</span>

<span class="cm">/*</span>
<span class="cm"> * Construct bit field</span>
<span class="cm"> *</span>
<span class="cm"> * Creates the portion of the named bit fields that lie within the</span>
<span class="cm"> * range [min,max).</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_INSERT_FIELDS_NATIVE(min, max,				\</span>
<span class="cp">				 field1, value1,			\</span>
<span class="cp">				 field2, value2,			\</span>
<span class="cp">				 field3, value3,			\</span>
<span class="cp">				 field4, value4,			\</span>
<span class="cp">				 field5, value5,			\</span>
<span class="cp">				 field6, value6,			\</span>
<span class="cp">				 field7, value7,			\</span>
<span class="cp">				 field8, value8,			\</span>
<span class="cp">				 field9, value9,			\</span>
<span class="cp">				 field10, value10)			\</span>
<span class="cp">	(EFX_INSERT_FIELD_NATIVE((min), (max), field1, (value1)) |	\</span>
<span class="cp">	 EFX_INSERT_FIELD_NATIVE((min), (max), field2, (value2)) |	\</span>
<span class="cp">	 EFX_INSERT_FIELD_NATIVE((min), (max), field3, (value3)) |	\</span>
<span class="cp">	 EFX_INSERT_FIELD_NATIVE((min), (max), field4, (value4)) |	\</span>
<span class="cp">	 EFX_INSERT_FIELD_NATIVE((min), (max), field5, (value5)) |	\</span>
<span class="cp">	 EFX_INSERT_FIELD_NATIVE((min), (max), field6, (value6)) |	\</span>
<span class="cp">	 EFX_INSERT_FIELD_NATIVE((min), (max), field7, (value7)) |	\</span>
<span class="cp">	 EFX_INSERT_FIELD_NATIVE((min), (max), field8, (value8)) |	\</span>
<span class="cp">	 EFX_INSERT_FIELD_NATIVE((min), (max), field9, (value9)) |	\</span>
<span class="cp">	 EFX_INSERT_FIELD_NATIVE((min), (max), field10, (value10)))</span>

<span class="cp">#define EFX_INSERT_FIELDS64(...)				\</span>
<span class="cp">	cpu_to_le64(EFX_INSERT_FIELDS_NATIVE(__VA_ARGS__))</span>

<span class="cp">#define EFX_INSERT_FIELDS32(...)				\</span>
<span class="cp">	cpu_to_le32(EFX_INSERT_FIELDS_NATIVE(__VA_ARGS__))</span>

<span class="cp">#define EFX_POPULATE_OWORD64(oword, ...) do {				\</span>
<span class="cp">	(oword).u64[0] = EFX_INSERT_FIELDS64(0, 63, __VA_ARGS__);	\</span>
<span class="cp">	(oword).u64[1] = EFX_INSERT_FIELDS64(64, 127, __VA_ARGS__);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_POPULATE_QWORD64(qword, ...) do {				\</span>
<span class="cp">	(qword).u64[0] = EFX_INSERT_FIELDS64(0, 63, __VA_ARGS__);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_POPULATE_OWORD32(oword, ...) do {				\</span>
<span class="cp">	(oword).u32[0] = EFX_INSERT_FIELDS32(0, 31, __VA_ARGS__);	\</span>
<span class="cp">	(oword).u32[1] = EFX_INSERT_FIELDS32(32, 63, __VA_ARGS__);	\</span>
<span class="cp">	(oword).u32[2] = EFX_INSERT_FIELDS32(64, 95, __VA_ARGS__);	\</span>
<span class="cp">	(oword).u32[3] = EFX_INSERT_FIELDS32(96, 127, __VA_ARGS__);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_POPULATE_QWORD32(qword, ...) do {				\</span>
<span class="cp">	(qword).u32[0] = EFX_INSERT_FIELDS32(0, 31, __VA_ARGS__);	\</span>
<span class="cp">	(qword).u32[1] = EFX_INSERT_FIELDS32(32, 63, __VA_ARGS__);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_POPULATE_DWORD(dword, ...) do {				\</span>
<span class="cp">	(dword).u32[0] = EFX_INSERT_FIELDS32(0, 31, __VA_ARGS__);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#if BITS_PER_LONG == 64</span>
<span class="cp">#define EFX_POPULATE_OWORD EFX_POPULATE_OWORD64</span>
<span class="cp">#define EFX_POPULATE_QWORD EFX_POPULATE_QWORD64</span>
<span class="cp">#else</span>
<span class="cp">#define EFX_POPULATE_OWORD EFX_POPULATE_OWORD32</span>
<span class="cp">#define EFX_POPULATE_QWORD EFX_POPULATE_QWORD32</span>
<span class="cp">#endif</span>

<span class="cm">/* Populate an octword field with various numbers of arguments */</span>
<span class="cp">#define EFX_POPULATE_OWORD_10 EFX_POPULATE_OWORD</span>
<span class="cp">#define EFX_POPULATE_OWORD_9(oword, ...) \</span>
<span class="cp">	EFX_POPULATE_OWORD_10(oword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_OWORD_8(oword, ...) \</span>
<span class="cp">	EFX_POPULATE_OWORD_9(oword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_OWORD_7(oword, ...) \</span>
<span class="cp">	EFX_POPULATE_OWORD_8(oword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_OWORD_6(oword, ...) \</span>
<span class="cp">	EFX_POPULATE_OWORD_7(oword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_OWORD_5(oword, ...) \</span>
<span class="cp">	EFX_POPULATE_OWORD_6(oword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_OWORD_4(oword, ...) \</span>
<span class="cp">	EFX_POPULATE_OWORD_5(oword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_OWORD_3(oword, ...) \</span>
<span class="cp">	EFX_POPULATE_OWORD_4(oword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_OWORD_2(oword, ...) \</span>
<span class="cp">	EFX_POPULATE_OWORD_3(oword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_OWORD_1(oword, ...) \</span>
<span class="cp">	EFX_POPULATE_OWORD_2(oword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_ZERO_OWORD(oword) \</span>
<span class="cp">	EFX_POPULATE_OWORD_1(oword, EFX_DUMMY_FIELD, 0)</span>
<span class="cp">#define EFX_SET_OWORD(oword) \</span>
<span class="cp">	EFX_POPULATE_OWORD_4(oword, \</span>
<span class="cp">			     EFX_DWORD_0, 0xffffffff, \</span>
<span class="cp">			     EFX_DWORD_1, 0xffffffff, \</span>
<span class="cp">			     EFX_DWORD_2, 0xffffffff, \</span>
<span class="cp">			     EFX_DWORD_3, 0xffffffff)</span>

<span class="cm">/* Populate a quadword field with various numbers of arguments */</span>
<span class="cp">#define EFX_POPULATE_QWORD_10 EFX_POPULATE_QWORD</span>
<span class="cp">#define EFX_POPULATE_QWORD_9(qword, ...) \</span>
<span class="cp">	EFX_POPULATE_QWORD_10(qword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_QWORD_8(qword, ...) \</span>
<span class="cp">	EFX_POPULATE_QWORD_9(qword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_QWORD_7(qword, ...) \</span>
<span class="cp">	EFX_POPULATE_QWORD_8(qword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_QWORD_6(qword, ...) \</span>
<span class="cp">	EFX_POPULATE_QWORD_7(qword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_QWORD_5(qword, ...) \</span>
<span class="cp">	EFX_POPULATE_QWORD_6(qword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_QWORD_4(qword, ...) \</span>
<span class="cp">	EFX_POPULATE_QWORD_5(qword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_QWORD_3(qword, ...) \</span>
<span class="cp">	EFX_POPULATE_QWORD_4(qword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_QWORD_2(qword, ...) \</span>
<span class="cp">	EFX_POPULATE_QWORD_3(qword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_QWORD_1(qword, ...) \</span>
<span class="cp">	EFX_POPULATE_QWORD_2(qword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_ZERO_QWORD(qword) \</span>
<span class="cp">	EFX_POPULATE_QWORD_1(qword, EFX_DUMMY_FIELD, 0)</span>
<span class="cp">#define EFX_SET_QWORD(qword) \</span>
<span class="cp">	EFX_POPULATE_QWORD_2(qword, \</span>
<span class="cp">			     EFX_DWORD_0, 0xffffffff, \</span>
<span class="cp">			     EFX_DWORD_1, 0xffffffff)</span>

<span class="cm">/* Populate a dword field with various numbers of arguments */</span>
<span class="cp">#define EFX_POPULATE_DWORD_10 EFX_POPULATE_DWORD</span>
<span class="cp">#define EFX_POPULATE_DWORD_9(dword, ...) \</span>
<span class="cp">	EFX_POPULATE_DWORD_10(dword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_DWORD_8(dword, ...) \</span>
<span class="cp">	EFX_POPULATE_DWORD_9(dword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_DWORD_7(dword, ...) \</span>
<span class="cp">	EFX_POPULATE_DWORD_8(dword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_DWORD_6(dword, ...) \</span>
<span class="cp">	EFX_POPULATE_DWORD_7(dword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_DWORD_5(dword, ...) \</span>
<span class="cp">	EFX_POPULATE_DWORD_6(dword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_DWORD_4(dword, ...) \</span>
<span class="cp">	EFX_POPULATE_DWORD_5(dword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_DWORD_3(dword, ...) \</span>
<span class="cp">	EFX_POPULATE_DWORD_4(dword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_DWORD_2(dword, ...) \</span>
<span class="cp">	EFX_POPULATE_DWORD_3(dword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_POPULATE_DWORD_1(dword, ...) \</span>
<span class="cp">	EFX_POPULATE_DWORD_2(dword, EFX_DUMMY_FIELD, 0, __VA_ARGS__)</span>
<span class="cp">#define EFX_ZERO_DWORD(dword) \</span>
<span class="cp">	EFX_POPULATE_DWORD_1(dword, EFX_DUMMY_FIELD, 0)</span>
<span class="cp">#define EFX_SET_DWORD(dword) \</span>
<span class="cp">	EFX_POPULATE_DWORD_1(dword, EFX_DWORD_0, 0xffffffff)</span>

<span class="cm">/*</span>
<span class="cm"> * Modify a named field within an already-populated structure.  Used</span>
<span class="cm"> * for read-modify-write operations.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define EFX_INVERT_OWORD(oword) do {		\</span>
<span class="cp">	(oword).u64[0] = ~((oword).u64[0]);	\</span>
<span class="cp">	(oword).u64[1] = ~((oword).u64[1]);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_AND_OWORD(oword, from, mask)			\</span>
<span class="cp">	do {							\</span>
<span class="cp">		(oword).u64[0] = (from).u64[0] &amp; (mask).u64[0];	\</span>
<span class="cp">		(oword).u64[1] = (from).u64[1] &amp; (mask).u64[1];	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_OR_OWORD(oword, from, mask)				\</span>
<span class="cp">	do {							\</span>
<span class="cp">		(oword).u64[0] = (from).u64[0] | (mask).u64[0];	\</span>
<span class="cp">		(oword).u64[1] = (from).u64[1] | (mask).u64[1];	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_INSERT64(min, max, low, high, value)			\</span>
<span class="cp">	cpu_to_le64(EFX_INSERT_NATIVE(min, max, low, high, value))</span>

<span class="cp">#define EFX_INSERT32(min, max, low, high, value)			\</span>
<span class="cp">	cpu_to_le32(EFX_INSERT_NATIVE(min, max, low, high, value))</span>

<span class="cp">#define EFX_INPLACE_MASK64(min, max, low, high)				\</span>
<span class="cp">	EFX_INSERT64(min, max, low, high, EFX_MASK64(high + 1 - low))</span>

<span class="cp">#define EFX_INPLACE_MASK32(min, max, low, high)				\</span>
<span class="cp">	EFX_INSERT32(min, max, low, high, EFX_MASK32(high + 1 - low))</span>

<span class="cp">#define EFX_SET_OWORD64(oword, low, high, value) do {			\</span>
<span class="cp">	(oword).u64[0] = (((oword).u64[0]				\</span>
<span class="cp">			   &amp; ~EFX_INPLACE_MASK64(0,  63, low, high))	\</span>
<span class="cp">			  | EFX_INSERT64(0,  63, low, high, value));	\</span>
<span class="cp">	(oword).u64[1] = (((oword).u64[1]				\</span>
<span class="cp">			   &amp; ~EFX_INPLACE_MASK64(64, 127, low, high))	\</span>
<span class="cp">			  | EFX_INSERT64(64, 127, low, high, value));	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_SET_QWORD64(qword, low, high, value) do {			\</span>
<span class="cp">	(qword).u64[0] = (((qword).u64[0]				\</span>
<span class="cp">			   &amp; ~EFX_INPLACE_MASK64(0, 63, low, high))	\</span>
<span class="cp">			  | EFX_INSERT64(0, 63, low, high, value));	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_SET_OWORD32(oword, low, high, value) do {			\</span>
<span class="cp">	(oword).u32[0] = (((oword).u32[0]				\</span>
<span class="cp">			   &amp; ~EFX_INPLACE_MASK32(0, 31, low, high))	\</span>
<span class="cp">			  | EFX_INSERT32(0, 31, low, high, value));	\</span>
<span class="cp">	(oword).u32[1] = (((oword).u32[1]				\</span>
<span class="cp">			   &amp; ~EFX_INPLACE_MASK32(32, 63, low, high))	\</span>
<span class="cp">			  | EFX_INSERT32(32, 63, low, high, value));	\</span>
<span class="cp">	(oword).u32[2] = (((oword).u32[2]				\</span>
<span class="cp">			   &amp; ~EFX_INPLACE_MASK32(64, 95, low, high))	\</span>
<span class="cp">			  | EFX_INSERT32(64, 95, low, high, value));	\</span>
<span class="cp">	(oword).u32[3] = (((oword).u32[3]				\</span>
<span class="cp">			   &amp; ~EFX_INPLACE_MASK32(96, 127, low, high))	\</span>
<span class="cp">			  | EFX_INSERT32(96, 127, low, high, value));	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_SET_QWORD32(qword, low, high, value) do {			\</span>
<span class="cp">	(qword).u32[0] = (((qword).u32[0]				\</span>
<span class="cp">			   &amp; ~EFX_INPLACE_MASK32(0, 31, low, high))	\</span>
<span class="cp">			  | EFX_INSERT32(0, 31, low, high, value));	\</span>
<span class="cp">	(qword).u32[1] = (((qword).u32[1]				\</span>
<span class="cp">			   &amp; ~EFX_INPLACE_MASK32(32, 63, low, high))	\</span>
<span class="cp">			  | EFX_INSERT32(32, 63, low, high, value));	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_SET_DWORD32(dword, low, high, value) do {			\</span>
<span class="cp">	(dword).u32[0] = (((dword).u32[0]				\</span>
<span class="cp">			   &amp; ~EFX_INPLACE_MASK32(0, 31, low, high))	\</span>
<span class="cp">			  | EFX_INSERT32(0, 31, low, high, value));	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define EFX_SET_OWORD_FIELD64(oword, field, value)			\</span>
<span class="cp">	EFX_SET_OWORD64(oword, EFX_LOW_BIT(field),			\</span>
<span class="cp">			 EFX_HIGH_BIT(field), value)</span>

<span class="cp">#define EFX_SET_QWORD_FIELD64(qword, field, value)			\</span>
<span class="cp">	EFX_SET_QWORD64(qword, EFX_LOW_BIT(field),			\</span>
<span class="cp">			 EFX_HIGH_BIT(field), value)</span>

<span class="cp">#define EFX_SET_OWORD_FIELD32(oword, field, value)			\</span>
<span class="cp">	EFX_SET_OWORD32(oword, EFX_LOW_BIT(field),			\</span>
<span class="cp">			 EFX_HIGH_BIT(field), value)</span>

<span class="cp">#define EFX_SET_QWORD_FIELD32(qword, field, value)			\</span>
<span class="cp">	EFX_SET_QWORD32(qword, EFX_LOW_BIT(field),			\</span>
<span class="cp">			 EFX_HIGH_BIT(field), value)</span>

<span class="cp">#define EFX_SET_DWORD_FIELD(dword, field, value)			\</span>
<span class="cp">	EFX_SET_DWORD32(dword, EFX_LOW_BIT(field),			\</span>
<span class="cp">			 EFX_HIGH_BIT(field), value)</span>



<span class="cp">#if BITS_PER_LONG == 64</span>
<span class="cp">#define EFX_SET_OWORD_FIELD EFX_SET_OWORD_FIELD64</span>
<span class="cp">#define EFX_SET_QWORD_FIELD EFX_SET_QWORD_FIELD64</span>
<span class="cp">#else</span>
<span class="cp">#define EFX_SET_OWORD_FIELD EFX_SET_OWORD_FIELD32</span>
<span class="cp">#define EFX_SET_QWORD_FIELD EFX_SET_QWORD_FIELD32</span>
<span class="cp">#endif</span>

<span class="cm">/* Used to avoid compiler warnings about shift range exceeding width</span>
<span class="cm"> * of the data types when dma_addr_t is only 32 bits wide.</span>
<span class="cm"> */</span>
<span class="cp">#define DMA_ADDR_T_WIDTH	(8 * sizeof(dma_addr_t))</span>
<span class="cp">#define EFX_DMA_TYPE_WIDTH(width) \</span>
<span class="cp">	(((width) &lt; DMA_ADDR_T_WIDTH) ? (width) : DMA_ADDR_T_WIDTH)</span>


<span class="cm">/* Static initialiser */</span>
<span class="cp">#define EFX_OWORD32(a, b, c, d)				\</span>
<span class="cp">	{ .u32 = { cpu_to_le32(a), cpu_to_le32(b),	\</span>
<span class="cp">		   cpu_to_le32(c), cpu_to_le32(d) } }</span>

<span class="cp">#endif </span><span class="cm">/* EFX_BITFIELD_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
