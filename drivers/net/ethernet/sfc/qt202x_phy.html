<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › qt202x_phy.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>qt202x_phy.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2006-2010 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Driver for AMCC QT202x SFP+ and XFP adapters; see www.amcc.com for details</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &quot;efx.h&quot;</span>
<span class="cp">#include &quot;mdio_10g.h&quot;</span>
<span class="cp">#include &quot;phy.h&quot;</span>
<span class="cp">#include &quot;nic.h&quot;</span>

<span class="cp">#define QT202X_REQUIRED_DEVS (MDIO_DEVS_PCS |		\</span>
<span class="cp">			      MDIO_DEVS_PMAPMD |	\</span>
<span class="cp">			      MDIO_DEVS_PHYXS)</span>

<span class="cp">#define QT202X_LOOPBACKS ((1 &lt;&lt; LOOPBACK_PCS) |		\</span>
<span class="cp">			  (1 &lt;&lt; LOOPBACK_PMAPMD) |	\</span>
<span class="cp">			  (1 &lt;&lt; LOOPBACK_PHYXS_WS))</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/* Quake-specific MDIO registers */</span>
<span class="cp">#define MDIO_QUAKE_LED0_REG	(0xD006)</span>

<span class="cm">/* QT2025C only */</span>
<span class="cp">#define PCS_FW_HEARTBEAT_REG	0xd7ee</span>
<span class="cp">#define PCS_FW_HEARTB_LBN	0</span>
<span class="cp">#define PCS_FW_HEARTB_WIDTH	8</span>
<span class="cp">#define PCS_FW_PRODUCT_CODE_1	0xd7f0</span>
<span class="cp">#define PCS_FW_VERSION_1	0xd7f3</span>
<span class="cp">#define PCS_FW_BUILD_1		0xd7f6</span>
<span class="cp">#define PCS_UC8051_STATUS_REG	0xd7fd</span>
<span class="cp">#define PCS_UC_STATUS_LBN	0</span>
<span class="cp">#define PCS_UC_STATUS_WIDTH	8</span>
<span class="cp">#define PCS_UC_STATUS_FW_SAVE	0x20</span>
<span class="cp">#define PMA_PMD_MODE_REG	0xc301</span>
<span class="cp">#define PMA_PMD_RXIN_SEL_LBN	6</span>
<span class="cp">#define PMA_PMD_FTX_CTRL2_REG	0xc309</span>
<span class="cp">#define PMA_PMD_FTX_STATIC_LBN	13</span>
<span class="cp">#define PMA_PMD_VEND1_REG	0xc001</span>
<span class="cp">#define PMA_PMD_VEND1_LBTXD_LBN	15</span>
<span class="cp">#define PCS_VEND1_REG		0xc000</span>
<span class="cp">#define PCS_VEND1_LBTXD_LBN	5</span>

<span class="kt">void</span> <span class="nf">falcon_qt202x_set_led</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">led</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">MDIO_QUAKE_LED0_REG</span> <span class="o">+</span> <span class="n">led</span><span class="p">;</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">MDIO_MMD_PMAPMD</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">qt202x_phy_data</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">efx_phy_mode</span> <span class="n">phy_mode</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bug17190_in_bad_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bug17190_timer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">firmware_ver</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define QT2022C2_MAX_RESET_TIME 500</span>
<span class="cp">#define QT2022C2_RESET_WAIT 10</span>

<span class="cp">#define QT2025C_MAX_HEARTB_TIME (5 * HZ)</span>
<span class="cp">#define QT2025C_HEARTB_WAIT 100</span>
<span class="cp">#define QT2025C_MAX_FWSTART_TIME (25 * HZ / 10)</span>
<span class="cp">#define QT2025C_FWSTART_WAIT 100</span>

<span class="cp">#define BUG17190_INTERVAL (2 * HZ)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qt2025c_wait_heartbeat</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">QT2025C_MAX_HEARTB_TIME</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">old_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait for firmware heartbeat to start */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">efx_mdio_read</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MDIO_MMD_PCS</span><span class="p">,</span> <span class="n">PCS_FW_HEARTBEAT_REG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
		<span class="n">counter</span> <span class="o">=</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="n">PCS_FW_HEARTB_LBN</span><span class="p">)</span> <span class="o">&amp;</span>
			    <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PCS_FW_HEARTB_WIDTH</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">old_counter</span> <span class="o">=</span> <span class="n">counter</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">!=</span> <span class="n">old_counter</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Some cables have EEPROMs that conflict with the</span>
<span class="cm">			 * PHY&#39;s on-board EEPROM so it cannot load firmware */</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;If an SFP+ direct attach cable is&quot;</span>
				  <span class="s">&quot; connected, please check that it complies&quot;</span>
				  <span class="s">&quot; with the SFP+ specification</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">QT2025C_HEARTB_WAIT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qt2025c_wait_fw_status_good</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">QT2025C_MAX_FWSTART_TIME</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>

	<span class="cm">/* Wait for firmware status to look good */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">efx_mdio_read</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MDIO_MMD_PCS</span><span class="p">,</span> <span class="n">PCS_UC8051_STATUS_REG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span>
		     <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PCS_UC_STATUS_WIDTH</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PCS_UC_STATUS_LBN</span><span class="p">)</span> <span class="o">&gt;=</span>
		    <span class="n">PCS_UC_STATUS_FW_SAVE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">QT2025C_FWSTART_WAIT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qt2025c_restart_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restart microcontroller execution of firmware from RAM */</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0xe854</span><span class="p">,</span> <span class="mh">0x00c0</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0xe854</span><span class="p">,</span> <span class="mh">0x0040</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qt2025c_wait_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">qt2025c_wait_heartbeat</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">qt2025c_wait_fw_status_good</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Bug 17689: occasionally heartbeat starts but firmware status</span>
<span class="cm">		 * code never progresses beyond 0x00.  Try again, once, after</span>
<span class="cm">		 * restarting execution of the firmware image. */</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;bashing QT2025C microcontroller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">qt2025c_restart_firmware</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">qt2025c_wait_heartbeat</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">qt2025c_wait_fw_status_good</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qt2025c_firmware_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qt202x_phy_data</span> <span class="o">*</span><span class="n">phy_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">firmware_id</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">firmware_id</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">firmware_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">efx_mdio_read</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MDIO_MMD_PCS</span><span class="p">,</span>
					       <span class="n">PCS_FW_PRODUCT_CODE_1</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;QT2025C firmware %xr%d v%d.%d.%d.%d [20%02d-%02d-%02d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">firmware_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">firmware_id</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">firmware_id</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
		   <span class="n">firmware_id</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">firmware_id</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">,</span>
		   <span class="n">firmware_id</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">firmware_id</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
		   <span class="n">firmware_id</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">firmware_id</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">firmware_id</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
	<span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">firmware_ver</span> <span class="o">=</span> <span class="p">((</span><span class="n">firmware_id</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">|</span>
				 <span class="p">((</span><span class="n">firmware_id</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
				 <span class="p">(</span><span class="n">firmware_id</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">firmware_id</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qt2025c_bug17190_workaround</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qt202x_phy_data</span> <span class="o">*</span><span class="n">phy_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_data</span><span class="p">;</span>

	<span class="cm">/* The PHY can get stuck in a state where it reports PHY_XS and PMA/PMD</span>
<span class="cm">	 * layers up, but PCS down (no block_lock).  If we notice this state</span>
<span class="cm">	 * persisting for a couple of seconds, we switch PMA/PMD loopback</span>
<span class="cm">	 * briefly on and then off again, which is normally sufficient to</span>
<span class="cm">	 * recover it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">up</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">efx_mdio_links_ok</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MDIO_DEVS_PMAPMD</span> <span class="o">|</span> <span class="n">MDIO_DEVS_PHYXS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">bug17190_in_bad_state</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">bug17190_in_bad_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">bug17190_in_bad_state</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">bug17190_timer</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">BUG17190_INTERVAL</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">bug17190_timer</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;bashing QT2025C PMA/PMD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">efx_mdio_set_flag</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MDIO_MMD_PMAPMD</span><span class="p">,</span> <span class="n">MDIO_CTRL1</span><span class="p">,</span>
				  <span class="n">MDIO_PMA_CTRL1_LOOPBACK</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="n">efx_mdio_set_flag</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MDIO_MMD_PMAPMD</span><span class="p">,</span> <span class="n">MDIO_CTRL1</span><span class="p">,</span>
				  <span class="n">MDIO_PMA_CTRL1_LOOPBACK</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">bug17190_timer</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">BUG17190_INTERVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qt2025c_select_phy_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qt202x_phy_data</span> <span class="o">*</span><span class="n">phy_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">falcon_board</span> <span class="o">*</span><span class="n">board</span> <span class="o">=</span> <span class="n">falcon_board</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">phy_op_mode</span><span class="p">;</span>

	<span class="cm">/* Only 2.0.1.0+ PHY firmware supports the more optimal SFP+</span>
<span class="cm">	 * Self-Configure mode.  Don&#39;t attempt any switching if we encounter</span>
<span class="cm">	 * older firmware. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">firmware_ver</span> <span class="o">&lt;</span> <span class="mh">0x02000100</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* In general we will get optimal behaviour in &quot;SFP+ Self-Configure&quot;</span>
<span class="cm">	 * mode; however, that powers down most of the PHY when no module is</span>
<span class="cm">	 * present, so we must use a different mode (any fixed mode will do)</span>
<span class="cm">	 * to be sure that loopbacks will work. */</span>
	<span class="n">phy_op_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">loopback_mode</span> <span class="o">==</span> <span class="n">LOOPBACK_NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x0038</span> <span class="o">:</span> <span class="mh">0x0020</span><span class="p">;</span>

	<span class="cm">/* Only change mode if really necessary */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">efx_mdio_read</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc319</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x0038</span><span class="p">)</span> <span class="o">==</span> <span class="n">phy_op_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Switching PHY to mode 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">phy_op_mode</span><span class="p">);</span>

	<span class="cm">/* This sequence replicates the register writes configured in the boot</span>
<span class="cm">	 * EEPROM (including the differences between board revisions), except</span>
<span class="cm">	 * that the operating mode is changed, and the PHY is prevented from</span>
<span class="cm">	 * unnecessarily reloading the main firmware image again. */</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc300</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
	<span class="cm">/* (Note: this portion of the boot EEPROM sequence, which bit-bashes 9</span>
<span class="cm">	 * STOPs onto the firmware/module I2C bus to reset it, varies across</span>
<span class="cm">	 * board revisions, as the bus is connected to different GPIO/LED</span>
<span class="cm">	 * outputs on the PHY.) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc303</span><span class="p">,</span> <span class="mh">0x4498</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc303</span><span class="p">,</span> <span class="mh">0x4488</span><span class="p">);</span>
			<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc303</span><span class="p">,</span> <span class="mh">0x4480</span><span class="p">);</span>
			<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc303</span><span class="p">,</span> <span class="mh">0x4490</span><span class="p">);</span>
			<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc303</span><span class="p">,</span> <span class="mh">0x4498</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc303</span><span class="p">,</span> <span class="mh">0x0920</span><span class="p">);</span>
		<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xd008</span><span class="p">,</span> <span class="mh">0x0004</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc303</span><span class="p">,</span> <span class="mh">0x0900</span><span class="p">);</span>
			<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xd008</span><span class="p">,</span> <span class="mh">0x0005</span><span class="p">);</span>
			<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc303</span><span class="p">,</span> <span class="mh">0x0920</span><span class="p">);</span>
			<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xd008</span><span class="p">,</span> <span class="mh">0x0004</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc303</span><span class="p">,</span> <span class="mh">0x4900</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc303</span><span class="p">,</span> <span class="mh">0x4900</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc302</span><span class="p">,</span> <span class="mh">0x0004</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc316</span><span class="p">,</span> <span class="mh">0x0013</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc318</span><span class="p">,</span> <span class="mh">0x0054</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc319</span><span class="p">,</span> <span class="n">phy_op_mode</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc31a</span><span class="p">,</span> <span class="mh">0x0098</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0x0026</span><span class="p">,</span> <span class="mh">0x0e00</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0x0027</span><span class="p">,</span> <span class="mh">0x0013</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0x0028</span><span class="p">,</span> <span class="mh">0xa528</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xd006</span><span class="p">,</span> <span class="mh">0x000a</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xd007</span><span class="p">,</span> <span class="mh">0x0009</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xd008</span><span class="p">,</span> <span class="mh">0x0004</span><span class="p">);</span>
	<span class="cm">/* This additional write is not present in the boot EEPROM.  It</span>
<span class="cm">	 * prevents the PHY&#39;s internal boot ROM doing another pointless (and</span>
<span class="cm">	 * slow) reload of the firmware image (the microcontroller&#39;s code</span>
<span class="cm">	 * memory is not affected by the microcontroller reset). */</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc317</span><span class="p">,</span> <span class="mh">0x00ff</span><span class="p">);</span>
	<span class="cm">/* PMA/PMD loopback sets RXIN to inverse polarity and the firmware</span>
<span class="cm">	 * restart doesn&#39;t reset it. We need to do that ourselves. */</span>
	<span class="n">efx_mdio_set_flag</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PMA_PMD_MODE_REG</span><span class="p">,</span>
			  <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PMA_PMD_RXIN_SEL_LBN</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">efx_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xc300</span><span class="p">,</span> <span class="mh">0x0002</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

	<span class="cm">/* Restart microcontroller execution of firmware from RAM */</span>
	<span class="n">qt2025c_restart_firmware</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Wait for the microcontroller to be ready again */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">qt2025c_wait_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;PHY microcontroller reset during mode switch &quot;</span>
			  <span class="s">&quot;timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qt202x_reset_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">PHY_TYPE_QT2025C</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Wait for the reset triggered by falcon_reset_hw()</span>
<span class="cm">		 * to complete */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">qt2025c_wait_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Reset the PHYXS MMD. This is documented as doing</span>
<span class="cm">		 * a complete soft reset. */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mdio_reset_mmd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MDIO_MMD_PHYXS</span><span class="p">,</span>
					<span class="n">QT2022C2_MAX_RESET_TIME</span> <span class="o">/</span>
					<span class="n">QT2022C2_RESET_WAIT</span><span class="p">,</span>
					<span class="n">QT2022C2_RESET_WAIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait 250ms for the PHY to complete bootup */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>

	<span class="n">falcon_board</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">init_phy</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;PHY reset timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qt202x_phy_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qt202x_phy_data</span> <span class="o">*</span><span class="n">phy_data</span><span class="p">;</span>

	<span class="n">phy_data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">qt202x_phy_data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_data</span> <span class="o">=</span> <span class="n">phy_data</span><span class="p">;</span>
	<span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span><span class="p">;</span>
	<span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">bug17190_in_bad_state</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">bug17190_timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">mmds</span> <span class="o">=</span> <span class="n">QT202X_REQUIRED_DEVS</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">mode_support</span> <span class="o">=</span> <span class="n">MDIO_SUPPORTS_C45</span> <span class="o">|</span> <span class="n">MDIO_EMULATE_C22</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">loopback_modes</span> <span class="o">=</span> <span class="n">QT202X_LOOPBACKS</span> <span class="o">|</span> <span class="n">FALCON_XMAC_LOOPBACKS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qt202x_phy_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">devid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">qt202x_reset_phy</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;PHY init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">devid</span> <span class="o">=</span> <span class="n">efx_mdio_read_id</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MDIO_MMD_PHYXS</span><span class="p">);</span>
	<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;PHY ID reg %x (OUI %06x model %02x revision %x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">devid</span><span class="p">,</span> <span class="n">efx_mdio_id_oui</span><span class="p">(</span><span class="n">devid</span><span class="p">),</span> <span class="n">efx_mdio_id_model</span><span class="p">(</span><span class="n">devid</span><span class="p">),</span>
		   <span class="n">efx_mdio_id_rev</span><span class="p">(</span><span class="n">devid</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">PHY_TYPE_QT2025C</span><span class="p">)</span>
		<span class="n">qt2025c_firmware_id</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qt202x_link_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">efx_mdio_links_ok</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">QT202X_REQUIRED_DEVS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">qt202x_phy_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">was_up</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">up</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">up</span> <span class="o">=</span> <span class="n">qt202x_link_ok</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">wanted_fc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">PHY_TYPE_QT2025C</span><span class="p">)</span>
		<span class="n">qt2025c_bug17190_workaround</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">.</span><span class="n">up</span> <span class="o">!=</span> <span class="n">was_up</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qt202x_phy_reconfigure</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qt202x_phy_data</span> <span class="o">*</span><span class="n">phy_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">PHY_TYPE_QT2025C</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">qt2025c_select_phy_mode</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="cm">/* There are several different register bits which can</span>
<span class="cm">		 * disable TX (and save power) on direct-attach cables</span>
<span class="cm">		 * or optical transceivers, varying somewhat between</span>
<span class="cm">		 * firmware versions.  Only &#39;static mode&#39; appears to</span>
<span class="cm">		 * cover everything. */</span>
		<span class="n">mdio_set_flag</span><span class="p">(</span>
			<span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">prtad</span><span class="p">,</span> <span class="n">MDIO_MMD_PMAPMD</span><span class="p">,</span>
			<span class="n">PMA_PMD_FTX_CTRL2_REG</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PMA_PMD_FTX_STATIC_LBN</span><span class="p">,</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">&amp;</span> <span class="n">PHY_MODE_TX_DISABLED</span> <span class="o">||</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">&amp;</span> <span class="n">PHY_MODE_LOW_POWER</span> <span class="o">||</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">loopback_mode</span> <span class="o">==</span> <span class="n">LOOPBACK_PCS</span> <span class="o">||</span>
			<span class="n">efx</span><span class="o">-&gt;</span><span class="n">loopback_mode</span> <span class="o">==</span> <span class="n">LOOPBACK_PMAPMD</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Reset the PHY when moving from tx off to tx on */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">&amp;</span> <span class="n">PHY_MODE_TX_DISABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">&amp;</span> <span class="n">PHY_MODE_TX_DISABLED</span><span class="p">))</span>
			<span class="n">qt202x_reset_phy</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

		<span class="n">efx_mdio_transmit_disable</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx_mdio_phy_reconfigure</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">phy_data</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_mode</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qt202x_phy_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mdio45_ethtool_gset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">,</span> <span class="n">ecmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qt202x_phy_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Free the context block */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qt202x_phy_get_module_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ethtool_modinfo</span> <span class="o">*</span><span class="n">modinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">modinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ETH_MODULE_SFF_8079</span><span class="p">;</span>
	<span class="n">modinfo</span><span class="o">-&gt;</span><span class="n">eeprom_len</span> <span class="o">=</span> <span class="n">ETH_MODULE_SFF_8079_LEN</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qt202x_phy_get_module_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ethtool_eeprom</span> <span class="o">*</span><span class="n">ee</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mmd</span><span class="p">,</span> <span class="n">reg_base</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>		

	<span class="k">if</span> <span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">PHY_TYPE_QT2025C</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mmd</span> <span class="o">=</span> <span class="n">MDIO_MMD_PCS</span><span class="p">;</span>
		<span class="n">reg_base</span> <span class="o">=</span> <span class="mh">0xd000</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mmd</span> <span class="o">=</span> <span class="n">MDIO_MMD_PMAPMD</span><span class="p">;</span>
		<span class="n">reg_base</span> <span class="o">=</span> <span class="mh">0x8007</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mdio_read</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">mmd</span><span class="p">,</span> <span class="n">reg_base</span> <span class="o">+</span> <span class="n">ee</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_phy_operations</span> <span class="n">falcon_qt202x_phy_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>		 <span class="o">=</span> <span class="n">qt202x_phy_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span>		 <span class="o">=</span> <span class="n">qt202x_phy_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reconfigure</span>	 <span class="o">=</span> <span class="n">qt202x_phy_reconfigure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		 <span class="o">=</span> <span class="n">qt202x_phy_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fini</span>		 <span class="o">=</span> <span class="n">efx_port_dummy_op_void</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		 <span class="o">=</span> <span class="n">qt202x_phy_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_settings</span>	 <span class="o">=</span> <span class="n">qt202x_phy_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span>	 <span class="o">=</span> <span class="n">efx_mdio_set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">test_alive</span>	 <span class="o">=</span> <span class="n">efx_mdio_test_alive</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_module_eeprom</span> <span class="o">=</span> <span class="n">qt202x_phy_get_module_eeprom</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_module_info</span> <span class="o">=</span> <span class="n">qt202x_phy_get_module_info</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
