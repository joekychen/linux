<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › filter.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>filter.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2005-2010 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &quot;efx.h&quot;</span>
<span class="cp">#include &quot;filter.h&quot;</span>
<span class="cp">#include &quot;io.h&quot;</span>
<span class="cp">#include &quot;nic.h&quot;</span>
<span class="cp">#include &quot;regs.h&quot;</span>

<span class="cm">/* &quot;Fudge factors&quot; - difference between programmed value and actual depth.</span>
<span class="cm"> * Due to pipelined implementation we need to program H/W with a value that</span>
<span class="cm"> * is larger than the hop limit we want.</span>
<span class="cm"> */</span>
<span class="cp">#define FILTER_CTL_SRCH_FUDGE_WILD 3</span>
<span class="cp">#define FILTER_CTL_SRCH_FUDGE_FULL 1</span>

<span class="cm">/* Hard maximum hop limit.  Hardware will time-out beyond 200-something.</span>
<span class="cm"> * We also need to avoid infinite loops in efx_filter_search() when the</span>
<span class="cm"> * table is full.</span>
<span class="cm"> */</span>
<span class="cp">#define FILTER_CTL_SRCH_MAX 200</span>

<span class="cm">/* Don&#39;t try very hard to find space for performance hints, as this is</span>
<span class="cm"> * counter-productive. */</span>
<span class="cp">#define FILTER_CTL_SRCH_HINT_MAX 5</span>

<span class="k">enum</span> <span class="n">efx_filter_table_id</span> <span class="p">{</span>
	<span class="n">EFX_FILTER_TABLE_RX_IP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">EFX_FILTER_TABLE_RX_MAC</span><span class="p">,</span>
	<span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">,</span>
	<span class="n">EFX_FILTER_TABLE_TX_MAC</span><span class="p">,</span>
	<span class="n">EFX_FILTER_TABLE_COUNT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">efx_filter_index</span> <span class="p">{</span>
	<span class="n">EFX_FILTER_INDEX_UC_DEF</span><span class="p">,</span>
	<span class="n">EFX_FILTER_INDEX_MC_DEF</span><span class="p">,</span>
	<span class="n">EFX_FILTER_SIZE_RX_DEF</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">efx_filter_table_id</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">offset</span><span class="p">;</span>		<span class="cm">/* address of table relative to BAR */</span>
	<span class="kt">unsigned</span>	<span class="n">size</span><span class="p">;</span>		<span class="cm">/* number of entries */</span>
	<span class="kt">unsigned</span>	<span class="n">step</span><span class="p">;</span>		<span class="cm">/* step between entries */</span>
	<span class="kt">unsigned</span>	<span class="n">used</span><span class="p">;</span>		<span class="cm">/* number currently used */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="o">*</span><span class="n">used_bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">search_depth</span><span class="p">[</span><span class="n">EFX_FILTER_TYPE_COUNT</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_COUNT</span><span class="p">];</span>
<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>
	<span class="n">u32</span>		<span class="o">*</span><span class="n">rps_flow_id</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">rps_expire_index</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* The filter hash function is LFSR polynomial x^16 + x^3 + 1 of a 32-bit</span>
<span class="cm"> * key derived from the n-tuple.  The initial LFSR state is 0xffff. */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">efx_filter_hash</span><span class="p">(</span><span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* First 16 rounds */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="mh">0x1fff</span> <span class="o">^</span> <span class="n">key</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">^</span> <span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">^</span> <span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">^</span> <span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="cm">/* Last 16 rounds */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">^</span> <span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span> <span class="o">^</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">^</span> <span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">^</span> <span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tmp</span> <span class="o">^</span> <span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* To allow for hash collisions, filter search continues at these</span>
<span class="cm"> * increments from the first possible entry selected by the hash. */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">efx_filter_increment</span><span class="p">(</span><span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">key</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">efx_filter_table_id</span>
<span class="nf">efx_filter_spec_table_id</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_FILTER_TABLE_RX_IP</span> <span class="o">!=</span> <span class="p">(</span><span class="n">EFX_FILTER_TCP_FULL</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_FILTER_TABLE_RX_IP</span> <span class="o">!=</span> <span class="p">(</span><span class="n">EFX_FILTER_TCP_WILD</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_FILTER_TABLE_RX_IP</span> <span class="o">!=</span> <span class="p">(</span><span class="n">EFX_FILTER_UDP_FULL</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_FILTER_TABLE_RX_IP</span> <span class="o">!=</span> <span class="p">(</span><span class="n">EFX_FILTER_UDP_WILD</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_FILTER_TABLE_RX_MAC</span> <span class="o">!=</span> <span class="p">(</span><span class="n">EFX_FILTER_MAC_FULL</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_FILTER_TABLE_RX_MAC</span> <span class="o">!=</span> <span class="p">(</span><span class="n">EFX_FILTER_MAC_WILD</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_FILTER_TABLE_TX_MAC</span> <span class="o">!=</span> <span class="n">EFX_FILTER_TABLE_RX_MAC</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFX_FILTER_UNSPEC</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_TX</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span>
<span class="nf">efx_filter_spec_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFX_FILTER_UNSPEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">efx_filter_spec_table_id</span><span class="p">(</span><span class="n">spec</span><span class="p">)];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_filter_table_reset_search_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_filter_push_rx_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">filter_ctl</span><span class="p">;</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FR_BZ_RX_FILTER_CTL</span><span class="p">);</span>

	<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_RX_IP</span><span class="p">];</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_BZ_TCP_FULL_SRCH_LIMIT</span><span class="p">,</span>
			    <span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">EFX_FILTER_TCP_FULL</span><span class="p">]</span> <span class="o">+</span>
			    <span class="n">FILTER_CTL_SRCH_FUDGE_FULL</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_BZ_TCP_WILD_SRCH_LIMIT</span><span class="p">,</span>
			    <span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">EFX_FILTER_TCP_WILD</span><span class="p">]</span> <span class="o">+</span>
			    <span class="n">FILTER_CTL_SRCH_FUDGE_WILD</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_BZ_UDP_FULL_SRCH_LIMIT</span><span class="p">,</span>
			    <span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">EFX_FILTER_UDP_FULL</span><span class="p">]</span> <span class="o">+</span>
			    <span class="n">FILTER_CTL_SRCH_FUDGE_FULL</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_BZ_UDP_WILD_SRCH_LIMIT</span><span class="p">,</span>
			    <span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">EFX_FILTER_UDP_WILD</span><span class="p">]</span> <span class="o">+</span>
			    <span class="n">FILTER_CTL_SRCH_FUDGE_WILD</span><span class="p">);</span>

	<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_RX_MAC</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span>
			<span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_CZ_ETHERNET_FULL_SEARCH_LIMIT</span><span class="p">,</span>
			<span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">EFX_FILTER_MAC_FULL</span><span class="p">]</span> <span class="o">+</span>
			<span class="n">FILTER_CTL_SRCH_FUDGE_FULL</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span>
			<span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_CZ_ETHERNET_WILDCARD_SEARCH_LIMIT</span><span class="p">,</span>
			<span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">EFX_FILTER_MAC_WILD</span><span class="p">]</span> <span class="o">+</span>
			<span class="n">FILTER_CTL_SRCH_FUDGE_WILD</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span>
			<span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_CZ_UNICAST_NOMATCH_Q_ID</span><span class="p">,</span>
			<span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">EFX_FILTER_INDEX_UC_DEF</span><span class="p">].</span><span class="n">dmaq_id</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span>
			<span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_CZ_UNICAST_NOMATCH_RSS_ENABLED</span><span class="p">,</span>
			<span class="o">!!</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">EFX_FILTER_INDEX_UC_DEF</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span>
			   <span class="n">EFX_FILTER_FLAG_RX_RSS</span><span class="p">));</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span>
			<span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_CZ_UNICAST_NOMATCH_IP_OVERRIDE</span><span class="p">,</span>
			<span class="o">!!</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">EFX_FILTER_INDEX_UC_DEF</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span>
			   <span class="n">EFX_FILTER_FLAG_RX_OVERRIDE_IP</span><span class="p">));</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span>
			<span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_CZ_MULTICAST_NOMATCH_Q_ID</span><span class="p">,</span>
			<span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">EFX_FILTER_INDEX_MC_DEF</span><span class="p">].</span><span class="n">dmaq_id</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span>
			<span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_CZ_MULTICAST_NOMATCH_RSS_ENABLED</span><span class="p">,</span>
			<span class="o">!!</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">EFX_FILTER_INDEX_MC_DEF</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span>
			   <span class="n">EFX_FILTER_FLAG_RX_RSS</span><span class="p">));</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span>
			<span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FRF_CZ_MULTICAST_NOMATCH_IP_OVERRIDE</span><span class="p">,</span>
			<span class="o">!!</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">EFX_FILTER_INDEX_MC_DEF</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span>
			   <span class="n">EFX_FILTER_FLAG_RX_OVERRIDE_IP</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter_ctl</span><span class="p">,</span> <span class="n">FR_BZ_RX_FILTER_CTL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_filter_push_tx_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">tx_cfg</span><span class="p">;</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_cfg</span><span class="p">,</span> <span class="n">FR_AZ_TX_CFG</span><span class="p">);</span>

	<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_TX_MAC</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span>
			<span class="n">tx_cfg</span><span class="p">,</span> <span class="n">FRF_CZ_TX_ETH_FILTER_FULL_SEARCH_RANGE</span><span class="p">,</span>
			<span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">EFX_FILTER_MAC_FULL</span><span class="p">]</span> <span class="o">+</span>
			<span class="n">FILTER_CTL_SRCH_FUDGE_FULL</span><span class="p">);</span>
		<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span>
			<span class="n">tx_cfg</span><span class="p">,</span> <span class="n">FRF_CZ_TX_ETH_FILTER_WILD_SEARCH_RANGE</span><span class="p">,</span>
			<span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">EFX_FILTER_MAC_WILD</span><span class="p">]</span> <span class="o">+</span>
			<span class="n">FILTER_CTL_SRCH_FUDGE_WILD</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_cfg</span><span class="p">,</span> <span class="n">FR_AZ_TX_CFG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__efx_filter_set_ipv4</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">,</span>
					 <span class="n">__be32</span> <span class="n">host1</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">port1</span><span class="p">,</span>
					 <span class="n">__be32</span> <span class="n">host2</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">port2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">host1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">port1</span><span class="p">);</span>
	<span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">port2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">host1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">host2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__efx_filter_get_ipv4</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">,</span>
					 <span class="n">__be32</span> <span class="o">*</span><span class="n">host1</span><span class="p">,</span> <span class="n">__be16</span> <span class="o">*</span><span class="n">port1</span><span class="p">,</span>
					 <span class="n">__be32</span> <span class="o">*</span><span class="n">host2</span><span class="p">,</span> <span class="n">__be16</span> <span class="o">*</span><span class="n">port2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">host1</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="o">*</span><span class="n">port1</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="o">*</span><span class="n">host2</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="o">*</span><span class="n">port2</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * efx_filter_set_ipv4_local - specify IPv4 host, transport protocol and port</span>
<span class="cm"> * @spec: Specification to initialise</span>
<span class="cm"> * @proto: Transport layer protocol number</span>
<span class="cm"> * @host: Local host address (network byte order)</span>
<span class="cm"> * @port: Local port (network byte order)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">efx_filter_set_ipv4_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">,</span> <span class="n">u8</span> <span class="n">proto</span><span class="p">,</span>
			      <span class="n">__be32</span> <span class="n">host</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">host1</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">port1</span><span class="p">;</span>

	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_RX</span><span class="p">));</span>

	<span class="cm">/* This cannot currently be combined with other filtering */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">EFX_FILTER_UNSPEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">proto</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPPROTO_TCP</span>:
		<span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">EFX_FILTER_TCP_WILD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_UDP</span>:
		<span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">EFX_FILTER_UDP_WILD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Filter is constructed in terms of source and destination,</span>
<span class="cm">	 * with the odd wrinkle that the ports are swapped in a UDP</span>
<span class="cm">	 * wildcard filter.  We need to convert from local and remote</span>
<span class="cm">	 * (= zero for wildcard) addresses.</span>
<span class="cm">	 */</span>
	<span class="n">host1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proto</span> <span class="o">!=</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">port1</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
		<span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__efx_filter_set_ipv4</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">host1</span><span class="p">,</span> <span class="n">port1</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_filter_get_ipv4_local</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">,</span>
			      <span class="n">u8</span> <span class="o">*</span><span class="n">proto</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">__be16</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">host1</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">port1</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EFX_FILTER_TCP_WILD</span>:
		<span class="o">*</span><span class="n">proto</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>
		<span class="n">__efx_filter_get_ipv4</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port1</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EFX_FILTER_UDP_WILD</span>:
		<span class="o">*</span><span class="n">proto</span> <span class="o">=</span> <span class="n">IPPROTO_UDP</span><span class="p">;</span>
		<span class="n">__efx_filter_get_ipv4</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host1</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * efx_filter_set_ipv4_full - specify IPv4 hosts, transport protocol and ports</span>
<span class="cm"> * @spec: Specification to initialise</span>
<span class="cm"> * @proto: Transport layer protocol number</span>
<span class="cm"> * @host: Local host address (network byte order)</span>
<span class="cm"> * @port: Local port (network byte order)</span>
<span class="cm"> * @rhost: Remote host address (network byte order)</span>
<span class="cm"> * @rport: Remote port (network byte order)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">efx_filter_set_ipv4_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">,</span> <span class="n">u8</span> <span class="n">proto</span><span class="p">,</span>
			     <span class="n">__be32</span> <span class="n">host</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">port</span><span class="p">,</span>
			     <span class="n">__be32</span> <span class="n">rhost</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">rport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_RX</span><span class="p">));</span>

	<span class="cm">/* This cannot currently be combined with other filtering */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">EFX_FILTER_UNSPEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rport</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">proto</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPPROTO_TCP</span>:
		<span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">EFX_FILTER_TCP_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_UDP</span>:
		<span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">EFX_FILTER_UDP_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__efx_filter_set_ipv4</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">rhost</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_filter_get_ipv4_full</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">,</span>
			     <span class="n">u8</span> <span class="o">*</span><span class="n">proto</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">__be16</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
			     <span class="n">__be32</span> <span class="o">*</span><span class="n">rhost</span><span class="p">,</span> <span class="n">__be16</span> <span class="o">*</span><span class="n">rport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EFX_FILTER_TCP_FULL</span>:
		<span class="o">*</span><span class="n">proto</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EFX_FILTER_UDP_FULL</span>:
		<span class="o">*</span><span class="n">proto</span> <span class="o">=</span> <span class="n">IPPROTO_UDP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__efx_filter_get_ipv4</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">rhost</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * efx_filter_set_eth_local - specify local Ethernet address and optional VID</span>
<span class="cm"> * @spec: Specification to initialise</span>
<span class="cm"> * @vid: VLAN ID to match, or %EFX_FILTER_VID_UNSPEC</span>
<span class="cm"> * @addr: Local Ethernet MAC address</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">efx_filter_set_eth_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="n">vid</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
			      <span class="p">(</span><span class="n">EFX_FILTER_FLAG_RX</span> <span class="o">|</span> <span class="n">EFX_FILTER_FLAG_TX</span><span class="p">)));</span>

	<span class="cm">/* This cannot currently be combined with other filtering */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">EFX_FILTER_UNSPEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vid</span> <span class="o">==</span> <span class="n">EFX_FILTER_VID_UNSPEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">EFX_FILTER_MAC_WILD</span><span class="p">;</span>
		<span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">EFX_FILTER_MAC_FULL</span><span class="p">;</span>
		<span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * efx_filter_set_uc_def - specify matching otherwise-unmatched unicast</span>
<span class="cm"> * @spec: Specification to initialise</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">efx_filter_set_uc_def</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
			      <span class="p">(</span><span class="n">EFX_FILTER_FLAG_RX</span> <span class="o">|</span> <span class="n">EFX_FILTER_FLAG_TX</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">EFX_FILTER_UNSPEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">EFX_FILTER_UC_DEF</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span> <span class="cm">/* ensure equality */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * efx_filter_set_mc_def - specify matching otherwise-unmatched multicast</span>
<span class="cm"> * @spec: Specification to initialise</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">efx_filter_set_mc_def</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
			      <span class="p">(</span><span class="n">EFX_FILTER_FLAG_RX</span> <span class="o">|</span> <span class="n">EFX_FILTER_FLAG_TX</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">EFX_FILTER_UNSPEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">EFX_FILTER_MC_DEF</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span> <span class="cm">/* ensure equality */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_filter_reset_rx_def</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">filter_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">filter_idx</span><span class="p">];</span>

	<span class="n">efx_filter_init_rx</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">EFX_FILTER_PRI_MANUAL</span><span class="p">,</span>
			   <span class="n">EFX_FILTER_FLAG_RX_RSS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">EFX_FILTER_UC_DEF</span> <span class="o">+</span> <span class="n">filter_idx</span><span class="p">;</span>
	<span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">filter_idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_filter_get_eth_local</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="o">*</span><span class="n">vid</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EFX_FILTER_MAC_WILD</span>:
		<span class="o">*</span><span class="n">vid</span> <span class="o">=</span> <span class="n">EFX_FILTER_VID_UNSPEC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EFX_FILTER_MAC_FULL</span>:
		<span class="o">*</span><span class="n">vid</span> <span class="o">=</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Build a filter entry and return its n-tuple key. */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">efx_filter_build</span><span class="p">(</span><span class="n">efx_oword_t</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data3</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">efx_filter_spec_table_id</span><span class="p">(</span><span class="n">spec</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EFX_FILTER_TABLE_RX_IP</span>: <span class="p">{</span>
		<span class="n">bool</span> <span class="n">is_udp</span> <span class="o">=</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFX_FILTER_UDP_FULL</span> <span class="o">||</span>
			       <span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFX_FILTER_UDP_WILD</span><span class="p">);</span>
		<span class="n">EFX_POPULATE_OWORD_7</span><span class="p">(</span>
			<span class="o">*</span><span class="n">filter</span><span class="p">,</span>
			<span class="n">FRF_BZ_RSS_EN</span><span class="p">,</span>
			<span class="o">!!</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_RX_RSS</span><span class="p">),</span>
			<span class="n">FRF_BZ_SCATTER_EN</span><span class="p">,</span>
			<span class="o">!!</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_RX_SCATTER</span><span class="p">),</span>
			<span class="n">FRF_BZ_TCP_UDP</span><span class="p">,</span> <span class="n">is_udp</span><span class="p">,</span>
			<span class="n">FRF_BZ_RXQ_ID</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">dmaq_id</span><span class="p">,</span>
			<span class="n">EFX_DWORD_2</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
			<span class="n">EFX_DWORD_1</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="n">EFX_DWORD_0</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">data3</span> <span class="o">=</span> <span class="n">is_udp</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">EFX_FILTER_TABLE_RX_DEF</span>:
		<span class="cm">/* One filter spec per type */</span>
		<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_FILTER_INDEX_UC_DEF</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_FILTER_INDEX_MC_DEF</span> <span class="o">!=</span>
			     <span class="n">EFX_FILTER_MC_DEF</span> <span class="o">-</span> <span class="n">EFX_FILTER_UC_DEF</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">-</span> <span class="n">EFX_FILTER_UC_DEF</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">EFX_FILTER_TABLE_RX_MAC</span>: <span class="p">{</span>
		<span class="n">bool</span> <span class="n">is_wild</span> <span class="o">=</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFX_FILTER_MAC_WILD</span><span class="p">;</span>
		<span class="n">EFX_POPULATE_OWORD_8</span><span class="p">(</span>
			<span class="o">*</span><span class="n">filter</span><span class="p">,</span>
			<span class="n">FRF_CZ_RMFT_RSS_EN</span><span class="p">,</span>
			<span class="o">!!</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_RX_RSS</span><span class="p">),</span>
			<span class="n">FRF_CZ_RMFT_SCATTER_EN</span><span class="p">,</span>
			<span class="o">!!</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_RX_SCATTER</span><span class="p">),</span>
			<span class="n">FRF_CZ_RMFT_IP_OVERRIDE</span><span class="p">,</span>
			<span class="o">!!</span><span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_RX_OVERRIDE_IP</span><span class="p">),</span>
			<span class="n">FRF_CZ_RMFT_RXQ_ID</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">dmaq_id</span><span class="p">,</span>
			<span class="n">FRF_CZ_RMFT_WILDCARD_MATCH</span><span class="p">,</span> <span class="n">is_wild</span><span class="p">,</span>
			<span class="n">FRF_CZ_RMFT_DEST_MAC_HI</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
			<span class="n">FRF_CZ_RMFT_DEST_MAC_LO</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="n">FRF_CZ_RMFT_VLAN_ID</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">data3</span> <span class="o">=</span> <span class="n">is_wild</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">EFX_FILTER_TABLE_TX_MAC</span>: <span class="p">{</span>
		<span class="n">bool</span> <span class="n">is_wild</span> <span class="o">=</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFX_FILTER_MAC_WILD</span><span class="p">;</span>
		<span class="n">EFX_POPULATE_OWORD_5</span><span class="p">(</span><span class="o">*</span><span class="n">filter</span><span class="p">,</span>
				     <span class="n">FRF_CZ_TMFT_TXQ_ID</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">dmaq_id</span><span class="p">,</span>
				     <span class="n">FRF_CZ_TMFT_WILDCARD_MATCH</span><span class="p">,</span> <span class="n">is_wild</span><span class="p">,</span>
				     <span class="n">FRF_CZ_TMFT_SRC_MAC_HI</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
				     <span class="n">FRF_CZ_TMFT_SRC_MAC_LO</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
				     <span class="n">FRF_CZ_TMFT_VLAN_ID</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">data3</span> <span class="o">=</span> <span class="n">is_wild</span> <span class="o">|</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">dmaq_id</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^</span> <span class="n">data3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">efx_filter_equal</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">||</span>
	    <span class="n">memcmp</span><span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_TX</span> <span class="o">&amp;&amp;</span>
	    <span class="n">left</span><span class="o">-&gt;</span><span class="n">dmaq_id</span> <span class="o">!=</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">dmaq_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_filter_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">for_insert</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">depth_required</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">hash</span><span class="p">,</span> <span class="n">incr</span><span class="p">,</span> <span class="n">filter_idx</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">depth_max</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">efx_filter_hash</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="n">incr</span> <span class="o">=</span> <span class="n">efx_filter_increment</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="n">filter_idx</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">depth_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">for_insert</span> <span class="o">?</span>
		     <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&lt;=</span> <span class="n">EFX_FILTER_PRI_HINT</span> <span class="o">?</span>
		      <span class="n">FILTER_CTL_SRCH_HINT_MAX</span> <span class="o">:</span> <span class="n">FILTER_CTL_SRCH_MAX</span><span class="p">)</span> <span class="o">:</span>
		     <span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/* Return success if entry is used and matches this spec</span>
<span class="cm">		 * or entry is unused and we are trying to insert.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">filter_idx</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">efx_filter_equal</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">filter_idx</span><span class="p">])</span> <span class="o">:</span>
		    <span class="n">for_insert</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">depth_required</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">filter_idx</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Return failure if we reached the maximum search depth */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">depth_max</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">for_insert</span> <span class="o">?</span> <span class="o">-</span><span class="n">EBUSY</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

		<span class="n">filter_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">filter_idx</span> <span class="o">+</span> <span class="n">incr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="o">++</span><span class="n">depth</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Construct/deconstruct external filter IDs.  These must be ordered</span>
<span class="cm"> * by matching priority, for RX NFC semantics.</span>
<span class="cm"> *</span>
<span class="cm"> * Each RX MAC filter entry has a flag for whether it can override an</span>
<span class="cm"> * RX IP filter that also matches.  So we assign locations for MAC</span>
<span class="cm"> * filters with overriding behaviour, then for IP filters, then for</span>
<span class="cm"> * MAC filters without overriding behaviour.</span>
<span class="cm"> */</span>

<span class="cp">#define EFX_FILTER_MATCH_PRI_RX_MAC_OVERRIDE_IP	0</span>
<span class="cp">#define EFX_FILTER_MATCH_PRI_RX_DEF_OVERRIDE_IP	1</span>
<span class="cp">#define EFX_FILTER_MATCH_PRI_NORMAL_BASE	2</span>

<span class="cp">#define EFX_FILTER_INDEX_WIDTH	13</span>
<span class="cp">#define EFX_FILTER_INDEX_MASK	((1 &lt;&lt; EFX_FILTER_INDEX_WIDTH) - 1)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">efx_filter_make_id</span><span class="p">(</span><span class="k">enum</span> <span class="n">efx_filter_table_id</span> <span class="n">table_id</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">match_pri</span> <span class="o">=</span> <span class="n">EFX_FILTER_MATCH_PRI_NORMAL_BASE</span> <span class="o">+</span> <span class="n">table_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_RX_OVERRIDE_IP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table_id</span> <span class="o">==</span> <span class="n">EFX_FILTER_TABLE_RX_MAC</span><span class="p">)</span>
			<span class="n">match_pri</span> <span class="o">=</span> <span class="n">EFX_FILTER_MATCH_PRI_RX_MAC_OVERRIDE_IP</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">table_id</span> <span class="o">==</span> <span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">)</span>
			<span class="n">match_pri</span> <span class="o">=</span> <span class="n">EFX_FILTER_MATCH_PRI_RX_DEF_OVERRIDE_IP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">match_pri</span> <span class="o">&lt;&lt;</span> <span class="n">EFX_FILTER_INDEX_WIDTH</span> <span class="o">|</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">efx_filter_table_id</span> <span class="nf">efx_filter_id_table_id</span><span class="p">(</span><span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">match_pri</span> <span class="o">=</span> <span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">EFX_FILTER_INDEX_WIDTH</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">match_pri</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EFX_FILTER_MATCH_PRI_RX_MAC_OVERRIDE_IP</span>:
		<span class="k">return</span> <span class="n">EFX_FILTER_TABLE_RX_MAC</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EFX_FILTER_MATCH_PRI_RX_DEF_OVERRIDE_IP</span>:
		<span class="k">return</span> <span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">match_pri</span> <span class="o">-</span> <span class="n">EFX_FILTER_MATCH_PRI_NORMAL_BASE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">efx_filter_id_index</span><span class="p">(</span><span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">id</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_INDEX_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">efx_filter_id_flags</span><span class="p">(</span><span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">match_pri</span> <span class="o">=</span> <span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">EFX_FILTER_INDEX_WIDTH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">match_pri</span> <span class="o">&lt;</span> <span class="n">EFX_FILTER_MATCH_PRI_NORMAL_BASE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EFX_FILTER_FLAG_RX</span> <span class="o">|</span> <span class="n">EFX_FILTER_FLAG_RX_OVERRIDE_IP</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">match_pri</span> <span class="o">&lt;=</span>
		 <span class="n">EFX_FILTER_MATCH_PRI_NORMAL_BASE</span> <span class="o">+</span> <span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EFX_FILTER_FLAG_RX</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">EFX_FILTER_FLAG_TX</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u32</span> <span class="nf">efx_filter_get_rx_id_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">table_id</span> <span class="o">=</span> <span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">table_id</span><span class="p">].</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">((</span><span class="n">EFX_FILTER_MATCH_PRI_NORMAL_BASE</span> <span class="o">+</span> <span class="n">table_id</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="n">EFX_FILTER_INDEX_WIDTH</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">table_id</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">table_id</span><span class="o">--</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * efx_filter_insert_filter - add or replace a filter</span>
<span class="cm"> * @efx: NIC in which to insert the filter</span>
<span class="cm"> * @spec: Specification for the filter</span>
<span class="cm"> * @replace: Flag for whether the specified filter may replace a filter</span>
<span class="cm"> *	with an identical match expression and equal or lower priority</span>
<span class="cm"> *</span>
<span class="cm"> * On success, return the filter ID.</span>
<span class="cm"> * On failure, return a negative error code.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">efx_filter_insert_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">replace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="n">efx_filter_spec_table</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">spec</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">saved_spec</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">filter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter_idx</span><span class="p">,</span> <span class="n">depth</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span> <span class="o">||</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">efx_filter_build</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span> <span class="n">spec</span><span class="p">);</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;%s: type %d search_depth=%d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
		   <span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_filter_search</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">depth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">filter_idx</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">filter_idx</span> <span class="o">&gt;=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">saved_spec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">filter_idx</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">filter_idx</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Should we replace the existing filter? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">replace</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">saved_spec</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">filter_idx</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">);</span>
		<span class="o">++</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">saved_spec</span> <span class="o">=</span> <span class="o">*</span><span class="n">spec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_filter_push_rx_config</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">table</span><span class="o">-&gt;</span><span class="n">search_depth</span><span class="p">[</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_TX</span><span class="p">)</span>
				<span class="n">efx_filter_push_tx_limits</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">efx_filter_push_rx_config</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span>
			   <span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">step</span> <span class="o">*</span> <span class="n">filter_idx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netif_vdbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;%s: filter type %d index %d rxq %u set&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">filter_idx</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">dmaq_id</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_filter_make_id</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">filter_idx</span><span class="p">,</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_filter_table_clear_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">efx_oword_t</span> <span class="n">filter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* RX default filters must always exist */</span>
		<span class="n">efx_filter_reset_rx_def</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">filter_idx</span><span class="p">);</span>
		<span class="n">efx_filter_push_rx_config</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">filter_idx</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">filter_idx</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">);</span>
		<span class="o">--</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">filter_idx</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

		<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span>
			   <span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">step</span> <span class="o">*</span> <span class="n">filter_idx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * efx_filter_remove_id_safe - remove a filter by ID, carefully</span>
<span class="cm"> * @efx: NIC from which to remove the filter</span>
<span class="cm"> * @priority: Priority of filter, as passed to @efx_filter_insert_filter</span>
<span class="cm"> * @filter_id: ID of filter, as returned by @efx_filter_insert_filter</span>
<span class="cm"> *</span>
<span class="cm"> * This function will range-check @filter_id, so it is safe to call</span>
<span class="cm"> * with a value passed from userland.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">efx_filter_remove_id_safe</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">efx_filter_priority</span> <span class="n">priority</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">filter_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">efx_filter_table_id</span> <span class="n">table_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">filter_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">table_id</span> <span class="o">=</span> <span class="n">efx_filter_id_table_id</span><span class="p">(</span><span class="n">filter_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">table_id</span> <span class="o">&gt;=</span> <span class="n">EFX_FILTER_TABLE_COUNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">table_id</span><span class="p">];</span>

	<span class="n">filter_idx</span> <span class="o">=</span> <span class="n">efx_filter_id_index</span><span class="p">(</span><span class="n">filter_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter_idx</span> <span class="o">&gt;=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">spec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">filter_idx</span><span class="p">];</span>

	<span class="n">filter_flags</span> <span class="o">=</span> <span class="n">efx_filter_id_flags</span><span class="p">(</span><span class="n">filter_id</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">filter_idx</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">spec</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">==</span> <span class="n">priority</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">((</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">^</span> <span class="n">filter_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_RX_OVERRIDE_IP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">efx_filter_table_clear_entry</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">filter_idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">efx_filter_table_reset_search_depth</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * efx_filter_get_filter_safe - retrieve a filter by ID, carefully</span>
<span class="cm"> * @efx: NIC from which to remove the filter</span>
<span class="cm"> * @priority: Priority of filter, as passed to @efx_filter_insert_filter</span>
<span class="cm"> * @filter_id: ID of filter, as returned by @efx_filter_insert_filter</span>
<span class="cm"> * @spec: Buffer in which to store filter specification</span>
<span class="cm"> *</span>
<span class="cm"> * This function will range-check @filter_id, so it is safe to call</span>
<span class="cm"> * with a value passed from userland.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">efx_filter_get_filter_safe</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">efx_filter_priority</span> <span class="n">priority</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">filter_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">efx_filter_table_id</span> <span class="n">table_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="o">*</span><span class="n">spec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">filter_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">table_id</span> <span class="o">=</span> <span class="n">efx_filter_id_table_id</span><span class="p">(</span><span class="n">filter_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">table_id</span> <span class="o">&gt;=</span> <span class="n">EFX_FILTER_TABLE_COUNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">table_id</span><span class="p">];</span>

	<span class="n">filter_idx</span> <span class="o">=</span> <span class="n">efx_filter_id_index</span><span class="p">(</span><span class="n">filter_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter_idx</span> <span class="o">&gt;=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">spec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">filter_idx</span><span class="p">];</span>

	<span class="n">filter_flags</span> <span class="o">=</span> <span class="n">efx_filter_id_flags</span><span class="p">(</span><span class="n">filter_id</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">filter_idx</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">spec</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">==</span> <span class="n">priority</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">((</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">^</span> <span class="n">filter_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EFX_FILTER_FLAG_RX_OVERRIDE_IP</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">spec_buf</span> <span class="o">=</span> <span class="o">*</span><span class="n">spec</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_filter_table_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">efx_filter_table_id</span> <span class="n">table_id</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">efx_filter_priority</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">table_id</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter_idx</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">filter_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">filter_idx</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">filter_idx</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">filter_idx</span><span class="p">].</span><span class="n">priority</span> <span class="o">&lt;=</span> <span class="n">priority</span><span class="p">)</span>
			<span class="n">efx_filter_table_clear_entry</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">filter_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">efx_filter_table_reset_search_depth</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * efx_filter_clear_rx - remove RX filters by priority</span>
<span class="cm"> * @efx: NIC from which to remove the filters</span>
<span class="cm"> * @priority: Maximum priority to remove</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">efx_filter_clear_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">efx_filter_priority</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_filter_table_clear</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">EFX_FILTER_TABLE_RX_IP</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
	<span class="n">efx_filter_table_clear</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">EFX_FILTER_TABLE_RX_MAC</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u32</span> <span class="nf">efx_filter_count_rx_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">efx_filter_priority</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">efx_filter_table_id</span> <span class="n">table_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">table_id</span> <span class="o">=</span> <span class="n">EFX_FILTER_TABLE_RX_IP</span><span class="p">;</span>
	     <span class="n">table_id</span> <span class="o">&lt;=</span> <span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">;</span>
	     <span class="n">table_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">table_id</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">filter_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">filter_idx</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">filter_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">filter_idx</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">filter_idx</span><span class="p">].</span><span class="n">priority</span> <span class="o">==</span> <span class="n">priority</span><span class="p">)</span>
				<span class="o">++</span><span class="n">count</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">s32</span> <span class="nf">efx_filter_get_rx_ids</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">efx_filter_priority</span> <span class="n">priority</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">efx_filter_table_id</span> <span class="n">table_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter_idx</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">table_id</span> <span class="o">=</span> <span class="n">EFX_FILTER_TABLE_RX_IP</span><span class="p">;</span>
	     <span class="n">table_id</span> <span class="o">&lt;=</span> <span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">;</span>
	     <span class="n">table_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">table_id</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">filter_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">filter_idx</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">filter_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">filter_idx</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">filter_idx</span><span class="p">].</span><span class="n">priority</span> <span class="o">==</span> <span class="n">priority</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">buf</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">efx_filter_make_id</span><span class="p">(</span>
					<span class="n">table_id</span><span class="p">,</span> <span class="n">filter_idx</span><span class="p">,</span>
					<span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">filter_idx</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Restore filter stater after reset */</span>
<span class="kt">void</span> <span class="nf">efx_restore_filters</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">efx_filter_table_id</span> <span class="n">table_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">filter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter_idx</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">table_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table_id</span> <span class="o">&lt;</span> <span class="n">EFX_FILTER_TABLE_COUNT</span><span class="p">;</span> <span class="n">table_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">table_id</span><span class="p">];</span>

		<span class="cm">/* Check whether this is a regular register table */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">filter_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">filter_idx</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">filter_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">filter_idx</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">efx_filter_build</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">filter_idx</span><span class="p">]);</span>
			<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span>
				   <span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">step</span> <span class="o">*</span> <span class="n">filter_idx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">efx_filter_push_rx_config</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_filter_push_tx_limits</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_probe_filters</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">table_id</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_FALCON_B0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">rps_flow_id</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">FR_BZ_RX_FILTER_TBL0_ROWS</span><span class="p">,</span>
					     <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rps_flow_id</span><span class="p">),</span>
					     <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rps_flow_id</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_RX_IP</span><span class="p">];</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">EFX_FILTER_TABLE_RX_IP</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">FR_BZ_RX_FILTER_TBL0</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">FR_BZ_RX_FILTER_TBL0_ROWS</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">step</span> <span class="o">=</span> <span class="n">FR_BZ_RX_FILTER_TBL0_STEP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">EFX_REV_SIENA_A0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_RX_MAC</span><span class="p">];</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">EFX_FILTER_TABLE_RX_MAC</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">FR_CZ_RX_MAC_FILTER_TBL0</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">FR_CZ_RX_MAC_FILTER_TBL0_ROWS</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">step</span> <span class="o">=</span> <span class="n">FR_CZ_RX_MAC_FILTER_TBL0_STEP</span><span class="p">;</span>

		<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">];</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">EFX_FILTER_SIZE_RX_DEF</span><span class="p">;</span>

		<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_TX_MAC</span><span class="p">];</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">EFX_FILTER_TABLE_TX_MAC</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">FR_CZ_TX_MAC_FILTER_TBL0</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">FR_CZ_TX_MAC_FILTER_TBL0_ROWS</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">step</span> <span class="o">=</span> <span class="n">FR_CZ_TX_MAC_FILTER_TBL0_STEP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">table_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table_id</span> <span class="o">&lt;</span> <span class="n">EFX_FILTER_TABLE_COUNT</span><span class="p">;</span> <span class="n">table_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">table_id</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">),</span>
					     <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
					     <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_RX_DEF</span><span class="p">].</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* RX default filters must always exist */</span>
		<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EFX_FILTER_SIZE_RX_DEF</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">efx_filter_reset_rx_def</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efx_filter_push_rx_config</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">efx_remove_filters</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_remove_filters</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">efx_filter_table_id</span> <span class="n">table_id</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">table_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table_id</span> <span class="o">&lt;</span> <span class="n">EFX_FILTER_TABLE_COUNT</span><span class="p">;</span> <span class="n">table_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">table_id</span><span class="p">].</span><span class="n">used_bitmap</span><span class="p">);</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">table_id</span><span class="p">].</span><span class="n">spec</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rps_flow_id</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>

<span class="kt">int</span> <span class="nf">efx_filter_rfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		   <span class="n">u16</span> <span class="n">rxq_index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flow_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_spec</span> <span class="n">spec</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">__be16</span> <span class="o">*</span><span class="n">ports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nhoff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">nhoff</span> <span class="o">=</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

	<span class="cm">/* RFS must validate the IP header length before calling us */</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nhoff</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ip</span><span class="p">));</span>
	<span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">nhoff</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip_is_fragment</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nhoff</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ports</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">__be16</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">nhoff</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">);</span>

	<span class="n">efx_filter_init_rx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spec</span><span class="p">,</span> <span class="n">EFX_FILTER_PRI_HINT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rxq_index</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_filter_set_ipv4_full</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spec</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">,</span>
				      <span class="n">ip</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">ports</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_filter_insert_filter</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spec</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Remember this so we can check whether to expire the filter later */</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">rps_flow_id</span><span class="p">[</span><span class="n">rc</span><span class="p">]</span> <span class="o">=</span> <span class="n">flow_id</span><span class="p">;</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">efx_get_channel</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">skb_get_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="o">++</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">rfs_filters_added</span><span class="p">;</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">rx_status</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		   <span class="s">&quot;steering %s %pI4:%u:%pI4:%u to queue %u [flow %u filter %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;TCP&quot;</span> <span class="o">:</span> <span class="s">&quot;UDP&quot;</span><span class="p">,</span>
		   <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ports</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
		   <span class="n">rxq_index</span><span class="p">,</span> <span class="n">flow_id</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">__efx_filter_rfs_expire</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">quota</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_filter_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">filter_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_filter_table</span> <span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">EFX_FILTER_TABLE_RX_IP</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">stop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">rps_expire_index</span><span class="p">;</span>
	<span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">quota</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">used_bitmap</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">priority</span> <span class="o">==</span> <span class="n">EFX_FILTER_PRI_HINT</span> <span class="o">&amp;&amp;</span>
		    <span class="n">rps_may_expire_flow</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
					<span class="n">table</span><span class="o">-&gt;</span><span class="n">spec</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">dmaq_id</span><span class="p">,</span>
					<span class="n">state</span><span class="o">-&gt;</span><span class="n">rps_flow_id</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">rx_status</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				   <span class="s">&quot;expiring filter %d [flow %u]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">index</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">rps_flow_id</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
			<span class="n">efx_filter_table_clear_entry</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">state</span><span class="o">-&gt;</span><span class="n">rps_expire_index</span> <span class="o">=</span> <span class="n">stop</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">efx_filter_table_reset_search_depth</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_RFS_ACCEL */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
