<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › siena.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>siena.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2005-2006 Fen Systems Ltd.</span>
<span class="cm"> * Copyright 2006-2010 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &quot;net_driver.h&quot;</span>
<span class="cp">#include &quot;bitfield.h&quot;</span>
<span class="cp">#include &quot;efx.h&quot;</span>
<span class="cp">#include &quot;nic.h&quot;</span>
<span class="cp">#include &quot;spi.h&quot;</span>
<span class="cp">#include &quot;regs.h&quot;</span>
<span class="cp">#include &quot;io.h&quot;</span>
<span class="cp">#include &quot;phy.h&quot;</span>
<span class="cp">#include &quot;workarounds.h&quot;</span>
<span class="cp">#include &quot;mcdi.h&quot;</span>
<span class="cp">#include &quot;mcdi_pcol.h&quot;</span>

<span class="cm">/* Hardware control for SFC9000 family including SFL9021 (aka Siena). */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">siena_init_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">siena_push_irq_moderation</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_dword_t</span> <span class="n">timer_cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_moderation</span><span class="p">)</span>
		<span class="n">EFX_POPULATE_DWORD_2</span><span class="p">(</span><span class="n">timer_cmd</span><span class="p">,</span>
				     <span class="n">FRF_CZ_TC_TIMER_MODE</span><span class="p">,</span>
				     <span class="n">FFE_CZ_TIMER_MODE_INT_HLDOFF</span><span class="p">,</span>
				     <span class="n">FRF_CZ_TC_TIMER_VAL</span><span class="p">,</span>
				     <span class="n">channel</span><span class="o">-&gt;</span><span class="n">irq_moderation</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">EFX_POPULATE_DWORD_2</span><span class="p">(</span><span class="n">timer_cmd</span><span class="p">,</span>
				     <span class="n">FRF_CZ_TC_TIMER_MODE</span><span class="p">,</span>
				     <span class="n">FFE_CZ_TIMER_MODE_DIS</span><span class="p">,</span>
				     <span class="n">FRF_CZ_TC_TIMER_VAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">efx_writed_page_locked</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_cmd</span><span class="p">,</span> <span class="n">FR_BZ_TIMER_COMMAND_P0</span><span class="p">,</span>
			       <span class="n">channel</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">siena_mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">prtad</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devad</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_mdio_write</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio_bus</span><span class="p">,</span> <span class="n">prtad</span><span class="p">,</span> <span class="n">devad</span><span class="p">,</span>
				 <span class="n">addr</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">MC_CMD_MDIO_STATUS_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">siena_mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">prtad</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devad</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">uint16_t</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_mdio_read</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio_bus</span><span class="p">,</span> <span class="n">prtad</span><span class="p">,</span> <span class="n">devad</span><span class="p">,</span>
				<span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">MC_CMD_MDIO_STATUS_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This call is responsible for hooking in the MAC and PHY operations */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">siena_probe_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Hook in PHY operations table */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx_mcdi_phy_ops</span><span class="p">;</span>

	<span class="cm">/* Set up MDIO structure for PHY */</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">mode_support</span> <span class="o">=</span> <span class="n">MDIO_SUPPORTS_C45</span> <span class="o">|</span> <span class="n">MDIO_EMULATE_C22</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">mdio_read</span> <span class="o">=</span> <span class="n">siena_mdio_read</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">mdio_write</span> <span class="o">=</span> <span class="n">siena_mdio_write</span><span class="p">;</span>

	<span class="cm">/* Fill out MDIO structure, loopback modes, and initial link state */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Allocate buffer for stats */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_nic_alloc_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">,</span>
				  <span class="n">MC_CMD_MAC_NSTATS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;stats buffer at %llx (virt %p phys %llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span>
		  <span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">addr</span><span class="p">));</span>

	<span class="n">efx_mcdi_mac_stats</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">siena_remove_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_op</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_nic_free_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_register_test</span> <span class="n">siena_register_tests</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">FR_AZ_ADR_REGION</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x0003FFFF</span><span class="p">,</span> <span class="mh">0x0003FFFF</span><span class="p">,</span> <span class="mh">0x0003FFFF</span><span class="p">,</span> <span class="mh">0x0003FFFF</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_CZ_USR_EV_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x000103FF</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_RX_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0xFFFFFFFE</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0x0003FFFF</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_TX_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x7FFF0037</span><span class="p">,</span> <span class="mh">0xFFFF8000</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0x03FFFFFF</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_TX_RESERVED</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0xFFFEFE80</span><span class="p">,</span> <span class="mh">0x1FFFFFFF</span><span class="p">,</span> <span class="mh">0x020000FE</span><span class="p">,</span> <span class="mh">0x007FFFFF</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_SRM_TX_DC_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x001FFFFF</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_RX_DC_CFG</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x00000003</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_AZ_RX_DC_PF_WM</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x000003FF</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_BZ_DP_CTRL</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0x00000FFF</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_BZ_RX_RSS_TKEY</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_CZ_RX_RSS_IPV6_REG1</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_CZ_RX_RSS_IPV6_REG2</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">FR_CZ_RX_RSS_IPV6_REG3</span><span class="p">,</span>
	  <span class="n">EFX_OWORD32</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="mh">0x00000007</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">siena_test_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">efx_nic_test_registers</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">siena_register_tests</span><span class="p">,</span>
				      <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">siena_register_tests</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Device reset</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">reset_type</span> <span class="nf">siena_map_reset_reason</span><span class="p">(</span><span class="k">enum</span> <span class="n">reset_type</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">RESET_TYPE_ALL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">siena_map_reset_flags</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">SIENA_RESET_PORT</span> <span class="o">=</span> <span class="p">(</span><span class="n">ETH_RESET_DMA</span> <span class="o">|</span> <span class="n">ETH_RESET_FILTER</span> <span class="o">|</span>
				    <span class="n">ETH_RESET_OFFLOAD</span> <span class="o">|</span> <span class="n">ETH_RESET_MAC</span> <span class="o">|</span>
				    <span class="n">ETH_RESET_PHY</span><span class="p">),</span>
		<span class="n">SIENA_RESET_MC</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIENA_RESET_PORT</span> <span class="o">|</span>
				  <span class="n">ETH_RESET_MGMT</span> <span class="o">&lt;&lt;</span> <span class="n">ETH_RESET_SHARED_SHIFT</span><span class="p">),</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIENA_RESET_MC</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIENA_RESET_MC</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SIENA_RESET_MC</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">RESET_TYPE_WORLD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIENA_RESET_PORT</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIENA_RESET_PORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SIENA_RESET_PORT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">RESET_TYPE_ALL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* no invisible reset implemented */</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">siena_reset_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">reset_type</span> <span class="n">method</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Recover from a failed assertion pre-reset */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_handle_assertion</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="n">RESET_TYPE_WORLD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">efx_mcdi_reset_mc</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">efx_mcdi_reset_port</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">siena_probe_nvconfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">caps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_get_board_cfg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">caps</span><span class="p">);</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">timer_quantum_ns</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MC_CMD_CAPABILITIES_TURBO_ACTIVE_LBN</span><span class="p">))</span> <span class="o">?</span>
		<span class="mi">3072</span> <span class="o">:</span> <span class="mi">6144</span><span class="p">;</span> <span class="cm">/* 768 cycles */</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">siena_dimension_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Each port has a small block of internal SRAM dedicated to</span>
<span class="cm">	 * the buffer table and descriptor caches.  In theory we can</span>
<span class="cm">	 * map both blocks to one port, but we don&#39;t.</span>
<span class="cm">	 */</span>
	<span class="n">efx_nic_dimension_resources</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">FR_CZ_BUF_FULL_TBL_ROWS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">siena_probe_nic</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">siena_nic_data</span> <span class="o">*</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">already_attached</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">efx_oword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Allocate storage for hardware specific data */</span>
	<span class="n">nic_data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">siena_nic_data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nic_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">nic_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_fpga_ver</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;Siena FPGA not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">FR_AZ_CS_DEBUG</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_id</span> <span class="o">=</span> <span class="n">EFX_OWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">FRF_CZ_CS_PORT_NUM</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">efx_mcdi_init</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Recover from a failed assertion before probing */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_handle_assertion</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>

	<span class="cm">/* Let the BMC know that the driver is now in charge of link and</span>
<span class="cm">	 * filter settings. We must do this before we reset the NIC */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_drv_attach</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">already_attached</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;Unable to register driver with MCPU</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">already_attached</span><span class="p">)</span>
		<span class="cm">/* Not a fatal error */</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;Host already registered with MCPU</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Now we can reset the NIC */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">siena_reset_hw</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_ALL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;failed to reset NIC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">siena_init_wol</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* Allocate memory for INT_KER */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_nic_alloc_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_oword_t</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail4</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;INT_KER at %llx (virt %p phys %llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span>
		  <span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">.</span><span class="n">addr</span><span class="p">));</span>

	<span class="cm">/* Read in the non-volatile configuration */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">siena_probe_nvconfig</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;NVRAM is invalid therefore using defaults</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">PHY_TYPE_NONE</span><span class="p">;</span>
		<span class="n">efx</span><span class="o">-&gt;</span><span class="n">mdio</span><span class="p">.</span><span class="n">prtad</span> <span class="o">=</span> <span class="n">MDIO_PRTAD_NONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">fail5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_mon_probe</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail5</span><span class="p">;</span>

	<span class="n">efx_sriov_probe</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail5:</span>
	<span class="n">efx_nic_free_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">);</span>
<span class="nl">fail4:</span>
<span class="nl">fail3:</span>
	<span class="n">efx_mcdi_drv_attach</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">fail2:</span>
<span class="nl">fail1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This call performs hardware-specific global initialisation, such as</span>
<span class="cm"> * defining the descriptor cache sizes and number of RSS channels.</span>
<span class="cm"> * It does not set up any buffers, descriptor rings or event queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">siena_init_nic</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_oword_t</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Recover from a failed assertion post-reset */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_handle_assertion</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Squash TX of packets of 16 bytes or less */</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_TX_RESERVED</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_TX_FLUSH_MIN_LEN_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_TX_RESERVED</span><span class="p">);</span>

	<span class="cm">/* Do not enable TX_NO_EOP_DISC_EN, since it limits packets to 16</span>
<span class="cm">	 * descriptors (which is bad).</span>
<span class="cm">	 */</span>
	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_TX_CFG</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_AZ_TX_NO_EOP_DISC_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_CZ_TX_FILTER_EN_BIT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_TX_CFG</span><span class="p">);</span>

	<span class="n">efx_reado</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_RX_CFG</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_RX_DESC_PUSH_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_RX_INGR_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* Enable hash insertion. This is broken for the &#39;Falcon&#39; hash</span>
<span class="cm">	 * if IPv6 hashing is also enabled, so also select Toeplitz</span>
<span class="cm">	 * TCP/IPv4 and IPv4 hashes. */</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_RX_HASH_INSRT_HDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_RX_HASH_ALG</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">EFX_SET_OWORD_FIELD</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_RX_IP_HASH</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_AZ_RX_CFG</span><span class="p">);</span>

	<span class="cm">/* Set hash key for IPv4 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_hash_key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_BZ_RX_RSS_TKEY</span><span class="p">);</span>

	<span class="cm">/* Enable IPv6 RSS */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_hash_key</span><span class="p">)</span> <span class="o">&lt;</span>
		     <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">+</span> <span class="n">FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">||</span>
		     <span class="n">FRF_CZ_RX_RSS_IPV6_TKEY_HI_LBN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_hash_key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_CZ_RX_RSS_IPV6_REG1</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_hash_key</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_CZ_RX_RSS_IPV6_REG2</span><span class="p">);</span>
	<span class="n">EFX_POPULATE_OWORD_2</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_CZ_RX_RSS_IPV6_THASH_ENABLE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FRF_CZ_RX_RSS_IPV6_IP_THASH_ENABLE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">rx_hash_key</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span>
	       <span class="n">FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_CZ_RX_RSS_IPV6_REG3</span><span class="p">);</span>

	<span class="cm">/* Enable event logging */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_log_ctrl</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Set destination of both TX and RX Flush events */</span>
	<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_BZ_FLS_EVQ_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_BZ_DP_CTRL</span><span class="p">);</span>

	<span class="n">EFX_POPULATE_OWORD_1</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">FRF_CZ_USREV_DIS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">efx_writeo</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">FR_CZ_USR_EV_CFG</span><span class="p">);</span>

	<span class="n">efx_nic_init_common</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">siena_remove_nic</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_mcdi_mon_remove</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="n">efx_nic_free_buffer</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">);</span>

	<span class="n">siena_reset_hw</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_ALL</span><span class="p">);</span>

	<span class="cm">/* Relinquish the device back to the BMC */</span>
	<span class="n">efx_mcdi_drv_attach</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Tear down the private nic state */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">);</span>
	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define STATS_GENERATION_INVALID ((__force __le64)(-1))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">siena_try_update_nic_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le64</span> <span class="o">*</span><span class="n">dma_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_mac_stats</span> <span class="o">*</span><span class="n">mac_stats</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">generation_start</span><span class="p">,</span> <span class="n">generation_end</span><span class="p">;</span>

	<span class="n">mac_stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">mac_stats</span><span class="p">;</span>
	<span class="n">dma_stats</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">generation_end</span> <span class="o">=</span> <span class="n">dma_stats</span><span class="p">[</span><span class="n">MC_CMD_MAC_GENERATION_END</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">generation_end</span> <span class="o">==</span> <span class="n">STATS_GENERATION_INVALID</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rmb</span><span class="p">();</span>

<span class="cp">#define MAC_STAT(M, D) \</span>
<span class="cp">	mac_stats-&gt;M = le64_to_cpu(dma_stats[MC_CMD_MAC_ ## D])</span>

	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_bytes</span><span class="p">,</span> <span class="n">TX_BYTES</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_bad_bytes</span><span class="p">,</span> <span class="n">TX_BAD_BYTES</span><span class="p">);</span>
	<span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_good_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">-</span>
				    <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_bad_bytes</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_packets</span><span class="p">,</span> <span class="n">TX_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_bad</span><span class="p">,</span> <span class="n">TX_BAD_FCS_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_pause</span><span class="p">,</span> <span class="n">TX_PAUSE_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_control</span><span class="p">,</span> <span class="n">TX_CONTROL_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_unicast</span><span class="p">,</span> <span class="n">TX_UNICAST_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_multicast</span><span class="p">,</span> <span class="n">TX_MULTICAST_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_broadcast</span><span class="p">,</span> <span class="n">TX_BROADCAST_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_lt64</span><span class="p">,</span> <span class="n">TX_LT64_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_64</span><span class="p">,</span> <span class="n">TX_64_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_65_to_127</span><span class="p">,</span> <span class="n">TX_65_TO_127_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_128_to_255</span><span class="p">,</span> <span class="n">TX_128_TO_255_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_256_to_511</span><span class="p">,</span> <span class="n">TX_256_TO_511_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_512_to_1023</span><span class="p">,</span> <span class="n">TX_512_TO_1023_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_1024_to_15xx</span><span class="p">,</span> <span class="n">TX_1024_TO_15XX_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_15xx_to_jumbo</span><span class="p">,</span> <span class="n">TX_15XX_TO_JUMBO_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_gtjumbo</span><span class="p">,</span> <span class="n">TX_GTJUMBO_PKTS</span><span class="p">);</span>
	<span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_collision</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_single_collision</span><span class="p">,</span> <span class="n">TX_SINGLE_COLLISION_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_multiple_collision</span><span class="p">,</span> <span class="n">TX_MULTIPLE_COLLISION_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_excessive_collision</span><span class="p">,</span> <span class="n">TX_EXCESSIVE_COLLISION_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_deferred</span><span class="p">,</span> <span class="n">TX_DEFERRED_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_late_collision</span><span class="p">,</span> <span class="n">TX_LATE_COLLISION_PKTS</span><span class="p">);</span>
	<span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_collision</span> <span class="o">=</span> <span class="p">(</span><span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_single_collision</span> <span class="o">+</span>
				   <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_multiple_collision</span> <span class="o">+</span>
				   <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_excessive_collision</span> <span class="o">+</span>
				   <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">tx_late_collision</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_excessive_deferred</span><span class="p">,</span> <span class="n">TX_EXCESSIVE_DEFERRED_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_non_tcpudp</span><span class="p">,</span> <span class="n">TX_NON_TCPUDP_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_mac_src_error</span><span class="p">,</span> <span class="n">TX_MAC_SRC_ERR_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">tx_ip_src_error</span><span class="p">,</span> <span class="n">TX_IP_SRC_ERR_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_bytes</span><span class="p">,</span> <span class="n">RX_BYTES</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_bad_bytes</span><span class="p">,</span> <span class="n">RX_BAD_BYTES</span><span class="p">);</span>
	<span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_good_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">-</span>
				    <span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_bad_bytes</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_packets</span><span class="p">,</span> <span class="n">RX_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_good</span><span class="p">,</span> <span class="n">RX_GOOD_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_bad</span><span class="p">,</span> <span class="n">RX_BAD_FCS_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_pause</span><span class="p">,</span> <span class="n">RX_PAUSE_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_control</span><span class="p">,</span> <span class="n">RX_CONTROL_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_unicast</span><span class="p">,</span> <span class="n">RX_UNICAST_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_multicast</span><span class="p">,</span> <span class="n">RX_MULTICAST_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_broadcast</span><span class="p">,</span> <span class="n">RX_BROADCAST_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_lt64</span><span class="p">,</span> <span class="n">RX_UNDERSIZE_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_64</span><span class="p">,</span> <span class="n">RX_64_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_65_to_127</span><span class="p">,</span> <span class="n">RX_65_TO_127_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_128_to_255</span><span class="p">,</span> <span class="n">RX_128_TO_255_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_256_to_511</span><span class="p">,</span> <span class="n">RX_256_TO_511_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_512_to_1023</span><span class="p">,</span> <span class="n">RX_512_TO_1023_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_1024_to_15xx</span><span class="p">,</span> <span class="n">RX_1024_TO_15XX_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_15xx_to_jumbo</span><span class="p">,</span> <span class="n">RX_15XX_TO_JUMBO_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_gtjumbo</span><span class="p">,</span> <span class="n">RX_GTJUMBO_PKTS</span><span class="p">);</span>
	<span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_bad_lt64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_bad_64_to_15xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_bad_15xx_to_jumbo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_bad_gtjumbo</span><span class="p">,</span> <span class="n">RX_JABBER_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_overflow</span><span class="p">,</span> <span class="n">RX_OVERFLOW_PKTS</span><span class="p">);</span>
	<span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_missed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_false_carrier</span><span class="p">,</span> <span class="n">RX_FALSE_CARRIER_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_symbol_error</span><span class="p">,</span> <span class="n">RX_SYMBOL_ERROR_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_align_error</span><span class="p">,</span> <span class="n">RX_ALIGN_ERROR_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_length_error</span><span class="p">,</span> <span class="n">RX_LENGTH_ERROR_PKTS</span><span class="p">);</span>
	<span class="n">MAC_STAT</span><span class="p">(</span><span class="n">rx_internal_error</span><span class="p">,</span> <span class="n">RX_INTERNAL_ERROR_PKTS</span><span class="p">);</span>
	<span class="n">mac_stats</span><span class="o">-&gt;</span><span class="n">rx_good_lt64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">efx</span><span class="o">-&gt;</span><span class="n">n_rx_nodesc_drop_cnt</span> <span class="o">=</span>
		<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma_stats</span><span class="p">[</span><span class="n">MC_CMD_MAC_RX_NODESC_DROPS</span><span class="p">]);</span>

<span class="cp">#undef MAC_STAT</span>

	<span class="n">rmb</span><span class="p">();</span>
	<span class="n">generation_start</span> <span class="o">=</span> <span class="n">dma_stats</span><span class="p">[</span><span class="n">MC_CMD_MAC_GENERATION_START</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">generation_end</span> <span class="o">!=</span> <span class="n">generation_start</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">siena_update_nic_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retry</span><span class="p">;</span>

	<span class="cm">/* If we&#39;re unlucky enough to read statistics wduring the DMA, wait</span>
<span class="cm">	 * up to 10ms for it to finish (typically takes &lt;500us) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">retry</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">retry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">siena_try_update_nic_stats</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Use the old values instead */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">siena_start_nic_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le64</span> <span class="o">*</span><span class="n">dma_stats</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">dma_stats</span><span class="p">[</span><span class="n">MC_CMD_MAC_GENERATION_END</span><span class="p">]</span> <span class="o">=</span> <span class="n">STATS_GENERATION_INVALID</span><span class="p">;</span>

	<span class="n">efx_mcdi_mac_stats</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span>
			   <span class="n">MC_CMD_MAC_NSTATS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">siena_stop_nic_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efx_mcdi_mac_stats</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">stats_buffer</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Wake on LAN</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">siena_get_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">siena_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>

	<span class="n">wol</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">=</span> <span class="n">WAKE_MAGIC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">wol_filter_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">=</span> <span class="n">WAKE_MAGIC</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">sopass</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">sopass</span><span class="p">));</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">siena_set_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">siena_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">WAKE_MAGIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">WAKE_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">wol_filter_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">efx_mcdi_wol_filter_remove</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span>
						   <span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">wol_filter_id</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_wol_filter_set_magic</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">wol_filter_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_wol_filter_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">wol_filter_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s failed: type=%d rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">__func__</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">siena_init_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">siena_nic_data</span> <span class="o">*</span><span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_wol_filter_get_magic</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">wol_filter_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If it failed, attempt to get into a synchronised</span>
<span class="cm">		 * state with MC by resetting any set WoL filters */</span>
		<span class="n">efx_mcdi_wol_filter_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">wol_filter_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">wol_filter_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Revision-dependent attributes used by efx.c and nic.c</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">efx_nic_type</span> <span class="n">siena_a0_nic_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">siena_probe_nic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">siena_remove_nic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">siena_init_nic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dimension_resources</span> <span class="o">=</span> <span class="n">siena_dimension_resources</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fini</span> <span class="o">=</span> <span class="n">efx_port_dummy_op_void</span><span class="p">,</span>
	<span class="p">.</span><span class="n">monitor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_reset_reason</span> <span class="o">=</span> <span class="n">siena_map_reset_reason</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_reset_flags</span> <span class="o">=</span> <span class="n">siena_map_reset_flags</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span> <span class="o">=</span> <span class="n">siena_reset_hw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe_port</span> <span class="o">=</span> <span class="n">siena_probe_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove_port</span> <span class="o">=</span> <span class="n">siena_remove_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare_flush</span> <span class="o">=</span> <span class="n">efx_port_dummy_op_void</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_stats</span> <span class="o">=</span> <span class="n">siena_update_nic_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_stats</span> <span class="o">=</span> <span class="n">siena_start_nic_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_stats</span> <span class="o">=</span> <span class="n">siena_stop_nic_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_id_led</span> <span class="o">=</span> <span class="n">efx_mcdi_set_id_led</span><span class="p">,</span>
	<span class="p">.</span><span class="n">push_irq_moderation</span> <span class="o">=</span> <span class="n">siena_push_irq_moderation</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reconfigure_mac</span> <span class="o">=</span> <span class="n">efx_mcdi_mac_reconfigure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_mac_fault</span> <span class="o">=</span> <span class="n">efx_mcdi_mac_check_fault</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reconfigure_port</span> <span class="o">=</span> <span class="n">efx_mcdi_phy_reconfigure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_wol</span> <span class="o">=</span> <span class="n">siena_get_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_wol</span> <span class="o">=</span> <span class="n">siena_set_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume_wol</span> <span class="o">=</span> <span class="n">siena_init_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">test_registers</span> <span class="o">=</span> <span class="n">siena_test_registers</span><span class="p">,</span>
	<span class="p">.</span><span class="n">test_nvram</span> <span class="o">=</span> <span class="n">efx_mcdi_nvram_test_all</span><span class="p">,</span>

	<span class="p">.</span><span class="n">revision</span> <span class="o">=</span> <span class="n">EFX_REV_SIENA_A0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mem_map_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">FR_CZ_MC_TREG_SMEM</span> <span class="o">+</span>
			 <span class="n">FR_CZ_MC_TREG_SMEM_STEP</span> <span class="o">*</span> <span class="n">FR_CZ_MC_TREG_SMEM_ROWS</span><span class="p">),</span>
	<span class="p">.</span><span class="n">txd_ptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_BZ_TX_DESC_PTR_TBL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rxd_ptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_BZ_RX_DESC_PTR_TBL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_tbl_base</span> <span class="o">=</span> <span class="n">FR_BZ_BUF_FULL_TBL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">evq_ptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_BZ_EVQ_PTR_TBL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">evq_rptr_tbl_base</span> <span class="o">=</span> <span class="n">FR_BZ_EVQ_RPTR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_dma_mask</span> <span class="o">=</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="n">FSF_AZ_TX_KER_BUF_ADDR_WIDTH</span><span class="p">),</span>
	<span class="p">.</span><span class="n">rx_buffer_hash_size</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rx_buffer_padding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_interrupt_mode</span> <span class="o">=</span> <span class="n">EFX_INT_MODE_MSIX</span><span class="p">,</span>
	<span class="p">.</span><span class="n">phys_addr_channels</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="cm">/* Hardware limit is 64, but the legacy</span>
<span class="cm">				   * interrupt handler only supports 32</span>
<span class="cm">				   * channels */</span>
	<span class="p">.</span><span class="n">timer_period_max</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">FRF_CZ_TC_TIMER_VAL_WIDTH</span><span class="p">,</span>
	<span class="p">.</span><span class="n">offload_features</span> <span class="o">=</span> <span class="p">(</span><span class="n">NETIF_F_IP_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_IPV6_CSUM</span> <span class="o">|</span>
			     <span class="n">NETIF_F_RXHASH</span> <span class="o">|</span> <span class="n">NETIF_F_NTUPLE</span><span class="p">),</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
