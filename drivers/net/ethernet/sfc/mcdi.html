<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sfc › mcdi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>mcdi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>
<span class="cm"> * Driver for Solarflare Solarstorm network controllers and boards</span>
<span class="cm"> * Copyright 2008-2011 Solarflare Communications Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation, incorporated herein by reference.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &quot;net_driver.h&quot;</span>
<span class="cp">#include &quot;nic.h&quot;</span>
<span class="cp">#include &quot;io.h&quot;</span>
<span class="cp">#include &quot;regs.h&quot;</span>
<span class="cp">#include &quot;mcdi_pcol.h&quot;</span>
<span class="cp">#include &quot;phy.h&quot;</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Management-Controller-to-Driver Interface</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="cp">#define MCDI_RPC_TIMEOUT       10 </span><span class="cm">/*seconds */</span><span class="cp"></span>

<span class="cp">#define MCDI_PDU(efx)							\</span>
<span class="cp">	(efx_port_num(efx) ? MC_SMEM_P1_PDU_OFST : MC_SMEM_P0_PDU_OFST)</span>
<span class="cp">#define MCDI_DOORBELL(efx)						\</span>
<span class="cp">	(efx_port_num(efx) ? MC_SMEM_P1_DOORBELL_OFST : MC_SMEM_P0_DOORBELL_OFST)</span>
<span class="cp">#define MCDI_STATUS(efx)						\</span>
<span class="cp">	(efx_port_num(efx) ? MC_SMEM_P1_STATUS_OFST : MC_SMEM_P0_STATUS_OFST)</span>

<span class="cm">/* A reboot/assertion causes the MCDI status word to be set after the</span>
<span class="cm"> * command word is set or a REBOOT event is sent. If we notice a reboot</span>
<span class="cm"> * via these mechanisms then wait 10ms for the status word to be set. */</span>
<span class="cp">#define MCDI_STATUS_DELAY_US		100</span>
<span class="cp">#define MCDI_STATUS_DELAY_COUNT		100</span>
<span class="cp">#define MCDI_STATUS_SLEEP_MS						\</span>
<span class="cp">	(MCDI_STATUS_DELAY_US * MCDI_STATUS_DELAY_COUNT / 1000)</span>

<span class="cp">#define SEQ_MASK							\</span>
<span class="cp">	EFX_MASK32(EFX_WIDTH(MCDI_HEADER_SEQ))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="nf">efx_mcdi</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">siena_nic_data</span> <span class="o">*</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_REV_SIENA_A0</span><span class="p">);</span>
	<span class="n">nic_data</span> <span class="o">=</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">nic_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">nic_data</span><span class="o">-&gt;</span><span class="n">mcdi</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_mcdi_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_REV_SIENA_A0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mcdi</span> <span class="o">=</span> <span class="n">efx_mcdi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">iface_lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">MCDI_STATE_QUIESCENT</span><span class="p">);</span>
	<span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MCDI_MODE_POLL</span><span class="p">;</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">efx_mcdi_poll_reboot</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_mcdi_copyin</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">cmd</span><span class="p">,</span>
			    <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span> <span class="o">=</span> <span class="n">efx_mcdi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">pdu</span> <span class="o">=</span> <span class="n">FR_CZ_MC_TREG_SMEM</span> <span class="o">+</span> <span class="n">MCDI_PDU</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">doorbell</span> <span class="o">=</span> <span class="n">FR_CZ_MC_TREG_SMEM</span> <span class="o">+</span> <span class="n">MCDI_DOORBELL</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">efx_dword_t</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">xflags</span><span class="p">,</span> <span class="n">seqno</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="n">MCDI_STATE_QUIESCENT</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">inlen</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">inlen</span> <span class="o">&gt;=</span> <span class="n">MC_SMEM_PDU_LEN</span><span class="p">);</span>

	<span class="n">seqno</span> <span class="o">=</span> <span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">seqno</span> <span class="o">&amp;</span> <span class="n">SEQ_MASK</span><span class="p">;</span>
	<span class="n">xflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MCDI_MODE_EVENTS</span><span class="p">)</span>
		<span class="n">xflags</span> <span class="o">|=</span> <span class="n">MCDI_HEADER_XFLAGS_EVREQ</span><span class="p">;</span>

	<span class="n">EFX_POPULATE_DWORD_6</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span>
			     <span class="n">MCDI_HEADER_RESPONSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">MCDI_HEADER_RESYNC</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">MCDI_HEADER_CODE</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
			     <span class="n">MCDI_HEADER_DATALEN</span><span class="p">,</span> <span class="n">inlen</span><span class="p">,</span>
			     <span class="n">MCDI_HEADER_SEQ</span><span class="p">,</span> <span class="n">seqno</span><span class="p">,</span>
			     <span class="n">MCDI_HEADER_XFLAGS</span><span class="p">,</span> <span class="n">xflags</span><span class="p">);</span>

	<span class="n">efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">pdu</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inlen</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">_efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)(</span><span class="n">inbuf</span> <span class="o">+</span> <span class="n">i</span><span class="p">)),</span> <span class="n">pdu</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/* Ensure the payload is written out before the header */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="cm">/* ring the doorbell with a distinctive value */</span>
	<span class="n">_efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__le32</span><span class="p">)</span> <span class="mh">0x45789abc</span><span class="p">,</span> <span class="n">doorbell</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_mcdi_copyout</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">outbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">outlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span> <span class="o">=</span> <span class="n">efx_mcdi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pdu</span> <span class="o">=</span> <span class="n">FR_CZ_MC_TREG_SMEM</span> <span class="o">+</span> <span class="n">MCDI_PDU</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="n">MCDI_STATE_QUIESCENT</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">outlen</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">outlen</span> <span class="o">&gt;=</span> <span class="n">MC_SMEM_PDU_LEN</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">outlen</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="o">*</span><span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)(</span><span class="n">outbuf</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span> <span class="o">=</span> <span class="n">_efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">pdu</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_mcdi_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span> <span class="o">=</span> <span class="n">efx_mcdi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time</span><span class="p">,</span> <span class="n">finish</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">respseq</span><span class="p">,</span> <span class="n">respcmd</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pdu</span> <span class="o">=</span> <span class="n">FR_CZ_MC_TREG_SMEM</span> <span class="o">+</span> <span class="n">MCDI_PDU</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">spins</span><span class="p">;</span>
	<span class="n">efx_dword_t</span> <span class="n">reg</span><span class="p">;</span>

	<span class="cm">/* Check for a reboot atomically with respect to efx_mcdi_copyout() */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">efx_mcdi_poll_reboot</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Poll for completion. Poll quickly (once a us) for the 1st jiffy,</span>
<span class="cm">	 * because generally mcdi responses are fast. After that, back off</span>
<span class="cm">	 * and poll once a jiffy (approximately)</span>
<span class="cm">	 */</span>
	<span class="n">spins</span> <span class="o">=</span> <span class="n">TICK_USEC</span><span class="p">;</span>
	<span class="n">finish</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">()</span> <span class="o">+</span> <span class="n">MCDI_RPC_TIMEOUT</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spins</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">--</span><span class="n">spins</span><span class="p">;</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">time</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

		<span class="n">rmb</span><span class="p">();</span>
		<span class="n">efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">pdu</span><span class="p">);</span>

		<span class="cm">/* All 1&#39;s indicates that shared memory is in reset (and is</span>
<span class="cm">		 * not a valid header). Wait for it to come out reset before</span>
<span class="cm">		 * completing the command */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EFX_DWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">EFX_DWORD_0</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xffffffff</span> <span class="o">&amp;&amp;</span>
		    <span class="n">EFX_DWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">MCDI_HEADER_RESPONSE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">finish</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">resplen</span> <span class="o">=</span> <span class="n">EFX_DWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">MCDI_HEADER_DATALEN</span><span class="p">);</span>
	<span class="n">respseq</span> <span class="o">=</span> <span class="n">EFX_DWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">MCDI_HEADER_SEQ</span><span class="p">);</span>
	<span class="n">respcmd</span> <span class="o">=</span> <span class="n">EFX_DWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">MCDI_HEADER_CODE</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">EFX_DWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">MCDI_HEADER_ERROR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">resplen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;MC rebooted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">respseq</span> <span class="o">^</span> <span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SEQ_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;MC response mismatch tx seq 0x%x rx seq 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">respseq</span><span class="p">,</span> <span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">pdu</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">EFX_DWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">EFX_DWORD_0</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#define TRANSLATE_ERROR(name)					\</span>
<span class="cp">		case MC_CMD_ERR_ ## name:			\</span>
<span class="cp">			rc = name;				\</span>
<span class="cp">			break</span>
			<span class="n">TRANSLATE_ERROR</span><span class="p">(</span><span class="n">ENOENT</span><span class="p">);</span>
			<span class="n">TRANSLATE_ERROR</span><span class="p">(</span><span class="n">EINTR</span><span class="p">);</span>
			<span class="n">TRANSLATE_ERROR</span><span class="p">(</span><span class="n">EACCES</span><span class="p">);</span>
			<span class="n">TRANSLATE_ERROR</span><span class="p">(</span><span class="n">EBUSY</span><span class="p">);</span>
			<span class="n">TRANSLATE_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="n">TRANSLATE_ERROR</span><span class="p">(</span><span class="n">EDEADLK</span><span class="p">);</span>
			<span class="n">TRANSLATE_ERROR</span><span class="p">(</span><span class="n">ENOSYS</span><span class="p">);</span>
			<span class="n">TRANSLATE_ERROR</span><span class="p">(</span><span class="n">ETIME</span><span class="p">);</span>
<span class="cp">#undef TRANSLATE_ERROR</span>
		<span class="nl">default:</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">resprc</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">resplen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Return rc=0 like wait_event_timeout() */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Test and clear MC-rebooted flag for this port/function */</span>
<span class="kt">int</span> <span class="nf">efx_mcdi_poll_reboot</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">FR_CZ_MC_TREG_SMEM</span> <span class="o">+</span> <span class="n">MCDI_STATUS</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">efx_dword_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_REV_SIENA_A0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">efx_readd</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">EFX_DWORD_FIELD</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">EFX_DWORD_0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">EFX_ZERO_DWORD</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">efx_writed</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">MC_STATUS_DWORD_ASSERT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_mcdi_acquire</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Wait until the interface becomes QUIESCENT and we win the race</span>
<span class="cm">	 * to mark it RUNNING. */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span>
		   <span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span>
				  <span class="n">MCDI_STATE_QUIESCENT</span><span class="p">,</span>
				  <span class="n">MCDI_STATE_RUNNING</span><span class="p">)</span>
		   <span class="o">==</span> <span class="n">MCDI_STATE_QUIESCENT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_mcdi_await_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span> <span class="o">=</span> <span class="n">efx_mcdi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_event_timeout</span><span class="p">(</span>
		    <span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span>
		    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="n">MCDI_STATE_COMPLETED</span><span class="p">,</span>
		    <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">MCDI_RPC_TIMEOUT</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="cm">/* Check if efx_mcdi_set_mode() switched us back to polled completions.</span>
<span class="cm">	 * In which case, poll for completions directly. If efx_mcdi_ev_cpl()</span>
<span class="cm">	 * completed the request first, then we&#39;ll just end up completing the</span>
<span class="cm">	 * request again, which is safe.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need an smp_rmb() to synchronise with efx_mcdi_mode_poll(), which</span>
<span class="cm">	 * wait_event_timeout() implicitly provides.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MCDI_MODE_POLL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">efx_mcdi_poll</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">efx_mcdi_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If the interface is RUNNING, then move to COMPLETED and wake any</span>
<span class="cm">	 * waiters. If the interface isn&#39;t in RUNNING then we&#39;ve received a</span>
<span class="cm">	 * duplicate completion after we&#39;ve already transitioned back to</span>
<span class="cm">	 * QUIESCENT. [A subsequent invocation would increment seqno, so would</span>
<span class="cm">	 * have failed the seqno check].</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span>
			   <span class="n">MCDI_STATE_RUNNING</span><span class="p">,</span>
			   <span class="n">MCDI_STATE_COMPLETED</span><span class="p">)</span> <span class="o">==</span> <span class="n">MCDI_STATE_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_mcdi_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">MCDI_STATE_QUIESCENT</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_mcdi_ev_cpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seqno</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">errno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span> <span class="o">=</span> <span class="n">efx_mcdi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">wake</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">iface_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">seqno</span> <span class="o">^</span> <span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SEQ_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">credits</span><span class="p">)</span>
			<span class="cm">/* The request has been cancelled */</span>
			<span class="o">--</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">credits</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;MC response mismatch tx seq 0x%x rx &quot;</span>
				  <span class="s">&quot;seq 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">seqno</span><span class="p">,</span> <span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">resprc</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
		<span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">resplen</span> <span class="o">=</span> <span class="n">datalen</span><span class="p">;</span>

		<span class="n">wake</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">iface_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span>
		<span class="n">efx_mcdi_complete</span><span class="p">(</span><span class="n">mcdi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Issue the given command by writing the data into the shared memory PDU,</span>
<span class="cm"> * ring the doorbell and wait for completion. Copyout the result. */</span>
<span class="kt">int</span> <span class="nf">efx_mcdi_rpc</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">cmd</span><span class="p">,</span>
		 <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">outbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">outlen</span><span class="p">,</span>
		 <span class="kt">size_t</span> <span class="o">*</span><span class="n">outlen_actual</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span> <span class="o">=</span> <span class="n">efx_mcdi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_REV_SIENA_A0</span><span class="p">);</span>

	<span class="n">efx_mcdi_acquire</span><span class="p">(</span><span class="n">mcdi</span><span class="p">);</span>

	<span class="cm">/* Serialise with efx_mcdi_ev_cpl() and efx_mcdi_ev_death() */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">iface_lock</span><span class="p">);</span>
	<span class="o">++</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">iface_lock</span><span class="p">);</span>

	<span class="n">efx_mcdi_copyin</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="n">inlen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MCDI_MODE_POLL</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_poll</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_await_completion</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Close the race with efx_mcdi_ev_cpl() executing just too late</span>
<span class="cm">		 * and completing a request we&#39;ve just cancelled, by ensuring</span>
<span class="cm">		 * that the seqno check therein fails.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">iface_lock</span><span class="p">);</span>
		<span class="o">++</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">;</span>
		<span class="o">++</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">credits</span><span class="p">;</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">iface_lock</span><span class="p">);</span>

		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;MC command 0x%x inlen %d mode %d timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">inlen</span><span class="p">,</span> <span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">resplen</span><span class="p">;</span>

		<span class="cm">/* At the very least we need a memory barrier here to ensure</span>
<span class="cm">		 * we pick up changes from efx_mcdi_ev_cpl(). Protect against</span>
<span class="cm">		 * a spurious efx_mcdi_ev_cpl() running concurrently by</span>
<span class="cm">		 * acquiring the iface_lock. */</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">iface_lock</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">resprc</span><span class="p">;</span>
		<span class="n">resplen</span> <span class="o">=</span> <span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">resplen</span><span class="p">;</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">iface_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efx_mcdi_copyout</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">outbuf</span><span class="p">,</span>
					 <span class="n">min</span><span class="p">(</span><span class="n">outlen</span><span class="p">,</span> <span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">resplen</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">outlen_actual</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="o">*</span><span class="n">outlen_actual</span> <span class="o">=</span> <span class="n">resplen</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MC_CMD_REBOOT</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
			<span class="p">;</span> <span class="cm">/* Don&#39;t reset if MC_CMD_REBOOT returns EIO */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">||</span> <span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;MC fatal error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="o">-</span><span class="n">rc</span><span class="p">);</span>
			<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_MC_FAILURE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="s">&quot;MC command 0x%x inlen %d failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">inlen</span><span class="p">,</span> <span class="o">-</span><span class="n">rc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">||</span> <span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="n">MCDI_STATUS_SLEEP_MS</span><span class="p">);</span>
			<span class="n">efx_mcdi_poll_reboot</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">efx_mcdi_release</span><span class="p">(</span><span class="n">mcdi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_mcdi_mode_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_REV_SIENA_A0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mcdi</span> <span class="o">=</span> <span class="n">efx_mcdi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MCDI_MODE_POLL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* We can switch from event completion to polled completion, because</span>
<span class="cm">	 * mcdi requests are always completed in shared memory. We do this by</span>
<span class="cm">	 * switching the mode to POLL&#39;d then completing the request.</span>
<span class="cm">	 * efx_mcdi_await_completion() will then call efx_mcdi_poll().</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need an smp_wmb() to synchronise with efx_mcdi_await_completion(),</span>
<span class="cm">	 * which efx_mcdi_complete() provides for us.</span>
<span class="cm">	 */</span>
	<span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MCDI_MODE_POLL</span><span class="p">;</span>

	<span class="n">efx_mcdi_complete</span><span class="p">(</span><span class="n">mcdi</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_mcdi_mode_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efx_nic_rev</span><span class="p">(</span><span class="n">efx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EFX_REV_SIENA_A0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mcdi</span> <span class="o">=</span> <span class="n">efx_mcdi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MCDI_MODE_EVENTS</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* We can&#39;t switch from polled to event completion in the middle of a</span>
<span class="cm">	 * request, because the completion method is specified in the request.</span>
<span class="cm">	 * So acquire the interface to serialise the requestors. We don&#39;t need</span>
<span class="cm">	 * to acquire the iface_lock to change the mode here, but we do need a</span>
<span class="cm">	 * write memory barrier ensure that efx_mcdi_rpc() sees it, which</span>
<span class="cm">	 * efx_mcdi_acquire() provides.</span>
<span class="cm">	 */</span>
	<span class="n">efx_mcdi_acquire</span><span class="p">(</span><span class="n">mcdi</span><span class="p">);</span>
	<span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MCDI_MODE_EVENTS</span><span class="p">;</span>
	<span class="n">efx_mcdi_release</span><span class="p">(</span><span class="n">mcdi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_mcdi_ev_death</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_mcdi_iface</span> <span class="o">*</span><span class="n">mcdi</span> <span class="o">=</span> <span class="n">efx_mcdi</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="cm">/* If there is an outstanding MCDI request, it has been terminated</span>
<span class="cm">	 * either by a BADASSERT or REBOOT event. If the mcdi interface is</span>
<span class="cm">	 * in polled mode, then do nothing because the MC reboot handler will</span>
<span class="cm">	 * set the header correctly. However, if the mcdi interface is waiting</span>
<span class="cm">	 * for a CMDDONE event it won&#39;t receive it [and since all MCDI events</span>
<span class="cm">	 * are sent to the same queue, we can&#39;t be racing with</span>
<span class="cm">	 * efx_mcdi_ev_cpl()]</span>
<span class="cm">	 *</span>
<span class="cm">	 * There&#39;s a race here with efx_mcdi_rpc(), because we might receive</span>
<span class="cm">	 * a REBOOT event *before* the request has been copied out. In polled</span>
<span class="cm">	 * mode (during startup) this is irrelevant, because efx_mcdi_complete()</span>
<span class="cm">	 * is ignored. In event mode, this condition is just an edge-case of</span>
<span class="cm">	 * receiving a REBOOT event after posting the MCDI request. Did the mc</span>
<span class="cm">	 * reboot before or after the copyout? The best we can do always is</span>
<span class="cm">	 * just return failure.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">iface_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efx_mcdi_complete</span><span class="p">(</span><span class="n">mcdi</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MCDI_MODE_EVENTS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">resprc</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
			<span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">resplen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">++</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">credits</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

		<span class="cm">/* Nobody was waiting for an MCDI request, so trigger a reset */</span>
		<span class="n">efx_schedule_reset</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">RESET_TYPE_MC_FAILURE</span><span class="p">);</span>

		<span class="cm">/* Consume the status word since efx_mcdi_rpc_finish() won&#39;t */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">MCDI_STATUS_DELAY_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">efx_mcdi_poll_reboot</span><span class="p">(</span><span class="n">efx</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">MCDI_STATUS_DELAY_US</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcdi</span><span class="o">-&gt;</span><span class="n">iface_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">efx_mcdi_event_link_speed</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">MCDI_EVENT_LINKCHANGE_SPEED_100M</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MCDI_EVENT_LINKCHANGE_SPEED_1G</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MCDI_EVENT_LINKCHANGE_SPEED_10G</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_mcdi_process_link_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">ev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">fcntl</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">lpa</span><span class="p">;</span>

	<span class="n">speed</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="n">MCDI_EVENT_LINKCHANGE_SPEED</span><span class="p">);</span>
	<span class="n">EFX_BUG_ON_PARANOID</span><span class="p">(</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">efx_mcdi_event_link_speed</span><span class="p">));</span>
	<span class="n">speed</span> <span class="o">=</span> <span class="n">efx_mcdi_event_link_speed</span><span class="p">[</span><span class="n">speed</span><span class="p">];</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="n">MCDI_EVENT_LINKCHANGE_LINK_FLAGS</span><span class="p">);</span>
	<span class="n">fcntl</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="n">MCDI_EVENT_LINKCHANGE_FCNTL</span><span class="p">);</span>
	<span class="n">lpa</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="n">MCDI_EVENT_LINKCHANGE_LP_CAP</span><span class="p">);</span>

	<span class="cm">/* efx-&gt;link_state is only modified by efx_mcdi_phy_get_link(),</span>
<span class="cm">	 * which is only run after flushing the event queues. Therefore, it</span>
<span class="cm">	 * is safe to modify the link state outside of the mac_lock here.</span>
<span class="cm">	 */</span>
	<span class="n">efx_mcdi_phy_decode_link</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">fcntl</span><span class="p">);</span>

	<span class="n">efx_mcdi_phy_check_fcntl</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">lpa</span><span class="p">);</span>

	<span class="n">efx_link_status_changed</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called from  falcon_process_eventq for MCDI events */</span>
<span class="kt">void</span> <span class="nf">efx_mcdi_process_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
			    <span class="n">efx_qword_t</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">efx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">code</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">MCDI_EVENT_CODE</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">data</span> <span class="o">=</span> <span class="n">EFX_QWORD_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">MCDI_EVENT_DATA</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MCDI_EVENT_CODE_BADSSERT</span>:
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			  <span class="s">&quot;MC watchdog or assertion failure at 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="n">efx_mcdi_ev_death</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">EINTR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MCDI_EVENT_CODE_PMNOTICE</span>:
		<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">wol</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;MCDI PM event.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MCDI_EVENT_CODE_CMDDONE</span>:
		<span class="n">efx_mcdi_ev_cpl</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span>
				<span class="n">MCDI_EVENT_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">CMDDONE_SEQ</span><span class="p">),</span>
				<span class="n">MCDI_EVENT_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">CMDDONE_DATALEN</span><span class="p">),</span>
				<span class="n">MCDI_EVENT_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">CMDDONE_ERRNO</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MCDI_EVENT_CODE_LINKCHANGE</span>:
		<span class="n">efx_mcdi_process_link_change</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MCDI_EVENT_CODE_SENSOREVT</span>:
		<span class="n">efx_mcdi_sensor_event</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MCDI_EVENT_CODE_SCHEDERR</span>:
		<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
			   <span class="s">&quot;MC Scheduler error address=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MCDI_EVENT_CODE_REBOOT</span>:
		<span class="n">netif_info</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;MC Reboot</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">efx_mcdi_ev_death</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">EIO</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MCDI_EVENT_CODE_MAC_STATS_DMA</span>:
		<span class="cm">/* MAC stats are gather lazily.  We can ignore this. */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MCDI_EVENT_CODE_FLR</span>:
		<span class="n">efx_sriov_flr</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MCDI_EVENT_FIELD</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">FLR_VF</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;Unknown MCDI event 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">code</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Specific request functions</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">efx_mcdi_print_fwver</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">ALIGN</span><span class="p">(</span><span class="n">MC_CMD_GET_VERSION_OUT_LEN</span><span class="p">,</span> <span class="mi">4</span><span class="p">)];</span>
	<span class="kt">size_t</span> <span class="n">outlength</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">__le16</span> <span class="o">*</span><span class="n">ver_words</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MC_CMD_GET_VERSION_IN_LEN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_GET_VERSION</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			  <span class="n">outbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">outbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">outlength</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">outlength</span> <span class="o">&lt;</span> <span class="n">MC_CMD_GET_VERSION_OUT_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ver_words</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">MCDI_PTR</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">GET_VERSION_OUT_VERSION</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%u.%u.%u.%u&quot;</span><span class="p">,</span>
		 <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ver_words</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ver_words</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
		 <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ver_words</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ver_words</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_drv_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">driver_operating</span><span class="p">,</span>
			<span class="n">bool</span> <span class="o">*</span><span class="n">was_attached</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_DRV_ATTACH_IN_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">MC_CMD_DRV_ATTACH_OUT_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">outlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">DRV_ATTACH_IN_NEW_STATE</span><span class="p">,</span>
		       <span class="n">driver_operating</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">DRV_ATTACH_IN_UPDATE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_DRV_ATTACH</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="n">outbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">outbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">outlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">outlen</span> <span class="o">&lt;</span> <span class="n">MC_CMD_DRV_ATTACH_OUT_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">was_attached</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">was_attached</span> <span class="o">=</span> <span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">DRV_ATTACH_OUT_OLD_STATE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_get_board_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_address</span><span class="p">,</span>
			   <span class="n">u16</span> <span class="o">*</span><span class="n">fw_subtype_list</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">capabilities</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">MC_CMD_GET_BOARD_CFG_OUT_LENMIN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">outlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port_num</span> <span class="o">=</span> <span class="n">efx_port_num</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MC_CMD_GET_BOARD_CFG_IN_LEN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_GET_BOARD_CFG</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			  <span class="n">outbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">outbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">outlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">outlen</span> <span class="o">&lt;</span> <span class="n">MC_CMD_GET_BOARD_CFG_OUT_LENMIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">port_num</span><span class="p">)</span>
		<span class="o">?</span> <span class="n">MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1_OFST</span>
		<span class="o">:</span> <span class="n">MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0_OFST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_address</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mac_address</span><span class="p">,</span> <span class="n">outbuf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fw_subtype_list</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">fw_subtype_list</span><span class="p">,</span>
		       <span class="n">outbuf</span> <span class="o">+</span> <span class="n">MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_OFST</span><span class="p">,</span>
		       <span class="n">MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_MINNUM</span> <span class="o">*</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">fw_subtype_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">capabilities</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port_num</span><span class="p">)</span>
			<span class="o">*</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span>
					<span class="n">GET_BOARD_CFG_OUT_CAPABILITIES_PORT1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span>
					<span class="n">GET_BOARD_CFG_OUT_CAPABILITIES_PORT0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">outlen</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_log_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">evq</span><span class="p">,</span> <span class="n">bool</span> <span class="n">uart</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dest_evq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_LOG_CTRL_IN_LEN</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">dest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="p">)</span>
		<span class="n">dest</span> <span class="o">|=</span> <span class="n">MC_CMD_LOG_CTRL_IN_LOG_DEST_UART</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">evq</span><span class="p">)</span>
		<span class="n">dest</span> <span class="o">|=</span> <span class="n">MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">LOG_CTRL_IN_LOG_DEST</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">LOG_CTRL_IN_LOG_DEST_EVQ</span><span class="p">,</span> <span class="n">dest_evq</span><span class="p">);</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MC_CMD_LOG_CTRL_OUT_LEN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_LOG_CTRL</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_nvram_types</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">nvram_types_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">MC_CMD_NVRAM_TYPES_OUT_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">outlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MC_CMD_NVRAM_TYPES_IN_LEN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_NVRAM_TYPES</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			  <span class="n">outbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">outbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">outlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">outlen</span> <span class="o">&lt;</span> <span class="n">MC_CMD_NVRAM_TYPES_OUT_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">nvram_types_out</span> <span class="o">=</span> <span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">NVRAM_TYPES_OUT_TYPES</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_nvram_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="o">*</span><span class="n">size_out</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">erase_size_out</span><span class="p">,</span>
			<span class="n">bool</span> <span class="o">*</span><span class="n">protected_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_NVRAM_INFO_IN_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">MC_CMD_NVRAM_INFO_OUT_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">outlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_INFO_IN_TYPE</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_NVRAM_INFO</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="n">outbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">outbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">outlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">outlen</span> <span class="o">&lt;</span> <span class="n">MC_CMD_NVRAM_INFO_OUT_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">size_out</span> <span class="o">=</span> <span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">NVRAM_INFO_OUT_SIZE</span><span class="p">);</span>
	<span class="o">*</span><span class="n">erase_size_out</span> <span class="o">=</span> <span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">NVRAM_INFO_OUT_ERASESIZE</span><span class="p">);</span>
	<span class="o">*</span><span class="n">protected_out</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">NVRAM_INFO_OUT_FLAGS</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MC_CMD_NVRAM_INFO_OUT_PROTECTED_LBN</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_nvram_update_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_NVRAM_UPDATE_START_IN_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_UPDATE_START_IN_TYPE</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MC_CMD_NVRAM_UPDATE_START_OUT_LEN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_NVRAM_UPDATE_START</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_nvram_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_NVRAM_READ_IN_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">MC_CMD_NVRAM_READ_OUT_LEN</span><span class="p">(</span><span class="n">EFX_MCDI_NVRAM_LEN_MAX</span><span class="p">)];</span>
	<span class="kt">size_t</span> <span class="n">outlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_READ_IN_TYPE</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_READ_IN_OFFSET</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_READ_IN_LENGTH</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_NVRAM_READ</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="n">outbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">outbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">outlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">MCDI_PTR</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">NVRAM_READ_OUT_READ_BUFFER</span><span class="p">),</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_nvram_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			   <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_NVRAM_WRITE_IN_LEN</span><span class="p">(</span><span class="n">EFX_MCDI_NVRAM_LEN_MAX</span><span class="p">)];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_WRITE_IN_TYPE</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_WRITE_IN_OFFSET</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_WRITE_IN_LENGTH</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">MCDI_PTR</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_WRITE_IN_WRITE_BUFFER</span><span class="p">),</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MC_CMD_NVRAM_WRITE_OUT_LEN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_NVRAM_WRITE</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span>
			  <span class="n">ALIGN</span><span class="p">(</span><span class="n">MC_CMD_NVRAM_WRITE_IN_LEN</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="mi">4</span><span class="p">),</span>
			  <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_nvram_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			 <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_NVRAM_ERASE_IN_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_ERASE_IN_TYPE</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_ERASE_IN_OFFSET</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_ERASE_IN_LENGTH</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MC_CMD_NVRAM_ERASE_OUT_LEN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_NVRAM_ERASE</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_nvram_update_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_NVRAM_UPDATE_FINISH_IN_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_UPDATE_FINISH_IN_TYPE</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MC_CMD_NVRAM_UPDATE_FINISH_OUT_LEN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_NVRAM_UPDATE_FINISH</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_mcdi_nvram_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_NVRAM_TEST_IN_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">MC_CMD_NVRAM_TEST_OUT_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">NVRAM_TEST_IN_TYPE</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_NVRAM_TEST</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="n">outbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">outbuf</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">NVRAM_TEST_OUT_RESULT</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MC_CMD_NVRAM_TEST_PASS</span>:
	<span class="k">case</span> <span class="n">MC_CMD_NVRAM_TEST_NOTSUPP</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_nvram_test_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">nvram_types</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_nvram_types</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nvram_types</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nvram_types</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nvram_types</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_nvram_test</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">type</span><span class="o">++</span><span class="p">;</span>
		<span class="n">nvram_types</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail2:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed type=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">__func__</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="nl">fail1:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_mcdi_read_assertion</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_GET_ASSERTS_IN_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">MC_CMD_GET_ASSERTS_OUT_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ofst</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">outlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Attempt to read any stored assertion state before we reboot</span>
<span class="cm">	 * the mcfw out of the assertion handler. Retry twice, once</span>
<span class="cm">	 * because a boot-time assertion might cause this command to fail</span>
<span class="cm">	 * with EINTR. And once again because GET_ASSERTS can race with</span>
<span class="cm">	 * MC_CMD_REBOOT running on the other port. */</span>
	<span class="n">retry</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">GET_ASSERTS_IN_CLEAR</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_GET_ASSERTS</span><span class="p">,</span>
				  <span class="n">inbuf</span><span class="p">,</span> <span class="n">MC_CMD_GET_ASSERTS_IN_LEN</span><span class="p">,</span>
				  <span class="n">outbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">outbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">outlen</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span> <span class="o">||</span> <span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">retry</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">outlen</span> <span class="o">&lt;</span> <span class="n">MC_CMD_GET_ASSERTS_OUT_LEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Print out any recorded assertion state */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">GET_ASSERTS_OUT_GLOBAL_FLAGS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">MC_CMD_GET_ASSERTS_FLAGS_NO_FAILS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">reason</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">MC_CMD_GET_ASSERTS_FLAGS_SYS_FAIL</span><span class="p">)</span>
		<span class="o">?</span> <span class="s">&quot;system-level assertion&quot;</span>
		<span class="o">:</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">MC_CMD_GET_ASSERTS_FLAGS_THR_FAIL</span><span class="p">)</span>
		<span class="o">?</span> <span class="s">&quot;thread-level assertion&quot;</span>
		<span class="o">:</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">MC_CMD_GET_ASSERTS_FLAGS_WDOG_FIRED</span><span class="p">)</span>
		<span class="o">?</span> <span class="s">&quot;watchdog reset&quot;</span>
		<span class="o">:</span> <span class="s">&quot;unknown assertion&quot;</span><span class="p">;</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="s">&quot;MCPU %s at PC = 0x%.8x in thread 0x%.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span>
		  <span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">GET_ASSERTS_OUT_SAVED_PC_OFFS</span><span class="p">),</span>
		  <span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">GET_ASSERTS_OUT_THREAD_OFFS</span><span class="p">));</span>

	<span class="cm">/* Print out the registers */</span>
	<span class="n">ofst</span> <span class="o">=</span> <span class="n">MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_OFST</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;R%.2d (?): 0x%.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
			<span class="n">MCDI_DWORD2</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">ofst</span><span class="p">));</span>
		<span class="n">ofst</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efx_dword_t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">efx_mcdi_exit_assertion</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_REBOOT_IN_LEN</span><span class="p">];</span>

	<span class="cm">/* Atomically reboot the mcfw out of the assertion handler */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MC_CMD_REBOOT_OUT_LEN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">REBOOT_IN_FLAGS</span><span class="p">,</span>
		       <span class="n">MC_CMD_REBOOT_FLAGS_AFTER_ASSERTION</span><span class="p">);</span>
	<span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_REBOOT</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="n">MC_CMD_REBOOT_IN_LEN</span><span class="p">,</span>
		     <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_handle_assertion</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_read_assertion</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">efx_mcdi_exit_assertion</span><span class="p">(</span><span class="n">efx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">efx_mcdi_set_id_led</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">efx_led_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_SET_ID_LED_IN_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_LED_OFF</span> <span class="o">!=</span> <span class="n">MC_CMD_LED_OFF</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_LED_ON</span> <span class="o">!=</span> <span class="n">MC_CMD_LED_ON</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EFX_LED_DEFAULT</span> <span class="o">!=</span> <span class="n">MC_CMD_LED_DEFAULT</span><span class="p">);</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MC_CMD_SET_ID_LED_OUT_LEN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">SET_ID_LED_IN_STATE</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_SET_ID_LED</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_reset_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_ENTITY_RESET</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_reset_mc</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_REBOOT_IN_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MC_CMD_REBOOT_OUT_LEN</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">REBOOT_IN_FLAGS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_REBOOT</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/* White is black, and up is down */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">efx_mcdi_wol_filter_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">type</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">id_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_WOL_FILTER_SET_IN_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">MC_CMD_WOL_FILTER_SET_OUT_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">outlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">WOL_FILTER_SET_IN_WOL_TYPE</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">WOL_FILTER_SET_IN_FILTER_MODE</span><span class="p">,</span>
		       <span class="n">MC_CMD_FILTER_MODE_SIMPLE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">MCDI_PTR</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">WOL_FILTER_SET_IN_MAGIC_MAC</span><span class="p">),</span> <span class="n">mac</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_WOL_FILTER_SET</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="n">outbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">outbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">outlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">outlen</span> <span class="o">&lt;</span> <span class="n">MC_CMD_WOL_FILTER_SET_OUT_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">id_out</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">WOL_FILTER_SET_OUT_FILTER_ID</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="o">*</span><span class="n">id_out</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>


<span class="kt">int</span>
<span class="nf">efx_mcdi_wol_filter_set_magic</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span>  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">id_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">efx_mcdi_wol_filter_set</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_WOL_TYPE_MAGIC</span><span class="p">,</span> <span class="n">mac</span><span class="p">,</span> <span class="n">id_out</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">efx_mcdi_wol_filter_get_magic</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">id_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">outbuf</span><span class="p">[</span><span class="n">MC_CMD_WOL_FILTER_GET_OUT_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">outlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_WOL_FILTER_GET</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			  <span class="n">outbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">outbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">outlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">outlen</span> <span class="o">&lt;</span> <span class="n">MC_CMD_WOL_FILTER_GET_OUT_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">id_out</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">MCDI_DWORD</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">WOL_FILTER_GET_OUT_FILTER_ID</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="o">*</span><span class="n">id_out</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">efx_mcdi_wol_filter_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">inbuf</span><span class="p">[</span><span class="n">MC_CMD_WOL_FILTER_REMOVE_IN_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">MCDI_SET_DWORD</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">WOL_FILTER_REMOVE_IN_FILTER_ID</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">id</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_WOL_FILTER_REMOVE</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inbuf</span><span class="p">),</span>
			  <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_flush_rxqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">efx_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">efx_rx_queue</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">qid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">qid</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">EFX_MAX_CHANNELS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">qid</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qid</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">efx_for_each_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">efx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">efx_for_each_channel_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">flush_pending</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">flush_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efx</span><span class="o">-&gt;</span><span class="n">rxq_flush_pending</span><span class="p">);</span>
				<span class="n">qid</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
					<span class="n">efx_rx_queue_index</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_FLUSH_RX_QUEUES</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">qid</span><span class="p">,</span>
			  <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">qid</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">qid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">efx_mcdi_wol_filter_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">efx_nic</span> <span class="o">*</span><span class="n">efx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">efx_mcdi_rpc</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">MC_CMD_WOL_FILTER_RESET</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">netif_err</span><span class="p">(</span><span class="n">efx</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">efx</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">,</span> <span class="s">&quot;%s: failed rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
