<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › dec › tulip › tulip.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>tulip.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">	drivers/net/ethernet/dec/tulip/tulip.h</span>

<span class="cm">	Copyright 2000,2001  The Linux Kernel Team</span>
<span class="cm">	Written/copyright 1994-2001 by Donald Becker.</span>

<span class="cm">	This software may be used and distributed according to the terms</span>
<span class="cm">	of the GNU General Public License, incorporated herein by reference.</span>

<span class="cm">	Please submit bugs to http://bugzilla.kernel.org/ .</span>
<span class="cm">*/</span>

<span class="cp">#ifndef __NET_TULIP_H__</span>
<span class="cp">#define __NET_TULIP_H__</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>



<span class="cm">/* undefine, or define to various debugging levels (&gt;4 == obscene levels) */</span>
<span class="cp">#define TULIP_DEBUG 1</span>

<span class="cp">#ifdef CONFIG_TULIP_MMIO</span>
<span class="cp">#define TULIP_BAR	1	</span><span class="cm">/* CBMA */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define TULIP_BAR	0	</span><span class="cm">/* CBIO */</span><span class="cp"></span>
<span class="cp">#endif</span>



<span class="k">struct</span> <span class="n">tulip_chip_table</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">chip_name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">io_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">valid_intrs</span><span class="p">;</span>	<span class="cm">/* CSR7 interrupt enable settings */</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">media_timer</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">work_func_t</span> <span class="n">media_task</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">enum</span> <span class="n">tbl_flag</span> <span class="p">{</span>
	<span class="n">HAS_MII</span>			<span class="o">=</span> <span class="mh">0x00001</span><span class="p">,</span>
	<span class="n">HAS_MEDIA_TABLE</span>		<span class="o">=</span> <span class="mh">0x00002</span><span class="p">,</span>
	<span class="n">CSR12_IN_SROM</span>		<span class="o">=</span> <span class="mh">0x00004</span><span class="p">,</span>
	<span class="n">ALWAYS_CHECK_MII</span>	<span class="o">=</span> <span class="mh">0x00008</span><span class="p">,</span>
	<span class="n">HAS_ACPI</span>		<span class="o">=</span> <span class="mh">0x00010</span><span class="p">,</span>
	<span class="n">MC_HASH_ONLY</span>		<span class="o">=</span> <span class="mh">0x00020</span><span class="p">,</span> <span class="cm">/* Hash-only multicast filter. */</span>
	<span class="n">HAS_PNICNWAY</span>		<span class="o">=</span> <span class="mh">0x00080</span><span class="p">,</span>
	<span class="n">HAS_NWAY</span>		<span class="o">=</span> <span class="mh">0x00040</span><span class="p">,</span> <span class="cm">/* Uses internal NWay xcvr. */</span>
	<span class="n">HAS_INTR_MITIGATION</span>	<span class="o">=</span> <span class="mh">0x00100</span><span class="p">,</span>
	<span class="n">IS_ASIX</span>			<span class="o">=</span> <span class="mh">0x00200</span><span class="p">,</span>
	<span class="n">HAS_8023X</span>		<span class="o">=</span> <span class="mh">0x00400</span><span class="p">,</span>
	<span class="n">COMET_MAC_ADDR</span>		<span class="o">=</span> <span class="mh">0x00800</span><span class="p">,</span>
	<span class="n">HAS_PCI_MWI</span>		<span class="o">=</span> <span class="mh">0x01000</span><span class="p">,</span>
	<span class="n">HAS_PHY_IRQ</span>		<span class="o">=</span> <span class="mh">0x02000</span><span class="p">,</span>
	<span class="n">HAS_SWAPPED_SEEPROM</span>	<span class="o">=</span> <span class="mh">0x04000</span><span class="p">,</span>
	<span class="n">NEEDS_FAKE_MEDIA_TABLE</span>	<span class="o">=</span> <span class="mh">0x08000</span><span class="p">,</span>
	<span class="n">COMET_PM</span>		<span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* chip types.  careful!  order is VERY IMPORTANT here, as these</span>
<span class="cm"> * are used throughout the driver as indices into arrays */</span>
<span class="cm">/* Note 21142 == 21143. */</span>
<span class="k">enum</span> <span class="n">chips</span> <span class="p">{</span>
	<span class="n">DC21040</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DC21041</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">DC21140</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">DC21142</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">DC21143</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">LC82C168</span><span class="p">,</span>
	<span class="n">MX98713</span><span class="p">,</span>
	<span class="n">MX98715</span><span class="p">,</span>
	<span class="n">MX98725</span><span class="p">,</span>
	<span class="n">AX88140</span><span class="p">,</span>
	<span class="n">PNIC2</span><span class="p">,</span>
	<span class="n">COMET</span><span class="p">,</span>
	<span class="n">COMPEX9881</span><span class="p">,</span>
	<span class="n">I21145</span><span class="p">,</span>
	<span class="n">DM910X</span><span class="p">,</span>
	<span class="n">CONEXANT</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">enum</span> <span class="n">MediaIs</span> <span class="p">{</span>
	<span class="n">MediaIsFD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">MediaAlwaysFD</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">MediaIsMII</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">MediaIsFx</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">MediaIs100</span> <span class="o">=</span> <span class="mi">16</span>
<span class="p">};</span>


<span class="cm">/* Offsets to the Command and Status Registers, &quot;CSRs&quot;.  All accesses</span>
<span class="cm">   must be longword instructions and quadword aligned. */</span>
<span class="k">enum</span> <span class="n">tulip_offsets</span> <span class="p">{</span>
	<span class="n">CSR0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">CSR1</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="n">CSR2</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">CSR3</span> <span class="o">=</span> <span class="mh">0x18</span><span class="p">,</span>
	<span class="n">CSR4</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">CSR5</span> <span class="o">=</span> <span class="mh">0x28</span><span class="p">,</span>
	<span class="n">CSR6</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">,</span>
	<span class="n">CSR7</span> <span class="o">=</span> <span class="mh">0x38</span><span class="p">,</span>
	<span class="n">CSR8</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">CSR9</span> <span class="o">=</span> <span class="mh">0x48</span><span class="p">,</span>
	<span class="n">CSR10</span> <span class="o">=</span> <span class="mh">0x50</span><span class="p">,</span>
	<span class="n">CSR11</span> <span class="o">=</span> <span class="mh">0x58</span><span class="p">,</span>
	<span class="n">CSR12</span> <span class="o">=</span> <span class="mh">0x60</span><span class="p">,</span>
	<span class="n">CSR13</span> <span class="o">=</span> <span class="mh">0x68</span><span class="p">,</span>
	<span class="n">CSR14</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">,</span>
	<span class="n">CSR15</span> <span class="o">=</span> <span class="mh">0x78</span><span class="p">,</span>
	<span class="n">CSR18</span> <span class="o">=</span> <span class="mh">0x88</span><span class="p">,</span>
	<span class="n">CSR19</span> <span class="o">=</span> <span class="mh">0x8c</span><span class="p">,</span>
	<span class="n">CSR20</span> <span class="o">=</span> <span class="mh">0x90</span><span class="p">,</span>
	<span class="n">CSR27</span> <span class="o">=</span> <span class="mh">0xAC</span><span class="p">,</span>
	<span class="n">CSR28</span> <span class="o">=</span> <span class="mh">0xB0</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* register offset and bits for CFDD PCI config reg */</span>
<span class="k">enum</span> <span class="n">pci_cfg_driver_reg</span> <span class="p">{</span>
	<span class="n">CFDD</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">CFDD_Sleep</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">),</span>
	<span class="n">CFDD_Snooze</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#define RxPollInt (RxIntr|RxNoBuf|RxDied|RxJabber)</span>

<span class="cm">/* The bits in the CSR5 status registers, mostly interrupt sources. */</span>
<span class="k">enum</span> <span class="n">status_bits</span> <span class="p">{</span>
	<span class="n">TimerInt</span> <span class="o">=</span> <span class="mh">0x800</span><span class="p">,</span>
	<span class="n">SystemError</span> <span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>
	<span class="n">TPLnkFail</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>
	<span class="n">TPLnkPass</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">NormalIntr</span> <span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span>
	<span class="n">AbnormalIntr</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span>
	<span class="n">RxJabber</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">,</span>
	<span class="n">RxDied</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span>
	<span class="n">RxNoBuf</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
	<span class="n">RxIntr</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">TxFIFOUnderflow</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">RxErrIntr</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">TxJabber</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="n">TxNoBuf</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">TxDied</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">TxIntr</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* bit mask for CSR5 TX/RX process state */</span>
<span class="cp">#define CSR5_TS	0x00700000</span>
<span class="cp">#define CSR5_RS	0x000e0000</span>

<span class="k">enum</span> <span class="n">tulip_mode_bits</span> <span class="p">{</span>
	<span class="n">TxThreshold</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">),</span>
	<span class="n">FullDuplex</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>
	<span class="n">TxOn</span>			<span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>
	<span class="n">AcceptBroadcast</span>		<span class="o">=</span> <span class="mh">0x0100</span><span class="p">,</span>
	<span class="n">AcceptAllMulticast</span>	<span class="o">=</span> <span class="mh">0x0080</span><span class="p">,</span>
	<span class="n">AcceptAllPhys</span>		<span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span>
	<span class="n">AcceptRunt</span>		<span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="n">RxOn</span>			<span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">RxTx</span>			<span class="o">=</span> <span class="p">(</span><span class="n">TxOn</span> <span class="o">|</span> <span class="n">RxOn</span><span class="p">),</span>
<span class="p">};</span>


<span class="k">enum</span> <span class="n">tulip_busconfig_bits</span> <span class="p">{</span>
	<span class="n">MWI</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">),</span>
	<span class="n">MRL</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">),</span>
	<span class="n">MRM</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">),</span>
	<span class="n">CALShift</span>		<span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">BurstLenShift</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* The Tulip Rx and Tx buffer descriptors. */</span>
<span class="k">struct</span> <span class="n">tulip_rx_desc</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">buffer1</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">buffer2</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">tulip_tx_desc</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">buffer1</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">buffer2</span><span class="p">;</span>		<span class="cm">/* We use only buffer 1.  */</span>
<span class="p">};</span>


<span class="k">enum</span> <span class="n">desc_status_bits</span> <span class="p">{</span>
	<span class="n">DescOwned</span>    <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">,</span>
	<span class="n">DescWholePkt</span> <span class="o">=</span> <span class="mh">0x60000000</span><span class="p">,</span>
	<span class="n">DescEndPkt</span>   <span class="o">=</span> <span class="mh">0x40000000</span><span class="p">,</span>
	<span class="n">DescStartPkt</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">,</span>
	<span class="n">DescEndRing</span>  <span class="o">=</span> <span class="mh">0x02000000</span><span class="p">,</span>
	<span class="n">DescUseLink</span>  <span class="o">=</span> <span class="mh">0x01000000</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Error summary flag is logical or of &#39;CRC Error&#39;, &#39;Collision Seen&#39;,</span>
<span class="cm">	 * &#39;Frame Too Long&#39;, &#39;Runt&#39; and &#39;Descriptor Error&#39; flags generated</span>
<span class="cm">	 * within tulip chip.</span>
<span class="cm">	 */</span>
	<span class="n">RxDescErrorSummary</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span>
	<span class="n">RxDescCRCError</span> <span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">RxDescCollisionSeen</span> <span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * &#39;Frame Too Long&#39; flag is set if packet length including CRC exceeds</span>
<span class="cm">	 * 1518.  However, a full sized VLAN tagged frame is 1522 bytes</span>
<span class="cm">	 * including CRC.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The tulip chip does not block oversized frames, and if this flag is</span>
<span class="cm">	 * set on a receive descriptor it does not indicate the frame has been</span>
<span class="cm">	 * truncated.  The receive descriptor also includes the actual length.</span>
<span class="cm">	 * Therefore we can safety ignore this flag and check the length</span>
<span class="cm">	 * ourselves.</span>
<span class="cm">	 */</span>
	<span class="n">RxDescFrameTooLong</span> <span class="o">=</span> <span class="mh">0x0080</span><span class="p">,</span>
	<span class="n">RxDescRunt</span> <span class="o">=</span> <span class="mh">0x0800</span><span class="p">,</span>
	<span class="n">RxDescDescErr</span> <span class="o">=</span> <span class="mh">0x4000</span><span class="p">,</span>
	<span class="n">RxWholePkt</span>   <span class="o">=</span> <span class="mh">0x00000300</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Top three bits of 14 bit frame length (status bits 27-29) should</span>
<span class="cm">	 * never be set as that would make frame over 2047 bytes. The Receive</span>
<span class="cm">	 * Watchdog flag (bit 4) may indicate the length is over 2048 and the</span>
<span class="cm">	 * length field is invalid.</span>
<span class="cm">	 */</span>
	<span class="n">RxLengthOver2047</span> <span class="o">=</span> <span class="mh">0x38000010</span>
<span class="p">};</span>


<span class="k">enum</span> <span class="n">t21143_csr6_bits</span> <span class="p">{</span>
	<span class="n">csr6_sc</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">31</span><span class="p">),</span>
	<span class="n">csr6_ra</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">),</span>
	<span class="n">csr6_ign_dest_msb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">26</span><span class="p">),</span>
	<span class="n">csr6_mbo</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">25</span><span class="p">),</span>
	<span class="n">csr6_scr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">),</span>  <span class="cm">/* scramble mode flag: can&#39;t be set */</span>
	<span class="n">csr6_pcs</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">23</span><span class="p">),</span>  <span class="cm">/* Enables PCS functions (symbol mode requires csr6_ps be set) default is set */</span>
	<span class="n">csr6_ttm</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">22</span><span class="p">),</span>  <span class="cm">/* Transmit Threshold Mode, set for 10baseT, 0 for 100BaseTX */</span>
	<span class="n">csr6_sf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">21</span><span class="p">),</span>   <span class="cm">/* Store and forward. If set ignores TR bits */</span>
	<span class="n">csr6_hbd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">19</span><span class="p">),</span>  <span class="cm">/* Heart beat disable. Disables SQE function in 10baseT */</span>
	<span class="n">csr6_ps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">18</span><span class="p">),</span>   <span class="cm">/* Port Select. 0 (defualt) = 10baseT, 1 = 100baseTX: can&#39;t be set */</span>
	<span class="n">csr6_ca</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">17</span><span class="p">),</span>   <span class="cm">/* Collision Offset Enable. If set uses special algorithm in low collision situations */</span>
	<span class="n">csr6_trh</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">15</span><span class="p">),</span>  <span class="cm">/* Transmit Threshold high bit */</span>
	<span class="n">csr6_trl</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">14</span><span class="p">),</span>  <span class="cm">/* Transmit Threshold low bit */</span>

	<span class="cm">/***************************************************************</span>
<span class="cm">	 * This table shows transmit threshold values based on media   *</span>
<span class="cm">	 * and these two registers (from PNIC1 &amp; 2 docs) Note: this is *</span>
<span class="cm">	 * all meaningless if sf is set.                               *</span>
<span class="cm">	 ***************************************************************/</span>

	<span class="cm">/***********************************</span>
<span class="cm">	 * (trh,trl) * 100BaseTX * 10BaseT *</span>
<span class="cm">	 ***********************************</span>
<span class="cm">	 *   (0,0)   *     128   *    72   *</span>
<span class="cm">	 *   (0,1)   *     256   *    96   *</span>
<span class="cm">	 *   (1,0)   *     512   *   128   *</span>
<span class="cm">	 *   (1,1)   *    1024   *   160   *</span>
<span class="cm">	 ***********************************/</span>

	<span class="n">csr6_fc</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">),</span>   <span class="cm">/* Forces a collision in next transmission (for testing in loopback mode) */</span>
	<span class="n">csr6_om_int_loop</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">),</span> <span class="cm">/* internal (FIFO) loopback flag */</span>
	<span class="n">csr6_om_ext_loop</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">),</span> <span class="cm">/* external (PMD) loopback flag */</span>
	<span class="cm">/* set both and you get (PHY) loopback */</span>
	<span class="n">csr6_fd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">),</span>    <span class="cm">/* Full duplex mode, disables hearbeat, no loopback */</span>
	<span class="n">csr6_pm</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span>    <span class="cm">/* Pass All Multicast */</span>
	<span class="n">csr6_pr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">),</span>    <span class="cm">/* Promiscuous mode */</span>
	<span class="n">csr6_sb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">),</span>    <span class="cm">/* Start(1)/Stop(0) backoff counter */</span>
	<span class="n">csr6_if</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span>    <span class="cm">/* Inverse Filtering, rejects only addresses in address table: can&#39;t be set */</span>
	<span class="n">csr6_pb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span>    <span class="cm">/* Pass Bad Frames, (1) causes even bad frames to be passed on */</span>
	<span class="n">csr6_ho</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">),</span>    <span class="cm">/* Hash-only filtering mode: can&#39;t be set */</span>
	<span class="n">csr6_hp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">),</span>    <span class="cm">/* Hash/Perfect Receive Filtering Mode: can&#39;t be set */</span>

	<span class="n">csr6_mask_capture</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr6_sc</span> <span class="o">|</span> <span class="n">csr6_ca</span><span class="p">),</span>
	<span class="n">csr6_mask_defstate</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr6_mask_capture</span> <span class="o">|</span> <span class="n">csr6_mbo</span><span class="p">),</span>
	<span class="n">csr6_mask_hdcap</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr6_mask_defstate</span> <span class="o">|</span> <span class="n">csr6_hbd</span> <span class="o">|</span> <span class="n">csr6_ps</span><span class="p">),</span>
	<span class="n">csr6_mask_hdcaptt</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr6_mask_hdcap</span>  <span class="o">|</span> <span class="n">csr6_trh</span> <span class="o">|</span> <span class="n">csr6_trl</span><span class="p">),</span>
	<span class="n">csr6_mask_fullcap</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr6_mask_hdcaptt</span> <span class="o">|</span> <span class="n">csr6_fd</span><span class="p">),</span>
	<span class="n">csr6_mask_fullpromisc</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr6_pr</span> <span class="o">|</span> <span class="n">csr6_pm</span><span class="p">),</span>
	<span class="n">csr6_mask_filters</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr6_hp</span> <span class="o">|</span> <span class="n">csr6_ho</span> <span class="o">|</span> <span class="n">csr6_if</span><span class="p">),</span>
	<span class="n">csr6_mask_100bt</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr6_scr</span> <span class="o">|</span> <span class="n">csr6_pcs</span> <span class="o">|</span> <span class="n">csr6_hbd</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">tulip_comet_csr13_bits</span> <span class="p">{</span>
<span class="cm">/* The LINKOFFE and LINKONE work in conjunction with LSCE, i.e. they</span>
<span class="cm"> * determine which link status transition wakes up if LSCE is</span>
<span class="cm"> * enabled */</span>
        <span class="n">comet_csr13_linkoffe</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span>
        <span class="n">comet_csr13_linkone</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span>
        <span class="n">comet_csr13_wfre</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>
        <span class="n">comet_csr13_mpre</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>
        <span class="n">comet_csr13_lsce</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
        <span class="n">comet_csr13_wfr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
        <span class="n">comet_csr13_mpr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">comet_csr13_lsc</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">tulip_comet_csr18_bits</span> <span class="p">{</span>
        <span class="n">comet_csr18_pmes_sticky</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">),</span>
        <span class="n">comet_csr18_pm_mode</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">),</span>
        <span class="n">comet_csr18_apm_mode</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">),</span>
        <span class="n">comet_csr18_d3a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">tulip_comet_csr20_bits</span> <span class="p">{</span>
        <span class="n">comet_csr20_pmes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* Keep the ring sizes a power of two for efficiency.</span>
<span class="cm">   Making the Tx ring too large decreases the effectiveness of channel</span>
<span class="cm">   bonding and packet priority.</span>
<span class="cm">   There are no ill effects from too-large receive rings. */</span>

<span class="cp">#define TX_RING_SIZE	32</span>
<span class="cp">#define RX_RING_SIZE	128</span>
<span class="cp">#define MEDIA_MASK     31</span>

<span class="cm">/* The receiver on the DC21143 rev 65 can fail to close the last</span>
<span class="cm"> * receive descriptor in certain circumstances (see errata) when</span>
<span class="cm"> * using MWI. This can only occur if the receive buffer ends on</span>
<span class="cm"> * a cache line boundary, so the &quot;+ 4&quot; below ensures it doesn&#39;t.</span>
<span class="cm"> */</span>
<span class="cp">#define PKT_BUF_SZ	(1536 + 4)	</span><span class="cm">/* Size of each temporary Rx buffer. */</span><span class="cp"></span>

<span class="cp">#define TULIP_MIN_CACHE_LINE	8	</span><span class="cm">/* in units of 32-bit words */</span><span class="cp"></span>

<span class="cp">#if defined(__sparc__) || defined(__hppa__)</span>
<span class="cm">/* The UltraSparc PCI controllers will disconnect at every 64-byte</span>
<span class="cm"> * crossing anyways so it makes no sense to tell Tulip to burst</span>
<span class="cm"> * any more than that.</span>
<span class="cm"> */</span>
<span class="cp">#define TULIP_MAX_CACHE_LINE	16	</span><span class="cm">/* in units of 32-bit words */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define TULIP_MAX_CACHE_LINE	32	</span><span class="cm">/* in units of 32-bit words */</span><span class="cp"></span>
<span class="cp">#endif</span>


<span class="cm">/* Ring-wrap flag in length field, use for last ring entry.</span>
<span class="cm">	0x01000000 means chain on buffer2 address,</span>
<span class="cm">	0x02000000 means use the ring start address in CSR2/3.</span>
<span class="cm">   Note: Some work-alike chips do not function correctly in chained mode.</span>
<span class="cm">   The ASIX chip works only in chained mode.</span>
<span class="cm">   Thus we indicates ring mode, but always write the &#39;next&#39; field for</span>
<span class="cm">   chained mode as well.</span>
<span class="cm">*/</span>
<span class="cp">#define DESC_RING_WRAP 0x02000000</span>


<span class="cp">#define EEPROM_SIZE 512 	</span><span class="cm">/* 2 &lt;&lt; EEPROM_ADDRLEN */</span><span class="cp"></span>


<span class="cp">#define RUN_AT(x) (jiffies + (x))</span>

<span class="cp">#define get_u16(ptr) get_unaligned_le16((ptr))</span>

<span class="k">struct</span> <span class="n">medialeaf</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">media</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">leafdata</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">mediatable</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">defaultmedia</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">leafcount</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">csr12dir</span><span class="p">;</span>		<span class="cm">/* General purpose pin directions. */</span>
	<span class="kt">unsigned</span> <span class="n">has_mii</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">has_nonmii</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">has_reset</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csr15dir</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csr15val</span><span class="p">;</span>		<span class="cm">/* 21143 NWay setting. */</span>
	<span class="k">struct</span> <span class="n">medialeaf</span> <span class="n">mleaf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">mediainfo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mediainfo</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">info_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ring_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">mapping</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">tulip_private</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">product_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">next_module</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tulip_rx_desc</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tulip_tx_desc</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rx_ring_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_ring_dma</span><span class="p">;</span>
	<span class="cm">/* The saved address of a sent-in-place packet/buffer, for skfree(). */</span>
	<span class="k">struct</span> <span class="n">ring_info</span> <span class="n">tx_buffers</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="p">];</span>
	<span class="cm">/* The addresses of receive-in-place skbuffs. */</span>
	<span class="k">struct</span> <span class="n">ring_info</span> <span class="n">rx_buffers</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">setup_frame</span><span class="p">[</span><span class="mi">96</span><span class="p">];</span>	<span class="cm">/* Pseudo-Tx frame to init address table. */</span>
	<span class="kt">int</span> <span class="n">chip_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">revision</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>	<span class="cm">/* Media selection timer. */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">oom_timer</span><span class="p">;</span>    <span class="cm">/* Out of memory timer. */</span>
	<span class="n">u32</span> <span class="n">mc_filter</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">mii_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_rx</span><span class="p">,</span> <span class="n">cur_tx</span><span class="p">;</span>	<span class="cm">/* The next free ring entry */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirty_rx</span><span class="p">,</span> <span class="n">dirty_tx</span><span class="p">;</span>	<span class="cm">/* The ring entries to be free()ed. */</span>

<span class="cp">#ifdef 	CONFIG_TULIP_NAPI_HW_MITIGATION</span>
        <span class="kt">int</span> <span class="n">mit_on</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">full_duplex</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Full-duplex operation requested. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">full_duplex_lock</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fake_addr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Multiport board faked address. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">default_port</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>	<span class="cm">/* Last dev-&gt;if_port value. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">media2</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>	<span class="cm">/* Secondary monitored media port. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">medialock</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Don&#39;t sense media type. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mediasense</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Media sensing in progress. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nway</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">nwayset</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* 21143 internal NWay. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout_recovery</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">csr0</span><span class="p">;</span>	<span class="cm">/* CSR0 setting. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">csr6</span><span class="p">;</span>	<span class="cm">/* Current CSR6 control settings. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">eeprom</span><span class="p">[</span><span class="n">EEPROM_SIZE</span><span class="p">];</span>	<span class="cm">/* Serial EEPROM contents. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">link_change</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">csr5</span><span class="p">);</span>
        <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="n">wolinfo</span><span class="p">;</span>        <span class="cm">/* WOL settings */</span>
	<span class="n">u16</span> <span class="n">sym_advertise</span><span class="p">,</span> <span class="n">mii_advertise</span><span class="p">;</span> <span class="cm">/* NWay capabilities advertised.  */</span>
	<span class="n">u16</span> <span class="n">lpar</span><span class="p">;</span>		<span class="cm">/* 21143 Link partner ability. */</span>
	<span class="n">u16</span> <span class="n">advertising</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">signed</span> <span class="kt">char</span> <span class="n">phys</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">mii_cnt</span><span class="p">;</span>	<span class="cm">/* MII device addresses. */</span>
	<span class="k">struct</span> <span class="n">mediatable</span> <span class="o">*</span><span class="n">mtable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cur_index</span><span class="p">;</span>		<span class="cm">/* Current media index. */</span>
	<span class="kt">int</span> <span class="n">saved_if_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ttimer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">susp_rx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nir</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csr12_shadow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pad0</span><span class="p">;</span>		<span class="cm">/* Used for 8-byte alignment */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">media_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">eeprom_fixup</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">newtable</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* Max length below. */</span>
<span class="p">};</span>


<span class="cm">/* 21142.c */</span>
<span class="k">extern</span> <span class="n">u16</span> <span class="n">t21142_csr14</span><span class="p">[];</span>
<span class="kt">void</span> <span class="n">t21142_media_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">t21142_start_nway</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">t21142_lnk_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">csr5</span><span class="p">);</span>


<span class="cm">/* PNIC2.c */</span>
<span class="kt">void</span> <span class="n">pnic2_lnk_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">csr5</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pnic2_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pnic2_start_nway</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pnic2_lnk_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">csr5</span><span class="p">);</span>

<span class="cm">/* eeprom.c */</span>
<span class="kt">void</span> <span class="n">tulip_parse_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">tulip_read_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr_len</span><span class="p">);</span>

<span class="cm">/* interrupt.c */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tulip_max_interrupt_work</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tulip_rx_copybreak</span><span class="p">;</span>
<span class="n">irqreturn_t</span> <span class="n">tulip_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">tulip_refill_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_TULIP_NAPI</span>
<span class="kt">int</span> <span class="n">tulip_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">);</span>
<span class="cp">#endif</span>


<span class="cm">/* media.c */</span>
<span class="kt">int</span> <span class="n">tulip_mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">tulip_mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">tulip_select_media</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">startup</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">tulip_check_duplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">tulip_find_mii</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">board_idx</span><span class="p">);</span>

<span class="cm">/* pnic.c */</span>
<span class="kt">void</span> <span class="n">pnic_do_nway</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pnic_lnk_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">csr5</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pnic_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="cm">/* timer.c */</span>
<span class="kt">void</span> <span class="n">tulip_media_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mxic_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">comet_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="cm">/* tulip_core.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tulip_debug</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">medianame</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">tulip_media_cap</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tulip_chip_table</span> <span class="n">tulip_tbl</span><span class="p">[];</span>
<span class="kt">void</span> <span class="n">oom_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">t21040_csr13</span><span class="p">[];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tulip_start_rxtx</span><span class="p">(</span><span class="k">struct</span> <span class="n">tulip_private</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">csr6</span> <span class="o">|</span> <span class="n">RxTx</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CSR6</span><span class="p">);</span>
	<span class="n">barrier</span><span class="p">();</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CSR6</span><span class="p">);</span> <span class="cm">/* mmio sync */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tulip_stop_rxtx</span><span class="p">(</span><span class="k">struct</span> <span class="n">tulip_private</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csr6</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CSR6</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">csr6</span> <span class="o">&amp;</span> <span class="n">RxTx</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">1300</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">csr6</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RxTx</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CSR6</span><span class="p">);</span>
		<span class="n">barrier</span><span class="p">();</span>
		<span class="cm">/* wait until in-flight frame completes.</span>
<span class="cm">		 * Max time @ 10BT: 1500*8b/10Mbps == 1200us (+ 100us margin)</span>
<span class="cm">		 * Typically expect this loop to end in &lt; 50 us on 100BT.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ioread32</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CSR5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CSR5_TS</span><span class="o">|</span><span class="n">CSR5_RS</span><span class="p">)))</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
			<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;tulip_stop_rxtx() failed (CSR5 0x%x CSR6 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">ioread32</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CSR5</span><span class="p">),</span>
				   <span class="n">ioread32</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CSR6</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tulip_restart_rxtx</span><span class="p">(</span><span class="k">struct</span> <span class="n">tulip_private</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tulip_stop_rxtx</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">tulip_start_rxtx</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tulip_tx_timeout_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">tulip_private</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Stop and restart the chip&#39;s Tx processes. */</span>
	<span class="n">tulip_restart_rxtx</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="cm">/* Trigger an immediate transmit demand. */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CSR1</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __NET_TULIP_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
