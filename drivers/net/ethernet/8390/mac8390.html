<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › 8390 › mac8390.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>mac8390.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* mac8390.c: New driver for 8390-based Nubus (or Nubus-alike)</span>
<span class="cm">   Ethernet cards on Linux */</span>
<span class="cm">/* Based on the former daynaport.c driver, by Alan Cox.  Some code</span>
<span class="cm">   taken from or inspired by skeleton.c by Donald Becker, acenic.c by</span>
<span class="cm">   Jes Sorensen, and ne2k-pci.c by Donald Becker and Paul Gortmaker.</span>

<span class="cm">   This software may be used and distributed according to the terms of</span>
<span class="cm">   the GNU Public License, incorporated herein by reference.  */</span>

<span class="cm">/* 2000-02-28: support added for Dayna and Kinetics cards by</span>
<span class="cm">   A.G.deWijn@phys.uu.nl */</span>
<span class="cm">/* 2000-04-04: support added for Dayna2 by bart@etpmod.phys.tue.nl */</span>
<span class="cm">/* 2001-04-18: support for DaynaPort E/LC-M by rayk@knightsmanor.org */</span>
<span class="cm">/* 2001-05-15: support for Cabletron ported from old daynaport driver</span>
<span class="cm"> * and fixed access to Sonic Sys card which masquerades as a Farallon</span>
<span class="cm"> * by rayk@knightsmanor.org */</span>
<span class="cm">/* 2002-12-30: Try to support more cards, some clues from NetBSD driver */</span>
<span class="cm">/* 2003-12-26: Make sure Asante cards always work. */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/nubus.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/hwtest.h&gt;</span>
<span class="cp">#include &lt;asm/macints.h&gt;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="o">=</span>
	<span class="s">&quot;v0.4 2001-05-15 David Huggins-Daines &lt;dhd@debian.org&gt; and others</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cp">#define EI_SHIFT(x)	(ei_local-&gt;reg_offset[x])</span>
<span class="cp">#define ei_inb(port)	in_8(port)</span>
<span class="cp">#define ei_outb(val, port)	out_8(port, val)</span>
<span class="cp">#define ei_inb_p(port)	in_8(port)</span>
<span class="cp">#define ei_outb_p(val, port)	out_8(port, val)</span>

<span class="cp">#include &quot;lib8390.c&quot;</span>

<span class="cp">#define WD_START_PG			0x00	</span><span class="cm">/* First page of TX buffer */</span><span class="cp"></span>
<span class="cp">#define CABLETRON_RX_START_PG		0x00    </span><span class="cm">/* First page of RX buffer */</span><span class="cp"></span>
<span class="cp">#define CABLETRON_RX_STOP_PG		0x30    </span><span class="cm">/* Last page +1 of RX ring */</span><span class="cp"></span>
<span class="cp">#define CABLETRON_TX_START_PG		CABLETRON_RX_STOP_PG</span>
						<span class="cm">/* First page of TX buffer */</span>

<span class="cm">/*</span>
<span class="cm"> * Unfortunately it seems we have to hardcode these for the moment</span>
<span class="cm"> * Shouldn&#39;t the card know about this?</span>
<span class="cm"> * Does anyone know where to read it off the card?</span>
<span class="cm"> * Do we trust the data provided by the card?</span>
<span class="cm"> */</span>

<span class="cp">#define DAYNA_8390_BASE		0x80000</span>
<span class="cp">#define DAYNA_8390_MEM		0x00000</span>

<span class="cp">#define CABLETRON_8390_BASE	0x90000</span>
<span class="cp">#define CABLETRON_8390_MEM	0x00000</span>

<span class="cp">#define INTERLAN_8390_BASE	0xE0000</span>
<span class="cp">#define INTERLAN_8390_MEM	0xD0000</span>

<span class="k">enum</span> <span class="n">mac8390_type</span> <span class="p">{</span>
	<span class="n">MAC8390_NONE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">MAC8390_APPLE</span><span class="p">,</span>
	<span class="n">MAC8390_ASANTE</span><span class="p">,</span>
	<span class="n">MAC8390_FARALLON</span><span class="p">,</span>
	<span class="n">MAC8390_CABLETRON</span><span class="p">,</span>
	<span class="n">MAC8390_DAYNA</span><span class="p">,</span>
	<span class="n">MAC8390_INTERLAN</span><span class="p">,</span>
	<span class="n">MAC8390_KINETICS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cardname</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;apple&quot;</span><span class="p">,</span>
	<span class="s">&quot;asante&quot;</span><span class="p">,</span>
	<span class="s">&quot;farallon&quot;</span><span class="p">,</span>
	<span class="s">&quot;cabletron&quot;</span><span class="p">,</span>
	<span class="s">&quot;dayna&quot;</span><span class="p">,</span>
	<span class="s">&quot;interlan&quot;</span><span class="p">,</span>
	<span class="s">&quot;kinetics&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">word16</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">1</span><span class="p">,</span> <span class="cm">/* apple */</span>
	<span class="mi">1</span><span class="p">,</span> <span class="cm">/* asante */</span>
	<span class="mi">1</span><span class="p">,</span> <span class="cm">/* farallon */</span>
	<span class="mi">1</span><span class="p">,</span> <span class="cm">/* cabletron */</span>
	<span class="mi">0</span><span class="p">,</span> <span class="cm">/* dayna */</span>
	<span class="mi">1</span><span class="p">,</span> <span class="cm">/* interlan */</span>
	<span class="mi">0</span><span class="p">,</span> <span class="cm">/* kinetics */</span>
<span class="p">};</span>

<span class="cm">/* on which cards do we use NuBus resources? */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">useresources</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">1</span><span class="p">,</span> <span class="cm">/* apple */</span>
	<span class="mi">1</span><span class="p">,</span> <span class="cm">/* asante */</span>
	<span class="mi">1</span><span class="p">,</span> <span class="cm">/* farallon */</span>
	<span class="mi">0</span><span class="p">,</span> <span class="cm">/* cabletron */</span>
	<span class="mi">0</span><span class="p">,</span> <span class="cm">/* dayna */</span>
	<span class="mi">0</span><span class="p">,</span> <span class="cm">/* interlan */</span>
	<span class="mi">0</span><span class="p">,</span> <span class="cm">/* kinetics */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">mac8390_access</span> <span class="p">{</span>
	<span class="n">ACCESS_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">ACCESS_32</span><span class="p">,</span>
	<span class="n">ACCESS_16</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">mac8390_memtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mac8390_initdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nubus_dev</span> <span class="o">*</span><span class="n">ndev</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">mac8390_type</span> <span class="n">type</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mac8390_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mac8390_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mac8390_no_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">interlan_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* Sane (32-bit chunk memory read/write) - Some Farallon and Apple do this*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sane_get_8390_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">e8390_pkt_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_page</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sane_block_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_offset</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sane_block_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">start_page</span><span class="p">);</span>

<span class="cm">/* dayna_memcpy to and from card */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dayna_memcpy_fromcard</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dayna_memcpy_tocard</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/* Dayna - Dayna/Kinetics use this */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dayna_get_8390_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">e8390_pkt_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_page</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dayna_block_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_offset</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dayna_block_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_page</span><span class="p">);</span>

<span class="cp">#define memcpy_fromio(a, b, c)	memcpy((a), (void *)(b), (c))</span>
<span class="cp">#define memcpy_toio(a, b, c)	memcpy((void *)(a), (b), (c))</span>

<span class="cp">#define memcmp_withio(a, b, c)	memcmp((a), (void *)(b), (c))</span>

<span class="cm">/* Slow Sane (16-bit chunk memory read/write) Cabletron uses this */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">slow_sane_get_8390_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">e8390_pkt_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_page</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">slow_sane_block_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_offset</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">slow_sane_block_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_page</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">word_memcpy_tocard</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">word_memcpy_fromcard</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">mac8390_type</span> <span class="n">__init</span> <span class="nf">mac8390_ident</span><span class="p">(</span><span class="k">struct</span> <span class="n">nubus_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dr_sw</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NUBUS_DRSW_3COM</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dr_hw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NUBUS_DRHW_APPLE_SONIC_NB</span>:
		<span class="k">case</span> <span class="n">NUBUS_DRHW_APPLE_SONIC_LC</span>:
		<span class="k">case</span> <span class="n">NUBUS_DRHW_SONNET</span>:
			<span class="k">return</span> <span class="n">MAC8390_NONE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">MAC8390_APPLE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NUBUS_DRSW_APPLE</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dr_hw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NUBUS_DRHW_ASANTE_LC</span>:
			<span class="k">return</span> <span class="n">MAC8390_NONE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NUBUS_DRHW_CABLETRON</span>:
			<span class="k">return</span> <span class="n">MAC8390_CABLETRON</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">MAC8390_APPLE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NUBUS_DRSW_ASANTE</span>:
		<span class="k">return</span> <span class="n">MAC8390_ASANTE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NUBUS_DRSW_TECHWORKS</span>:
	<span class="k">case</span> <span class="n">NUBUS_DRSW_DAYNA2</span>:
	<span class="k">case</span> <span class="n">NUBUS_DRSW_DAYNA_LC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dr_hw</span> <span class="o">==</span> <span class="n">NUBUS_DRHW_CABLETRON</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">MAC8390_CABLETRON</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">MAC8390_APPLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NUBUS_DRSW_FARALLON</span>:
		<span class="k">return</span> <span class="n">MAC8390_FARALLON</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NUBUS_DRSW_KINETICS</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dr_hw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NUBUS_DRHW_INTERLAN</span>:
			<span class="k">return</span> <span class="n">MAC8390_INTERLAN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">MAC8390_KINETICS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NUBUS_DRSW_DAYNA</span>:
		<span class="cm">/*</span>
<span class="cm">		 * These correspond to Dayna Sonic cards</span>
<span class="cm">		 * which use the macsonic driver</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dr_hw</span> <span class="o">==</span> <span class="n">NUBUS_DRHW_SMC9194</span> <span class="o">||</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dr_hw</span> <span class="o">==</span> <span class="n">NUBUS_DRHW_INTERLAN</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">MAC8390_NONE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">MAC8390_DAYNA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">MAC8390_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">mac8390_access</span> <span class="n">__init</span> <span class="nf">mac8390_testio</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">membase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">outdata</span> <span class="o">=</span> <span class="mh">0xA5A0B5B0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">indata</span> <span class="o">=</span>  <span class="mh">0x00000000</span><span class="p">;</span>
	<span class="cm">/* Try writing 32 bits */</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">membase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">outdata</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="cm">/* Now compare them */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp_withio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outdata</span><span class="p">,</span> <span class="n">membase</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ACCESS_32</span><span class="p">;</span>
	<span class="cm">/* Write 16 bit output */</span>
	<span class="n">word_memcpy_tocard</span><span class="p">(</span><span class="n">membase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">outdata</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="cm">/* Now read it back */</span>
	<span class="n">word_memcpy_fromcard</span><span class="p">(</span><span class="o">&amp;</span><span class="n">indata</span><span class="p">,</span> <span class="n">membase</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">outdata</span> <span class="o">==</span> <span class="n">indata</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ACCESS_16</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ACCESS_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mac8390_memsize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">membase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Check up to 32K in 4K increments */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)(</span><span class="n">membase</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mh">0x1000</span><span class="p">));</span>

		<span class="cm">/* Unwriteable - we have a fully decoded card and the</span>
<span class="cm">		   RAM end located */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwreg_present</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* write a distinctive byte */</span>
		<span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="mh">0xA5A0</span> <span class="o">|</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/* check that we read back what we wrote */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">m</span> <span class="o">!=</span> <span class="p">(</span><span class="mh">0xA5A0</span> <span class="o">|</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* check for partial decode and wrap */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)(</span><span class="n">membase</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mh">0x1000</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="p">(</span><span class="mh">0xA5A0</span> <span class="o">|</span> <span class="n">j</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * in any case, we stopped once we tried one block too many,</span>
<span class="cm">	 * or once we reached 32K</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mh">0x1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__init</span> <span class="nf">mac8390_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nubus_dev</span> <span class="o">*</span><span class="n">ndev</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">mac8390_type</span> <span class="n">cardtype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nubus_dir</span> <span class="n">dir</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nubus_dirent</span> <span class="n">ent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>

	<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">pr_fmt</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">),</span> <span class="n">version</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">SLOT2IRQ</span><span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
	<span class="cm">/* This is getting to be a habit */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot_addr</span> <span class="o">|</span>
			  <span class="p">((</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get some Nubus info - we will trust the card&#39;s idea</span>
<span class="cm">	 * of where its memory and registers are.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nubus_get_func_dir</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dir</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Unable to get Nubus functional directory for slot %X!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the MAC address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nubus_find_rsrc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="p">,</span> <span class="n">NUBUS_RESID_MAC_ADDRESS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: Couldn&#39;t get MAC address!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nubus_get_rsrc_mem</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">useresources</span><span class="p">[</span><span class="n">cardtype</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nubus_rewinddir</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nubus_find_rsrc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="p">,</span> <span class="n">NUBUS_RESID_MINOR_BASEOS</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">ent</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Memory offset resource for slot %X not found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nubus_get_rsrc_mem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="cm">/* yes, this is how the Apple driver does it */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="mh">0x10000</span><span class="p">;</span>
		<span class="n">nubus_rewinddir</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nubus_find_rsrc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="p">,</span> <span class="n">NUBUS_RESID_MINOR_LENGTH</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">ent</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: Memory length resource for slot %X not found, probing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">mac8390_memsize</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">nubus_get_rsrc_mem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cardtype</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MAC8390_KINETICS</span>:
		<span class="k">case</span> <span class="n">MAC8390_DAYNA</span>: <span class="cm">/* it&#39;s the same */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot_addr</span> <span class="o">+</span>
					       <span class="n">DAYNA_8390_BASE</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot_addr</span> <span class="o">+</span>
					       <span class="n">DAYNA_8390_MEM</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span>
				       <span class="n">mac8390_memsize</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MAC8390_INTERLAN</span>:
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot_addr</span> <span class="o">+</span>
					       <span class="n">INTERLAN_8390_BASE</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot_addr</span> <span class="o">+</span>
					       <span class="n">INTERLAN_8390_MEM</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span>
				       <span class="n">mac8390_memsize</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MAC8390_CABLETRON</span>:
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot_addr</span> <span class="o">+</span>
					       <span class="n">CABLETRON_8390_BASE</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot_addr</span> <span class="o">+</span>
					       <span class="n">CABLETRON_8390_MEM</span><span class="p">);</span>
			<span class="cm">/* The base address is unreadable if 0x00</span>
<span class="cm">			 * has been written to the command register</span>
<span class="cm">			 * Reset the chip by writing E8390_NODMA +</span>
<span class="cm">			 *   E8390_PAGE0 + E8390_STOP just to be</span>
<span class="cm">			 *   sure</span>
<span class="cm">			 */</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
			<span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="mh">0x21</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span>
				       <span class="n">mac8390_memsize</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Card type %s is unsupported, sorry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">mac8390_probe</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nubus_dev</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slots</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">mac8390_type</span> <span class="n">cardtype</span><span class="p">;</span>

	<span class="cm">/* probably should check for Nubus instead */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACH_IS_MAC</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">____alloc_ei_netdev</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unit</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;eth%d&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">nubus_find_type</span><span class="p">(</span><span class="n">NUBUS_CAT_NETWORK</span><span class="p">,</span> <span class="n">NUBUS_TYPE_ETHERNET</span><span class="p">,</span>
				       <span class="n">ndev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Have we seen it already? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slots</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">slots</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>

		<span class="n">cardtype</span> <span class="o">=</span> <span class="n">mac8390_ident</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cardtype</span> <span class="o">==</span> <span class="n">MAC8390_NONE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mac8390_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ndev</span><span class="p">,</span> <span class="n">cardtype</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Do the nasty 8390 stuff */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mac8390_initdev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ndev</span><span class="p">,</span> <span class="n">cardtype</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef MODULE</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;David Huggins-Daines &lt;dhd@debian.org&gt; and others&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Macintosh NS8390-based Nubus Ethernet driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/* overkill, of course */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev_mac8390</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">mac8390_probe</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_mac890</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;No useable cards found, driver NOT installed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_mac890</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* MODULE */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">mac8390_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> 		<span class="o">=</span> <span class="n">mac8390_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">mac8390_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">__ei_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">__ei_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">__ei_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">__ei_set_multicast_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> 	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">eth_change_mtu</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">__ei_poll</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mac8390_initdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">nubus_dev</span> <span class="o">*</span><span class="n">ndev</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">mac8390_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">u32</span> <span class="n">fwrd4_offsets</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mi">0</span><span class="p">,</span>      <span class="mi">4</span><span class="p">,</span>      <span class="mi">8</span><span class="p">,</span>      <span class="mi">12</span><span class="p">,</span>
		<span class="mi">16</span><span class="p">,</span>     <span class="mi">20</span><span class="p">,</span>     <span class="mi">24</span><span class="p">,</span>     <span class="mi">28</span><span class="p">,</span>
		<span class="mi">32</span><span class="p">,</span>     <span class="mi">36</span><span class="p">,</span>     <span class="mi">40</span><span class="p">,</span>     <span class="mi">44</span><span class="p">,</span>
		<span class="mi">48</span><span class="p">,</span>     <span class="mi">52</span><span class="p">,</span>     <span class="mi">56</span><span class="p">,</span>     <span class="mi">60</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="n">u32</span> <span class="n">back4_offsets</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mi">60</span><span class="p">,</span>     <span class="mi">56</span><span class="p">,</span>     <span class="mi">52</span><span class="p">,</span>     <span class="mi">48</span><span class="p">,</span>
		<span class="mi">44</span><span class="p">,</span>     <span class="mi">40</span><span class="p">,</span>     <span class="mi">36</span><span class="p">,</span>     <span class="mi">32</span><span class="p">,</span>
		<span class="mi">28</span><span class="p">,</span>     <span class="mi">24</span><span class="p">,</span>     <span class="mi">20</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>
		<span class="mi">12</span><span class="p">,</span>     <span class="mi">8</span><span class="p">,</span>      <span class="mi">4</span><span class="p">,</span>      <span class="mi">0</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="n">u32</span> <span class="n">fwrd2_offsets</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mi">0</span><span class="p">,</span>      <span class="mi">2</span><span class="p">,</span>      <span class="mi">4</span><span class="p">,</span>      <span class="mi">6</span><span class="p">,</span>
		<span class="mi">8</span><span class="p">,</span>     <span class="mi">10</span><span class="p">,</span>     <span class="mi">12</span><span class="p">,</span>     <span class="mi">14</span><span class="p">,</span>
		<span class="mi">16</span><span class="p">,</span>    <span class="mi">18</span><span class="p">,</span>     <span class="mi">20</span><span class="p">,</span>     <span class="mi">22</span><span class="p">,</span>
		<span class="mi">24</span><span class="p">,</span>    <span class="mi">26</span><span class="p">,</span>     <span class="mi">28</span><span class="p">,</span>     <span class="mi">30</span>
	<span class="p">};</span>

	<span class="kt">int</span> <span class="n">access_bitmode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Now fill in our stuff */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mac8390_netdev_ops</span><span class="p">;</span>

	<span class="cm">/* GAR, ei_status is actually a macro even though it looks global */</span>
	<span class="n">ei_status</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">cardname</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="n">ei_status</span><span class="p">.</span><span class="n">word16</span> <span class="o">=</span> <span class="n">word16</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>

	<span class="cm">/* Cabletron&#39;s TX/RX buffers are backwards */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">MAC8390_CABLETRON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">tx_start_page</span> <span class="o">=</span> <span class="n">CABLETRON_TX_START_PG</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">rx_start_page</span> <span class="o">=</span> <span class="n">CABLETRON_RX_START_PG</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">stop_page</span> <span class="o">=</span> <span class="n">CABLETRON_RX_STOP_PG</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_start</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_end</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">CABLETRON_RX_STOP_PG</span><span class="o">*</span><span class="mi">256</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">tx_start_page</span> <span class="o">=</span> <span class="n">WD_START_PG</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">rx_start_page</span> <span class="o">=</span> <span class="n">WD_START_PG</span> <span class="o">+</span> <span class="n">TX_PAGES</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">stop_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">)</span><span class="o">/</span><span class="mi">256</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_start</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">TX_PAGES</span><span class="o">*</span><span class="mi">256</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_end</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill in model-specific information and functions */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MAC8390_FARALLON</span>:
	<span class="k">case</span> <span class="n">MAC8390_APPLE</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">mac8390_testio</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ACCESS_UNKNOWN</span>:
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Don&#39;t know how to access card memory!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ACCESS_16</span>:
			<span class="cm">/* 16 bit card, register map is reversed */</span>
			<span class="n">ei_status</span><span class="p">.</span><span class="n">reset_8390</span> <span class="o">=</span> <span class="n">mac8390_no_reset</span><span class="p">;</span>
			<span class="n">ei_status</span><span class="p">.</span><span class="n">block_input</span> <span class="o">=</span> <span class="n">slow_sane_block_input</span><span class="p">;</span>
			<span class="n">ei_status</span><span class="p">.</span><span class="n">block_output</span> <span class="o">=</span> <span class="n">slow_sane_block_output</span><span class="p">;</span>
			<span class="n">ei_status</span><span class="p">.</span><span class="n">get_8390_hdr</span> <span class="o">=</span> <span class="n">slow_sane_get_8390_hdr</span><span class="p">;</span>
			<span class="n">ei_status</span><span class="p">.</span><span class="n">reg_offset</span> <span class="o">=</span> <span class="n">back4_offsets</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ACCESS_32</span>:
			<span class="cm">/* 32 bit card, register map is reversed */</span>
			<span class="n">ei_status</span><span class="p">.</span><span class="n">reset_8390</span> <span class="o">=</span> <span class="n">mac8390_no_reset</span><span class="p">;</span>
			<span class="n">ei_status</span><span class="p">.</span><span class="n">block_input</span> <span class="o">=</span> <span class="n">sane_block_input</span><span class="p">;</span>
			<span class="n">ei_status</span><span class="p">.</span><span class="n">block_output</span> <span class="o">=</span> <span class="n">sane_block_output</span><span class="p">;</span>
			<span class="n">ei_status</span><span class="p">.</span><span class="n">get_8390_hdr</span> <span class="o">=</span> <span class="n">sane_get_8390_hdr</span><span class="p">;</span>
			<span class="n">ei_status</span><span class="p">.</span><span class="n">reg_offset</span> <span class="o">=</span> <span class="n">back4_offsets</span><span class="p">;</span>
			<span class="n">access_bitmode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MAC8390_ASANTE</span>:
		<span class="cm">/* Some Asante cards pass the 32 bit test</span>
<span class="cm">		 * but overwrite system memory when run at 32 bit.</span>
<span class="cm">		 * so we run them all at 16 bit.</span>
<span class="cm">		 */</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">reset_8390</span> <span class="o">=</span> <span class="n">mac8390_no_reset</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">block_input</span> <span class="o">=</span> <span class="n">slow_sane_block_input</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">block_output</span> <span class="o">=</span> <span class="n">slow_sane_block_output</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">get_8390_hdr</span> <span class="o">=</span> <span class="n">slow_sane_get_8390_hdr</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">reg_offset</span> <span class="o">=</span> <span class="n">back4_offsets</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MAC8390_CABLETRON</span>:
		<span class="cm">/* 16 bit card, register map is short forward */</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">reset_8390</span> <span class="o">=</span> <span class="n">mac8390_no_reset</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">block_input</span> <span class="o">=</span> <span class="n">slow_sane_block_input</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">block_output</span> <span class="o">=</span> <span class="n">slow_sane_block_output</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">get_8390_hdr</span> <span class="o">=</span> <span class="n">slow_sane_get_8390_hdr</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">reg_offset</span> <span class="o">=</span> <span class="n">fwrd2_offsets</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MAC8390_DAYNA</span>:
	<span class="k">case</span> <span class="n">MAC8390_KINETICS</span>:
		<span class="cm">/* 16 bit memory, register map is forward */</span>
		<span class="cm">/* dayna and similar */</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">reset_8390</span> <span class="o">=</span> <span class="n">mac8390_no_reset</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">block_input</span> <span class="o">=</span> <span class="n">dayna_block_input</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">block_output</span> <span class="o">=</span> <span class="n">dayna_block_output</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">get_8390_hdr</span> <span class="o">=</span> <span class="n">dayna_get_8390_hdr</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">reg_offset</span> <span class="o">=</span> <span class="n">fwrd4_offsets</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MAC8390_INTERLAN</span>:
		<span class="cm">/* 16 bit memory, register map is forward */</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">reset_8390</span> <span class="o">=</span> <span class="n">interlan_reset</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">block_input</span> <span class="o">=</span> <span class="n">slow_sane_block_input</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">block_output</span> <span class="o">=</span> <span class="n">slow_sane_block_output</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">get_8390_hdr</span> <span class="o">=</span> <span class="n">slow_sane_get_8390_hdr</span><span class="p">;</span>
		<span class="n">ei_status</span><span class="p">.</span><span class="n">reg_offset</span> <span class="o">=</span> <span class="n">fwrd4_offsets</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Card type %s is unsupported, sorry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__NS8390_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Good, done, now spit out some messages */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: %s in slot %X (type %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">,</span>
		<span class="n">cardname</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;MAC %pM IRQ %d, %d KB shared memory at %#lx, %d-bit access.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">,</span> <span class="n">access_bitmode</span> <span class="o">?</span> <span class="mi">32</span> <span class="o">:</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mac8390_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">__ei_open</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">__ei_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;8390 Ethernet&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: unable to get IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mac8390_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">__ei_close</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mac8390_no_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ei_status</span><span class="p">.</span><span class="n">txing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei_debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;reset not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">interlan_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">nubus_slot_addr</span><span class="p">(</span><span class="n">IRQ2SLOT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei_debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Need to reset the NS8390 t=%lu...&quot;</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>
	<span class="n">ei_status</span><span class="p">.</span><span class="n">txing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">target</span><span class="p">[</span><span class="mh">0xC0000</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei_debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;reset complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* dayna_memcpy_fromio/dayna_memcpy_toio */</span>
<span class="cm">/* directly from daynaport.c by Alan Cox */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dayna_memcpy_fromcard</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
	<span class="n">from</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* word, skip overhead */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="o">+</span><span class="n">from</span><span class="p">);</span>
	<span class="cm">/* Leading byte? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">target</span><span class="o">++</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">target</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="k">volatile</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>			<span class="cm">/* skip cruft */</span>
		<span class="n">target</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Trailing byte? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dayna_memcpy_tocard</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
	<span class="n">to</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* word, skip overhead */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="o">+</span><span class="n">to</span><span class="p">);</span>
	<span class="cm">/* Leading byte? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* avoid a byte write (stomps on other data) */</span>
		<span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span><span class="mh">0xFF00</span><span class="p">)</span><span class="o">|*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">;</span>	<span class="cm">/* Copy and */</span>
		<span class="n">ptr</span><span class="o">++</span><span class="p">;</span>			<span class="cm">/* skip cruft */</span>
		<span class="n">src</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Trailing byte? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* card doesn&#39;t like byte writes */</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="mh">0x00FF</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">*</span><span class="n">src</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* sane block input/output */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sane_get_8390_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">e8390_pkt_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hdr_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">ring_page</span> <span class="o">-</span> <span class="n">WD_START_PG</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>
	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">hdr_start</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="cm">/* Fix endianness */</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">swab16</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sane_block_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_base</span> <span class="o">=</span> <span class="n">ring_offset</span> <span class="o">-</span> <span class="p">(</span><span class="n">WD_START_PG</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_start</span> <span class="o">=</span> <span class="n">xfer_base</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfer_start</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We must wrap the input move. */</span>
		<span class="kt">int</span> <span class="n">semi_count</span> <span class="o">=</span> <span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_end</span> <span class="o">-</span> <span class="n">xfer_start</span><span class="p">;</span>
		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">xfer_base</span><span class="p">,</span>
			      <span class="n">semi_count</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">semi_count</span><span class="p">;</span>
		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">semi_count</span><span class="p">,</span> <span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_start</span><span class="p">,</span>
			      <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">xfer_base</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sane_block_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">shmem</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_page</span> <span class="o">-</span> <span class="n">WD_START_PG</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>

	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">shmem</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* dayna block input/output */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dayna_get_8390_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">e8390_pkt_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hdr_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">ring_page</span> <span class="o">-</span> <span class="n">WD_START_PG</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>

	<span class="n">dayna_memcpy_fromcard</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">hdr_start</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="cm">/* Fix endianness */</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dayna_block_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_base</span> <span class="o">=</span> <span class="n">ring_offset</span> <span class="o">-</span> <span class="p">(</span><span class="n">WD_START_PG</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_start</span> <span class="o">=</span> <span class="n">xfer_base</span><span class="o">+</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">;</span>

	<span class="cm">/* Note the offset math is done in card memory space which is word</span>
<span class="cm">	   per long onto our space. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfer_start</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We must wrap the input move. */</span>
		<span class="kt">int</span> <span class="n">semi_count</span> <span class="o">=</span> <span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_end</span> <span class="o">-</span> <span class="n">xfer_start</span><span class="p">;</span>
		<span class="n">dayna_memcpy_fromcard</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">xfer_base</span><span class="p">,</span> <span class="n">semi_count</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">semi_count</span><span class="p">;</span>
		<span class="n">dayna_memcpy_fromcard</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">semi_count</span><span class="p">,</span>
				      <span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_start</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">,</span>
				      <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dayna_memcpy_fromcard</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">xfer_base</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dayna_block_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">start_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">shmem</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_page</span> <span class="o">-</span> <span class="n">WD_START_PG</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>

	<span class="n">dayna_memcpy_tocard</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">shmem</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Cabletron block I/O */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">slow_sane_get_8390_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">e8390_pkt_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">ring_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hdr_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">ring_page</span> <span class="o">-</span> <span class="n">WD_START_PG</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>
	<span class="n">word_memcpy_fromcard</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">hdr_start</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="cm">/* Register endianism - fix here rather than 8390.c */</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="o">|</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slow_sane_block_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_base</span> <span class="o">=</span> <span class="n">ring_offset</span> <span class="o">-</span> <span class="p">(</span><span class="n">WD_START_PG</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_start</span> <span class="o">=</span> <span class="n">xfer_base</span><span class="o">+</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfer_start</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We must wrap the input move. */</span>
		<span class="kt">int</span> <span class="n">semi_count</span> <span class="o">=</span> <span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_end</span> <span class="o">-</span> <span class="n">xfer_start</span><span class="p">;</span>
		<span class="n">word_memcpy_fromcard</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">xfer_base</span><span class="p">,</span>
				     <span class="n">semi_count</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">semi_count</span><span class="p">;</span>
		<span class="n">word_memcpy_fromcard</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">semi_count</span><span class="p">,</span>
				     <span class="n">ei_status</span><span class="p">.</span><span class="n">rmem_start</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">word_memcpy_fromcard</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">xfer_base</span><span class="p">,</span>
				     <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slow_sane_block_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">shmem</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_page</span> <span class="o">-</span> <span class="n">WD_START_PG</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>

	<span class="n">word_memcpy_tocard</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">shmem</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">word_memcpy_tocard</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">tp</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>

	<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span><span class="n">to</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">word_memcpy_fromcard</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">fp</span><span class="p">;</span>

	<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span><span class="n">to</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
