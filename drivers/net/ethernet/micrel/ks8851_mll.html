<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › micrel › ks8851_mll.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ks8851_mll.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * drivers/net/ethernet/micrel/ks8851_mll.c</span>
<span class="cm"> * Copyright (c) 2009 Micrel Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * Supports:</span>
<span class="cm"> * KS8851 16bit MLL chip from Micrel Inc.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#define	DRV_NAME	&quot;ks8851_mll&quot;</span>

<span class="k">static</span> <span class="n">u8</span> <span class="n">KS_DEFAULT_MAC_ADDRESS</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0xA1</span><span class="p">,</span> <span class="mh">0x86</span><span class="p">,</span> <span class="mh">0x95</span><span class="p">,</span> <span class="mh">0x11</span> <span class="p">};</span>
<span class="cp">#define MAX_RECV_FRAMES			255</span>
<span class="cp">#define MAX_BUF_SIZE			2048</span>
<span class="cp">#define TX_BUF_SIZE			2000</span>
<span class="cp">#define RX_BUF_SIZE			2000</span>

<span class="cp">#define KS_CCR				0x08</span>
<span class="cp">#define CCR_EEPROM			(1 &lt;&lt; 9)</span>
<span class="cp">#define CCR_SPI				(1 &lt;&lt; 8)</span>
<span class="cp">#define CCR_8BIT			(1 &lt;&lt; 7)</span>
<span class="cp">#define CCR_16BIT			(1 &lt;&lt; 6)</span>
<span class="cp">#define CCR_32BIT			(1 &lt;&lt; 5)</span>
<span class="cp">#define CCR_SHARED			(1 &lt;&lt; 4)</span>
<span class="cp">#define CCR_32PIN			(1 &lt;&lt; 0)</span>

<span class="cm">/* MAC address registers */</span>
<span class="cp">#define KS_MARL				0x10</span>
<span class="cp">#define KS_MARM				0x12</span>
<span class="cp">#define KS_MARH				0x14</span>

<span class="cp">#define KS_OBCR				0x20</span>
<span class="cp">#define OBCR_ODS_16MA			(1 &lt;&lt; 6)</span>

<span class="cp">#define KS_EEPCR			0x22</span>
<span class="cp">#define EEPCR_EESA			(1 &lt;&lt; 4)</span>
<span class="cp">#define EEPCR_EESB			(1 &lt;&lt; 3)</span>
<span class="cp">#define EEPCR_EEDO			(1 &lt;&lt; 2)</span>
<span class="cp">#define EEPCR_EESCK			(1 &lt;&lt; 1)</span>
<span class="cp">#define EEPCR_EECS			(1 &lt;&lt; 0)</span>

<span class="cp">#define KS_MBIR				0x24</span>
<span class="cp">#define MBIR_TXMBF			(1 &lt;&lt; 12)</span>
<span class="cp">#define MBIR_TXMBFA			(1 &lt;&lt; 11)</span>
<span class="cp">#define MBIR_RXMBF			(1 &lt;&lt; 4)</span>
<span class="cp">#define MBIR_RXMBFA			(1 &lt;&lt; 3)</span>

<span class="cp">#define KS_GRR				0x26</span>
<span class="cp">#define GRR_QMU				(1 &lt;&lt; 1)</span>
<span class="cp">#define GRR_GSR				(1 &lt;&lt; 0)</span>

<span class="cp">#define KS_WFCR				0x2A</span>
<span class="cp">#define WFCR_MPRXE			(1 &lt;&lt; 7)</span>
<span class="cp">#define WFCR_WF3E			(1 &lt;&lt; 3)</span>
<span class="cp">#define WFCR_WF2E			(1 &lt;&lt; 2)</span>
<span class="cp">#define WFCR_WF1E			(1 &lt;&lt; 1)</span>
<span class="cp">#define WFCR_WF0E			(1 &lt;&lt; 0)</span>

<span class="cp">#define KS_WF0CRC0			0x30</span>
<span class="cp">#define KS_WF0CRC1			0x32</span>
<span class="cp">#define KS_WF0BM0			0x34</span>
<span class="cp">#define KS_WF0BM1			0x36</span>
<span class="cp">#define KS_WF0BM2			0x38</span>
<span class="cp">#define KS_WF0BM3			0x3A</span>

<span class="cp">#define KS_WF1CRC0			0x40</span>
<span class="cp">#define KS_WF1CRC1			0x42</span>
<span class="cp">#define KS_WF1BM0			0x44</span>
<span class="cp">#define KS_WF1BM1			0x46</span>
<span class="cp">#define KS_WF1BM2			0x48</span>
<span class="cp">#define KS_WF1BM3			0x4A</span>

<span class="cp">#define KS_WF2CRC0			0x50</span>
<span class="cp">#define KS_WF2CRC1			0x52</span>
<span class="cp">#define KS_WF2BM0			0x54</span>
<span class="cp">#define KS_WF2BM1			0x56</span>
<span class="cp">#define KS_WF2BM2			0x58</span>
<span class="cp">#define KS_WF2BM3			0x5A</span>

<span class="cp">#define KS_WF3CRC0			0x60</span>
<span class="cp">#define KS_WF3CRC1			0x62</span>
<span class="cp">#define KS_WF3BM0			0x64</span>
<span class="cp">#define KS_WF3BM1			0x66</span>
<span class="cp">#define KS_WF3BM2			0x68</span>
<span class="cp">#define KS_WF3BM3			0x6A</span>

<span class="cp">#define KS_TXCR				0x70</span>
<span class="cp">#define TXCR_TCGICMP			(1 &lt;&lt; 8)</span>
<span class="cp">#define TXCR_TCGUDP			(1 &lt;&lt; 7)</span>
<span class="cp">#define TXCR_TCGTCP			(1 &lt;&lt; 6)</span>
<span class="cp">#define TXCR_TCGIP			(1 &lt;&lt; 5)</span>
<span class="cp">#define TXCR_FTXQ			(1 &lt;&lt; 4)</span>
<span class="cp">#define TXCR_TXFCE			(1 &lt;&lt; 3)</span>
<span class="cp">#define TXCR_TXPE			(1 &lt;&lt; 2)</span>
<span class="cp">#define TXCR_TXCRC			(1 &lt;&lt; 1)</span>
<span class="cp">#define TXCR_TXE			(1 &lt;&lt; 0)</span>

<span class="cp">#define KS_TXSR				0x72</span>
<span class="cp">#define TXSR_TXLC			(1 &lt;&lt; 13)</span>
<span class="cp">#define TXSR_TXMC			(1 &lt;&lt; 12)</span>
<span class="cp">#define TXSR_TXFID_MASK			(0x3f &lt;&lt; 0)</span>
<span class="cp">#define TXSR_TXFID_SHIFT		(0)</span>
<span class="cp">#define TXSR_TXFID_GET(_v)		(((_v) &gt;&gt; 0) &amp; 0x3f)</span>


<span class="cp">#define KS_RXCR1			0x74</span>
<span class="cp">#define RXCR1_FRXQ			(1 &lt;&lt; 15)</span>
<span class="cp">#define RXCR1_RXUDPFCC			(1 &lt;&lt; 14)</span>
<span class="cp">#define RXCR1_RXTCPFCC			(1 &lt;&lt; 13)</span>
<span class="cp">#define RXCR1_RXIPFCC			(1 &lt;&lt; 12)</span>
<span class="cp">#define RXCR1_RXPAFMA			(1 &lt;&lt; 11)</span>
<span class="cp">#define RXCR1_RXFCE			(1 &lt;&lt; 10)</span>
<span class="cp">#define RXCR1_RXEFE			(1 &lt;&lt; 9)</span>
<span class="cp">#define RXCR1_RXMAFMA			(1 &lt;&lt; 8)</span>
<span class="cp">#define RXCR1_RXBE			(1 &lt;&lt; 7)</span>
<span class="cp">#define RXCR1_RXME			(1 &lt;&lt; 6)</span>
<span class="cp">#define RXCR1_RXUE			(1 &lt;&lt; 5)</span>
<span class="cp">#define RXCR1_RXAE			(1 &lt;&lt; 4)</span>
<span class="cp">#define RXCR1_RXINVF			(1 &lt;&lt; 1)</span>
<span class="cp">#define RXCR1_RXE			(1 &lt;&lt; 0)</span>
<span class="cp">#define RXCR1_FILTER_MASK    		(RXCR1_RXINVF | RXCR1_RXAE | \</span>
<span class="cp">					 RXCR1_RXMAFMA | RXCR1_RXPAFMA)</span>

<span class="cp">#define KS_RXCR2			0x76</span>
<span class="cp">#define RXCR2_SRDBL_MASK		(0x7 &lt;&lt; 5)</span>
<span class="cp">#define RXCR2_SRDBL_SHIFT		(5)</span>
<span class="cp">#define RXCR2_SRDBL_4B			(0x0 &lt;&lt; 5)</span>
<span class="cp">#define RXCR2_SRDBL_8B			(0x1 &lt;&lt; 5)</span>
<span class="cp">#define RXCR2_SRDBL_16B			(0x2 &lt;&lt; 5)</span>
<span class="cp">#define RXCR2_SRDBL_32B			(0x3 &lt;&lt; 5)</span>
<span class="cm">/* #define RXCR2_SRDBL_FRAME		(0x4 &lt;&lt; 5) */</span>
<span class="cp">#define RXCR2_IUFFP			(1 &lt;&lt; 4)</span>
<span class="cp">#define RXCR2_RXIUFCEZ			(1 &lt;&lt; 3)</span>
<span class="cp">#define RXCR2_UDPLFE			(1 &lt;&lt; 2)</span>
<span class="cp">#define RXCR2_RXICMPFCC			(1 &lt;&lt; 1)</span>
<span class="cp">#define RXCR2_RXSAF			(1 &lt;&lt; 0)</span>

<span class="cp">#define KS_TXMIR			0x78</span>

<span class="cp">#define KS_RXFHSR			0x7C</span>
<span class="cp">#define RXFSHR_RXFV			(1 &lt;&lt; 15)</span>
<span class="cp">#define RXFSHR_RXICMPFCS		(1 &lt;&lt; 13)</span>
<span class="cp">#define RXFSHR_RXIPFCS			(1 &lt;&lt; 12)</span>
<span class="cp">#define RXFSHR_RXTCPFCS			(1 &lt;&lt; 11)</span>
<span class="cp">#define RXFSHR_RXUDPFCS			(1 &lt;&lt; 10)</span>
<span class="cp">#define RXFSHR_RXBF			(1 &lt;&lt; 7)</span>
<span class="cp">#define RXFSHR_RXMF			(1 &lt;&lt; 6)</span>
<span class="cp">#define RXFSHR_RXUF			(1 &lt;&lt; 5)</span>
<span class="cp">#define RXFSHR_RXMR			(1 &lt;&lt; 4)</span>
<span class="cp">#define RXFSHR_RXFT			(1 &lt;&lt; 3)</span>
<span class="cp">#define RXFSHR_RXFTL			(1 &lt;&lt; 2)</span>
<span class="cp">#define RXFSHR_RXRF			(1 &lt;&lt; 1)</span>
<span class="cp">#define RXFSHR_RXCE			(1 &lt;&lt; 0)</span>
<span class="cp">#define	RXFSHR_ERR			(RXFSHR_RXCE | RXFSHR_RXRF |\</span>
<span class="cp">					RXFSHR_RXFTL | RXFSHR_RXMR |\</span>
<span class="cp">					RXFSHR_RXICMPFCS | RXFSHR_RXIPFCS |\</span>
<span class="cp">					RXFSHR_RXTCPFCS)</span>
<span class="cp">#define KS_RXFHBCR			0x7E</span>
<span class="cp">#define RXFHBCR_CNT_MASK		0x0FFF</span>

<span class="cp">#define KS_TXQCR			0x80</span>
<span class="cp">#define TXQCR_AETFE			(1 &lt;&lt; 2)</span>
<span class="cp">#define TXQCR_TXQMAM			(1 &lt;&lt; 1)</span>
<span class="cp">#define TXQCR_METFE			(1 &lt;&lt; 0)</span>

<span class="cp">#define KS_RXQCR			0x82</span>
<span class="cp">#define RXQCR_RXDTTS			(1 &lt;&lt; 12)</span>
<span class="cp">#define RXQCR_RXDBCTS			(1 &lt;&lt; 11)</span>
<span class="cp">#define RXQCR_RXFCTS			(1 &lt;&lt; 10)</span>
<span class="cp">#define RXQCR_RXIPHTOE			(1 &lt;&lt; 9)</span>
<span class="cp">#define RXQCR_RXDTTE			(1 &lt;&lt; 7)</span>
<span class="cp">#define RXQCR_RXDBCTE			(1 &lt;&lt; 6)</span>
<span class="cp">#define RXQCR_RXFCTE			(1 &lt;&lt; 5)</span>
<span class="cp">#define RXQCR_ADRFE			(1 &lt;&lt; 4)</span>
<span class="cp">#define RXQCR_SDA			(1 &lt;&lt; 3)</span>
<span class="cp">#define RXQCR_RRXEF			(1 &lt;&lt; 0)</span>
<span class="cp">#define RXQCR_CMD_CNTL                	(RXQCR_RXFCTE|RXQCR_ADRFE)</span>

<span class="cp">#define KS_TXFDPR			0x84</span>
<span class="cp">#define TXFDPR_TXFPAI			(1 &lt;&lt; 14)</span>
<span class="cp">#define TXFDPR_TXFP_MASK		(0x7ff &lt;&lt; 0)</span>
<span class="cp">#define TXFDPR_TXFP_SHIFT		(0)</span>

<span class="cp">#define KS_RXFDPR			0x86</span>
<span class="cp">#define RXFDPR_RXFPAI			(1 &lt;&lt; 14)</span>

<span class="cp">#define KS_RXDTTR			0x8C</span>
<span class="cp">#define KS_RXDBCTR			0x8E</span>

<span class="cp">#define KS_IER				0x90</span>
<span class="cp">#define KS_ISR				0x92</span>
<span class="cp">#define IRQ_LCI				(1 &lt;&lt; 15)</span>
<span class="cp">#define IRQ_TXI				(1 &lt;&lt; 14)</span>
<span class="cp">#define IRQ_RXI				(1 &lt;&lt; 13)</span>
<span class="cp">#define IRQ_RXOI			(1 &lt;&lt; 11)</span>
<span class="cp">#define IRQ_TXPSI			(1 &lt;&lt; 9)</span>
<span class="cp">#define IRQ_RXPSI			(1 &lt;&lt; 8)</span>
<span class="cp">#define IRQ_TXSAI			(1 &lt;&lt; 6)</span>
<span class="cp">#define IRQ_RXWFDI			(1 &lt;&lt; 5)</span>
<span class="cp">#define IRQ_RXMPDI			(1 &lt;&lt; 4)</span>
<span class="cp">#define IRQ_LDI				(1 &lt;&lt; 3)</span>
<span class="cp">#define IRQ_EDI				(1 &lt;&lt; 2)</span>
<span class="cp">#define IRQ_SPIBEI			(1 &lt;&lt; 1)</span>
<span class="cp">#define IRQ_DEDI			(1 &lt;&lt; 0)</span>

<span class="cp">#define KS_RXFCTR			0x9C</span>
<span class="cp">#define RXFCTR_THRESHOLD_MASK     	0x00FF</span>

<span class="cp">#define KS_RXFC				0x9D</span>
<span class="cp">#define RXFCTR_RXFC_MASK		(0xff &lt;&lt; 8)</span>
<span class="cp">#define RXFCTR_RXFC_SHIFT		(8)</span>
<span class="cp">#define RXFCTR_RXFC_GET(_v)		(((_v) &gt;&gt; 8) &amp; 0xff)</span>
<span class="cp">#define RXFCTR_RXFCT_MASK		(0xff &lt;&lt; 0)</span>
<span class="cp">#define RXFCTR_RXFCT_SHIFT		(0)</span>

<span class="cp">#define KS_TXNTFSR			0x9E</span>

<span class="cp">#define KS_MAHTR0			0xA0</span>
<span class="cp">#define KS_MAHTR1			0xA2</span>
<span class="cp">#define KS_MAHTR2			0xA4</span>
<span class="cp">#define KS_MAHTR3			0xA6</span>

<span class="cp">#define KS_FCLWR			0xB0</span>
<span class="cp">#define KS_FCHWR			0xB2</span>
<span class="cp">#define KS_FCOWR			0xB4</span>

<span class="cp">#define KS_CIDER			0xC0</span>
<span class="cp">#define CIDER_ID			0x8870</span>
<span class="cp">#define CIDER_REV_MASK			(0x7 &lt;&lt; 1)</span>
<span class="cp">#define CIDER_REV_SHIFT			(1)</span>
<span class="cp">#define CIDER_REV_GET(_v)		(((_v) &gt;&gt; 1) &amp; 0x7)</span>

<span class="cp">#define KS_CGCR				0xC6</span>
<span class="cp">#define KS_IACR				0xC8</span>
<span class="cp">#define IACR_RDEN			(1 &lt;&lt; 12)</span>
<span class="cp">#define IACR_TSEL_MASK			(0x3 &lt;&lt; 10)</span>
<span class="cp">#define IACR_TSEL_SHIFT			(10)</span>
<span class="cp">#define IACR_TSEL_MIB			(0x3 &lt;&lt; 10)</span>
<span class="cp">#define IACR_ADDR_MASK			(0x1f &lt;&lt; 0)</span>
<span class="cp">#define IACR_ADDR_SHIFT			(0)</span>

<span class="cp">#define KS_IADLR			0xD0</span>
<span class="cp">#define KS_IAHDR			0xD2</span>

<span class="cp">#define KS_PMECR			0xD4</span>
<span class="cp">#define PMECR_PME_DELAY			(1 &lt;&lt; 14)</span>
<span class="cp">#define PMECR_PME_POL			(1 &lt;&lt; 12)</span>
<span class="cp">#define PMECR_WOL_WAKEUP		(1 &lt;&lt; 11)</span>
<span class="cp">#define PMECR_WOL_MAGICPKT		(1 &lt;&lt; 10)</span>
<span class="cp">#define PMECR_WOL_LINKUP		(1 &lt;&lt; 9)</span>
<span class="cp">#define PMECR_WOL_ENERGY		(1 &lt;&lt; 8)</span>
<span class="cp">#define PMECR_AUTO_WAKE_EN		(1 &lt;&lt; 7)</span>
<span class="cp">#define PMECR_WAKEUP_NORMAL		(1 &lt;&lt; 6)</span>
<span class="cp">#define PMECR_WKEVT_MASK		(0xf &lt;&lt; 2)</span>
<span class="cp">#define PMECR_WKEVT_SHIFT		(2)</span>
<span class="cp">#define PMECR_WKEVT_GET(_v)		(((_v) &gt;&gt; 2) &amp; 0xf)</span>
<span class="cp">#define PMECR_WKEVT_ENERGY		(0x1 &lt;&lt; 2)</span>
<span class="cp">#define PMECR_WKEVT_LINK		(0x2 &lt;&lt; 2)</span>
<span class="cp">#define PMECR_WKEVT_MAGICPKT		(0x4 &lt;&lt; 2)</span>
<span class="cp">#define PMECR_WKEVT_FRAME		(0x8 &lt;&lt; 2)</span>
<span class="cp">#define PMECR_PM_MASK			(0x3 &lt;&lt; 0)</span>
<span class="cp">#define PMECR_PM_SHIFT			(0)</span>
<span class="cp">#define PMECR_PM_NORMAL			(0x0 &lt;&lt; 0)</span>
<span class="cp">#define PMECR_PM_ENERGY			(0x1 &lt;&lt; 0)</span>
<span class="cp">#define PMECR_PM_SOFTDOWN		(0x2 &lt;&lt; 0)</span>
<span class="cp">#define PMECR_PM_POWERSAVE		(0x3 &lt;&lt; 0)</span>

<span class="cm">/* Standard MII PHY data */</span>
<span class="cp">#define KS_P1MBCR			0xE4</span>
<span class="cp">#define P1MBCR_FORCE_FDX		(1 &lt;&lt; 8)</span>

<span class="cp">#define KS_P1MBSR			0xE6</span>
<span class="cp">#define P1MBSR_AN_COMPLETE		(1 &lt;&lt; 5)</span>
<span class="cp">#define P1MBSR_AN_CAPABLE		(1 &lt;&lt; 3)</span>
<span class="cp">#define P1MBSR_LINK_UP			(1 &lt;&lt; 2)</span>

<span class="cp">#define KS_PHY1ILR			0xE8</span>
<span class="cp">#define KS_PHY1IHR			0xEA</span>
<span class="cp">#define KS_P1ANAR			0xEC</span>
<span class="cp">#define KS_P1ANLPR			0xEE</span>

<span class="cp">#define KS_P1SCLMD			0xF4</span>
<span class="cp">#define P1SCLMD_LEDOFF			(1 &lt;&lt; 15)</span>
<span class="cp">#define P1SCLMD_TXIDS			(1 &lt;&lt; 14)</span>
<span class="cp">#define P1SCLMD_RESTARTAN		(1 &lt;&lt; 13)</span>
<span class="cp">#define P1SCLMD_DISAUTOMDIX		(1 &lt;&lt; 10)</span>
<span class="cp">#define P1SCLMD_FORCEMDIX		(1 &lt;&lt; 9)</span>
<span class="cp">#define P1SCLMD_AUTONEGEN		(1 &lt;&lt; 7)</span>
<span class="cp">#define P1SCLMD_FORCE100		(1 &lt;&lt; 6)</span>
<span class="cp">#define P1SCLMD_FORCEFDX		(1 &lt;&lt; 5)</span>
<span class="cp">#define P1SCLMD_ADV_FLOW		(1 &lt;&lt; 4)</span>
<span class="cp">#define P1SCLMD_ADV_100BT_FDX		(1 &lt;&lt; 3)</span>
<span class="cp">#define P1SCLMD_ADV_100BT_HDX		(1 &lt;&lt; 2)</span>
<span class="cp">#define P1SCLMD_ADV_10BT_FDX		(1 &lt;&lt; 1)</span>
<span class="cp">#define P1SCLMD_ADV_10BT_HDX		(1 &lt;&lt; 0)</span>

<span class="cp">#define KS_P1CR				0xF6</span>
<span class="cp">#define P1CR_HP_MDIX			(1 &lt;&lt; 15)</span>
<span class="cp">#define P1CR_REV_POL			(1 &lt;&lt; 13)</span>
<span class="cp">#define P1CR_OP_100M			(1 &lt;&lt; 10)</span>
<span class="cp">#define P1CR_OP_FDX			(1 &lt;&lt; 9)</span>
<span class="cp">#define P1CR_OP_MDI			(1 &lt;&lt; 7)</span>
<span class="cp">#define P1CR_AN_DONE			(1 &lt;&lt; 6)</span>
<span class="cp">#define P1CR_LINK_GOOD			(1 &lt;&lt; 5)</span>
<span class="cp">#define P1CR_PNTR_FLOW			(1 &lt;&lt; 4)</span>
<span class="cp">#define P1CR_PNTR_100BT_FDX		(1 &lt;&lt; 3)</span>
<span class="cp">#define P1CR_PNTR_100BT_HDX		(1 &lt;&lt; 2)</span>
<span class="cp">#define P1CR_PNTR_10BT_FDX		(1 &lt;&lt; 1)</span>
<span class="cp">#define P1CR_PNTR_10BT_HDX		(1 &lt;&lt; 0)</span>

<span class="cm">/* TX Frame control */</span>

<span class="cp">#define TXFR_TXIC			(1 &lt;&lt; 15)</span>
<span class="cp">#define TXFR_TXFID_MASK			(0x3f &lt;&lt; 0)</span>
<span class="cp">#define TXFR_TXFID_SHIFT		(0)</span>

<span class="cp">#define KS_P1SR				0xF8</span>
<span class="cp">#define P1SR_HP_MDIX			(1 &lt;&lt; 15)</span>
<span class="cp">#define P1SR_REV_POL			(1 &lt;&lt; 13)</span>
<span class="cp">#define P1SR_OP_100M			(1 &lt;&lt; 10)</span>
<span class="cp">#define P1SR_OP_FDX			(1 &lt;&lt; 9)</span>
<span class="cp">#define P1SR_OP_MDI			(1 &lt;&lt; 7)</span>
<span class="cp">#define P1SR_AN_DONE			(1 &lt;&lt; 6)</span>
<span class="cp">#define P1SR_LINK_GOOD			(1 &lt;&lt; 5)</span>
<span class="cp">#define P1SR_PNTR_FLOW			(1 &lt;&lt; 4)</span>
<span class="cp">#define P1SR_PNTR_100BT_FDX		(1 &lt;&lt; 3)</span>
<span class="cp">#define P1SR_PNTR_100BT_HDX		(1 &lt;&lt; 2)</span>
<span class="cp">#define P1SR_PNTR_10BT_FDX		(1 &lt;&lt; 1)</span>
<span class="cp">#define P1SR_PNTR_10BT_HDX		(1 &lt;&lt; 0)</span>

<span class="cp">#define	ENUM_BUS_NONE			0</span>
<span class="cp">#define	ENUM_BUS_8BIT			1</span>
<span class="cp">#define	ENUM_BUS_16BIT			2</span>
<span class="cp">#define	ENUM_BUS_32BIT			3</span>

<span class="cp">#define MAX_MCAST_LST			32</span>
<span class="cp">#define HW_MCAST_SIZE			8</span>

<span class="cm">/**</span>
<span class="cm"> * union ks_tx_hdr - tx header data</span>
<span class="cm"> * @txb: The header as bytes</span>
<span class="cm"> * @txw: The header as 16bit, little-endian words</span>
<span class="cm"> *</span>
<span class="cm"> * A dual representation of the tx header data to allow</span>
<span class="cm"> * access to individual bytes, and to allow 16bit accesses</span>
<span class="cm"> * with 16bit alignment.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">ks_tx_hdr</span> <span class="p">{</span>
	<span class="n">u8</span>      <span class="n">txb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">__le16</span>  <span class="n">txw</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ks_net - KS8851 driver private data</span>
<span class="cm"> * @net_device 	: The network device we&#39;re bound to</span>
<span class="cm"> * @hw_addr	: start address of data register.</span>
<span class="cm"> * @hw_addr_cmd	: start address of command register.</span>
<span class="cm"> * @txh    	: temporaly buffer to save status/length.</span>
<span class="cm"> * @lock	: Lock to ensure that the device is not accessed when busy.</span>
<span class="cm"> * @pdev	: Pointer to platform device.</span>
<span class="cm"> * @mii		: The MII state information for the mii calls.</span>
<span class="cm"> * @frame_head_info   	: frame header information for multi-pkt rx.</span>
<span class="cm"> * @statelock	: Lock on this structure for tx list.</span>
<span class="cm"> * @msg_enable	: The message flags controlling driver output (see ethtool).</span>
<span class="cm"> * @frame_cnt  	: number of frames received.</span>
<span class="cm"> * @bus_width  	: i/o bus width.</span>
<span class="cm"> * @rc_rxqcr	: Cached copy of KS_RXQCR.</span>
<span class="cm"> * @rc_txcr	: Cached copy of KS_TXCR.</span>
<span class="cm"> * @rc_ier	: Cached copy of KS_IER.</span>
<span class="cm"> * @sharedbus  	: Multipex(addr and data bus) mode indicator.</span>
<span class="cm"> * @cmd_reg_cache	: command register cached.</span>
<span class="cm"> * @cmd_reg_cache_int	: command register cached. Used in the irq handler.</span>
<span class="cm"> * @promiscuous	: promiscuous mode indicator.</span>
<span class="cm"> * @all_mcast  	: mutlicast indicator.</span>
<span class="cm"> * @mcast_lst_size   	: size of multicast list.</span>
<span class="cm"> * @mcast_lst    	: multicast list.</span>
<span class="cm"> * @mcast_bits    	: multicast enabed.</span>
<span class="cm"> * @mac_addr   		: MAC address assigned to this device.</span>
<span class="cm"> * @fid    		: frame id.</span>
<span class="cm"> * @extra_byte    	: number of extra byte prepended rx pkt.</span>
<span class="cm"> * @enabled    		: indicator this device works.</span>
<span class="cm"> *</span>
<span class="cm"> * The @lock ensures that the chip is protected when certain operations are</span>
<span class="cm"> * in progress. When the read or write packet transfer is in progress, most</span>
<span class="cm"> * of the chip registers are not accessible until the transfer is finished and</span>
<span class="cm"> * the DMA has been de-asserted.</span>
<span class="cm"> *</span>
<span class="cm"> * The @statelock is used to protect information in the structure which may</span>
<span class="cm"> * need to be accessed via several sources, such as the network driver layer</span>
<span class="cm"> * or one of the work queues.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/* Receive multiplex framer header info */</span>
<span class="k">struct</span> <span class="n">type_frame_head</span> <span class="p">{</span>
	<span class="n">u16</span>	<span class="n">sts</span><span class="p">;</span>         <span class="cm">/* Frame status */</span>
	<span class="n">u16</span>	<span class="n">len</span><span class="p">;</span>         <span class="cm">/* Byte count */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ks_net</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>    	<span class="o">*</span><span class="n">hw_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>    	<span class="o">*</span><span class="n">hw_addr_cmd</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ks_tx_hdr</span>		<span class="n">txh</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>      	<span class="n">lock</span><span class="p">;</span> <span class="cm">/* spinlock to be interrupt safe */</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mii_if_info</span>	<span class="n">mii</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_frame_head</span>	<span class="o">*</span><span class="n">frame_head_info</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">statelock</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">msg_enable</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">frame_cnt</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bus_width</span><span class="p">;</span>

	<span class="n">u16</span>			<span class="n">rc_rxqcr</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">rc_txcr</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">rc_ier</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">sharedbus</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">cmd_reg_cache</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">cmd_reg_cache_int</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">promiscuous</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">all_mcast</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">mcast_lst_size</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">mcast_lst</span><span class="p">[</span><span class="n">MAX_MCAST_LST</span><span class="p">][</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="n">mcast_bits</span><span class="p">[</span><span class="n">HW_MCAST_SIZE</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="n">mac_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">u8</span>                      <span class="n">fid</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">extra_byte</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">enabled</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">msg_enable</span><span class="p">;</span>

<span class="cp">#define BE3             0x8000      </span><span class="cm">/* Byte Enable 3 */</span><span class="cp"></span>
<span class="cp">#define BE2             0x4000      </span><span class="cm">/* Byte Enable 2 */</span><span class="cp"></span>
<span class="cp">#define BE1             0x2000      </span><span class="cm">/* Byte Enable 1 */</span><span class="cp"></span>
<span class="cp">#define BE0             0x1000      </span><span class="cm">/* Byte Enable 0 */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * register read/write calls.</span>
<span class="cm"> *</span>
<span class="cm"> * All these calls issue transactions to access the chip&#39;s registers. They</span>
<span class="cm"> * all require that the necessary lock is held to prevent accesses when the</span>
<span class="cm"> * chip is busy transferring packet data (RX/TX FIFO accesses).</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ks_rdreg8 - read 8 bit register from device</span>
<span class="cm"> * @ks	  : The chip information</span>
<span class="cm"> * @offset: The register address</span>
<span class="cm"> *</span>
<span class="cm"> * Read a 8bit register from the chip, returning the result</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">ks_rdreg8</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">shift_bit</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">shift_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">offset</span> <span class="o">|</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">BE0</span> <span class="o">&lt;&lt;</span> <span class="n">shift_bit</span><span class="p">);</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr_cmd</span><span class="p">);</span>
	<span class="n">data</span>  <span class="o">=</span> <span class="n">ioread16</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="n">shift_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_rdreg16 - read 16 bit register from device</span>
<span class="cm"> * @ks	  : The chip information</span>
<span class="cm"> * @offset: The register address</span>
<span class="cm"> *</span>
<span class="cm"> * Read a 16bit register from the chip, returning the result</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">ks_rdreg16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">offset</span> <span class="o">|</span> <span class="p">((</span><span class="n">BE1</span> <span class="o">|</span> <span class="n">BE0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">));</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr_cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ioread16</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_wrreg8 - write 8bit register value to chip</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> * @offset: The register address</span>
<span class="cm"> * @value: The value to write</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_wrreg8</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>  <span class="n">shift_bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">value_write</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">offset</span> <span class="o">|</span> <span class="p">(</span><span class="n">BE0</span> <span class="o">&lt;&lt;</span> <span class="n">shift_bit</span><span class="p">);</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr_cmd</span><span class="p">);</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">value_write</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_wrreg16 - write 16bit register value to chip</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> * @offset: The register address</span>
<span class="cm"> * @value: The value to write</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_wrreg16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">offset</span> <span class="o">|</span> <span class="p">((</span><span class="n">BE1</span> <span class="o">|</span> <span class="n">BE0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">));</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr_cmd</span><span class="p">);</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_inblk - read a block of data from QMU. This is called after sudo DMA mode enabled.</span>
<span class="cm"> * @ks: The chip state</span>
<span class="cm"> * @wptr: buffer address to save data</span>
<span class="cm"> * @len: length in byte to read</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ks_inblk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">wptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">len</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span><span class="n">wptr</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">ioread16</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_outblk - write data to QMU. This is called after sudo DMA mode enabled.</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> * @wptr: buffer address</span>
<span class="cm"> * @len: length in byte to write</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ks_outblk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">wptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">len</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span>
		<span class="n">iowrite16</span><span class="p">(</span><span class="o">*</span><span class="n">wptr</span><span class="o">++</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_disable_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_IER</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
<span class="p">}</span>  <span class="cm">/* ks_disable_int */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_enable_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_IER</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">rc_ier</span><span class="p">);</span>
<span class="p">}</span>  <span class="cm">/* ks_enable_int */</span>

<span class="cm">/**</span>
<span class="cm"> * ks_tx_fifo_space - return the available hardware buffer size.</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ks_tx_fifo_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_TXMIR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1fff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_save_cmd_reg - save the command register from the cache.</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ks_save_cmd_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*ks8851 MLL has a bug to read back the command register.</span>
<span class="cm">	* So rely on software to save the content of command register.</span>
<span class="cm">	*/</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache_int</span> <span class="o">=</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_restore_cmd_reg - restore the command register from the cache and</span>
<span class="cm"> * 	write to hardware register.</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ks_restore_cmd_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache</span> <span class="o">=</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache_int</span><span class="p">;</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">cmd_reg_cache</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr_cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_set_powermode - set power mode of the device</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> * @pwrmode: The power mode value to write to KS_PMECR.</span>
<span class="cm"> *</span>
<span class="cm"> * Change the power mode of the chip.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_set_powermode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">pwrmode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">pmecr</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;setting power mode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pwrmode</span><span class="p">);</span>

	<span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_GRR</span><span class="p">);</span>
	<span class="n">pmecr</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_PMECR</span><span class="p">);</span>
	<span class="n">pmecr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PMECR_PM_MASK</span><span class="p">;</span>
	<span class="n">pmecr</span> <span class="o">|=</span> <span class="n">pwrmode</span><span class="p">;</span>

	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_PMECR</span><span class="p">,</span> <span class="n">pmecr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_read_config - read chip configuration of bus width.</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_read_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">reg_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Regardless of bus width, 8 bit read should always work.*/</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">ks_rdreg8</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_CCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00FF</span><span class="p">;</span>
	<span class="n">reg_data</span> <span class="o">|=</span> <span class="n">ks_rdreg8</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_CCR</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>

	<span class="cm">/* addr/data bus are multiplexed */</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">sharedbus</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg_data</span> <span class="o">&amp;</span> <span class="n">CCR_SHARED</span><span class="p">)</span> <span class="o">==</span> <span class="n">CCR_SHARED</span><span class="p">;</span>

	<span class="cm">/* There are garbage data when reading data from QMU,</span>
<span class="cm">	depending on bus-width.</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg_data</span> <span class="o">&amp;</span> <span class="n">CCR_8BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">bus_width</span> <span class="o">=</span> <span class="n">ENUM_BUS_8BIT</span><span class="p">;</span>
		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">extra_byte</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_data</span> <span class="o">&amp;</span> <span class="n">CCR_16BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">bus_width</span> <span class="o">=</span> <span class="n">ENUM_BUS_16BIT</span><span class="p">;</span>
		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">extra_byte</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">bus_width</span> <span class="o">=</span> <span class="n">ENUM_BUS_32BIT</span><span class="p">;</span>
		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">extra_byte</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_soft_reset - issue one of the soft reset to the device</span>
<span class="cm"> * @ks: The device state.</span>
<span class="cm"> * @op: The bit(s) to set in the GRR</span>
<span class="cm"> *</span>
<span class="cm"> * Issue the relevant soft-reset command to the device&#39;s GRR register</span>
<span class="cm"> * specified by @op.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the delays are in there as a caution to ensure that the reset</span>
<span class="cm"> * has time to take effect and then complete. Since the datasheet does</span>
<span class="cm"> * not currently specify the exact sequence, we have chosen something</span>
<span class="cm"> * that seems to work with our device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_soft_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable interrupt first */</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_IER</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_GRR</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>	<span class="cm">/* wait a short time to effect reset */</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_GRR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>	<span class="cm">/* wait for condition to clear */</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">ks_enable_qmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">w</span><span class="p">;</span>

	<span class="n">w</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_TXCR</span><span class="p">);</span>
	<span class="cm">/* Enables QMU Transmit (TXCR). */</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_TXCR</span><span class="p">,</span> <span class="n">w</span> <span class="o">|</span> <span class="n">TXCR_TXE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * RX Frame Count Threshold Enable and Auto-Dequeue RXQ Frame</span>
<span class="cm">	 * Enable</span>
<span class="cm">	 */</span>

	<span class="n">w</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXQCR</span><span class="p">);</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXQCR</span><span class="p">,</span> <span class="n">w</span> <span class="o">|</span> <span class="n">RXQCR_RXFCTE</span><span class="p">);</span>

	<span class="cm">/* Enables QMU Receive (RXCR1). */</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">);</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">,</span> <span class="n">w</span> <span class="o">|</span> <span class="n">RXCR1_RXE</span><span class="p">);</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>  <span class="cm">/* ks_enable_qmu */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_disable_qmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span>	<span class="n">w</span><span class="p">;</span>

	<span class="n">w</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_TXCR</span><span class="p">);</span>

	<span class="cm">/* Disables QMU Transmit (TXCR). */</span>
	<span class="n">w</span>  <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TXCR_TXE</span><span class="p">;</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_TXCR</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

	<span class="cm">/* Disables QMU Receive (RXCR1). */</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">);</span>
	<span class="n">w</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RXCR1_RXE</span> <span class="p">;</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="p">}</span>  <span class="cm">/* ks_disable_qmu */</span>

<span class="cm">/**</span>
<span class="cm"> * ks_read_qmu - read 1 pkt data from the QMU.</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> * @buf: buffer address to save 1 pkt</span>
<span class="cm"> * @len: Pkt length</span>
<span class="cm"> * Here is the sequence to read 1 pkt:</span>
<span class="cm"> *	1. set sudo DMA mode</span>
<span class="cm"> *	2. read prepend data</span>
<span class="cm"> *	3. read pkt data</span>
<span class="cm"> *	4. reset sudo DMA Mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ks_read_qmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">r</span> <span class="o">=</span>  <span class="n">ks</span><span class="o">-&gt;</span><span class="n">extra_byte</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="p">;</span>
	<span class="n">u32</span> <span class="n">w</span> <span class="o">=</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">extra_byte</span> <span class="o">-</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/* 1. set sudo DMA mode */</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXFDPR</span><span class="p">,</span> <span class="n">RXFDPR_RXFPAI</span><span class="p">);</span>
	<span class="n">ks_wrreg8</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXQCR</span><span class="p">,</span> <span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">rc_rxqcr</span> <span class="o">|</span> <span class="n">RXQCR_SDA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

	<span class="cm">/* 2. read prepend data */</span>
	<span class="cm">/**</span>
<span class="cm">	 * read 4 + extra bytes and discard them.</span>
<span class="cm">	 * extra bytes for dummy, 2 for status, 2 for len</span>
<span class="cm">	 */</span>

	<span class="cm">/* use likely(r) for 8 bit access for performance */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
		<span class="n">ioread8</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
	<span class="n">ks_inblk</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">w</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* 3. read pkt data */</span>
	<span class="n">ks_inblk</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span>

	<span class="cm">/* 4. reset sudo DMA Mode */</span>
	<span class="n">ks_wrreg8</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXQCR</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">rc_rxqcr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_rcv - read multiple pkts data from the QMU.</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> * @netdev: The network device being opened.</span>
<span class="cm"> *</span>
<span class="cm"> * Read all of header information before reading pkt content.</span>
<span class="cm"> * It is not allowed only port of pkts in QMU after issuing</span>
<span class="cm"> * interrupt ack.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_frame_head</span> <span class="o">*</span><span class="n">frame_hdr</span> <span class="o">=</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">frame_head_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">frame_cnt</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXFCTR</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>

	<span class="cm">/* read all header information */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">frame_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Checking Received packet status */</span>
		<span class="n">frame_hdr</span><span class="o">-&gt;</span><span class="n">sts</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXFHSR</span><span class="p">);</span>
		<span class="cm">/* Get packet len from hardware */</span>
		<span class="n">frame_hdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXFHBCR</span><span class="p">);</span>
		<span class="n">frame_hdr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">frame_hdr</span> <span class="o">=</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">frame_head_info</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">frame_cnt</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">frame_hdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">frame_hdr</span><span class="o">-&gt;</span><span class="n">sts</span> <span class="o">&amp;</span> <span class="n">RXFSHR_RXFV</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">frame_hdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">RX_BUF_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">frame_hdr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="cm">/* read data block including CRC 4 bytes */</span>
			<span class="n">ks_read_qmu</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">frame_hdr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frame_hdr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
			<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: err:skb alloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXQCR</span><span class="p">,</span> <span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">rc_rxqcr</span> <span class="o">|</span> <span class="n">RXQCR_RRXEF</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
				<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">frame_hdr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_update_link_status - link status update.</span>
<span class="cm"> * @netdev: The network device being opened.</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_update_link_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* check the status of the link */</span>
	<span class="n">u32</span> <span class="n">link_up_status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_P1SR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">P1SR_LINK_GOOD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">link_up_status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">link_up_status</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
		  <span class="s">&quot;%s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">link_up_status</span> <span class="o">?</span> <span class="s">&quot;UP&quot;</span> <span class="o">:</span> <span class="s">&quot;DOWN&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_irq - device interrupt handler</span>
<span class="cm"> * @irq: Interrupt number passed from the IRQ handler.</span>
<span class="cm"> * @pw: The private word passed to register_irq(), our struct ks_net.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the handler invoked to find out what happened</span>
<span class="cm"> *</span>
<span class="cm"> * Read the interrupt status, work out what needs to be done and then clear</span>
<span class="cm"> * any of the interrupts that are not needed.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ks_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/*this should be the first in IRQ handler */</span>
	<span class="n">ks_save_cmd_reg</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_ISR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ks_restore_cmd_reg</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_ISR</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRQ_RXI</span><span class="p">))</span>
		<span class="n">ks_rcv</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRQ_LCI</span><span class="p">))</span>
		<span class="n">ks_update_link_status</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">ks</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRQ_TXI</span><span class="p">))</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRQ_LDI</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">u16</span> <span class="n">pmecr</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_PMECR</span><span class="p">);</span>
		<span class="n">pmecr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PMECR_WKEVT_MASK</span><span class="p">;</span>
		<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_PMECR</span><span class="p">,</span> <span class="n">pmecr</span> <span class="o">|</span> <span class="n">PMECR_WKEVT_LINK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* this should be the last in IRQ handler*/</span>
	<span class="n">ks_restore_cmd_reg</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * ks_net_open - open network device</span>
<span class="cm"> * @netdev: The network device being opened.</span>
<span class="cm"> *</span>
<span class="cm"> * Called when the network device is marked active, such as a user executing</span>
<span class="cm"> * &#39;ifconfig up&#39; on the device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

<span class="cp">#define	KS_INT_FLAGS	(IRQF_DISABLED|IRQF_TRIGGER_LOW)</span>
	<span class="cm">/* lock the card, even if we may not actually do anything</span>
<span class="cm">	 * else at the moment.</span>
<span class="cm">	 */</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;%s - entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* reset the HW */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ks_irq</span><span class="p">,</span> <span class="n">KS_INT_FLAGS</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to request IRQ: %d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* wake up powermode to normal mode */</span>
	<span class="n">ks_set_powermode</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">PMECR_PM_NORMAL</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>	<span class="cm">/* wait for normal mode to take effect */</span>

	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_ISR</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">ks_enable_int</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="n">ks_enable_qmu</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;network device up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_net_stop - close network device</span>
<span class="cm"> * @netdev: The device being closed.</span>
<span class="cm"> *</span>
<span class="cm"> * Called to close down a network device which has been active. Cancell any</span>
<span class="cm"> * work, shutdown the RX and TX process and then place the chip into a low</span>
<span class="cm"> * power state whilst it is not being used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_net_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;shutting down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* turn off the IRQs and ack any outstanding */</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_IER</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_ISR</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>

	<span class="cm">/* shutdown RX/TX QMU */</span>
	<span class="n">ks_disable_qmu</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>

	<span class="cm">/* set powermode to soft power down to save power */</span>
	<span class="n">ks_set_powermode</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">PMECR_PM_SOFTDOWN</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * ks_write_qmu - write 1 pkt data to the QMU.</span>
<span class="cm"> * @ks: The chip information</span>
<span class="cm"> * @pdata: buffer address to save 1 pkt</span>
<span class="cm"> * @len: Pkt length in byte</span>
<span class="cm"> * Here is the sequence to write 1 pkt:</span>
<span class="cm"> *	1. set sudo DMA mode</span>
<span class="cm"> *	2. write status/length</span>
<span class="cm"> *	3. write pkt data</span>
<span class="cm"> *	4. reset sudo DMA Mode</span>
<span class="cm"> *	5. reset sudo DMA mode</span>
<span class="cm"> *	6. Wait until pkt is out</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_write_qmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">pdata</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* start header at txb[0] to align txw entries */</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">txh</span><span class="p">.</span><span class="n">txw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">txh</span><span class="p">.</span><span class="n">txw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* 1. set sudo-DMA mode */</span>
	<span class="n">ks_wrreg8</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXQCR</span><span class="p">,</span> <span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">rc_rxqcr</span> <span class="o">|</span> <span class="n">RXQCR_SDA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="cm">/* 2. write status/lenth info */</span>
	<span class="n">ks_outblk</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">txh</span><span class="p">.</span><span class="n">txw</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="cm">/* 3. write pkt data */</span>
	<span class="n">ks_outblk</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">pdata</span><span class="p">,</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span>
	<span class="cm">/* 4. reset sudo-DMA mode */</span>
	<span class="n">ks_wrreg8</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXQCR</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">rc_rxqcr</span><span class="p">);</span>
	<span class="cm">/* 5. Enqueue Tx(move the pkt from TX buffer into TXQ) */</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_TXQCR</span><span class="p">,</span> <span class="n">TXQCR_METFE</span><span class="p">);</span>
	<span class="cm">/* 6. wait until TXQCR_METFE is auto-cleared */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_TXQCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TXQCR_METFE</span><span class="p">)</span>
		<span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_start_xmit - transmit packet</span>
<span class="cm"> * @skb		: The buffer to transmit</span>
<span class="cm"> * @netdev	: The device used to transmit the packet.</span>
<span class="cm"> *</span>
<span class="cm"> * Called by the network layer to transmit the @skb.</span>
<span class="cm"> * spin_lock_irqsave is required because tx and rx should be mutual exclusive.</span>
<span class="cm"> * So while tx is in-progress, prevent IRQ interrupt from happenning.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retv</span> <span class="o">=</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">disable_irq</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">ks_disable_int</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">statelock</span><span class="p">);</span>

	<span class="cm">/* Extra space are required:</span>
<span class="cm">	*  4 byte for alignment, 4 for status/length, 4 for CRC</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ks_tx_fifo_space</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">12</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ks_write_qmu</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">retv</span> <span class="o">=</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">statelock</span><span class="p">);</span>
	<span class="n">ks_enable_int</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_start_rx - ready to serve pkts</span>
<span class="cm"> * @ks		: The chip information</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_start_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">cntl</span><span class="p">;</span>

	<span class="cm">/* Enables QMU Receive (RXCR1). */</span>
	<span class="n">cntl</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">);</span>
	<span class="n">cntl</span> <span class="o">|=</span> <span class="n">RXCR1_RXE</span> <span class="p">;</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">,</span> <span class="n">cntl</span><span class="p">);</span>
<span class="p">}</span>  <span class="cm">/* ks_start_rx */</span>

<span class="cm">/**</span>
<span class="cm"> * ks_stop_rx - stop to serve pkts</span>
<span class="cm"> * @ks		: The chip information</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_stop_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">cntl</span><span class="p">;</span>

	<span class="cm">/* Disables QMU Receive (RXCR1). */</span>
	<span class="n">cntl</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">);</span>
	<span class="n">cntl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RXCR1_RXE</span> <span class="p">;</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">,</span> <span class="n">cntl</span><span class="p">);</span>

<span class="p">}</span>  <span class="cm">/* ks_stop_rx */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">ethernet_polynomial</span> <span class="o">=</span> <span class="mh">0x04c11db7U</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ether_gen_crc</span><span class="p">(</span><span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">crc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">current_octet</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="o">++</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bit</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">bit</span><span class="o">++</span><span class="p">,</span> <span class="n">current_octet</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">crc</span> <span class="o">=</span> <span class="p">(</span><span class="n">crc</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span>
				<span class="p">((</span><span class="n">crc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">current_octet</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">ethernet_polynomial</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">crc</span><span class="p">;</span>
<span class="p">}</span>  <span class="cm">/* ether_gen_crc */</span>

<span class="cm">/**</span>
<span class="cm">* ks_set_grpaddr - set multicast information</span>
<span class="cm">* @ks : The chip information</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_set_grpaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>	<span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">index</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_bits</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="o">*</span> <span class="n">HW_MCAST_SIZE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_lst_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="n">ether_gen_crc</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_lst</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">position</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">position</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_bits</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HW_MCAST_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">KS_MAHTR0</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">),</span>
				<span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_bits</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>  <span class="cm">/* ks_set_grpaddr */</span>

<span class="cm">/*</span>
<span class="cm">* ks_clear_mcast - clear multicast information</span>
<span class="cm">*</span>
<span class="cm">* @ks : The chip information</span>
<span class="cm">* This routine removes all mcast addresses set in the hardware.</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_clear_mcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span>	<span class="n">i</span><span class="p">,</span> <span class="n">mcast_size</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HW_MCAST_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mcast_size</span> <span class="o">=</span> <span class="n">HW_MCAST_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mcast_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_MAHTR0</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_set_promis</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="n">u16</span> <span class="n">promiscuous_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span>		<span class="n">cntl</span><span class="p">;</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">promiscuous</span> <span class="o">=</span> <span class="n">promiscuous_mode</span><span class="p">;</span>
	<span class="n">ks_stop_rx</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>  <span class="cm">/* Stop receiving for reconfiguration */</span>
	<span class="n">cntl</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">);</span>

	<span class="n">cntl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RXCR1_FILTER_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">promiscuous_mode</span><span class="p">)</span>
		<span class="cm">/* Enable Promiscuous mode */</span>
		<span class="n">cntl</span> <span class="o">|=</span> <span class="n">RXCR1_RXAE</span> <span class="o">|</span> <span class="n">RXCR1_RXINVF</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* Disable Promiscuous mode (default normal mode) */</span>
		<span class="n">cntl</span> <span class="o">|=</span> <span class="n">RXCR1_RXPAFMA</span><span class="p">;</span>

	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">,</span> <span class="n">cntl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">ks_start_rx</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>

<span class="p">}</span>  <span class="cm">/* ks_set_promis */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_set_mcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mcast</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span>	<span class="n">cntl</span><span class="p">;</span>

	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">all_mcast</span> <span class="o">=</span> <span class="n">mcast</span><span class="p">;</span>
	<span class="n">ks_stop_rx</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>  <span class="cm">/* Stop receiving for reconfiguration */</span>
	<span class="n">cntl</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">);</span>
	<span class="n">cntl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RXCR1_FILTER_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcast</span><span class="p">)</span>
		<span class="cm">/* Enable &quot;Perfect with Multicast address passed mode&quot; */</span>
		<span class="n">cntl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">RXCR1_RXAE</span> <span class="o">|</span> <span class="n">RXCR1_RXMAFMA</span> <span class="o">|</span> <span class="n">RXCR1_RXPAFMA</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/**</span>
<span class="cm">		 * Disable &quot;Perfect with Multicast address passed</span>
<span class="cm">		 * mode&quot; (normal mode).</span>
<span class="cm">		 */</span>
		<span class="n">cntl</span> <span class="o">|=</span> <span class="n">RXCR1_RXPAFMA</span><span class="p">;</span>

	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">,</span> <span class="n">cntl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">ks_start_rx</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
<span class="p">}</span>  <span class="cm">/* ks_set_mcast */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

	<span class="cm">/* Turn on/off promiscuous mode. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="o">==</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
		<span class="n">ks_set_promis</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="o">==</span> <span class="n">IFF_PROMISC</span><span class="p">));</span>
	<span class="cm">/* Turn on/off all mcast mode. */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="o">==</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span>
		<span class="n">ks_set_mcast</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="o">==</span> <span class="n">IFF_ALLMULTI</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">ks_set_promis</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_MULTICAST</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">MAX_MCAST_LST</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">MAX_MCAST_LST</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_lst</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_lst_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
			<span class="n">ks_set_grpaddr</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/**</span>
<span class="cm">			 * List too big to support so</span>
<span class="cm">			 * turn on all mcast mode.</span>
<span class="cm">			 */</span>
			<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_lst_size</span> <span class="o">=</span> <span class="n">MAX_MCAST_LST</span><span class="p">;</span>
			<span class="n">ks_set_mcast</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_lst_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ks_clear_mcast</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="cm">/* ks_set_rx_mode */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_set_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">;</span>

	<span class="n">ks_stop_rx</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>  <span class="cm">/* Stop receiving for reconfiguration */</span>

	<span class="n">u</span> <span class="o">=</span> <span class="o">*</span><span class="n">pw</span><span class="o">++</span><span class="p">;</span>
	<span class="n">w</span> <span class="o">=</span> <span class="p">((</span><span class="n">u</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_MARH</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

	<span class="n">u</span> <span class="o">=</span> <span class="o">*</span><span class="n">pw</span><span class="o">++</span><span class="p">;</span>
	<span class="n">w</span> <span class="o">=</span> <span class="p">((</span><span class="n">u</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_MARM</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

	<span class="n">u</span> <span class="o">=</span> <span class="o">*</span><span class="n">pw</span><span class="p">;</span>
	<span class="n">w</span> <span class="o">=</span> <span class="p">((</span><span class="n">u</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_MARL</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">ks_start_rx</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">da</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_assign_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NET_ADDR_RANDOM</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="n">da</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">;</span>

	<span class="n">ks_set_mac</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">da</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_net_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">generic_mii_ioctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">,</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">req</span><span class="p">),</span> <span class="n">cmd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">ks_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">ks_net_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">ks_net_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">ks_net_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">ks_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">ks_set_mac_address</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">ks_set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">eth_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* ethtool support */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">di</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="s">&quot;1.00&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">ks_get_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_set_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mii_ethtool_gset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_set_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mii_ethtool_sset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">ks_get_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mii_link_ok</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_nway_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mii_nway_restart</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">ks_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_drvinfo</span>	<span class="o">=</span> <span class="n">ks_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span>	<span class="o">=</span> <span class="n">ks_get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span>	<span class="o">=</span> <span class="n">ks_set_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_settings</span>	<span class="o">=</span> <span class="n">ks_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span>	<span class="o">=</span> <span class="n">ks_set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span>	<span class="o">=</span> <span class="n">ks_get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nway_reset</span>	<span class="o">=</span> <span class="n">ks_nway_reset</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* MII interface controls */</span>

<span class="cm">/**</span>
<span class="cm"> * ks_phy_reg - convert MII register into a KS8851 register</span>
<span class="cm"> * @reg: MII register number.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the KS8851 register number for the corresponding MII PHY register</span>
<span class="cm"> * if possible. Return zero if the MII register has no direct mapping to the</span>
<span class="cm"> * KS8851 register set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_phy_reg</span><span class="p">(</span><span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MII_BMCR</span>:
		<span class="k">return</span> <span class="n">KS_P1MBCR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MII_BMSR</span>:
		<span class="k">return</span> <span class="n">KS_P1MBSR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MII_PHYSID1</span>:
		<span class="k">return</span> <span class="n">KS_PHY1ILR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MII_PHYSID2</span>:
		<span class="k">return</span> <span class="n">KS_PHY1IHR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MII_ADVERTISE</span>:
		<span class="k">return</span> <span class="n">KS_P1ANAR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MII_LPA</span>:
		<span class="k">return</span> <span class="n">KS_P1ANLPR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mh">0x0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_phy_read - MII interface PHY register read.</span>
<span class="cm"> * @netdev: The network device the PHY is on.</span>
<span class="cm"> * @phy_addr: Address of PHY (ignored as we only have one)</span>
<span class="cm"> * @reg: The register to read.</span>
<span class="cm"> *</span>
<span class="cm"> * This call reads data from the PHY register specified in @reg. Since the</span>
<span class="cm"> * device does not support all the MII registers, the non-existent values</span>
<span class="cm"> * are always returned as zero.</span>
<span class="cm"> *</span>
<span class="cm"> * We return zero for unsupported registers as the MII code does not check</span>
<span class="cm"> * the value returned for any error status, and simply returns it to the</span>
<span class="cm"> * caller. The mii-tool that the driver was tested with takes any -ve error</span>
<span class="cm"> * as real PHY capabilities, thus displaying incorrect data to the user.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_phy_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ksreg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">ksreg</span> <span class="o">=</span> <span class="n">ks_phy_reg</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ksreg</span><span class="p">)</span>
		<span class="k">return</span> <span class="mh">0x0</span><span class="p">;</span>	<span class="cm">/* no error return allowed, so use zero */</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">ksreg</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_phy_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ksreg</span><span class="p">;</span>

	<span class="n">ksreg</span> <span class="o">=</span> <span class="n">ks_phy_reg</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ksreg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">ksreg</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ks_read_selftest - read the selftest memory info.</span>
<span class="cm"> * @ks: The device state</span>
<span class="cm"> *</span>
<span class="cm"> * Read and check the TX/RX memory selftest information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_read_selftest</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">both_done</span> <span class="o">=</span> <span class="n">MBIR_TXMBF</span> <span class="o">|</span> <span class="n">MBIR_RXMBF</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rd</span><span class="p">;</span>

	<span class="n">rd</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_MBIR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rd</span> <span class="o">&amp;</span> <span class="n">both_done</span><span class="p">)</span> <span class="o">!=</span> <span class="n">both_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_warn</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Memory selftest not finished</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rd</span> <span class="o">&amp;</span> <span class="n">MBIR_TXMBFA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;TX memory selftest fails</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rd</span> <span class="o">&amp;</span> <span class="n">MBIR_RXMBFA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;RX memory selftest fails</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netdev_info</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;the selftest passes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span>	<span class="n">w</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Configure QMU Transmit</span>
<span class="cm">	 */</span>

	<span class="cm">/* Setup Transmit Frame Data Pointer Auto-Increment (TXFDPR) */</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_TXFDPR</span><span class="p">,</span> <span class="n">TXFDPR_TXFPAI</span><span class="p">);</span>

	<span class="cm">/* Setup Receive Frame Data Pointer Auto-Increment */</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXFDPR</span><span class="p">,</span> <span class="n">RXFDPR_RXFPAI</span><span class="p">);</span>

	<span class="cm">/* Setup Receive Frame Threshold - 1 frame (RXFCTFC) */</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXFCTR</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="n">RXFCTR_THRESHOLD_MASK</span><span class="p">);</span>

	<span class="cm">/* Setup RxQ Command Control (RXQCR) */</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">rc_rxqcr</span> <span class="o">=</span> <span class="n">RXQCR_CMD_CNTL</span><span class="p">;</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXQCR</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">rc_rxqcr</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * set the force mode to half duplex, default is full duplex</span>
<span class="cm">	 *  because if the auto-negotiation fails, most switch uses</span>
<span class="cm">	 *  half-duplex.</span>
<span class="cm">	 */</span>

	<span class="n">w</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_P1MBCR</span><span class="p">);</span>
	<span class="n">w</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">P1MBCR_FORCE_FDX</span><span class="p">;</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_P1MBCR</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

	<span class="n">w</span> <span class="o">=</span> <span class="n">TXCR_TXFCE</span> <span class="o">|</span> <span class="n">TXCR_TXPE</span> <span class="o">|</span> <span class="n">TXCR_TXCRC</span> <span class="o">|</span> <span class="n">TXCR_TCGIP</span><span class="p">;</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_TXCR</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

	<span class="n">w</span> <span class="o">=</span> <span class="n">RXCR1_RXFCE</span> <span class="o">|</span> <span class="n">RXCR1_RXBE</span> <span class="o">|</span> <span class="n">RXCR1_RXUE</span> <span class="o">|</span> <span class="n">RXCR1_RXME</span> <span class="o">|</span> <span class="n">RXCR1_RXIPFCC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">promiscuous</span><span class="p">)</span>         <span class="cm">/* bPromiscuous */</span>
		<span class="n">w</span> <span class="o">|=</span> <span class="p">(</span><span class="n">RXCR1_RXAE</span> <span class="o">|</span> <span class="n">RXCR1_RXINVF</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">all_mcast</span><span class="p">)</span> <span class="cm">/* Multicast address passed mode */</span>
		<span class="n">w</span> <span class="o">|=</span> <span class="p">(</span><span class="n">RXCR1_RXAE</span> <span class="o">|</span> <span class="n">RXCR1_RXMAFMA</span> <span class="o">|</span> <span class="n">RXCR1_RXPAFMA</span><span class="p">);</span>
	<span class="k">else</span>                                   <span class="cm">/* Normal mode */</span>
		<span class="n">w</span> <span class="o">|=</span> <span class="n">RXCR1_RXPAFMA</span><span class="p">;</span>

	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_RXCR1</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
<span class="p">}</span>  <span class="cm">/*ks_setup */</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">ks_setup_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">rc_ier</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="cm">/* Clear the interrupts status of the hardware. */</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_ISR</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>

	<span class="cm">/* Enables the interrupts of the hardware. */</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">rc_ier</span> <span class="o">=</span> <span class="p">(</span><span class="n">IRQ_LCI</span> <span class="o">|</span> <span class="n">IRQ_TXI</span> <span class="o">|</span> <span class="n">IRQ_RXI</span><span class="p">);</span>
<span class="p">}</span>  <span class="cm">/* ks_setup_int */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ks_hw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define	MHEADER_SIZE	(sizeof(struct type_frame_head) * MAX_RECV_FRAMES)</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">promiscuous</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">all_mcast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mcast_lst_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">frame_head_info</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">MHEADER_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">frame_head_info</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">ks_set_mac</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_DEFAULT_MAC_ADDRESS</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ks8851_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">io_d</span><span class="p">,</span> <span class="o">*</span><span class="n">io_c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">id</span><span class="p">,</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">io_d</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">io_c</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">io_d</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">io_d</span><span class="p">),</span> <span class="n">DRV_NAME</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_mem_region</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">io_c</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">io_c</span><span class="p">),</span> <span class="n">DRV_NAME</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_mem_region1</span><span class="p">;</span>

	<span class="n">netdev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ks_net</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc_etherdev</span><span class="p">;</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">io_d</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">io_d</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_ioremap</span><span class="p">;</span>

	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr_cmd</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">io_c</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">io_c</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr_cmd</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_ioremap1</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_get_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">statelock</span><span class="p">);</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ks_netdev_ops</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ks_ethtool_ops</span><span class="p">;</span>

	<span class="cm">/* setup mii state */</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">.</span><span class="n">dev</span>             <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">.</span><span class="n">phy_id</span>          <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">.</span><span class="n">phy_id_mask</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">.</span><span class="n">reg_num_mask</span>    <span class="o">=</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">.</span><span class="n">mdio_read</span>       <span class="o">=</span> <span class="n">ks_phy_read</span><span class="p">;</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">.</span><span class="n">mdio_write</span>      <span class="o">=</span> <span class="n">ks_phy_write</span><span class="p">;</span>

	<span class="n">netdev_info</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;message enable is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg_enable</span><span class="p">);</span>
	<span class="cm">/* set the default message enable */</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">netif_msg_init</span><span class="p">(</span><span class="n">msg_enable</span><span class="p">,</span> <span class="p">(</span><span class="n">NETIF_MSG_DRV</span> <span class="o">|</span>
						     <span class="n">NETIF_MSG_PROBE</span> <span class="o">|</span>
						     <span class="n">NETIF_MSG_LINK</span><span class="p">));</span>
	<span class="n">ks_read_config</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>

	<span class="cm">/* simple check for a valid chip being connected to the bus */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_CIDER</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CIDER_REV_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CIDER_ID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;failed to read device ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_register</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ks_read_selftest</span><span class="p">(</span><span class="n">ks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;failed to read device ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_register</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_register</span><span class="p">;</span>

	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

	<span class="n">ks_soft_reset</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">GRR_GSR</span><span class="p">);</span>
	<span class="n">ks_hw_init</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="n">ks_disable_qmu</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="n">ks_setup</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="n">ks_setup_int</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_OBCR</span><span class="p">);</span>
	<span class="n">ks_wrreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_OBCR</span><span class="p">,</span> <span class="n">data</span> <span class="o">|</span> <span class="n">OBCR_ODS_16MA</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * If you want to use the default MAC addr,</span>
<span class="cm">	 * comment out the 2 functions below.</span>
<span class="cm">	 */</span>

	<span class="n">random_ether_addr</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="n">ks_set_mac</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">ks_rdreg16</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KS_CIDER</span><span class="p">);</span>

	<span class="n">netdev_info</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Found chip, family: 0x%x, id: 0x%x, rev: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="p">(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">,</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_register:</span>
<span class="nl">err_get_irq:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr_cmd</span><span class="p">);</span>
<span class="nl">err_ioremap1:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
<span class="nl">err_ioremap:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="nl">err_alloc_etherdev:</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">io_c</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">io_c</span><span class="p">));</span>
<span class="nl">err_mem_region1:</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">io_d</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">io_d</span><span class="p">));</span>
<span class="nl">err_mem_region:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">ks8851_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ks_net</span> <span class="o">*</span><span class="n">ks</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">iomem</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">frame_head_info</span><span class="p">);</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">iomem</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">iomem</span><span class="p">));</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">ks8851_platform_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">ks8851_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">ks8851_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">ks8851_platform_driver</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;KS8851 MLL Network driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;David Choi &lt;david.choi@micrel.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">msg_enable</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="s">&quot;Message verbosity level (0=none, 31=all)&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
