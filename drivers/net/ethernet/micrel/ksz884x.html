<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › micrel › ksz884x.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ksz884x.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * drivers/net/ethernet/micrel/ksx884x.c - Micrel KSZ8841/2 PCI Ethernet driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2009-2010 Micrel, Inc.</span>
<span class="cm"> * 	Tristram Ha &lt;Tristram.Ha@micrel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>


<span class="cm">/* DMA Registers */</span>

<span class="cp">#define KS_DMA_TX_CTRL			0x0000</span>
<span class="cp">#define DMA_TX_ENABLE			0x00000001</span>
<span class="cp">#define DMA_TX_CRC_ENABLE		0x00000002</span>
<span class="cp">#define DMA_TX_PAD_ENABLE		0x00000004</span>
<span class="cp">#define DMA_TX_LOOPBACK			0x00000100</span>
<span class="cp">#define DMA_TX_FLOW_ENABLE		0x00000200</span>
<span class="cp">#define DMA_TX_CSUM_IP			0x00010000</span>
<span class="cp">#define DMA_TX_CSUM_TCP			0x00020000</span>
<span class="cp">#define DMA_TX_CSUM_UDP			0x00040000</span>
<span class="cp">#define DMA_TX_BURST_SIZE		0x3F000000</span>

<span class="cp">#define KS_DMA_RX_CTRL			0x0004</span>
<span class="cp">#define DMA_RX_ENABLE			0x00000001</span>
<span class="cp">#define KS884X_DMA_RX_MULTICAST		0x00000002</span>
<span class="cp">#define DMA_RX_PROMISCUOUS		0x00000004</span>
<span class="cp">#define DMA_RX_ERROR			0x00000008</span>
<span class="cp">#define DMA_RX_UNICAST			0x00000010</span>
<span class="cp">#define DMA_RX_ALL_MULTICAST		0x00000020</span>
<span class="cp">#define DMA_RX_BROADCAST		0x00000040</span>
<span class="cp">#define DMA_RX_FLOW_ENABLE		0x00000200</span>
<span class="cp">#define DMA_RX_CSUM_IP			0x00010000</span>
<span class="cp">#define DMA_RX_CSUM_TCP			0x00020000</span>
<span class="cp">#define DMA_RX_CSUM_UDP			0x00040000</span>
<span class="cp">#define DMA_RX_BURST_SIZE		0x3F000000</span>

<span class="cp">#define DMA_BURST_SHIFT			24</span>
<span class="cp">#define DMA_BURST_DEFAULT		8</span>

<span class="cp">#define KS_DMA_TX_START			0x0008</span>
<span class="cp">#define KS_DMA_RX_START			0x000C</span>
<span class="cp">#define DMA_START			0x00000001</span>

<span class="cp">#define KS_DMA_TX_ADDR			0x0010</span>
<span class="cp">#define KS_DMA_RX_ADDR			0x0014</span>

<span class="cp">#define DMA_ADDR_LIST_MASK		0xFFFFFFFC</span>
<span class="cp">#define DMA_ADDR_LIST_SHIFT		2</span>

<span class="cm">/* MTR0 */</span>
<span class="cp">#define KS884X_MULTICAST_0_OFFSET	0x0020</span>
<span class="cp">#define KS884X_MULTICAST_1_OFFSET	0x0021</span>
<span class="cp">#define KS884X_MULTICAST_2_OFFSET	0x0022</span>
<span class="cp">#define KS884x_MULTICAST_3_OFFSET	0x0023</span>
<span class="cm">/* MTR1 */</span>
<span class="cp">#define KS884X_MULTICAST_4_OFFSET	0x0024</span>
<span class="cp">#define KS884X_MULTICAST_5_OFFSET	0x0025</span>
<span class="cp">#define KS884X_MULTICAST_6_OFFSET	0x0026</span>
<span class="cp">#define KS884X_MULTICAST_7_OFFSET	0x0027</span>

<span class="cm">/* Interrupt Registers */</span>

<span class="cm">/* INTEN */</span>
<span class="cp">#define KS884X_INTERRUPTS_ENABLE	0x0028</span>
<span class="cm">/* INTST */</span>
<span class="cp">#define KS884X_INTERRUPTS_STATUS	0x002C</span>

<span class="cp">#define KS884X_INT_RX_STOPPED		0x02000000</span>
<span class="cp">#define KS884X_INT_TX_STOPPED		0x04000000</span>
<span class="cp">#define KS884X_INT_RX_OVERRUN		0x08000000</span>
<span class="cp">#define KS884X_INT_TX_EMPTY		0x10000000</span>
<span class="cp">#define KS884X_INT_RX			0x20000000</span>
<span class="cp">#define KS884X_INT_TX			0x40000000</span>
<span class="cp">#define KS884X_INT_PHY			0x80000000</span>

<span class="cp">#define KS884X_INT_RX_MASK		\</span>
<span class="cp">	(KS884X_INT_RX | KS884X_INT_RX_OVERRUN)</span>
<span class="cp">#define KS884X_INT_TX_MASK		\</span>
<span class="cp">	(KS884X_INT_TX | KS884X_INT_TX_EMPTY)</span>
<span class="cp">#define KS884X_INT_MASK	(KS884X_INT_RX | KS884X_INT_TX | KS884X_INT_PHY)</span>

<span class="cm">/* MAC Additional Station Address */</span>

<span class="cm">/* MAAL0 */</span>
<span class="cp">#define KS_ADD_ADDR_0_LO		0x0080</span>
<span class="cm">/* MAAH0 */</span>
<span class="cp">#define KS_ADD_ADDR_0_HI		0x0084</span>
<span class="cm">/* MAAL1 */</span>
<span class="cp">#define KS_ADD_ADDR_1_LO		0x0088</span>
<span class="cm">/* MAAH1 */</span>
<span class="cp">#define KS_ADD_ADDR_1_HI		0x008C</span>
<span class="cm">/* MAAL2 */</span>
<span class="cp">#define KS_ADD_ADDR_2_LO		0x0090</span>
<span class="cm">/* MAAH2 */</span>
<span class="cp">#define KS_ADD_ADDR_2_HI		0x0094</span>
<span class="cm">/* MAAL3 */</span>
<span class="cp">#define KS_ADD_ADDR_3_LO		0x0098</span>
<span class="cm">/* MAAH3 */</span>
<span class="cp">#define KS_ADD_ADDR_3_HI		0x009C</span>
<span class="cm">/* MAAL4 */</span>
<span class="cp">#define KS_ADD_ADDR_4_LO		0x00A0</span>
<span class="cm">/* MAAH4 */</span>
<span class="cp">#define KS_ADD_ADDR_4_HI		0x00A4</span>
<span class="cm">/* MAAL5 */</span>
<span class="cp">#define KS_ADD_ADDR_5_LO		0x00A8</span>
<span class="cm">/* MAAH5 */</span>
<span class="cp">#define KS_ADD_ADDR_5_HI		0x00AC</span>
<span class="cm">/* MAAL6 */</span>
<span class="cp">#define KS_ADD_ADDR_6_LO		0x00B0</span>
<span class="cm">/* MAAH6 */</span>
<span class="cp">#define KS_ADD_ADDR_6_HI		0x00B4</span>
<span class="cm">/* MAAL7 */</span>
<span class="cp">#define KS_ADD_ADDR_7_LO		0x00B8</span>
<span class="cm">/* MAAH7 */</span>
<span class="cp">#define KS_ADD_ADDR_7_HI		0x00BC</span>
<span class="cm">/* MAAL8 */</span>
<span class="cp">#define KS_ADD_ADDR_8_LO		0x00C0</span>
<span class="cm">/* MAAH8 */</span>
<span class="cp">#define KS_ADD_ADDR_8_HI		0x00C4</span>
<span class="cm">/* MAAL9 */</span>
<span class="cp">#define KS_ADD_ADDR_9_LO		0x00C8</span>
<span class="cm">/* MAAH9 */</span>
<span class="cp">#define KS_ADD_ADDR_9_HI		0x00CC</span>
<span class="cm">/* MAAL10 */</span>
<span class="cp">#define KS_ADD_ADDR_A_LO		0x00D0</span>
<span class="cm">/* MAAH10 */</span>
<span class="cp">#define KS_ADD_ADDR_A_HI		0x00D4</span>
<span class="cm">/* MAAL11 */</span>
<span class="cp">#define KS_ADD_ADDR_B_LO		0x00D8</span>
<span class="cm">/* MAAH11 */</span>
<span class="cp">#define KS_ADD_ADDR_B_HI		0x00DC</span>
<span class="cm">/* MAAL12 */</span>
<span class="cp">#define KS_ADD_ADDR_C_LO		0x00E0</span>
<span class="cm">/* MAAH12 */</span>
<span class="cp">#define KS_ADD_ADDR_C_HI		0x00E4</span>
<span class="cm">/* MAAL13 */</span>
<span class="cp">#define KS_ADD_ADDR_D_LO		0x00E8</span>
<span class="cm">/* MAAH13 */</span>
<span class="cp">#define KS_ADD_ADDR_D_HI		0x00EC</span>
<span class="cm">/* MAAL14 */</span>
<span class="cp">#define KS_ADD_ADDR_E_LO		0x00F0</span>
<span class="cm">/* MAAH14 */</span>
<span class="cp">#define KS_ADD_ADDR_E_HI		0x00F4</span>
<span class="cm">/* MAAL15 */</span>
<span class="cp">#define KS_ADD_ADDR_F_LO		0x00F8</span>
<span class="cm">/* MAAH15 */</span>
<span class="cp">#define KS_ADD_ADDR_F_HI		0x00FC</span>

<span class="cp">#define ADD_ADDR_HI_MASK		0x0000FFFF</span>
<span class="cp">#define ADD_ADDR_ENABLE			0x80000000</span>
<span class="cp">#define ADD_ADDR_INCR			8</span>

<span class="cm">/* Miscellaneous Registers */</span>

<span class="cm">/* MARL */</span>
<span class="cp">#define KS884X_ADDR_0_OFFSET		0x0200</span>
<span class="cp">#define KS884X_ADDR_1_OFFSET		0x0201</span>
<span class="cm">/* MARM */</span>
<span class="cp">#define KS884X_ADDR_2_OFFSET		0x0202</span>
<span class="cp">#define KS884X_ADDR_3_OFFSET		0x0203</span>
<span class="cm">/* MARH */</span>
<span class="cp">#define KS884X_ADDR_4_OFFSET		0x0204</span>
<span class="cp">#define KS884X_ADDR_5_OFFSET		0x0205</span>

<span class="cm">/* OBCR */</span>
<span class="cp">#define KS884X_BUS_CTRL_OFFSET		0x0210</span>

<span class="cp">#define BUS_SPEED_125_MHZ		0x0000</span>
<span class="cp">#define BUS_SPEED_62_5_MHZ		0x0001</span>
<span class="cp">#define BUS_SPEED_41_66_MHZ		0x0002</span>
<span class="cp">#define BUS_SPEED_25_MHZ		0x0003</span>

<span class="cm">/* EEPCR */</span>
<span class="cp">#define KS884X_EEPROM_CTRL_OFFSET	0x0212</span>

<span class="cp">#define EEPROM_CHIP_SELECT		0x0001</span>
<span class="cp">#define EEPROM_SERIAL_CLOCK		0x0002</span>
<span class="cp">#define EEPROM_DATA_OUT			0x0004</span>
<span class="cp">#define EEPROM_DATA_IN			0x0008</span>
<span class="cp">#define EEPROM_ACCESS_ENABLE		0x0010</span>

<span class="cm">/* MBIR */</span>
<span class="cp">#define KS884X_MEM_INFO_OFFSET		0x0214</span>

<span class="cp">#define RX_MEM_TEST_FAILED		0x0008</span>
<span class="cp">#define RX_MEM_TEST_FINISHED		0x0010</span>
<span class="cp">#define TX_MEM_TEST_FAILED		0x0800</span>
<span class="cp">#define TX_MEM_TEST_FINISHED		0x1000</span>

<span class="cm">/* GCR */</span>
<span class="cp">#define KS884X_GLOBAL_CTRL_OFFSET	0x0216</span>
<span class="cp">#define GLOBAL_SOFTWARE_RESET		0x0001</span>

<span class="cp">#define KS8841_POWER_MANAGE_OFFSET	0x0218</span>

<span class="cm">/* WFCR */</span>
<span class="cp">#define KS8841_WOL_CTRL_OFFSET		0x021A</span>
<span class="cp">#define KS8841_WOL_MAGIC_ENABLE		0x0080</span>
<span class="cp">#define KS8841_WOL_FRAME3_ENABLE	0x0008</span>
<span class="cp">#define KS8841_WOL_FRAME2_ENABLE	0x0004</span>
<span class="cp">#define KS8841_WOL_FRAME1_ENABLE	0x0002</span>
<span class="cp">#define KS8841_WOL_FRAME0_ENABLE	0x0001</span>

<span class="cm">/* WF0 */</span>
<span class="cp">#define KS8841_WOL_FRAME_CRC_OFFSET	0x0220</span>
<span class="cp">#define KS8841_WOL_FRAME_BYTE0_OFFSET	0x0224</span>
<span class="cp">#define KS8841_WOL_FRAME_BYTE2_OFFSET	0x0228</span>

<span class="cm">/* IACR */</span>
<span class="cp">#define KS884X_IACR_P			0x04A0</span>
<span class="cp">#define KS884X_IACR_OFFSET		KS884X_IACR_P</span>

<span class="cm">/* IADR1 */</span>
<span class="cp">#define KS884X_IADR1_P			0x04A2</span>
<span class="cp">#define KS884X_IADR2_P			0x04A4</span>
<span class="cp">#define KS884X_IADR3_P			0x04A6</span>
<span class="cp">#define KS884X_IADR4_P			0x04A8</span>
<span class="cp">#define KS884X_IADR5_P			0x04AA</span>

<span class="cp">#define KS884X_ACC_CTRL_SEL_OFFSET	KS884X_IACR_P</span>
<span class="cp">#define KS884X_ACC_CTRL_INDEX_OFFSET	(KS884X_ACC_CTRL_SEL_OFFSET + 1)</span>

<span class="cp">#define KS884X_ACC_DATA_0_OFFSET	KS884X_IADR4_P</span>
<span class="cp">#define KS884X_ACC_DATA_1_OFFSET	(KS884X_ACC_DATA_0_OFFSET + 1)</span>
<span class="cp">#define KS884X_ACC_DATA_2_OFFSET	KS884X_IADR5_P</span>
<span class="cp">#define KS884X_ACC_DATA_3_OFFSET	(KS884X_ACC_DATA_2_OFFSET + 1)</span>
<span class="cp">#define KS884X_ACC_DATA_4_OFFSET	KS884X_IADR2_P</span>
<span class="cp">#define KS884X_ACC_DATA_5_OFFSET	(KS884X_ACC_DATA_4_OFFSET + 1)</span>
<span class="cp">#define KS884X_ACC_DATA_6_OFFSET	KS884X_IADR3_P</span>
<span class="cp">#define KS884X_ACC_DATA_7_OFFSET	(KS884X_ACC_DATA_6_OFFSET + 1)</span>
<span class="cp">#define KS884X_ACC_DATA_8_OFFSET	KS884X_IADR1_P</span>

<span class="cm">/* P1MBCR */</span>
<span class="cp">#define KS884X_P1MBCR_P			0x04D0</span>
<span class="cp">#define KS884X_P1MBSR_P			0x04D2</span>
<span class="cp">#define KS884X_PHY1ILR_P		0x04D4</span>
<span class="cp">#define KS884X_PHY1IHR_P		0x04D6</span>
<span class="cp">#define KS884X_P1ANAR_P			0x04D8</span>
<span class="cp">#define KS884X_P1ANLPR_P		0x04DA</span>

<span class="cm">/* P2MBCR */</span>
<span class="cp">#define KS884X_P2MBCR_P			0x04E0</span>
<span class="cp">#define KS884X_P2MBSR_P			0x04E2</span>
<span class="cp">#define KS884X_PHY2ILR_P		0x04E4</span>
<span class="cp">#define KS884X_PHY2IHR_P		0x04E6</span>
<span class="cp">#define KS884X_P2ANAR_P			0x04E8</span>
<span class="cp">#define KS884X_P2ANLPR_P		0x04EA</span>

<span class="cp">#define KS884X_PHY_1_CTRL_OFFSET	KS884X_P1MBCR_P</span>
<span class="cp">#define PHY_CTRL_INTERVAL		(KS884X_P2MBCR_P - KS884X_P1MBCR_P)</span>

<span class="cp">#define KS884X_PHY_CTRL_OFFSET		0x00</span>

<span class="cm">/* Mode Control Register */</span>
<span class="cp">#define PHY_REG_CTRL			0</span>

<span class="cp">#define PHY_RESET			0x8000</span>
<span class="cp">#define PHY_LOOPBACK			0x4000</span>
<span class="cp">#define PHY_SPEED_100MBIT		0x2000</span>
<span class="cp">#define PHY_AUTO_NEG_ENABLE		0x1000</span>
<span class="cp">#define PHY_POWER_DOWN			0x0800</span>
<span class="cp">#define PHY_MII_DISABLE			0x0400</span>
<span class="cp">#define PHY_AUTO_NEG_RESTART		0x0200</span>
<span class="cp">#define PHY_FULL_DUPLEX			0x0100</span>
<span class="cp">#define PHY_COLLISION_TEST		0x0080</span>
<span class="cp">#define PHY_HP_MDIX			0x0020</span>
<span class="cp">#define PHY_FORCE_MDIX			0x0010</span>
<span class="cp">#define PHY_AUTO_MDIX_DISABLE		0x0008</span>
<span class="cp">#define PHY_REMOTE_FAULT_DISABLE	0x0004</span>
<span class="cp">#define PHY_TRANSMIT_DISABLE		0x0002</span>
<span class="cp">#define PHY_LED_DISABLE			0x0001</span>

<span class="cp">#define KS884X_PHY_STATUS_OFFSET	0x02</span>

<span class="cm">/* Mode Status Register */</span>
<span class="cp">#define PHY_REG_STATUS			1</span>

<span class="cp">#define PHY_100BT4_CAPABLE		0x8000</span>
<span class="cp">#define PHY_100BTX_FD_CAPABLE		0x4000</span>
<span class="cp">#define PHY_100BTX_CAPABLE		0x2000</span>
<span class="cp">#define PHY_10BT_FD_CAPABLE		0x1000</span>
<span class="cp">#define PHY_10BT_CAPABLE		0x0800</span>
<span class="cp">#define PHY_MII_SUPPRESS_CAPABLE	0x0040</span>
<span class="cp">#define PHY_AUTO_NEG_ACKNOWLEDGE	0x0020</span>
<span class="cp">#define PHY_REMOTE_FAULT		0x0010</span>
<span class="cp">#define PHY_AUTO_NEG_CAPABLE		0x0008</span>
<span class="cp">#define PHY_LINK_STATUS			0x0004</span>
<span class="cp">#define PHY_JABBER_DETECT		0x0002</span>
<span class="cp">#define PHY_EXTENDED_CAPABILITY		0x0001</span>

<span class="cp">#define KS884X_PHY_ID_1_OFFSET		0x04</span>
<span class="cp">#define KS884X_PHY_ID_2_OFFSET		0x06</span>

<span class="cm">/* PHY Identifier Registers */</span>
<span class="cp">#define PHY_REG_ID_1			2</span>
<span class="cp">#define PHY_REG_ID_2			3</span>

<span class="cp">#define KS884X_PHY_AUTO_NEG_OFFSET	0x08</span>

<span class="cm">/* Auto-Negotiation Advertisement Register */</span>
<span class="cp">#define PHY_REG_AUTO_NEGOTIATION	4</span>

<span class="cp">#define PHY_AUTO_NEG_NEXT_PAGE		0x8000</span>
<span class="cp">#define PHY_AUTO_NEG_REMOTE_FAULT	0x2000</span>
<span class="cm">/* Not supported. */</span>
<span class="cp">#define PHY_AUTO_NEG_ASYM_PAUSE		0x0800</span>
<span class="cp">#define PHY_AUTO_NEG_SYM_PAUSE		0x0400</span>
<span class="cp">#define PHY_AUTO_NEG_100BT4		0x0200</span>
<span class="cp">#define PHY_AUTO_NEG_100BTX_FD		0x0100</span>
<span class="cp">#define PHY_AUTO_NEG_100BTX		0x0080</span>
<span class="cp">#define PHY_AUTO_NEG_10BT_FD		0x0040</span>
<span class="cp">#define PHY_AUTO_NEG_10BT		0x0020</span>
<span class="cp">#define PHY_AUTO_NEG_SELECTOR		0x001F</span>
<span class="cp">#define PHY_AUTO_NEG_802_3		0x0001</span>

<span class="cp">#define PHY_AUTO_NEG_PAUSE  (PHY_AUTO_NEG_SYM_PAUSE | PHY_AUTO_NEG_ASYM_PAUSE)</span>

<span class="cp">#define KS884X_PHY_REMOTE_CAP_OFFSET	0x0A</span>

<span class="cm">/* Auto-Negotiation Link Partner Ability Register */</span>
<span class="cp">#define PHY_REG_REMOTE_CAPABILITY	5</span>

<span class="cp">#define PHY_REMOTE_NEXT_PAGE		0x8000</span>
<span class="cp">#define PHY_REMOTE_ACKNOWLEDGE		0x4000</span>
<span class="cp">#define PHY_REMOTE_REMOTE_FAULT		0x2000</span>
<span class="cp">#define PHY_REMOTE_SYM_PAUSE		0x0400</span>
<span class="cp">#define PHY_REMOTE_100BTX_FD		0x0100</span>
<span class="cp">#define PHY_REMOTE_100BTX		0x0080</span>
<span class="cp">#define PHY_REMOTE_10BT_FD		0x0040</span>
<span class="cp">#define PHY_REMOTE_10BT			0x0020</span>

<span class="cm">/* P1VCT */</span>
<span class="cp">#define KS884X_P1VCT_P			0x04F0</span>
<span class="cp">#define KS884X_P1PHYCTRL_P		0x04F2</span>

<span class="cm">/* P2VCT */</span>
<span class="cp">#define KS884X_P2VCT_P			0x04F4</span>
<span class="cp">#define KS884X_P2PHYCTRL_P		0x04F6</span>

<span class="cp">#define KS884X_PHY_SPECIAL_OFFSET	KS884X_P1VCT_P</span>
<span class="cp">#define PHY_SPECIAL_INTERVAL		(KS884X_P2VCT_P - KS884X_P1VCT_P)</span>

<span class="cp">#define KS884X_PHY_LINK_MD_OFFSET	0x00</span>

<span class="cp">#define PHY_START_CABLE_DIAG		0x8000</span>
<span class="cp">#define PHY_CABLE_DIAG_RESULT		0x6000</span>
<span class="cp">#define PHY_CABLE_STAT_NORMAL		0x0000</span>
<span class="cp">#define PHY_CABLE_STAT_OPEN		0x2000</span>
<span class="cp">#define PHY_CABLE_STAT_SHORT		0x4000</span>
<span class="cp">#define PHY_CABLE_STAT_FAILED		0x6000</span>
<span class="cp">#define PHY_CABLE_10M_SHORT		0x1000</span>
<span class="cp">#define PHY_CABLE_FAULT_COUNTER		0x01FF</span>

<span class="cp">#define KS884X_PHY_PHY_CTRL_OFFSET	0x02</span>

<span class="cp">#define PHY_STAT_REVERSED_POLARITY	0x0020</span>
<span class="cp">#define PHY_STAT_MDIX			0x0010</span>
<span class="cp">#define PHY_FORCE_LINK			0x0008</span>
<span class="cp">#define PHY_POWER_SAVING_DISABLE	0x0004</span>
<span class="cp">#define PHY_REMOTE_LOOPBACK		0x0002</span>

<span class="cm">/* SIDER */</span>
<span class="cp">#define KS884X_SIDER_P			0x0400</span>
<span class="cp">#define KS884X_CHIP_ID_OFFSET		KS884X_SIDER_P</span>
<span class="cp">#define KS884X_FAMILY_ID_OFFSET		(KS884X_CHIP_ID_OFFSET + 1)</span>

<span class="cp">#define REG_FAMILY_ID			0x88</span>

<span class="cp">#define REG_CHIP_ID_41			0x8810</span>
<span class="cp">#define REG_CHIP_ID_42			0x8800</span>

<span class="cp">#define KS884X_CHIP_ID_MASK_41		0xFF10</span>
<span class="cp">#define KS884X_CHIP_ID_MASK		0xFFF0</span>
<span class="cp">#define KS884X_CHIP_ID_SHIFT		4</span>
<span class="cp">#define KS884X_REVISION_MASK		0x000E</span>
<span class="cp">#define KS884X_REVISION_SHIFT		1</span>
<span class="cp">#define KS8842_START			0x0001</span>

<span class="cp">#define CHIP_IP_41_M			0x8810</span>
<span class="cp">#define CHIP_IP_42_M			0x8800</span>
<span class="cp">#define CHIP_IP_61_M			0x8890</span>
<span class="cp">#define CHIP_IP_62_M			0x8880</span>

<span class="cp">#define CHIP_IP_41_P			0x8850</span>
<span class="cp">#define CHIP_IP_42_P			0x8840</span>
<span class="cp">#define CHIP_IP_61_P			0x88D0</span>
<span class="cp">#define CHIP_IP_62_P			0x88C0</span>

<span class="cm">/* SGCR1 */</span>
<span class="cp">#define KS8842_SGCR1_P			0x0402</span>
<span class="cp">#define KS8842_SWITCH_CTRL_1_OFFSET	KS8842_SGCR1_P</span>

<span class="cp">#define SWITCH_PASS_ALL			0x8000</span>
<span class="cp">#define SWITCH_TX_FLOW_CTRL		0x2000</span>
<span class="cp">#define SWITCH_RX_FLOW_CTRL		0x1000</span>
<span class="cp">#define SWITCH_CHECK_LENGTH		0x0800</span>
<span class="cp">#define SWITCH_AGING_ENABLE		0x0400</span>
<span class="cp">#define SWITCH_FAST_AGING		0x0200</span>
<span class="cp">#define SWITCH_AGGR_BACKOFF		0x0100</span>
<span class="cp">#define SWITCH_PASS_PAUSE		0x0008</span>
<span class="cp">#define SWITCH_LINK_AUTO_AGING		0x0001</span>

<span class="cm">/* SGCR2 */</span>
<span class="cp">#define KS8842_SGCR2_P			0x0404</span>
<span class="cp">#define KS8842_SWITCH_CTRL_2_OFFSET	KS8842_SGCR2_P</span>

<span class="cp">#define SWITCH_VLAN_ENABLE		0x8000</span>
<span class="cp">#define SWITCH_IGMP_SNOOP		0x4000</span>
<span class="cp">#define IPV6_MLD_SNOOP_ENABLE		0x2000</span>
<span class="cp">#define IPV6_MLD_SNOOP_OPTION		0x1000</span>
<span class="cp">#define PRIORITY_SCHEME_SELECT		0x0800</span>
<span class="cp">#define SWITCH_MIRROR_RX_TX		0x0100</span>
<span class="cp">#define UNICAST_VLAN_BOUNDARY		0x0080</span>
<span class="cp">#define MULTICAST_STORM_DISABLE		0x0040</span>
<span class="cp">#define SWITCH_BACK_PRESSURE		0x0020</span>
<span class="cp">#define FAIR_FLOW_CTRL			0x0010</span>
<span class="cp">#define NO_EXC_COLLISION_DROP		0x0008</span>
<span class="cp">#define SWITCH_HUGE_PACKET		0x0004</span>
<span class="cp">#define SWITCH_LEGAL_PACKET		0x0002</span>
<span class="cp">#define SWITCH_BUF_RESERVE		0x0001</span>

<span class="cm">/* SGCR3 */</span>
<span class="cp">#define KS8842_SGCR3_P			0x0406</span>
<span class="cp">#define KS8842_SWITCH_CTRL_3_OFFSET	KS8842_SGCR3_P</span>

<span class="cp">#define BROADCAST_STORM_RATE_LO		0xFF00</span>
<span class="cp">#define SWITCH_REPEATER			0x0080</span>
<span class="cp">#define SWITCH_HALF_DUPLEX		0x0040</span>
<span class="cp">#define SWITCH_FLOW_CTRL		0x0020</span>
<span class="cp">#define SWITCH_10_MBIT			0x0010</span>
<span class="cp">#define SWITCH_REPLACE_NULL_VID		0x0008</span>
<span class="cp">#define BROADCAST_STORM_RATE_HI		0x0007</span>

<span class="cp">#define BROADCAST_STORM_RATE		0x07FF</span>

<span class="cm">/* SGCR4 */</span>
<span class="cp">#define KS8842_SGCR4_P			0x0408</span>

<span class="cm">/* SGCR5 */</span>
<span class="cp">#define KS8842_SGCR5_P			0x040A</span>
<span class="cp">#define KS8842_SWITCH_CTRL_5_OFFSET	KS8842_SGCR5_P</span>

<span class="cp">#define LED_MODE			0x8200</span>
<span class="cp">#define LED_SPEED_DUPLEX_ACT		0x0000</span>
<span class="cp">#define LED_SPEED_DUPLEX_LINK_ACT	0x8000</span>
<span class="cp">#define LED_DUPLEX_10_100		0x0200</span>

<span class="cm">/* SGCR6 */</span>
<span class="cp">#define KS8842_SGCR6_P			0x0410</span>
<span class="cp">#define KS8842_SWITCH_CTRL_6_OFFSET	KS8842_SGCR6_P</span>

<span class="cp">#define KS8842_PRIORITY_MASK		3</span>
<span class="cp">#define KS8842_PRIORITY_SHIFT		2</span>

<span class="cm">/* SGCR7 */</span>
<span class="cp">#define KS8842_SGCR7_P			0x0412</span>
<span class="cp">#define KS8842_SWITCH_CTRL_7_OFFSET	KS8842_SGCR7_P</span>

<span class="cp">#define SWITCH_UNK_DEF_PORT_ENABLE	0x0008</span>
<span class="cp">#define SWITCH_UNK_DEF_PORT_3		0x0004</span>
<span class="cp">#define SWITCH_UNK_DEF_PORT_2		0x0002</span>
<span class="cp">#define SWITCH_UNK_DEF_PORT_1		0x0001</span>

<span class="cm">/* MACAR1 */</span>
<span class="cp">#define KS8842_MACAR1_P			0x0470</span>
<span class="cp">#define KS8842_MACAR2_P			0x0472</span>
<span class="cp">#define KS8842_MACAR3_P			0x0474</span>
<span class="cp">#define KS8842_MAC_ADDR_1_OFFSET	KS8842_MACAR1_P</span>
<span class="cp">#define KS8842_MAC_ADDR_0_OFFSET	(KS8842_MAC_ADDR_1_OFFSET + 1)</span>
<span class="cp">#define KS8842_MAC_ADDR_3_OFFSET	KS8842_MACAR2_P</span>
<span class="cp">#define KS8842_MAC_ADDR_2_OFFSET	(KS8842_MAC_ADDR_3_OFFSET + 1)</span>
<span class="cp">#define KS8842_MAC_ADDR_5_OFFSET	KS8842_MACAR3_P</span>
<span class="cp">#define KS8842_MAC_ADDR_4_OFFSET	(KS8842_MAC_ADDR_5_OFFSET + 1)</span>

<span class="cm">/* TOSR1 */</span>
<span class="cp">#define KS8842_TOSR1_P			0x0480</span>
<span class="cp">#define KS8842_TOSR2_P			0x0482</span>
<span class="cp">#define KS8842_TOSR3_P			0x0484</span>
<span class="cp">#define KS8842_TOSR4_P			0x0486</span>
<span class="cp">#define KS8842_TOSR5_P			0x0488</span>
<span class="cp">#define KS8842_TOSR6_P			0x048A</span>
<span class="cp">#define KS8842_TOSR7_P			0x0490</span>
<span class="cp">#define KS8842_TOSR8_P			0x0492</span>
<span class="cp">#define KS8842_TOS_1_OFFSET		KS8842_TOSR1_P</span>
<span class="cp">#define KS8842_TOS_2_OFFSET		KS8842_TOSR2_P</span>
<span class="cp">#define KS8842_TOS_3_OFFSET		KS8842_TOSR3_P</span>
<span class="cp">#define KS8842_TOS_4_OFFSET		KS8842_TOSR4_P</span>
<span class="cp">#define KS8842_TOS_5_OFFSET		KS8842_TOSR5_P</span>
<span class="cp">#define KS8842_TOS_6_OFFSET		KS8842_TOSR6_P</span>

<span class="cp">#define KS8842_TOS_7_OFFSET		KS8842_TOSR7_P</span>
<span class="cp">#define KS8842_TOS_8_OFFSET		KS8842_TOSR8_P</span>

<span class="cm">/* P1CR1 */</span>
<span class="cp">#define KS8842_P1CR1_P			0x0500</span>
<span class="cp">#define KS8842_P1CR2_P			0x0502</span>
<span class="cp">#define KS8842_P1VIDR_P			0x0504</span>
<span class="cp">#define KS8842_P1CR3_P			0x0506</span>
<span class="cp">#define KS8842_P1IRCR_P			0x0508</span>
<span class="cp">#define KS8842_P1ERCR_P			0x050A</span>
<span class="cp">#define KS884X_P1SCSLMD_P		0x0510</span>
<span class="cp">#define KS884X_P1CR4_P			0x0512</span>
<span class="cp">#define KS884X_P1SR_P			0x0514</span>

<span class="cm">/* P2CR1 */</span>
<span class="cp">#define KS8842_P2CR1_P			0x0520</span>
<span class="cp">#define KS8842_P2CR2_P			0x0522</span>
<span class="cp">#define KS8842_P2VIDR_P			0x0524</span>
<span class="cp">#define KS8842_P2CR3_P			0x0526</span>
<span class="cp">#define KS8842_P2IRCR_P			0x0528</span>
<span class="cp">#define KS8842_P2ERCR_P			0x052A</span>
<span class="cp">#define KS884X_P2SCSLMD_P		0x0530</span>
<span class="cp">#define KS884X_P2CR4_P			0x0532</span>
<span class="cp">#define KS884X_P2SR_P			0x0534</span>

<span class="cm">/* P3CR1 */</span>
<span class="cp">#define KS8842_P3CR1_P			0x0540</span>
<span class="cp">#define KS8842_P3CR2_P			0x0542</span>
<span class="cp">#define KS8842_P3VIDR_P			0x0544</span>
<span class="cp">#define KS8842_P3CR3_P			0x0546</span>
<span class="cp">#define KS8842_P3IRCR_P			0x0548</span>
<span class="cp">#define KS8842_P3ERCR_P			0x054A</span>

<span class="cp">#define KS8842_PORT_1_CTRL_1		KS8842_P1CR1_P</span>
<span class="cp">#define KS8842_PORT_2_CTRL_1		KS8842_P2CR1_P</span>
<span class="cp">#define KS8842_PORT_3_CTRL_1		KS8842_P3CR1_P</span>

<span class="cp">#define PORT_CTRL_ADDR(port, addr)		\</span>
<span class="cp">	(addr = KS8842_PORT_1_CTRL_1 + (port) *	\</span>
<span class="cp">		(KS8842_PORT_2_CTRL_1 - KS8842_PORT_1_CTRL_1))</span>

<span class="cp">#define KS8842_PORT_CTRL_1_OFFSET	0x00</span>

<span class="cp">#define PORT_BROADCAST_STORM		0x0080</span>
<span class="cp">#define PORT_DIFFSERV_ENABLE		0x0040</span>
<span class="cp">#define PORT_802_1P_ENABLE		0x0020</span>
<span class="cp">#define PORT_BASED_PRIORITY_MASK	0x0018</span>
<span class="cp">#define PORT_BASED_PRIORITY_BASE	0x0003</span>
<span class="cp">#define PORT_BASED_PRIORITY_SHIFT	3</span>
<span class="cp">#define PORT_BASED_PRIORITY_0		0x0000</span>
<span class="cp">#define PORT_BASED_PRIORITY_1		0x0008</span>
<span class="cp">#define PORT_BASED_PRIORITY_2		0x0010</span>
<span class="cp">#define PORT_BASED_PRIORITY_3		0x0018</span>
<span class="cp">#define PORT_INSERT_TAG			0x0004</span>
<span class="cp">#define PORT_REMOVE_TAG			0x0002</span>
<span class="cp">#define PORT_PRIO_QUEUE_ENABLE		0x0001</span>

<span class="cp">#define KS8842_PORT_CTRL_2_OFFSET	0x02</span>

<span class="cp">#define PORT_INGRESS_VLAN_FILTER	0x4000</span>
<span class="cp">#define PORT_DISCARD_NON_VID		0x2000</span>
<span class="cp">#define PORT_FORCE_FLOW_CTRL		0x1000</span>
<span class="cp">#define PORT_BACK_PRESSURE		0x0800</span>
<span class="cp">#define PORT_TX_ENABLE			0x0400</span>
<span class="cp">#define PORT_RX_ENABLE			0x0200</span>
<span class="cp">#define PORT_LEARN_DISABLE		0x0100</span>
<span class="cp">#define PORT_MIRROR_SNIFFER		0x0080</span>
<span class="cp">#define PORT_MIRROR_RX			0x0040</span>
<span class="cp">#define PORT_MIRROR_TX			0x0020</span>
<span class="cp">#define PORT_USER_PRIORITY_CEILING	0x0008</span>
<span class="cp">#define PORT_VLAN_MEMBERSHIP		0x0007</span>

<span class="cp">#define KS8842_PORT_CTRL_VID_OFFSET	0x04</span>

<span class="cp">#define PORT_DEFAULT_VID		0x0001</span>

<span class="cp">#define KS8842_PORT_CTRL_3_OFFSET	0x06</span>

<span class="cp">#define PORT_INGRESS_LIMIT_MODE		0x000C</span>
<span class="cp">#define PORT_INGRESS_ALL		0x0000</span>
<span class="cp">#define PORT_INGRESS_UNICAST		0x0004</span>
<span class="cp">#define PORT_INGRESS_MULTICAST		0x0008</span>
<span class="cp">#define PORT_INGRESS_BROADCAST		0x000C</span>
<span class="cp">#define PORT_COUNT_IFG			0x0002</span>
<span class="cp">#define PORT_COUNT_PREAMBLE		0x0001</span>

<span class="cp">#define KS8842_PORT_IN_RATE_OFFSET	0x08</span>
<span class="cp">#define KS8842_PORT_OUT_RATE_OFFSET	0x0A</span>

<span class="cp">#define PORT_PRIORITY_RATE		0x0F</span>
<span class="cp">#define PORT_PRIORITY_RATE_SHIFT	4</span>

<span class="cp">#define KS884X_PORT_LINK_MD		0x10</span>

<span class="cp">#define PORT_CABLE_10M_SHORT		0x8000</span>
<span class="cp">#define PORT_CABLE_DIAG_RESULT		0x6000</span>
<span class="cp">#define PORT_CABLE_STAT_NORMAL		0x0000</span>
<span class="cp">#define PORT_CABLE_STAT_OPEN		0x2000</span>
<span class="cp">#define PORT_CABLE_STAT_SHORT		0x4000</span>
<span class="cp">#define PORT_CABLE_STAT_FAILED		0x6000</span>
<span class="cp">#define PORT_START_CABLE_DIAG		0x1000</span>
<span class="cp">#define PORT_FORCE_LINK			0x0800</span>
<span class="cp">#define PORT_POWER_SAVING_DISABLE	0x0400</span>
<span class="cp">#define PORT_PHY_REMOTE_LOOPBACK	0x0200</span>
<span class="cp">#define PORT_CABLE_FAULT_COUNTER	0x01FF</span>

<span class="cp">#define KS884X_PORT_CTRL_4_OFFSET	0x12</span>

<span class="cp">#define PORT_LED_OFF			0x8000</span>
<span class="cp">#define PORT_TX_DISABLE			0x4000</span>
<span class="cp">#define PORT_AUTO_NEG_RESTART		0x2000</span>
<span class="cp">#define PORT_REMOTE_FAULT_DISABLE	0x1000</span>
<span class="cp">#define PORT_POWER_DOWN			0x0800</span>
<span class="cp">#define PORT_AUTO_MDIX_DISABLE		0x0400</span>
<span class="cp">#define PORT_FORCE_MDIX			0x0200</span>
<span class="cp">#define PORT_LOOPBACK			0x0100</span>
<span class="cp">#define PORT_AUTO_NEG_ENABLE		0x0080</span>
<span class="cp">#define PORT_FORCE_100_MBIT		0x0040</span>
<span class="cp">#define PORT_FORCE_FULL_DUPLEX		0x0020</span>
<span class="cp">#define PORT_AUTO_NEG_SYM_PAUSE		0x0010</span>
<span class="cp">#define PORT_AUTO_NEG_100BTX_FD		0x0008</span>
<span class="cp">#define PORT_AUTO_NEG_100BTX		0x0004</span>
<span class="cp">#define PORT_AUTO_NEG_10BT_FD		0x0002</span>
<span class="cp">#define PORT_AUTO_NEG_10BT		0x0001</span>

<span class="cp">#define KS884X_PORT_STATUS_OFFSET	0x14</span>

<span class="cp">#define PORT_HP_MDIX			0x8000</span>
<span class="cp">#define PORT_REVERSED_POLARITY		0x2000</span>
<span class="cp">#define PORT_RX_FLOW_CTRL		0x0800</span>
<span class="cp">#define PORT_TX_FLOW_CTRL		0x1000</span>
<span class="cp">#define PORT_STATUS_SPEED_100MBIT	0x0400</span>
<span class="cp">#define PORT_STATUS_FULL_DUPLEX		0x0200</span>
<span class="cp">#define PORT_REMOTE_FAULT		0x0100</span>
<span class="cp">#define PORT_MDIX_STATUS		0x0080</span>
<span class="cp">#define PORT_AUTO_NEG_COMPLETE		0x0040</span>
<span class="cp">#define PORT_STATUS_LINK_GOOD		0x0020</span>
<span class="cp">#define PORT_REMOTE_SYM_PAUSE		0x0010</span>
<span class="cp">#define PORT_REMOTE_100BTX_FD		0x0008</span>
<span class="cp">#define PORT_REMOTE_100BTX		0x0004</span>
<span class="cp">#define PORT_REMOTE_10BT_FD		0x0002</span>
<span class="cp">#define PORT_REMOTE_10BT		0x0001</span>

<span class="cm">/*</span>
<span class="cm">#define STATIC_MAC_TABLE_ADDR		00-0000FFFF-FFFFFFFF</span>
<span class="cm">#define STATIC_MAC_TABLE_FWD_PORTS	00-00070000-00000000</span>
<span class="cm">#define STATIC_MAC_TABLE_VALID		00-00080000-00000000</span>
<span class="cm">#define STATIC_MAC_TABLE_OVERRIDE	00-00100000-00000000</span>
<span class="cm">#define STATIC_MAC_TABLE_USE_FID	00-00200000-00000000</span>
<span class="cm">#define STATIC_MAC_TABLE_FID		00-03C00000-00000000</span>
<span class="cm">*/</span>

<span class="cp">#define STATIC_MAC_TABLE_ADDR		0x0000FFFF</span>
<span class="cp">#define STATIC_MAC_TABLE_FWD_PORTS	0x00070000</span>
<span class="cp">#define STATIC_MAC_TABLE_VALID		0x00080000</span>
<span class="cp">#define STATIC_MAC_TABLE_OVERRIDE	0x00100000</span>
<span class="cp">#define STATIC_MAC_TABLE_USE_FID	0x00200000</span>
<span class="cp">#define STATIC_MAC_TABLE_FID		0x03C00000</span>

<span class="cp">#define STATIC_MAC_FWD_PORTS_SHIFT	16</span>
<span class="cp">#define STATIC_MAC_FID_SHIFT		22</span>

<span class="cm">/*</span>
<span class="cm">#define VLAN_TABLE_VID			00-00000000-00000FFF</span>
<span class="cm">#define VLAN_TABLE_FID			00-00000000-0000F000</span>
<span class="cm">#define VLAN_TABLE_MEMBERSHIP		00-00000000-00070000</span>
<span class="cm">#define VLAN_TABLE_VALID		00-00000000-00080000</span>
<span class="cm">*/</span>

<span class="cp">#define VLAN_TABLE_VID			0x00000FFF</span>
<span class="cp">#define VLAN_TABLE_FID			0x0000F000</span>
<span class="cp">#define VLAN_TABLE_MEMBERSHIP		0x00070000</span>
<span class="cp">#define VLAN_TABLE_VALID		0x00080000</span>

<span class="cp">#define VLAN_TABLE_FID_SHIFT		12</span>
<span class="cp">#define VLAN_TABLE_MEMBERSHIP_SHIFT	16</span>

<span class="cm">/*</span>
<span class="cm">#define DYNAMIC_MAC_TABLE_ADDR		00-0000FFFF-FFFFFFFF</span>
<span class="cm">#define DYNAMIC_MAC_TABLE_FID		00-000F0000-00000000</span>
<span class="cm">#define DYNAMIC_MAC_TABLE_SRC_PORT	00-00300000-00000000</span>
<span class="cm">#define DYNAMIC_MAC_TABLE_TIMESTAMP	00-00C00000-00000000</span>
<span class="cm">#define DYNAMIC_MAC_TABLE_ENTRIES	03-FF000000-00000000</span>
<span class="cm">#define DYNAMIC_MAC_TABLE_MAC_EMPTY	04-00000000-00000000</span>
<span class="cm">#define DYNAMIC_MAC_TABLE_RESERVED	78-00000000-00000000</span>
<span class="cm">#define DYNAMIC_MAC_TABLE_NOT_READY	80-00000000-00000000</span>
<span class="cm">*/</span>

<span class="cp">#define DYNAMIC_MAC_TABLE_ADDR		0x0000FFFF</span>
<span class="cp">#define DYNAMIC_MAC_TABLE_FID		0x000F0000</span>
<span class="cp">#define DYNAMIC_MAC_TABLE_SRC_PORT	0x00300000</span>
<span class="cp">#define DYNAMIC_MAC_TABLE_TIMESTAMP	0x00C00000</span>
<span class="cp">#define DYNAMIC_MAC_TABLE_ENTRIES	0xFF000000</span>

<span class="cp">#define DYNAMIC_MAC_TABLE_ENTRIES_H	0x03</span>
<span class="cp">#define DYNAMIC_MAC_TABLE_MAC_EMPTY	0x04</span>
<span class="cp">#define DYNAMIC_MAC_TABLE_RESERVED	0x78</span>
<span class="cp">#define DYNAMIC_MAC_TABLE_NOT_READY	0x80</span>

<span class="cp">#define DYNAMIC_MAC_FID_SHIFT		16</span>
<span class="cp">#define DYNAMIC_MAC_SRC_PORT_SHIFT	20</span>
<span class="cp">#define DYNAMIC_MAC_TIMESTAMP_SHIFT	22</span>
<span class="cp">#define DYNAMIC_MAC_ENTRIES_SHIFT	24</span>
<span class="cp">#define DYNAMIC_MAC_ENTRIES_H_SHIFT	8</span>

<span class="cm">/*</span>
<span class="cm">#define MIB_COUNTER_VALUE		00-00000000-3FFFFFFF</span>
<span class="cm">#define MIB_COUNTER_VALID		00-00000000-40000000</span>
<span class="cm">#define MIB_COUNTER_OVERFLOW		00-00000000-80000000</span>
<span class="cm">*/</span>

<span class="cp">#define MIB_COUNTER_VALUE		0x3FFFFFFF</span>
<span class="cp">#define MIB_COUNTER_VALID		0x40000000</span>
<span class="cp">#define MIB_COUNTER_OVERFLOW		0x80000000</span>

<span class="cp">#define MIB_PACKET_DROPPED		0x0000FFFF</span>

<span class="cp">#define KS_MIB_PACKET_DROPPED_TX_0	0x100</span>
<span class="cp">#define KS_MIB_PACKET_DROPPED_TX_1	0x101</span>
<span class="cp">#define KS_MIB_PACKET_DROPPED_TX	0x102</span>
<span class="cp">#define KS_MIB_PACKET_DROPPED_RX_0	0x103</span>
<span class="cp">#define KS_MIB_PACKET_DROPPED_RX_1	0x104</span>
<span class="cp">#define KS_MIB_PACKET_DROPPED_RX	0x105</span>

<span class="cm">/* Change default LED mode. */</span>
<span class="cp">#define SET_DEFAULT_LED			LED_SPEED_DUPLEX_ACT</span>

<span class="cp">#define MAC_ADDR_ORDER(i)		(ETH_ALEN - 1 - (i))</span>

<span class="cp">#define MAX_ETHERNET_BODY_SIZE		1500</span>
<span class="cp">#define ETHERNET_HEADER_SIZE		(14 + VLAN_HLEN)</span>

<span class="cp">#define MAX_ETHERNET_PACKET_SIZE	\</span>
<span class="cp">	(MAX_ETHERNET_BODY_SIZE + ETHERNET_HEADER_SIZE)</span>

<span class="cp">#define REGULAR_RX_BUF_SIZE		(MAX_ETHERNET_PACKET_SIZE + 4)</span>
<span class="cp">#define MAX_RX_BUF_SIZE			(1912 + 4)</span>

<span class="cp">#define ADDITIONAL_ENTRIES		16</span>
<span class="cp">#define MAX_MULTICAST_LIST		32</span>

<span class="cp">#define HW_MULTICAST_SIZE		8</span>

<span class="cp">#define HW_TO_DEV_PORT(port)		(port - 1)</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">media_connected</span><span class="p">,</span>
	<span class="n">media_disconnected</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">OID_COUNTER_UNKOWN</span><span class="p">,</span>

	<span class="n">OID_COUNTER_FIRST</span><span class="p">,</span>

	<span class="cm">/* total transmit errors */</span>
	<span class="n">OID_COUNTER_XMIT_ERROR</span><span class="p">,</span>

	<span class="cm">/* total receive errors */</span>
	<span class="n">OID_COUNTER_RCV_ERROR</span><span class="p">,</span>

	<span class="n">OID_COUNTER_LAST</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Hardware descriptor definitions</span>
<span class="cm"> */</span>

<span class="cp">#define DESC_ALIGNMENT			16</span>
<span class="cp">#define BUFFER_ALIGNMENT		8</span>

<span class="cp">#define NUM_OF_RX_DESC			64</span>
<span class="cp">#define NUM_OF_TX_DESC			64</span>

<span class="cp">#define KS_DESC_RX_FRAME_LEN		0x000007FF</span>
<span class="cp">#define KS_DESC_RX_FRAME_TYPE		0x00008000</span>
<span class="cp">#define KS_DESC_RX_ERROR_CRC		0x00010000</span>
<span class="cp">#define KS_DESC_RX_ERROR_RUNT		0x00020000</span>
<span class="cp">#define KS_DESC_RX_ERROR_TOO_LONG	0x00040000</span>
<span class="cp">#define KS_DESC_RX_ERROR_PHY		0x00080000</span>
<span class="cp">#define KS884X_DESC_RX_PORT_MASK	0x00300000</span>
<span class="cp">#define KS_DESC_RX_MULTICAST		0x01000000</span>
<span class="cp">#define KS_DESC_RX_ERROR		0x02000000</span>
<span class="cp">#define KS_DESC_RX_ERROR_CSUM_UDP	0x04000000</span>
<span class="cp">#define KS_DESC_RX_ERROR_CSUM_TCP	0x08000000</span>
<span class="cp">#define KS_DESC_RX_ERROR_CSUM_IP	0x10000000</span>
<span class="cp">#define KS_DESC_RX_LAST			0x20000000</span>
<span class="cp">#define KS_DESC_RX_FIRST		0x40000000</span>
<span class="cp">#define KS_DESC_RX_ERROR_COND		\</span>
<span class="cp">	(KS_DESC_RX_ERROR_CRC |		\</span>
<span class="cp">	KS_DESC_RX_ERROR_RUNT |		\</span>
<span class="cp">	KS_DESC_RX_ERROR_PHY |		\</span>
<span class="cp">	KS_DESC_RX_ERROR_TOO_LONG)</span>

<span class="cp">#define KS_DESC_HW_OWNED		0x80000000</span>

<span class="cp">#define KS_DESC_BUF_SIZE		0x000007FF</span>
<span class="cp">#define KS884X_DESC_TX_PORT_MASK	0x00300000</span>
<span class="cp">#define KS_DESC_END_OF_RING		0x02000000</span>
<span class="cp">#define KS_DESC_TX_CSUM_GEN_UDP		0x04000000</span>
<span class="cp">#define KS_DESC_TX_CSUM_GEN_TCP		0x08000000</span>
<span class="cp">#define KS_DESC_TX_CSUM_GEN_IP		0x10000000</span>
<span class="cp">#define KS_DESC_TX_LAST			0x20000000</span>
<span class="cp">#define KS_DESC_TX_FIRST		0x40000000</span>
<span class="cp">#define KS_DESC_TX_INTERRUPT		0x80000000</span>

<span class="cp">#define KS_DESC_PORT_SHIFT		20</span>

<span class="cp">#define KS_DESC_RX_MASK			(KS_DESC_BUF_SIZE)</span>

<span class="cp">#define KS_DESC_TX_MASK			\</span>
<span class="cp">	(KS_DESC_TX_INTERRUPT |		\</span>
<span class="cp">	KS_DESC_TX_FIRST |		\</span>
<span class="cp">	KS_DESC_TX_LAST |		\</span>
<span class="cp">	KS_DESC_TX_CSUM_GEN_IP |	\</span>
<span class="cp">	KS_DESC_TX_CSUM_GEN_TCP |	\</span>
<span class="cp">	KS_DESC_TX_CSUM_GEN_UDP |	\</span>
<span class="cp">	KS_DESC_BUF_SIZE)</span>

<span class="k">struct</span> <span class="n">ksz_desc_rx_stat</span> <span class="p">{</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
	<span class="n">u32</span> <span class="n">hw_owned</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first_desc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_desc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_err_ip</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_err_tcp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_err_udp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">multicast</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">src_port</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_phy</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_too_long</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_runt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_crc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frame_type</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved1</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frame_len</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">frame_len</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved1</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frame_type</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_crc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_runt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_too_long</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_phy</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">src_port</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">multicast</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_err_udp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_err_tcp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_err_ip</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_desc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first_desc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hw_owned</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ksz_desc_tx_stat</span> <span class="p">{</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
	<span class="n">u32</span> <span class="n">hw_owned</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved1</span><span class="o">:</span><span class="mi">31</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">reserved1</span><span class="o">:</span><span class="mi">31</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hw_owned</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ksz_desc_rx_buf</span> <span class="p">{</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
	<span class="n">u32</span> <span class="n">reserved4</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">end_of_ring</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved3</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">buf_size</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">buf_size</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved3</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">end_of_ring</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved4</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ksz_desc_tx_buf</span> <span class="p">{</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
	<span class="n">u32</span> <span class="n">intr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first_seg</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_seg</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_gen_ip</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_gen_tcp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_gen_udp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">end_of_ring</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved4</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dest_port</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved3</span><span class="o">:</span><span class="mi">9</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">buf_size</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">buf_size</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved3</span><span class="o">:</span><span class="mi">9</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dest_port</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved4</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">end_of_ring</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_gen_udp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_gen_tcp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum_gen_ip</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_seg</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first_seg</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">desc_stat</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_desc_rx_stat</span> <span class="n">rx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc_tx_stat</span> <span class="n">tx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">desc_buf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_desc_rx_buf</span> <span class="n">rx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc_tx_buf</span> <span class="n">tx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_hw_desc - Hardware descriptor data structure</span>
<span class="cm"> * @ctrl:	Descriptor control value.</span>
<span class="cm"> * @buf:	Descriptor buffer value.</span>
<span class="cm"> * @addr:	Physical address of memory buffer.</span>
<span class="cm"> * @next:	Pointer to next hardware descriptor.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_hw_desc</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">desc_stat</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">desc_buf</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_sw_desc - Software descriptor data structure</span>
<span class="cm"> * @ctrl:	Descriptor control value.</span>
<span class="cm"> * @buf:	Descriptor buffer value.</span>
<span class="cm"> * @buf_size:	Current buffers size value in hardware descriptor.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_sw_desc</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">desc_stat</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">desc_buf</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">buf_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_dma_buf - OS dependent DMA buffer data structure</span>
<span class="cm"> * @skb:	Associated socket buffer.</span>
<span class="cm"> * @dma:	Associated physical DMA address.</span>
<span class="cm"> * len:		Actual len used.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_dma_buf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_desc - Descriptor structure</span>
<span class="cm"> * @phw:	Hardware descriptor pointer to uncached physical memory.</span>
<span class="cm"> * @sw:		Cached memory to hold hardware descriptor values for</span>
<span class="cm"> * 		manipulation.</span>
<span class="cm"> * @dma_buf:	Operating system dependent data structure to hold physical</span>
<span class="cm"> * 		memory buffer allocation information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_hw_desc</span> <span class="o">*</span><span class="n">phw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_sw_desc</span> <span class="n">sw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_dma_buf</span> <span class="n">dma_buf</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DMA_BUFFER(desc)  ((struct ksz_dma_buf *)(&amp;(desc)-&gt;dma_buf))</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_desc_info - Descriptor information data structure</span>
<span class="cm"> * @ring:	First descriptor in the ring.</span>
<span class="cm"> * @cur:	Current descriptor being manipulated.</span>
<span class="cm"> * @ring_virt:	First hardware descriptor in the ring.</span>
<span class="cm"> * @ring_phys:	The physical address of the first descriptor of the ring.</span>
<span class="cm"> * @size:	Size of hardware descriptor.</span>
<span class="cm"> * @alloc:	Number of descriptors allocated.</span>
<span class="cm"> * @avail:	Number of descriptors available for use.</span>
<span class="cm"> * @last:	Index for last descriptor released to hardware.</span>
<span class="cm"> * @next:	Index for next descriptor available for use.</span>
<span class="cm"> * @mask:	Mask for index wrapping.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw_desc</span> <span class="o">*</span><span class="n">ring_virt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ring_phys</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alloc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">avail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * KSZ8842 switch definitions</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">TABLE_STATIC_MAC</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">TABLE_VLAN</span><span class="p">,</span>
	<span class="n">TABLE_DYNAMIC_MAC</span><span class="p">,</span>
	<span class="n">TABLE_MIB</span>
<span class="p">};</span>

<span class="cp">#define LEARNED_MAC_TABLE_ENTRIES	1024</span>
<span class="cp">#define STATIC_MAC_TABLE_ENTRIES	8</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_mac_table - Static MAC table data structure</span>
<span class="cm"> * @mac_addr:	MAC address to filter.</span>
<span class="cm"> * @vid:	VID value.</span>
<span class="cm"> * @fid:	FID value.</span>
<span class="cm"> * @ports:	Port membership.</span>
<span class="cm"> * @override:	Override setting.</span>
<span class="cm"> * @use_fid:	FID use setting.</span>
<span class="cm"> * @valid:	Valid setting indicating the entry is being used.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_mac_table</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">mac_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">vid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ports</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">override</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">use_fid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define VLAN_TABLE_ENTRIES		16</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_vlan_table - VLAN table data structure</span>
<span class="cm"> * @vid:	VID value.</span>
<span class="cm"> * @fid:	FID value.</span>
<span class="cm"> * @member:	Port membership.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_vlan_table</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">vid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">member</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DIFFSERV_ENTRIES		64</span>
<span class="cp">#define PRIO_802_1P_ENTRIES		8</span>
<span class="cp">#define PRIO_QUEUES			4</span>

<span class="cp">#define SWITCH_PORT_NUM			2</span>
<span class="cp">#define TOTAL_PORT_NUM			(SWITCH_PORT_NUM + 1)</span>
<span class="cp">#define HOST_MASK			(1 &lt;&lt; SWITCH_PORT_NUM)</span>
<span class="cp">#define PORT_MASK			7</span>

<span class="cp">#define MAIN_PORT			0</span>
<span class="cp">#define OTHER_PORT			1</span>
<span class="cp">#define HOST_PORT			SWITCH_PORT_NUM</span>

<span class="cp">#define PORT_COUNTER_NUM		0x20</span>
<span class="cp">#define TOTAL_PORT_COUNTER_NUM		(PORT_COUNTER_NUM + 2)</span>

<span class="cp">#define MIB_COUNTER_RX_LO_PRIORITY	0x00</span>
<span class="cp">#define MIB_COUNTER_RX_HI_PRIORITY	0x01</span>
<span class="cp">#define MIB_COUNTER_RX_UNDERSIZE	0x02</span>
<span class="cp">#define MIB_COUNTER_RX_FRAGMENT		0x03</span>
<span class="cp">#define MIB_COUNTER_RX_OVERSIZE		0x04</span>
<span class="cp">#define MIB_COUNTER_RX_JABBER		0x05</span>
<span class="cp">#define MIB_COUNTER_RX_SYMBOL_ERR	0x06</span>
<span class="cp">#define MIB_COUNTER_RX_CRC_ERR		0x07</span>
<span class="cp">#define MIB_COUNTER_RX_ALIGNMENT_ERR	0x08</span>
<span class="cp">#define MIB_COUNTER_RX_CTRL_8808	0x09</span>
<span class="cp">#define MIB_COUNTER_RX_PAUSE		0x0A</span>
<span class="cp">#define MIB_COUNTER_RX_BROADCAST	0x0B</span>
<span class="cp">#define MIB_COUNTER_RX_MULTICAST	0x0C</span>
<span class="cp">#define MIB_COUNTER_RX_UNICAST		0x0D</span>
<span class="cp">#define MIB_COUNTER_RX_OCTET_64		0x0E</span>
<span class="cp">#define MIB_COUNTER_RX_OCTET_65_127	0x0F</span>
<span class="cp">#define MIB_COUNTER_RX_OCTET_128_255	0x10</span>
<span class="cp">#define MIB_COUNTER_RX_OCTET_256_511	0x11</span>
<span class="cp">#define MIB_COUNTER_RX_OCTET_512_1023	0x12</span>
<span class="cp">#define MIB_COUNTER_RX_OCTET_1024_1522	0x13</span>
<span class="cp">#define MIB_COUNTER_TX_LO_PRIORITY	0x14</span>
<span class="cp">#define MIB_COUNTER_TX_HI_PRIORITY	0x15</span>
<span class="cp">#define MIB_COUNTER_TX_LATE_COLLISION	0x16</span>
<span class="cp">#define MIB_COUNTER_TX_PAUSE		0x17</span>
<span class="cp">#define MIB_COUNTER_TX_BROADCAST	0x18</span>
<span class="cp">#define MIB_COUNTER_TX_MULTICAST	0x19</span>
<span class="cp">#define MIB_COUNTER_TX_UNICAST		0x1A</span>
<span class="cp">#define MIB_COUNTER_TX_DEFERRED		0x1B</span>
<span class="cp">#define MIB_COUNTER_TX_TOTAL_COLLISION	0x1C</span>
<span class="cp">#define MIB_COUNTER_TX_EXCESS_COLLISION	0x1D</span>
<span class="cp">#define MIB_COUNTER_TX_SINGLE_COLLISION	0x1E</span>
<span class="cp">#define MIB_COUNTER_TX_MULTI_COLLISION	0x1F</span>

<span class="cp">#define MIB_COUNTER_RX_DROPPED_PACKET	0x20</span>
<span class="cp">#define MIB_COUNTER_TX_DROPPED_PACKET	0x21</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_port_mib - Port MIB data structure</span>
<span class="cm"> * @cnt_ptr:	Current pointer to MIB counter index.</span>
<span class="cm"> * @link_down:	Indication the link has just gone down.</span>
<span class="cm"> * @state:	Connection status of the port.</span>
<span class="cm"> * @mib_start:	The starting counter index.  Some ports do not start at 0.</span>
<span class="cm"> * @counter:	64-bit MIB counter value.</span>
<span class="cm"> * @dropped:	Temporary buffer to remember last read packet dropped values.</span>
<span class="cm"> *</span>
<span class="cm"> * MIB counters needs to be read periodically so that counters do not get</span>
<span class="cm"> * overflowed and give incorrect values.  A right balance is needed to</span>
<span class="cm"> * satisfy this condition and not waste too much CPU time.</span>
<span class="cm"> *</span>
<span class="cm"> * It is pointless to read MIB counters when the port is disconnected.  The</span>
<span class="cm"> * @state provides the connection status so that MIB counters are read only</span>
<span class="cm"> * when the port is connected.  The @link_down indicates the port is just</span>
<span class="cm"> * disconnected so that all MIB counters are read one last time to update the</span>
<span class="cm"> * information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_port_mib</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">cnt_ptr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">link_down</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mib_start</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">counter</span><span class="p">[</span><span class="n">TOTAL_PORT_COUNTER_NUM</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">dropped</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_port_cfg - Port configuration data structure</span>
<span class="cm"> * @vid:	VID value.</span>
<span class="cm"> * @member:	Port membership.</span>
<span class="cm"> * @port_prio:	Port priority.</span>
<span class="cm"> * @rx_rate:	Receive priority rate.</span>
<span class="cm"> * @tx_rate:	Transmit priority rate.</span>
<span class="cm"> * @stp_state:	Current Spanning Tree Protocol state.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_port_cfg</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">vid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">member</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">port_prio</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_rate</span><span class="p">[</span><span class="n">PRIO_QUEUES</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">tx_rate</span><span class="p">[</span><span class="n">PRIO_QUEUES</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">stp_state</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_switch - KSZ8842 switch data structure</span>
<span class="cm"> * @mac_table:	MAC table entries information.</span>
<span class="cm"> * @vlan_table:	VLAN table entries information.</span>
<span class="cm"> * @port_cfg:	Port configuration information.</span>
<span class="cm"> * @diffserv:	DiffServ priority settings.  Possible values from 6-bit of ToS</span>
<span class="cm"> * 		(bit7 ~ bit2) field.</span>
<span class="cm"> * @p_802_1p:	802.1P priority settings.  Possible values from 3-bit of 802.1p</span>
<span class="cm"> * 		Tag priority field.</span>
<span class="cm"> * @br_addr:	Bridge address.  Used for STP.</span>
<span class="cm"> * @other_addr:	Other MAC address.  Used for multiple network device mode.</span>
<span class="cm"> * @broad_per:	Broadcast storm percentage.</span>
<span class="cm"> * @member:	Current port membership.  Used for STP.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_switch</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_mac_table</span> <span class="n">mac_table</span><span class="p">[</span><span class="n">STATIC_MAC_TABLE_ENTRIES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ksz_vlan_table</span> <span class="n">vlan_table</span><span class="p">[</span><span class="n">VLAN_TABLE_ENTRIES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ksz_port_cfg</span> <span class="n">port_cfg</span><span class="p">[</span><span class="n">TOTAL_PORT_NUM</span><span class="p">];</span>

	<span class="n">u8</span> <span class="n">diffserv</span><span class="p">[</span><span class="n">DIFFSERV_ENTRIES</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">p_802_1p</span><span class="p">[</span><span class="n">PRIO_802_1P_ENTRIES</span><span class="p">];</span>

	<span class="n">u8</span> <span class="n">br_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">other_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="n">u8</span> <span class="n">broad_per</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">member</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define TX_RATE_UNIT			10000</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_port_info - Port information data structure</span>
<span class="cm"> * @state:	Connection status of the port.</span>
<span class="cm"> * @tx_rate:	Transmit rate divided by 10000 to get Mbit.</span>
<span class="cm"> * @duplex:	Duplex mode.</span>
<span class="cm"> * @advertised:	Advertised auto-negotiation setting.  Used to determine link.</span>
<span class="cm"> * @partner:	Auto-negotiation partner setting.  Used to determine link.</span>
<span class="cm"> * @port_id:	Port index to access actual hardware register.</span>
<span class="cm"> * @pdev:	Pointer to OS dependent network device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_port_info</span> <span class="p">{</span>
	<span class="n">uint</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">tx_rate</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">duplex</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">advertised</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">partner</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">port_id</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define MAX_TX_HELD_SIZE		52000</span>

<span class="cm">/* Hardware features and bug fixes. */</span>
<span class="cp">#define LINK_INT_WORKING		(1 &lt;&lt; 0)</span>
<span class="cp">#define SMALL_PACKET_TX_BUG		(1 &lt;&lt; 1)</span>
<span class="cp">#define HALF_DUPLEX_SIGNAL_BUG		(1 &lt;&lt; 2)</span>
<span class="cp">#define RX_HUGE_FRAME			(1 &lt;&lt; 4)</span>
<span class="cp">#define STP_SUPPORT			(1 &lt;&lt; 8)</span>

<span class="cm">/* Software overrides. */</span>
<span class="cp">#define PAUSE_FLOW_CTRL			(1 &lt;&lt; 0)</span>
<span class="cp">#define FAST_AGING			(1 &lt;&lt; 1)</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_hw - KSZ884X hardware data structure</span>
<span class="cm"> * @io:			Virtual address assigned.</span>
<span class="cm"> * @ksz_switch:		Pointer to KSZ8842 switch.</span>
<span class="cm"> * @port_info:		Port information.</span>
<span class="cm"> * @port_mib:		Port MIB information.</span>
<span class="cm"> * @dev_count:		Number of network devices this hardware supports.</span>
<span class="cm"> * @dst_ports:		Destination ports in switch for transmission.</span>
<span class="cm"> * @id:			Hardware ID.  Used for display only.</span>
<span class="cm"> * @mib_cnt:		Number of MIB counters this hardware has.</span>
<span class="cm"> * @mib_port_cnt:	Number of ports with MIB counters.</span>
<span class="cm"> * @tx_cfg:		Cached transmit control settings.</span>
<span class="cm"> * @rx_cfg:		Cached receive control settings.</span>
<span class="cm"> * @intr_mask:		Current interrupt mask.</span>
<span class="cm"> * @intr_set:		Current interrup set.</span>
<span class="cm"> * @intr_blocked:	Interrupt blocked.</span>
<span class="cm"> * @rx_desc_info:	Receive descriptor information.</span>
<span class="cm"> * @tx_desc_info:	Transmit descriptor information.</span>
<span class="cm"> * @tx_int_cnt:		Transmit interrupt count.  Used for TX optimization.</span>
<span class="cm"> * @tx_int_mask:	Transmit interrupt mask.  Used for TX optimization.</span>
<span class="cm"> * @tx_size:		Transmit data size.  Used for TX optimization.</span>
<span class="cm"> * 			The maximum is defined by MAX_TX_HELD_SIZE.</span>
<span class="cm"> * @perm_addr:		Permanent MAC address.</span>
<span class="cm"> * @override_addr:	Overrided MAC address.</span>
<span class="cm"> * @address:		Additional MAC address entries.</span>
<span class="cm"> * @addr_list_size:	Additional MAC address list size.</span>
<span class="cm"> * @mac_override:	Indication of MAC address overrided.</span>
<span class="cm"> * @promiscuous:	Counter to keep track of promiscuous mode set.</span>
<span class="cm"> * @all_multi:		Counter to keep track of all multicast mode set.</span>
<span class="cm"> * @multi_list:		Multicast address entries.</span>
<span class="cm"> * @multi_bits:		Cached multicast hash table settings.</span>
<span class="cm"> * @multi_list_size:	Multicast address list size.</span>
<span class="cm"> * @enabled:		Indication of hardware enabled.</span>
<span class="cm"> * @rx_stop:		Indication of receive process stop.</span>
<span class="cm"> * @features:		Hardware features to enable.</span>
<span class="cm"> * @overrides:		Hardware features to override.</span>
<span class="cm"> * @parent:		Pointer to parent, network device private structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">io</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ksz_switch</span> <span class="o">*</span><span class="n">ksz_switch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port_info</span> <span class="n">port_info</span><span class="p">[</span><span class="n">SWITCH_PORT_NUM</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ksz_port_mib</span> <span class="n">port_mib</span><span class="p">[</span><span class="n">TOTAL_PORT_NUM</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">dev_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dst_ports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mib_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mib_port_cnt</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">tx_cfg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_cfg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intr_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intr_set</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">intr_blocked</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="n">rx_desc_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="n">tx_desc_info</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">tx_int_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_int_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_size</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">perm_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">override_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">address</span><span class="p">[</span><span class="n">ADDITIONAL_ENTRIES</span><span class="p">][</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">addr_list_size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mac_override</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">promiscuous</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">all_multi</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">multi_list</span><span class="p">[</span><span class="n">MAX_MULTICAST_LIST</span><span class="p">][</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">multi_bits</span><span class="p">[</span><span class="n">HW_MULTICAST_SIZE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">multi_list_size</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">enabled</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rx_stop</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">uint</span> <span class="n">features</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">overrides</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">PHY_NO_FLOW_CTRL</span><span class="p">,</span>
	<span class="n">PHY_FLOW_CTRL</span><span class="p">,</span>
	<span class="n">PHY_TX_ONLY</span><span class="p">,</span>
	<span class="n">PHY_RX_ONLY</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_port - Virtual port data structure</span>
<span class="cm"> * @duplex:		Duplex mode setting.  1 for half duplex, 2 for full</span>
<span class="cm"> * 			duplex, and 0 for auto, which normally results in full</span>
<span class="cm"> * 			duplex.</span>
<span class="cm"> * @speed:		Speed setting.  10 for 10 Mbit, 100 for 100 Mbit, and</span>
<span class="cm"> * 			0 for auto, which normally results in 100 Mbit.</span>
<span class="cm"> * @force_link:		Force link setting.  0 for auto-negotiation, and 1 for</span>
<span class="cm"> * 			force.</span>
<span class="cm"> * @flow_ctrl:		Flow control setting.  PHY_NO_FLOW_CTRL for no flow</span>
<span class="cm"> * 			control, and PHY_FLOW_CTRL for flow control.</span>
<span class="cm"> * 			PHY_TX_ONLY and PHY_RX_ONLY are not supported for 100</span>
<span class="cm"> * 			Mbit PHY.</span>
<span class="cm"> * @first_port:		Index of first port this port supports.</span>
<span class="cm"> * @mib_port_cnt:	Number of ports with MIB counters.</span>
<span class="cm"> * @port_cnt:		Number of ports this port supports.</span>
<span class="cm"> * @counter:		Port statistics counter.</span>
<span class="cm"> * @hw:			Pointer to hardware structure.</span>
<span class="cm"> * @linked:		Pointer to port information linked to this port.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_port</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">duplex</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">force_link</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flow_ctrl</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">first_port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mib_port_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port_cnt</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">counter</span><span class="p">[</span><span class="n">OID_COUNTER_LAST</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port_info</span> <span class="o">*</span><span class="n">linked</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_timer_info - Timer information data structure</span>
<span class="cm"> * @timer:	Kernel timer.</span>
<span class="cm"> * @cnt:	Running timer counter.</span>
<span class="cm"> * @max:	Number of times to run timer; -1 for infinity.</span>
<span class="cm"> * @period:	Timer period in jiffies.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_timer_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">period</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_shared_mem - OS dependent shared memory data structure</span>
<span class="cm"> * @dma_addr:	Physical DMA address allocated.</span>
<span class="cm"> * @alloc_size:	Allocation size.</span>
<span class="cm"> * @phys:	Actual physical address used.</span>
<span class="cm"> * @alloc_virt:	Virtual address allocated.</span>
<span class="cm"> * @virt:	Actual virtual address used.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_shared_mem</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">alloc_size</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">phys</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">alloc_virt</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">virt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksz_counter_info - OS dependent counter information data structure</span>
<span class="cm"> * @counter:	Wait queue to wakeup after counters are read.</span>
<span class="cm"> * @time:	Next time in jiffies to read counter.</span>
<span class="cm"> * @read:	Indication of counters read in full or not.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksz_counter_info</span> <span class="p">{</span>
	<span class="n">wait_queue_head_t</span> <span class="n">counter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">read</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dev_info - Network device information data structure</span>
<span class="cm"> * @dev:		Pointer to network device.</span>
<span class="cm"> * @pdev:		Pointer to PCI device.</span>
<span class="cm"> * @hw:			Hardware structure.</span>
<span class="cm"> * @desc_pool:		Physical memory used for descriptor pool.</span>
<span class="cm"> * @hwlock:		Spinlock to prevent hardware from accessing.</span>
<span class="cm"> * @lock:		Mutex lock to prevent device from accessing.</span>
<span class="cm"> * @dev_rcv:		Receive process function used.</span>
<span class="cm"> * @last_skb:		Socket buffer allocated for descriptor rx fragments.</span>
<span class="cm"> * @skb_index:		Buffer index for receiving fragments.</span>
<span class="cm"> * @skb_len:		Buffer length for receiving fragments.</span>
<span class="cm"> * @mib_read:		Workqueue to read MIB counters.</span>
<span class="cm"> * @mib_timer_info:	Timer to read MIB counters.</span>
<span class="cm"> * @counter:		Used for MIB reading.</span>
<span class="cm"> * @mtu:		Current MTU used.  The default is REGULAR_RX_BUF_SIZE;</span>
<span class="cm"> * 			the maximum is MAX_RX_BUF_SIZE.</span>
<span class="cm"> * @opened:		Counter to keep track of device open.</span>
<span class="cm"> * @rx_tasklet:		Receive processing tasklet.</span>
<span class="cm"> * @tx_tasklet:		Transmit processing tasklet.</span>
<span class="cm"> * @wol_enable:		Wake-on-LAN enable set by ethtool.</span>
<span class="cm"> * @wol_support:	Wake-on-LAN support used by ethtool.</span>
<span class="cm"> * @pme_wait:		Used for KSZ8841 power management.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dev_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_shared_mem</span> <span class="n">desc_pool</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">hwlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dev_rcv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">last_skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skb_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skb_len</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">mib_read</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_timer_info</span> <span class="n">mib_timer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_counter_info</span> <span class="n">counter</span><span class="p">[</span><span class="n">TOTAL_PORT_NUM</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">mtu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">opened</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">rx_tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tx_tasklet</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">wol_enable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wol_support</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pme_wait</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dev_priv - Network device private data structure</span>
<span class="cm"> * @adapter:		Adapter device information.</span>
<span class="cm"> * @port:		Port information.</span>
<span class="cm"> * @monitor_time_info:	Timer to monitor ports.</span>
<span class="cm"> * @proc_sem:		Semaphore for proc accessing.</span>
<span class="cm"> * @id:			Device ID.</span>
<span class="cm"> * @mii_if:		MII interface information.</span>
<span class="cm"> * @advertising:	Temporary variable to store advertised settings.</span>
<span class="cm"> * @msg_enable:		The message flags controlling driver output.</span>
<span class="cm"> * @media_state:	The connection status of the device.</span>
<span class="cm"> * @multicast:		The all multicast state of the device.</span>
<span class="cm"> * @promiscuous:	The promiscuous state of the device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dev_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_timer_info</span> <span class="n">monitor_timer_info</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">semaphore</span> <span class="n">proc_sem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mii_if_info</span> <span class="n">mii_if</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">advertising</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">msg_enable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">media_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">multicast</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">promiscuous</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRV_NAME		&quot;KSZ884X PCI&quot;</span>
<span class="cp">#define DEVICE_NAME		&quot;KSZ884x PCI&quot;</span>
<span class="cp">#define DRV_VERSION		&quot;1.0.0&quot;</span>
<span class="cp">#define DRV_RELDATE		&quot;Feb 8, 2010&quot;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span>
	<span class="s">&quot;Micrel &quot;</span> <span class="n">DEVICE_NAME</span> <span class="s">&quot; &quot;</span> <span class="n">DRV_VERSION</span> <span class="s">&quot; (&quot;</span> <span class="n">DRV_RELDATE</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u8</span> <span class="n">DEFAULT_MAC_ADDRESS</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0xA1</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="mh">0x01</span> <span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt processing primary routines</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_ack_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">uint</span> <span class="n">interrupt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">interrupt</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_INTERRUPTS_STATUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_dis_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_blocked</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_mask</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_INTERRUPTS_ENABLE</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_set</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_INTERRUPTS_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_set_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">uint</span> <span class="n">interrupt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_set</span> <span class="o">=</span> <span class="n">interrupt</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">interrupt</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_INTERRUPTS_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_ena_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw_set_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_dis_intr_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">uint</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_turn_off_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">uint</span> <span class="n">interrupt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">read_intr</span><span class="p">;</span>

	<span class="n">read_intr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_INTERRUPTS_ENABLE</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_set</span> <span class="o">=</span> <span class="n">read_intr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">interrupt</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_set</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_INTERRUPTS_ENABLE</span><span class="p">);</span>
	<span class="n">hw_dis_intr_bit</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_turn_on_intr - turn on specified interrupts</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @bit:	The interrupt bits to be on.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine turns on the specified interrupts in the interrupt mask so that</span>
<span class="cm"> * those interrupts will be enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_turn_on_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_mask</span> <span class="o">|=</span> <span class="n">bit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_blocked</span><span class="p">)</span>
		<span class="n">hw_set_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_ena_intr_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">uint</span> <span class="n">interrupt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">read_intr</span><span class="p">;</span>

	<span class="n">read_intr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_INTERRUPTS_ENABLE</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_set</span> <span class="o">=</span> <span class="n">read_intr</span> <span class="o">|</span> <span class="n">interrupt</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_set</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_INTERRUPTS_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_read_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">uint</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_INTERRUPTS_STATUS</span><span class="p">);</span>
	<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="o">*</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_set</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_restore_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">uint</span> <span class="n">interrupt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interrupt</span><span class="p">)</span>
		<span class="n">hw_ena_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_block_intr - block hardware interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * This function blocks all interrupts of the hardware and returns the current</span>
<span class="cm"> * interrupt enable mask so that interrupts can be restored later.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the current interrupt enable mask.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">uint</span> <span class="nf">hw_block_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uint</span> <span class="n">interrupt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_blocked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dis_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">interrupt</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_blocked</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">interrupt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hardware descriptor routines</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reset_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">union</span> <span class="n">desc_stat</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">hw_owned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">release_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">tx</span><span class="p">.</span><span class="n">hw_owned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">!=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_rx_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">**</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">];</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">last</span><span class="o">++</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">&amp;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">avail</span><span class="o">--</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KS_DESC_RX_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_rx_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_rx_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">get_tx_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">**</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">];</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">++</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&amp;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">avail</span><span class="o">--</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KS_DESC_TX_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_tx_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_tx_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">tx</span><span class="p">.</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Switch functions */</span>

<span class="cp">#define TABLE_READ			0x10</span>
<span class="cp">#define TABLE_SEL_SHIFT			2</span>

<span class="cp">#define HW_DELAY(hw, reg)			\</span>
<span class="cp">	do {					\</span>
<span class="cp">		u16 dummy;			\</span>
<span class="cp">		dummy = readw(hw-&gt;io + reg);	\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * sw_r_table - read 4 bytes of data from switch table</span>
<span class="cm"> * @hw:		The hardware instance.</span>
<span class="cm"> * @table:	The table selector.</span>
<span class="cm"> * @addr:	The address of the table entry.</span>
<span class="cm"> * @data:	Buffer to store the read data.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine reads 4 bytes of data from the table of the switch.</span>
<span class="cm"> * Hardware interrupts are disabled to minimize corruption of read data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_r_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">table</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">ctrl_addr</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">interrupt</span><span class="p">;</span>

	<span class="n">ctrl_addr</span> <span class="o">=</span> <span class="p">(((</span><span class="n">table</span> <span class="o">&lt;&lt;</span> <span class="n">TABLE_SEL_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">TABLE_READ</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">interrupt</span> <span class="o">=</span> <span class="n">hw_block_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">writew</span><span class="p">(</span><span class="n">ctrl_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_IACR_OFFSET</span><span class="p">);</span>
	<span class="n">HW_DELAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_IACR_OFFSET</span><span class="p">);</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_ACC_DATA_0_OFFSET</span><span class="p">);</span>

	<span class="n">hw_restore_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_w_table_64 - write 8 bytes of data to the switch table</span>
<span class="cm"> * @hw:		The hardware instance.</span>
<span class="cm"> * @table:	The table selector.</span>
<span class="cm"> * @addr:	The address of the table entry.</span>
<span class="cm"> * @data_hi:	The high part of data to be written (bit63 ~ bit32).</span>
<span class="cm"> * @data_lo:	The low part of data to be written (bit31 ~ bit0).</span>
<span class="cm"> *</span>
<span class="cm"> * This routine writes 8 bytes of data to the table of the switch.</span>
<span class="cm"> * Hardware interrupts are disabled to minimize corruption of written data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_w_table_64</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">table</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data_hi</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">data_lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">ctrl_addr</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">interrupt</span><span class="p">;</span>

	<span class="n">ctrl_addr</span> <span class="o">=</span> <span class="p">((</span><span class="n">table</span> <span class="o">&lt;&lt;</span> <span class="n">TABLE_SEL_SHIFT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">interrupt</span> <span class="o">=</span> <span class="n">hw_block_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">data_hi</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_ACC_DATA_4_OFFSET</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">data_lo</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_ACC_DATA_0_OFFSET</span><span class="p">);</span>

	<span class="n">writew</span><span class="p">(</span><span class="n">ctrl_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_IACR_OFFSET</span><span class="p">);</span>
	<span class="n">HW_DELAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_IACR_OFFSET</span><span class="p">);</span>

	<span class="n">hw_restore_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_w_sta_mac_table - write to the static MAC table</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @addr:	The address of the table entry.</span>
<span class="cm"> * @mac_addr:	The MAC address.</span>
<span class="cm"> * @ports:	The port members.</span>
<span class="cm"> * @override:	The flag to override the port receive/transmit settings.</span>
<span class="cm"> * @valid:	The flag to indicate entry is valid.</span>
<span class="cm"> * @use_fid:	The flag to indicate the FID is valid.</span>
<span class="cm"> * @fid:	The FID value.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine writes an entry of the static MAC table of the switch.  It</span>
<span class="cm"> * calls sw_w_table_64() to write the data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_w_sta_mac_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">ports</span><span class="p">,</span> <span class="kt">int</span> <span class="n">override</span><span class="p">,</span> <span class="kt">int</span> <span class="n">valid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_fid</span><span class="p">,</span> <span class="n">u8</span> <span class="n">fid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data_hi</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data_lo</span><span class="p">;</span>

	<span class="n">data_lo</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">data_hi</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">data_hi</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ports</span> <span class="o">&lt;&lt;</span> <span class="n">STATIC_MAC_FWD_PORTS_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">override</span><span class="p">)</span>
		<span class="n">data_hi</span> <span class="o">|=</span> <span class="n">STATIC_MAC_TABLE_OVERRIDE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_fid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data_hi</span> <span class="o">|=</span> <span class="n">STATIC_MAC_TABLE_USE_FID</span><span class="p">;</span>
		<span class="n">data_hi</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">fid</span> <span class="o">&lt;&lt;</span> <span class="n">STATIC_MAC_FID_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span>
		<span class="n">data_hi</span> <span class="o">|=</span> <span class="n">STATIC_MAC_TABLE_VALID</span><span class="p">;</span>

	<span class="n">sw_w_table_64</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TABLE_STATIC_MAC</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data_hi</span><span class="p">,</span> <span class="n">data_lo</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_r_vlan_table - read from the VLAN table</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @addr:	The address of the table entry.</span>
<span class="cm"> * @vid:	Buffer to store the VID.</span>
<span class="cm"> * @fid:	Buffer to store the VID.</span>
<span class="cm"> * @member:	Buffer to store the port membership.</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads an entry of the VLAN table of the switch.  It calls</span>
<span class="cm"> * sw_r_table() to get the data.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if the entry is valid; otherwise -1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sw_r_vlan_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">vid</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">member</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">sw_r_table</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TABLE_VLAN</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">VLAN_TABLE_VALID</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">vid</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">VLAN_TABLE_VID</span><span class="p">);</span>
		<span class="o">*</span><span class="n">fid</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">VLAN_TABLE_FID</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">VLAN_TABLE_FID_SHIFT</span><span class="p">);</span>
		<span class="o">*</span><span class="n">member</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">VLAN_TABLE_MEMBERSHIP</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			<span class="n">VLAN_TABLE_MEMBERSHIP_SHIFT</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_r_mib_cnt - read MIB counter</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @addr:	The address of the counter.</span>
<span class="cm"> * @cnt:	Buffer to store the counter.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine reads a MIB counter of the port.</span>
<span class="cm"> * Hardware interrupts are disabled to minimize corruption of read data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_r_mib_cnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctrl_addr</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">interrupt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">ctrl_addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PORT_COUNTER_NUM</span> <span class="o">*</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">interrupt</span> <span class="o">=</span> <span class="n">hw_block_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">ctrl_addr</span> <span class="o">|=</span> <span class="p">(((</span><span class="n">TABLE_MIB</span> <span class="o">&lt;&lt;</span> <span class="n">TABLE_SEL_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">TABLE_READ</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">ctrl_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_IACR_OFFSET</span><span class="p">);</span>
	<span class="n">HW_DELAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_IACR_OFFSET</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_ACC_DATA_0_OFFSET</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">MIB_COUNTER_VALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">MIB_COUNTER_OVERFLOW</span><span class="p">)</span>
				<span class="o">*</span><span class="n">cnt</span> <span class="o">+=</span> <span class="n">MIB_COUNTER_VALUE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="o">*</span><span class="n">cnt</span> <span class="o">+=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="n">MIB_COUNTER_VALUE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">hw_restore_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_r_mib_pkt - read dropped packet counts</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @cnt:	Buffer to store the receive and transmit dropped packet counts.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine reads the dropped packet counts of the port.</span>
<span class="cm"> * Hardware interrupts are disabled to minimize corruption of read data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_r_mib_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cur</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctrl_addr</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">interrupt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">KS_MIB_PACKET_DROPPED_RX_0</span> <span class="o">+</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">interrupt</span> <span class="o">=</span> <span class="n">hw_block_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="n">ctrl_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">ctrl_addr</span> <span class="o">|=</span> <span class="p">(((</span><span class="n">TABLE_MIB</span> <span class="o">&lt;&lt;</span> <span class="n">TABLE_SEL_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">TABLE_READ</span><span class="p">)</span>
			<span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">ctrl_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_IACR_OFFSET</span><span class="p">);</span>
		<span class="n">HW_DELAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_IACR_OFFSET</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_ACC_DATA_0_OFFSET</span><span class="p">);</span>

		<span class="n">hw_restore_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">);</span>

		<span class="n">data</span> <span class="o">&amp;=</span> <span class="n">MIB_PACKET_DROPPED</span><span class="p">;</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="p">)</span>
				<span class="n">data</span> <span class="o">+=</span> <span class="n">MIB_PACKET_DROPPED</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">data</span> <span class="o">-=</span> <span class="n">cur</span><span class="p">;</span>
			<span class="o">*</span><span class="n">cnt</span> <span class="o">+=</span> <span class="n">data</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="n">last</span><span class="p">;</span>
		<span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">-=</span> <span class="n">KS_MIB_PACKET_DROPPED_TX</span> <span class="o">-</span>
			<span class="n">KS_MIB_PACKET_DROPPED_TX_0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">KS_MIB_PACKET_DROPPED_TX_0</span> <span class="o">+</span> <span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_r_cnt - read MIB counters periodically</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to read the counters of the port periodically to avoid</span>
<span class="cm"> * counter overflow.  The hardware should be acquired first before calling this</span>
<span class="cm"> * routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Return non-zero when not all counters not read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">port_r_cnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_port_mib</span> <span class="o">*</span><span class="n">mib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">mib_start</span> <span class="o">&lt;</span> <span class="n">PORT_COUNTER_NUM</span><span class="p">)</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span> <span class="o">&lt;</span> <span class="n">PORT_COUNTER_NUM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">port_r_mib_cnt</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span><span class="p">]);</span>
			<span class="o">++</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_cnt</span> <span class="o">&gt;</span> <span class="n">PORT_COUNTER_NUM</span><span class="p">)</span>
		<span class="n">port_r_mib_pkt</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">mib</span><span class="o">-&gt;</span><span class="n">dropped</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">PORT_COUNTER_NUM</span><span class="p">]);</span>
	<span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_init_cnt - initialize MIB counter values</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to initialize all counters to zero if the hardware</span>
<span class="cm"> * cannot do it after reset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_init_cnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_port_mib</span> <span class="o">*</span><span class="n">mib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>

	<span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">mib_start</span> <span class="o">&lt;</span> <span class="n">PORT_COUNTER_NUM</span><span class="p">)</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">port_r_mib_cnt</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span><span class="p">]);</span>
			<span class="o">++</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span> <span class="o">&lt;</span> <span class="n">PORT_COUNTER_NUM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_cnt</span> <span class="o">&gt;</span> <span class="n">PORT_COUNTER_NUM</span><span class="p">)</span>
		<span class="n">port_r_mib_pkt</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">mib</span><span class="o">-&gt;</span><span class="n">dropped</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">PORT_COUNTER_NUM</span><span class="p">]);</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="n">TOTAL_PORT_COUNTER_NUM</span><span class="p">);</span>
	<span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Port functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * port_chk - check port register bits</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @offset:	The offset of the port register.</span>
<span class="cm"> * @bits:	The data bits to check.</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks whether the specified bits of the port register are set</span>
<span class="cm"> * or not.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if the bits are not set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">port_chk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">PORT_CTRL_ADDR</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">bits</span><span class="p">)</span> <span class="o">==</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_cfg - set port register bits</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @offset:	The offset of the port register.</span>
<span class="cm"> * @bits:	The data bits to set.</span>
<span class="cm"> * @set:	The flag indicating whether the bits are to be set or not.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets or resets the specified bits of the port register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">bits</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">PORT_CTRL_ADDR</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">bits</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">bits</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_chk_shift - check port bit</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @offset:	The offset of the register.</span>
<span class="cm"> * @shift:	Number of bits to shift.</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks whether the specified port is set in the register or</span>
<span class="cm"> * not.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if the port is not set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">port_chk_shift</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">==</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_cfg_shift - set port bit</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @offset:	The offset of the register.</span>
<span class="cm"> * @shift:	Number of bits to shift.</span>
<span class="cm"> * @set:	The flag indicating whether the port is to be set or not.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets or resets the specified port in the register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_cfg_shift</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">bits</span> <span class="o">&lt;&lt;=</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">bits</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">bits</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_r8 - read byte from port register</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @offset:	The offset of the port register.</span>
<span class="cm"> * @data:	Buffer to store the data.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine reads a byte from the port register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_r8</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">PORT_CTRL_ADDR</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_r16 - read word from port register.</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @offset:	The offset of the port register.</span>
<span class="cm"> * @data:	Buffer to store the data.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine reads a word from the port register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_r16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">PORT_CTRL_ADDR</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_w16 - write word to port register.</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @offset:	The offset of the port register.</span>
<span class="cm"> * @data:	Data to write.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine writes a word to the port register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_w16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">PORT_CTRL_ADDR</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_chk - check switch register bits</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @addr:	The address of the switch register.</span>
<span class="cm"> * @bits:	The data bits to check.</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks whether the specified bits of the switch register are</span>
<span class="cm"> * set or not.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if the bits are not set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sw_chk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">bits</span><span class="p">)</span> <span class="o">==</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_cfg - set switch register bits</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @addr:	The address of the switch register.</span>
<span class="cm"> * @bits:	The data bits to set.</span>
<span class="cm"> * @set:	The flag indicating whether the bits are to be set or not.</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets or resets the specified bits of the switch register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">bits</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">bits</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Bandwidth */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_broad_storm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_BROADCAST_STORM</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">port_chk_broad_storm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_BROADCAST_STORM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Driver set switch broadcast storm protection at 10% rate. */</span>
<span class="cp">#define BROADCAST_STORM_PROTECTION_RATE	10</span>

<span class="cm">/* 148,800 frames * 67 ms / 100 */</span>
<span class="cp">#define BROADCAST_STORM_VALUE		9969</span>

<span class="cm">/**</span>
<span class="cm"> * sw_cfg_broad_storm - configure broadcast storm threshold</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @percent:	Broadcast storm threshold in percent of transmit rate.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine configures the broadcast storm threshold of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_cfg_broad_storm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">percent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">value</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">BROADCAST_STORM_VALUE</span> <span class="o">*</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">percent</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">BROADCAST_STORM_RATE</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">BROADCAST_STORM_RATE</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_3_OFFSET</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BROADCAST_STORM_RATE_LO</span> <span class="o">|</span> <span class="n">BROADCAST_STORM_RATE_HI</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="p">((</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x00FF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_3_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_get_board_storm - get broadcast storm threshold</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @percent:	Buffer to store the broadcast storm threshold percentage.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine retrieves the broadcast storm threshold of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_get_broad_storm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">percent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_3_OFFSET</span><span class="p">);</span>
	<span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">BROADCAST_STORM_RATE_HI</span><span class="p">);</span>
	<span class="n">num</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">num</span> <span class="o">|=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">BROADCAST_STORM_RATE_LO</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">BROADCAST_STORM_VALUE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">BROADCAST_STORM_VALUE</span><span class="p">;</span>
	<span class="o">*</span><span class="n">percent</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_dis_broad_storm - disable broadstorm</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine disables the broadcast storm limit function of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_dis_broad_storm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg_broad_storm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_ena_broad_storm - enable broadcast storm</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine enables the broadcast storm limit function of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_ena_broad_storm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sw_cfg_broad_storm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">broad_per</span><span class="p">);</span>
	<span class="n">port_cfg_broad_storm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_init_broad_storm - initialize broadcast storm</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine initializes the broadcast storm limit function of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_init_broad_storm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">broad_per</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sw_cfg_broad_storm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">broad_per</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">TOTAL_PORT_NUM</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sw_dis_broad_storm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="n">sw_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">MULTICAST_STORM_DISABLE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_cfg_broad_storm - configure broadcast storm</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @percent:	Broadcast storm threshold in percent of transmit rate.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine configures the broadcast storm threshold of the switch.</span>
<span class="cm"> * It is called by user functions.  The hardware should be acquired first.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_cfg_broad_storm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">percent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">percent</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
		<span class="n">percent</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">sw_cfg_broad_storm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">percent</span><span class="p">);</span>
	<span class="n">sw_get_broad_storm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">percent</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">broad_per</span> <span class="o">=</span> <span class="n">percent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_dis_prio_rate - disable switch priority rate</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine disables the priority rate function of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_dis_prio_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">PORT_CTRL_ADDR</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">KS8842_PORT_IN_RATE_OFFSET</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_init_prio_rate - initialize switch prioirty rate</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine initializes the priority rate function of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_init_prio_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_switch</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">TOTAL_PORT_NUM</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">prio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">prio</span> <span class="o">&lt;</span> <span class="n">PRIO_QUEUES</span><span class="p">;</span> <span class="n">prio</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sw</span><span class="o">-&gt;</span><span class="n">port_cfg</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">rx_rate</span><span class="p">[</span><span class="n">prio</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">sw</span><span class="o">-&gt;</span><span class="n">port_cfg</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">tx_rate</span><span class="p">[</span><span class="n">prio</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sw_dis_prio_rate</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Communication */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_back_pressure</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_BACK_PRESSURE</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_force_flow_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_FORCE_FLOW_CTRL</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">port_chk_back_pressure</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_BACK_PRESSURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">port_chk_force_flow_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_FORCE_FLOW_CTRL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Spanning Tree */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_dis_learn</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_LEARN_DISABLE</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_RX_ENABLE</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_TX_ENABLE</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sw_cfg_fast_aging</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sw_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">SWITCH_FAST_AGING</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sw_flush_dyn_mac_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">overrides</span> <span class="o">&amp;</span> <span class="n">FAST_AGING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sw_cfg_fast_aging</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">sw_cfg_fast_aging</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* VLAN */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_ins_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">insert</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_INSERT_TAG</span><span class="p">,</span> <span class="n">insert</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_rmv_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">remove</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_REMOVE_TAG</span><span class="p">,</span> <span class="n">remove</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">port_chk_ins_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_INSERT_TAG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">port_chk_rmv_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_REMOVE_TAG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_dis_non_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_DISCARD_NON_VID</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_in_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_INGRESS_VLAN_FILTER</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">port_chk_dis_non_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_DISCARD_NON_VID</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">port_chk_in_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_INGRESS_VLAN_FILTER</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Mirroring */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_mirror_sniffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_MIRROR_SNIFFER</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_mirror_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_MIRROR_RX</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_mirror_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_MIRROR_TX</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sw_cfg_mirror_rx_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sw_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">SWITCH_MIRROR_RX_TX</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_init_mirror</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">TOTAL_PORT_NUM</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port_cfg_mirror_sniffer</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">port_cfg_mirror_rx</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">port_cfg_mirror_tx</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sw_cfg_mirror_rx_tx</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sw_cfg_unk_def_deliver</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sw_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_7_OFFSET</span><span class="p">,</span>
		<span class="n">SWITCH_UNK_DEF_PORT_ENABLE</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sw_cfg_chk_unk_def_deliver</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sw_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_7_OFFSET</span><span class="p">,</span>
		<span class="n">SWITCH_UNK_DEF_PORT_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sw_cfg_unk_def_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg_shift</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_7_OFFSET</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sw_chk_unk_def_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk_shift</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_7_OFFSET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Priority */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_diffserv</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_DIFFSERV_ENABLE</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_802_1p</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_802_1P_ENABLE</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_replace_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_USER_PRIORITY_CEILING</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_PRIO_QUEUE_ENABLE</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">port_chk_diffserv</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_DIFFSERV_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">port_chk_802_1p</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_802_1P_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">port_chk_replace_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">PORT_USER_PRIORITY_CEILING</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">port_chk_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
		<span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">PORT_PRIO_QUEUE_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_dis_diffserv - disable switch DiffServ priority</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine disables the DiffServ priority function of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_dis_diffserv</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg_diffserv</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_dis_802_1p - disable switch 802.1p priority</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine disables the 802.1p priority function of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_dis_802_1p</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg_802_1p</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_cfg_replace_null_vid -</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @set:	The flag to disable or enable.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_cfg_replace_null_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sw_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_3_OFFSET</span><span class="p">,</span> <span class="n">SWITCH_REPLACE_NULL_VID</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_cfg_replace_vid - enable switch 802.10 priority re-mapping</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @set:	The flag to disable or enable.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine enables the 802.1p priority re-mapping function of the switch.</span>
<span class="cm"> * That allows 802.1p priority field to be replaced with the port&#39;s default</span>
<span class="cm"> * tag&#39;s priority value if the ingress packet&#39;s 802.1p priority has a higher</span>
<span class="cm"> * priority than port&#39;s default tag&#39;s priority.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_cfg_replace_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg_replace_vid</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_cfg_port_based - configure switch port based priority</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @prio:	The priority to set.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine configures the port based priority of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_cfg_port_based</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u8</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prio</span> <span class="o">&gt;</span> <span class="n">PORT_BASED_PRIORITY_BASE</span><span class="p">)</span>
		<span class="n">prio</span> <span class="o">=</span> <span class="n">PORT_BASED_PRIORITY_BASE</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">port_cfg</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">port_prio</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>

	<span class="n">port_r16</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_BASED_PRIORITY_MASK</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">prio</span> <span class="o">&lt;&lt;</span> <span class="n">PORT_BASED_PRIORITY_SHIFT</span><span class="p">;</span>
	<span class="n">port_w16</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">KS8842_PORT_CTRL_1_OFFSET</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_dis_multi_queue - disable transmit multiple queues</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine disables the transmit multiple queues selection of the switch</span>
<span class="cm"> * port.  Only single transmit queue on the port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_dis_multi_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_cfg_prio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_init_prio - initialize switch priority</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine initializes the switch QoS priority functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_init_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_switch</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Init all the 802.1p tag priority value to be assigned to different</span>
<span class="cm">	 * priority queue.</span>
<span class="cm">	 */</span>
	<span class="n">sw</span><span class="o">-&gt;</span><span class="n">p_802_1p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sw</span><span class="o">-&gt;</span><span class="n">p_802_1p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sw</span><span class="o">-&gt;</span><span class="n">p_802_1p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sw</span><span class="o">-&gt;</span><span class="n">p_802_1p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sw</span><span class="o">-&gt;</span><span class="n">p_802_1p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">sw</span><span class="o">-&gt;</span><span class="n">p_802_1p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">sw</span><span class="o">-&gt;</span><span class="n">p_802_1p</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">sw</span><span class="o">-&gt;</span><span class="n">p_802_1p</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Init all the DiffServ priority value to be assigned to priority</span>
<span class="cm">	 * queue 0.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tos</span> <span class="o">&lt;</span> <span class="n">DIFFSERV_ENTRIES</span><span class="p">;</span> <span class="n">tos</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sw</span><span class="o">-&gt;</span><span class="n">diffserv</span><span class="p">[</span><span class="n">tos</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* All QoS functions disabled. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">TOTAL_PORT_NUM</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sw_dis_multi_queue</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">sw_dis_diffserv</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">sw_dis_802_1p</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">sw_cfg_replace_vid</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">sw</span><span class="o">-&gt;</span><span class="n">port_cfg</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">port_prio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sw_cfg_port_based</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">port_cfg</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">port_prio</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sw_cfg_replace_null_vid</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_get_def_vid - get port default VID.</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @vid:	Buffer to store the VID.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine retrieves the default VID of the port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_get_def_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">PORT_CTRL_ADDR</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">KS8842_PORT_CTRL_VID_OFFSET</span><span class="p">;</span>
	<span class="o">*</span><span class="n">vid</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_init_vlan - initialize switch VLAN</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine initializes the VLAN function of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_init_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_switch</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">;</span>

	<span class="cm">/* Read 16 VLAN entries from device&#39;s VLAN table. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">entry</span> <span class="o">&lt;</span> <span class="n">VLAN_TABLE_ENTRIES</span><span class="p">;</span> <span class="n">entry</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sw_r_vlan_table</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">vlan_table</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">vid</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">vlan_table</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">fid</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">vlan_table</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">member</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">TOTAL_PORT_NUM</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port_get_def_vid</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">port_cfg</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">vid</span><span class="p">);</span>
		<span class="n">sw</span><span class="o">-&gt;</span><span class="n">port_cfg</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">member</span> <span class="o">=</span> <span class="n">PORT_MASK</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_cfg_port_base_vlan - configure port-based VLAN membership</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @member:	The port-based VLAN membership.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine configures the port-based VLAN membership of the port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_cfg_port_base_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u8</span> <span class="n">member</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">PORT_CTRL_ADDR</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_VLAN_MEMBERSHIP</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">member</span> <span class="o">&amp;</span> <span class="n">PORT_MASK</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">port_cfg</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_get_addr - get the switch MAC address.</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @mac_addr:	Buffer to store the MAC address.</span>
<span class="cm"> *</span>
<span class="cm"> * This function retrieves the MAC address of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sw_get_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_MAC_ADDR_0_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_MAC_ADDR_1_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_set_addr - configure switch MAC address</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @mac_addr:	The MAC address.</span>
<span class="cm"> *</span>
<span class="cm"> * This function configures the MAC address of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_set_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_MAC_ADDR_0_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_MAC_ADDR_1_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_set_global_ctrl - set switch global control</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets the global control of the switch function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_set_global_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Enable switch MII flow control. */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_3_OFFSET</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">SWITCH_FLOW_CTRL</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_3_OFFSET</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_1_OFFSET</span><span class="p">);</span>

	<span class="cm">/* Enable aggressive back off algorithm in half duplex mode. */</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">SWITCH_AGGR_BACKOFF</span><span class="p">;</span>

	<span class="cm">/* Enable automatic fast aging when link changed detected. */</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">SWITCH_AGING_ENABLE</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">SWITCH_LINK_AUTO_AGING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">overrides</span> <span class="o">&amp;</span> <span class="n">FAST_AGING</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">SWITCH_FAST_AGING</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SWITCH_FAST_AGING</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_1_OFFSET</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_2_OFFSET</span><span class="p">);</span>

	<span class="cm">/* Enable no excessive collision drop. */</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">NO_EXC_COLLISION_DROP</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_2_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">STP_STATE_DISABLED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">STP_STATE_LISTENING</span><span class="p">,</span>
	<span class="n">STP_STATE_LEARNING</span><span class="p">,</span>
	<span class="n">STP_STATE_FORWARDING</span><span class="p">,</span>
	<span class="n">STP_STATE_BLOCKED</span><span class="p">,</span>
	<span class="n">STP_STATE_SIMPLE</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * port_set_stp_state - configure port spanning tree state</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	The port index.</span>
<span class="cm"> * @state:	The spanning tree state.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine configures the spanning tree state of the port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_set_stp_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">port_r16</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STP_STATE_DISABLED</span>:
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_TX_ENABLE</span> <span class="o">|</span> <span class="n">PORT_RX_ENABLE</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">PORT_LEARN_DISABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">STP_STATE_LISTENING</span>:
<span class="cm">/*</span>
<span class="cm"> * No need to turn on transmit because of port direct mode.</span>
<span class="cm"> * Turning on receive is required if static MAC table is not setup.</span>
<span class="cm"> */</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_TX_ENABLE</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">PORT_RX_ENABLE</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">PORT_LEARN_DISABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">STP_STATE_LEARNING</span>:
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_TX_ENABLE</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">PORT_RX_ENABLE</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_LEARN_DISABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">STP_STATE_FORWARDING</span>:
		<span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">PORT_TX_ENABLE</span> <span class="o">|</span> <span class="n">PORT_RX_ENABLE</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_LEARN_DISABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">STP_STATE_BLOCKED</span>:
<span class="cm">/*</span>
<span class="cm"> * Need to setup static MAC table with override to keep receiving BPDU</span>
<span class="cm"> * messages.  See sw_init_stp routine.</span>
<span class="cm"> */</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_TX_ENABLE</span> <span class="o">|</span> <span class="n">PORT_RX_ENABLE</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">PORT_LEARN_DISABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">STP_STATE_SIMPLE</span>:
		<span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">PORT_TX_ENABLE</span> <span class="o">|</span> <span class="n">PORT_RX_ENABLE</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">PORT_LEARN_DISABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">port_w16</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">KS8842_PORT_CTRL_2_OFFSET</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">port_cfg</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">stp_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define STP_ENTRY			0</span>
<span class="cp">#define BROADCAST_ENTRY			1</span>
<span class="cp">#define BRIDGE_ADDR_ENTRY		2</span>
<span class="cp">#define IPV6_ADDR_ENTRY			3</span>

<span class="cm">/**</span>
<span class="cm"> * sw_clr_sta_mac_table - clear static MAC table</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine clears the static MAC table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_clr_sta_mac_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_mac_table</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">STATIC_MAC_TABLE_ENTRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">mac_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">sw_w_sta_mac_table</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">,</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">override</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">use_fid</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_init_stp - initialize switch spanning tree support</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine initializes the spanning tree support of the switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_init_stp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_mac_table</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">mac_table</span><span class="p">[</span><span class="n">STP_ENTRY</span><span class="p">];</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xC2</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ports</span> <span class="o">=</span> <span class="n">HOST_MASK</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">override</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sw_w_sta_mac_table</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">STP_ENTRY</span><span class="p">,</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">,</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">override</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">,</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">use_fid</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_block_addr - block certain packets from the host port</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine blocks certain packets from reaching to the host port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_block_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_mac_table</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">BROADCAST_ENTRY</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">IPV6_ADDR_ENTRY</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">mac_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sw_w_sta_mac_table</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">,</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">override</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">,</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">use_fid</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define PHY_LINK_SUPPORT		\</span>
<span class="cp">	(PHY_AUTO_NEG_ASYM_PAUSE |	\</span>
<span class="cp">	PHY_AUTO_NEG_SYM_PAUSE |	\</span>
<span class="cp">	PHY_AUTO_NEG_100BT4 |		\</span>
<span class="cp">	PHY_AUTO_NEG_100BTX_FD |	\</span>
<span class="cp">	PHY_AUTO_NEG_100BTX |		\</span>
<span class="cp">	PHY_AUTO_NEG_10BT_FD |		\</span>
<span class="cp">	PHY_AUTO_NEG_10BT)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_r_phy_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_CTRL_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_w_phy_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_CTRL_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_r_phy_link_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_STATUS_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_r_phy_auto_neg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_AUTO_NEG_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_w_phy_auto_neg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_AUTO_NEG_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_r_phy_rem_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_REMOTE_CAP_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_r_phy_crossover</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_CTRL_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_w_phy_crossover</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_CTRL_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_r_phy_polarity</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_PHY_CTRL_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_w_phy_polarity</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_PHY_CTRL_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_r_phy_link_md</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_LINK_MD_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_w_phy_link_md</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span> <span class="o">+</span> <span class="n">KS884X_PHY_LINK_MD_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_r_phy - read data from PHY register</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	Port to read.</span>
<span class="cm"> * @reg:	PHY register to read.</span>
<span class="cm"> * @val:	Buffer to store the read data.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine reads data from the PHY register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_r_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">phy</span><span class="p">;</span>

	<span class="n">phy</span> <span class="o">=</span> <span class="n">KS884X_PHY_1_CTRL_OFFSET</span> <span class="o">+</span> <span class="n">port</span> <span class="o">*</span> <span class="n">PHY_CTRL_INTERVAL</span> <span class="o">+</span> <span class="n">reg</span><span class="p">;</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_w_phy - write data to PHY register</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @port:	Port to write.</span>
<span class="cm"> * @reg:	PHY register to write.</span>
<span class="cm"> * @val:	Word data to write.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine writes data to the PHY register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_w_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">phy</span><span class="p">;</span>

	<span class="n">phy</span> <span class="o">=</span> <span class="n">KS884X_PHY_1_CTRL_OFFSET</span> <span class="o">+</span> <span class="n">port</span> <span class="o">*</span> <span class="n">PHY_CTRL_INTERVAL</span> <span class="o">+</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">phy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * EEPROM access functions</span>
<span class="cm"> */</span>

<span class="cp">#define AT93C_CODE			0</span>
<span class="cp">#define AT93C_WR_OFF			0x00</span>
<span class="cp">#define AT93C_WR_ALL			0x10</span>
<span class="cp">#define AT93C_ER_ALL			0x20</span>
<span class="cp">#define AT93C_WR_ON			0x30</span>

<span class="cp">#define AT93C_WRITE			1</span>
<span class="cp">#define AT93C_READ			2</span>
<span class="cp">#define AT93C_ERASE			3</span>

<span class="cp">#define EEPROM_DELAY			4</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drop_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_EEPROM_CTRL_OFFSET</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">gpio</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_EEPROM_CTRL_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">raise_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_EEPROM_CTRL_OFFSET</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">gpio</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_EEPROM_CTRL_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">state_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_EEPROM_CTRL_OFFSET</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">gpio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">eeprom_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_SERIAL_CLOCK</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">EEPROM_DELAY</span><span class="p">);</span>
	<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_SERIAL_CLOCK</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">EEPROM_DELAY</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">spi_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_SERIAL_CLOCK</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">EEPROM_DELAY</span><span class="p">);</span>

		<span class="n">temp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">state_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_DATA_IN</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_SERIAL_CLOCK</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">EEPROM_DELAY</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spi_w</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_DATA_OUT</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_DATA_OUT</span><span class="p">);</span>
		<span class="n">eeprom_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spi_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">data</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Initial start bit */</span>
	<span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_DATA_OUT</span><span class="p">);</span>
	<span class="n">eeprom_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* AT93C operation */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_DATA_OUT</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_DATA_OUT</span><span class="p">);</span>
		<span class="n">eeprom_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Address location */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_DATA_OUT</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_DATA_OUT</span><span class="p">);</span>
		<span class="n">eeprom_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define EEPROM_DATA_RESERVED		0</span>
<span class="cp">#define EEPROM_DATA_MAC_ADDR_0		1</span>
<span class="cp">#define EEPROM_DATA_MAC_ADDR_1		2</span>
<span class="cp">#define EEPROM_DATA_MAC_ADDR_2		3</span>
<span class="cp">#define EEPROM_DATA_SUBSYS_ID		4</span>
<span class="cp">#define EEPROM_DATA_SUBSYS_VEN_ID	5</span>
<span class="cp">#define EEPROM_DATA_PM_CAP		6</span>

<span class="cm">/* User defined EEPROM data */</span>
<span class="cp">#define EEPROM_DATA_OTHER_MAC_ADDR	9</span>

<span class="cm">/**</span>
<span class="cm"> * eeprom_read - read from AT93C46 EEPROM</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @reg:	The register offset.</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads a word from the AT93C46 EEPROM.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the data value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">eeprom_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_ACCESS_ENABLE</span> <span class="o">|</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>

	<span class="n">spi_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">AT93C_READ</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">spi_r</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_ACCESS_ENABLE</span> <span class="o">|</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeprom_write - write to AT93C46 EEPROM</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @reg:	The register offset.</span>
<span class="cm"> * @data:	The data value.</span>
<span class="cm"> *</span>
<span class="cm"> * This procedure writes a word to the AT93C46 EEPROM.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">eeprom_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_ACCESS_ENABLE</span> <span class="o">|</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>

	<span class="cm">/* Enable write. */</span>
	<span class="n">spi_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">AT93C_CODE</span><span class="p">,</span> <span class="n">AT93C_WR_ON</span><span class="p">);</span>
	<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Erase the register. */</span>
	<span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>
	<span class="n">spi_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">AT93C_ERASE</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Check operation complete. */</span>
	<span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">state_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_DATA_IN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Write the register. */</span>
	<span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>
	<span class="n">spi_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">AT93C_WRITE</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">spi_w</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Check operation complete. */</span>
	<span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">state_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_DATA_IN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Disable write. */</span>
	<span class="n">raise_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>
	<span class="n">spi_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">AT93C_CODE</span><span class="p">,</span> <span class="n">AT93C_WR_OFF</span><span class="p">);</span>

	<span class="n">drop_gpio</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_ACCESS_ENABLE</span> <span class="o">|</span> <span class="n">EEPROM_CHIP_SELECT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Link detection routines</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">advertised_flow_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_AUTO_NEG_SYM_PAUSE</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flow_ctrl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PHY_FLOW_CTRL</span>:
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">PORT_AUTO_NEG_SYM_PAUSE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* Not supported. */</span>
	<span class="k">case</span> <span class="n">PHY_TX_ONLY</span>:
	<span class="k">case</span> <span class="n">PHY_RX_ONLY</span>:
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ctrl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_flow_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rx_cfg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_cfg</span><span class="p">;</span>

	<span class="n">rx_cfg</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span><span class="p">;</span>
	<span class="n">tx_cfg</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">|=</span> <span class="n">DMA_RX_FLOW_ENABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_RX_FLOW_ENABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span> <span class="o">|=</span> <span class="n">DMA_TX_FLOW_ENABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_TX_FLOW_ENABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_cfg</span> <span class="o">!=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_RX_CTRL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_cfg</span> <span class="o">!=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_TX_CTRL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">determine_flow_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">local</span><span class="p">,</span> <span class="n">u16</span> <span class="n">remote</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">overrides</span> <span class="o">&amp;</span> <span class="n">PAUSE_FLOW_CTRL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rx</span> <span class="o">=</span> <span class="n">tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">force_link</span><span class="p">)</span>
		<span class="n">rx</span> <span class="o">=</span> <span class="n">tx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remote</span> <span class="o">&amp;</span> <span class="n">PHY_AUTO_NEG_SYM_PAUSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local</span> <span class="o">&amp;</span> <span class="n">PHY_AUTO_NEG_SYM_PAUSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rx</span> <span class="o">=</span> <span class="n">tx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">remote</span> <span class="o">&amp;</span> <span class="n">PHY_AUTO_NEG_ASYM_PAUSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">local</span> <span class="o">&amp;</span> <span class="n">PHY_AUTO_NEG_PAUSE</span><span class="p">)</span> <span class="o">==</span>
				<span class="n">PHY_AUTO_NEG_ASYM_PAUSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">remote</span> <span class="o">&amp;</span> <span class="n">PHY_AUTO_NEG_ASYM_PAUSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">local</span> <span class="o">&amp;</span> <span class="n">PHY_AUTO_NEG_PAUSE</span><span class="p">)</span> <span class="o">==</span> <span class="n">PHY_AUTO_NEG_PAUSE</span><span class="p">)</span>
			<span class="n">rx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">)</span>
		<span class="n">set_flow_ctrl</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">tx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">port_cfg_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ksz_port_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">link_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">HALF_DUPLEX_SIGNAL_BUG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">overrides</span> <span class="o">&amp;</span> <span class="n">PAUSE_FLOW_CTRL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">cfg</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span><span class="p">;</span>

		<span class="cm">/* Disable flow control in the half duplex mode. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_TX_FLOW_ENABLE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">&amp;&amp;</span> <span class="n">cfg</span> <span class="o">!=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_TX_CTRL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_get_link_speed - get current link status</span>
<span class="cm"> * @port: 	The port instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine reads PHY registers to determine the current link status of the</span>
<span class="cm"> * switch ports.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_get_link_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uint</span> <span class="n">interrupt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port_info</span> <span class="o">*</span><span class="n">linked</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">local</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">remote</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">interrupt</span> <span class="o">=</span> <span class="n">hw_block_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">port_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
		<span class="n">port_r16</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">KS884X_PORT_CTRL_4_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">port_r16</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">KS884X_PORT_STATUS_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Link status is changing all the time even when there is no</span>
<span class="cm">		 * cable connection!</span>
<span class="cm">		 */</span>
		<span class="n">remote</span> <span class="o">=</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PORT_AUTO_NEG_COMPLETE</span> <span class="o">|</span>
			<span class="n">PORT_STATUS_LINK_GOOD</span><span class="p">);</span>
		<span class="n">local</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

		<span class="cm">/* No change to status. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">advertised</span> <span class="o">&amp;&amp;</span> <span class="n">remote</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">partner</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">advertised</span> <span class="o">=</span> <span class="n">local</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">partner</span> <span class="o">=</span> <span class="n">remote</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_STATUS_LINK_GOOD</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Remember the first linked port. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">linked</span><span class="p">)</span>
				<span class="n">linked</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>

			<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_rate</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">TX_RATE_UNIT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_STATUS_SPEED_100MBIT</span><span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_rate</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">TX_RATE_UNIT</span><span class="p">;</span>

			<span class="n">info</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_STATUS_FULL_DUPLEX</span><span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">media_connected</span> <span class="o">!=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw_r_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">KS884X_PHY_AUTO_NEG_OFFSET</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
				<span class="n">hw_r_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">KS884X_PHY_REMOTE_CAP_OFFSET</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
				<span class="n">determine_flow_ctrl</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">port_cfg_back_pressure</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
						<span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="n">change</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">port_cfg_change</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">media_connected</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">media_disconnected</span> <span class="o">!=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">change</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>

				<span class="cm">/* Indicate the link just goes down. */</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">link_down</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">media_disconnected</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">linked</span> <span class="o">&amp;&amp;</span> <span class="n">media_disconnected</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">linked</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">linked</span> <span class="o">=</span> <span class="n">linked</span><span class="p">;</span>

	<span class="n">hw_restore_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define PHY_RESET_TIMEOUT		10</span>

<span class="cm">/**</span>
<span class="cm"> * port_set_link_speed - set port speed</span>
<span class="cm"> * @port: 	The port instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets the link speed of the switch ports.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_set_link_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_port_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">port_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>

		<span class="n">port_r16</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">KS884X_PORT_CTRL_4_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">port_r8</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">KS884X_PORT_STATUS_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>

		<span class="n">cfg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_STATUS_LINK_GOOD</span><span class="p">)</span>
			<span class="n">cfg</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

		<span class="n">data</span> <span class="o">|=</span> <span class="n">PORT_AUTO_NEG_ENABLE</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">advertised_flow_ctrl</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

		<span class="n">data</span> <span class="o">|=</span> <span class="n">PORT_AUTO_NEG_100BTX_FD</span> <span class="o">|</span> <span class="n">PORT_AUTO_NEG_100BTX</span> <span class="o">|</span>
			<span class="n">PORT_AUTO_NEG_10BT_FD</span> <span class="o">|</span> <span class="n">PORT_AUTO_NEG_10BT</span><span class="p">;</span>

		<span class="cm">/* Check if manual configuration is specified by the user. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">||</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">10</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span>
				<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_AUTO_NEG_100BTX_FD</span> <span class="o">|</span>
					<span class="n">PORT_AUTO_NEG_100BTX</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">100</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span>
				<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_AUTO_NEG_10BT_FD</span> <span class="o">|</span>
					<span class="n">PORT_AUTO_NEG_10BT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">)</span>
				<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_AUTO_NEG_100BTX_FD</span> <span class="o">|</span>
					<span class="n">PORT_AUTO_NEG_10BT_FD</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">)</span>
				<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_AUTO_NEG_100BTX</span> <span class="o">|</span>
					<span class="n">PORT_AUTO_NEG_10BT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="n">cfg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="n">PORT_AUTO_NEG_RESTART</span><span class="p">;</span>
			<span class="n">port_w16</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">KS884X_PORT_CTRL_4_OFFSET</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_force_link_speed - force port speed</span>
<span class="cm"> * @port: 	The port instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine forces the link speed of the switch ports.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_force_link_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">phy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">port_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phy</span> <span class="o">=</span> <span class="n">KS884X_PHY_1_CTRL_OFFSET</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">PHY_CTRL_INTERVAL</span><span class="p">;</span>
		<span class="n">hw_r_phy_ctrl</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">phy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>

		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PHY_AUTO_NEG_ENABLE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="mi">10</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PHY_SPEED_100MBIT</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">100</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="n">PHY_SPEED_100MBIT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PHY_FULL_DUPLEX</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="n">PHY_FULL_DUPLEX</span><span class="p">;</span>
		<span class="n">hw_w_phy_ctrl</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">phy</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_set_power_saving</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">port_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
		<span class="n">port_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
			<span class="n">KS884X_PORT_CTRL_4_OFFSET</span><span class="p">,</span> <span class="n">PORT_POWER_DOWN</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * KSZ8841 power management functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * hw_chk_wol_pme_status - check PMEN pin</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to check PMEN pin is asserted.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 1 if PMEN pin is asserted; otherwise, 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_chk_wol_pme_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dev_info</span><span class="p">,</span> <span class="n">hw</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_PME_STATUS</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_PM_CTRL_PME_STATUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_clr_wol_pme_status - clear PMEN pin</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to clear PME_Status to deassert PMEN pin.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_clr_wol_pme_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dev_info</span><span class="p">,</span> <span class="n">hw</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Clear PME_Status to deassert PMEN pin. */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">PCI_PM_CTRL_PME_STATUS</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_cfg_wol_pme - enable or disable Wake-on-LAN</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @set:	The flag indicating whether to enable or disable.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to enable or disable Wake-on-LAN.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_cfg_wol_pme</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dev_info</span><span class="p">,</span> <span class="n">hw</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">pm_cap</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">PCI_PM_CTRL_PME_ENABLE</span> <span class="o">|</span> <span class="n">PCI_D3hot</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_PME_ENABLE</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">pm_cap</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_cfg_wol - configure Wake-on-LAN features</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @frame:	The pattern frame bit.</span>
<span class="cm"> * @set:	The flag indicating whether to enable or disable.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to enable or disable certain Wake-on-LAN features.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_cfg_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8841_WOL_CTRL_OFFSET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">frame</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">frame</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8841_WOL_CTRL_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_set_wol_frame - program Wake-on-LAN pattern</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @i:		The frame index.</span>
<span class="cm"> * @mask_size:	The size of the mask.</span>
<span class="cm"> * @mask:	Mask to ignore certain bytes in the pattern.</span>
<span class="cm"> * @frame_size:	The size of the frame.</span>
<span class="cm"> * @pattern:	The frame data.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to program Wake-on-LAN pattern.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_set_wol_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">uint</span> <span class="n">mask_size</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">uint</span> <span class="n">frame_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">pattern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">from</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">crc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frame_size</span> <span class="o">&gt;</span> <span class="n">mask_size</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">frame_size</span> <span class="o">=</span> <span class="n">mask_size</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frame_size</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span>
		<span class="n">frame_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">*=</span> <span class="mh">0x10</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8841_WOL_FRAME_BYTE0_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8841_WOL_FRAME_BYTE2_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">bits</span> <span class="o">=</span> <span class="n">len</span> <span class="o">=</span> <span class="n">from</span> <span class="o">=</span> <span class="n">to</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
				<span class="n">data</span><span class="p">[</span><span class="n">to</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[</span><span class="n">from</span><span class="p">];</span>
			<span class="n">val</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="o">++</span><span class="n">from</span><span class="p">;</span>
			<span class="o">--</span><span class="n">bits</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>
			<span class="n">writeb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8841_WOL_FRAME_BYTE0_OFFSET</span> <span class="o">+</span> <span class="n">i</span>
				<span class="o">+</span> <span class="n">len</span><span class="p">);</span>
			<span class="o">++</span><span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
				<span class="n">bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">from</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">from</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">frame_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">val</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">from</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">val</span><span class="p">;</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8841_WOL_FRAME_BYTE0_OFFSET</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span>
			<span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">ether_crc</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">crc</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8841_WOL_FRAME_CRC_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_add_wol_arp - add ARP pattern</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @ip_addr:	The IPv4 address assigned to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to add ARP pattern for waking up the host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_add_wol_arp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ip_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x3F</span><span class="p">,</span> <span class="mh">0xF0</span><span class="p">,</span> <span class="mh">0x3F</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">,</span> <span class="mh">0x03</span> <span class="p">};</span>
	<span class="n">u8</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span>
		<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
		<span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">,</span>
		<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span>
		<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
		<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
		<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
		<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">};</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pattern</span><span class="p">[</span><span class="mi">38</span><span class="p">],</span> <span class="n">ip_addr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">hw_set_wol_frame</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="n">pattern</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_add_wol_bcast - add broadcast pattern</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to add broadcast pattern for waking up the host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_add_wol_bcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x3F</span> <span class="p">};</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">pattern</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span> <span class="p">};</span>

	<span class="n">hw_set_wol_frame</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">,</span> <span class="n">pattern</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_add_wol_mcast - add multicast pattern</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to add multicast pattern for waking up the host.</span>
<span class="cm"> *</span>
<span class="cm"> * It is assumed the multicast packet is the ICMPv6 neighbor solicitation used</span>
<span class="cm"> * by IPv6 ping command.  Note that multicast packets are filtred through the</span>
<span class="cm"> * multicast hash table, so not all multicast packets can wake up the host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_add_wol_mcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x3F</span> <span class="p">};</span>
	<span class="n">u8</span> <span class="n">pattern</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x33</span><span class="p">,</span> <span class="mh">0x33</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">};</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pattern</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">hw_set_wol_frame</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">pattern</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_add_wol_ucast - add unicast pattern</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to add unicast pattern to wakeup the host.</span>
<span class="cm"> *</span>
<span class="cm"> * It is assumed the unicast packet is directed to the device, as the hardware</span>
<span class="cm"> * can only receive them in normal case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_add_wol_ucast</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x3F</span> <span class="p">};</span>

	<span class="n">hw_set_wol_frame</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_enable_wol - enable Wake-on-LAN</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @wol_enable:	The Wake-on-LAN settings.</span>
<span class="cm"> * @net_addr:	The IPv4 address assigned to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to enable Wake-on-LAN depending on driver settings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_enable_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">wol_enable</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">net_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_cfg_wol</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8841_WOL_MAGIC_ENABLE</span><span class="p">,</span> <span class="p">(</span><span class="n">wol_enable</span> <span class="o">&amp;</span> <span class="n">WAKE_MAGIC</span><span class="p">));</span>
	<span class="n">hw_cfg_wol</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8841_WOL_FRAME0_ENABLE</span><span class="p">,</span> <span class="p">(</span><span class="n">wol_enable</span> <span class="o">&amp;</span> <span class="n">WAKE_UCAST</span><span class="p">));</span>
	<span class="n">hw_add_wol_ucast</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">hw_cfg_wol</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8841_WOL_FRAME1_ENABLE</span><span class="p">,</span> <span class="p">(</span><span class="n">wol_enable</span> <span class="o">&amp;</span> <span class="n">WAKE_MCAST</span><span class="p">));</span>
	<span class="n">hw_add_wol_mcast</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">hw_cfg_wol</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8841_WOL_FRAME2_ENABLE</span><span class="p">,</span> <span class="p">(</span><span class="n">wol_enable</span> <span class="o">&amp;</span> <span class="n">WAKE_BCAST</span><span class="p">));</span>
	<span class="n">hw_cfg_wol</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8841_WOL_FRAME3_ENABLE</span><span class="p">,</span> <span class="p">(</span><span class="n">wol_enable</span> <span class="o">&amp;</span> <span class="n">WAKE_ARP</span><span class="p">));</span>
	<span class="n">hw_add_wol_arp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">net_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_init - check driver is correct for the hardware</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks the hardware is correct for this driver and sets the</span>
<span class="cm"> * hardware up for proper initialization.</span>
<span class="cm"> *</span>
<span class="cm"> * Return number of ports or 0 if not right.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">revision</span><span class="p">;</span>

	<span class="cm">/* Set bus speed to 125MHz. */</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">BUS_SPEED_125_MHZ</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_BUS_CTRL_OFFSET</span><span class="p">);</span>

	<span class="cm">/* Check KSZ884x chip ID. */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_CHIP_ID_OFFSET</span><span class="p">);</span>

	<span class="n">revision</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">KS884X_REVISION_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">KS884X_REVISION_SHIFT</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="n">KS884X_CHIP_ID_MASK_41</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">REG_CHIP_ID_41</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">REG_CHIP_ID_42</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Setup hardware features or bug workarounds. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">revision</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">SMALL_PACKET_TX_BUG</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">rc</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">HALF_DUPLEX_SIGNAL_BUG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_reset - reset the hardware</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine resets the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">GLOBAL_SOFTWARE_RESET</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_GLOBAL_CTRL_OFFSET</span><span class="p">);</span>

	<span class="cm">/* Wait for device to reset. */</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* Write 0 to clear device reset. */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_GLOBAL_CTRL_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_setup - setup the hardware</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine setup the hardware for proper operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if SET_DEFAULT_LED</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Change default LED mode. */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_5_OFFSET</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LED_MODE</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">SET_DEFAULT_LED</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_5_OFFSET</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Setup transmit control. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">DMA_TX_PAD_ENABLE</span> <span class="o">|</span> <span class="n">DMA_TX_CRC_ENABLE</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">DMA_BURST_DEFAULT</span> <span class="o">&lt;&lt;</span> <span class="n">DMA_BURST_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">DMA_TX_ENABLE</span><span class="p">);</span>

	<span class="cm">/* Setup receive control. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">DMA_RX_BROADCAST</span> <span class="o">|</span> <span class="n">DMA_RX_UNICAST</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">DMA_BURST_DEFAULT</span> <span class="o">&lt;&lt;</span> <span class="n">DMA_BURST_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">DMA_RX_ENABLE</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">|=</span> <span class="n">KS884X_DMA_RX_MULTICAST</span><span class="p">;</span>

	<span class="cm">/* Hardware cannot handle UDP packet in IP fragments. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DMA_RX_CSUM_TCP</span> <span class="o">|</span> <span class="n">DMA_RX_CSUM_IP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">|=</span> <span class="n">DMA_RX_ALL_MULTICAST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">promiscuous</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">|=</span> <span class="n">DMA_RX_PROMISCUOUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_setup_intr - setup interrupt mask</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine setup the interrupt mask for proper operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_setup_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_mask</span> <span class="o">=</span> <span class="n">KS884X_INT_MASK</span> <span class="o">|</span> <span class="n">KS884X_INT_RX_OVERRUN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ksz_check_desc_num</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define MIN_DESC_SHIFT  2</span>

	<span class="kt">int</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shift</span><span class="p">;</span>

	<span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">alloc</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">shift</span><span class="o">++</span><span class="p">;</span>
		<span class="n">alloc</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">shift</span> <span class="o">&lt;</span> <span class="n">MIN_DESC_SHIFT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;Hardware descriptor numbers not right!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shift</span><span class="o">++</span><span class="p">;</span>
			<span class="n">alloc</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;</span> <span class="n">MIN_DESC_SHIFT</span><span class="p">)</span>
			<span class="n">shift</span> <span class="o">=</span> <span class="n">MIN_DESC_SHIFT</span><span class="p">;</span>
		<span class="n">alloc</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_init_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">desc_info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">transmit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phys</span> <span class="o">=</span> <span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">ring_phys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">ring_virt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">previous</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">phw</span> <span class="o">=</span> <span class="n">desc</span><span class="o">++</span><span class="p">;</span>
		<span class="n">phys</span> <span class="o">+=</span> <span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">previous</span> <span class="o">=</span> <span class="n">cur</span><span class="o">++</span><span class="p">;</span>
		<span class="n">previous</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">phys</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">previous</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">ring_phys</span><span class="p">);</span>
	<span class="n">previous</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">end_of_ring</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">previous</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">previous</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>

	<span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">;</span>
	<span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_set_desc_base - set descriptor base addresses</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @tx_addr:	The transmit descriptor base.</span>
<span class="cm"> * @rx_addr:	The receive descriptor base.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine programs the descriptor base addresses after reset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_set_desc_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tx_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Set base address of Tx/Rx descriptors. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tx_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_TX_ADDR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rx_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_RX_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_reset_pkts</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hw_resume_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">DMA_START</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_RX_START</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_start_rx - start receiving</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine starts the receive function of the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_start_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_RX_CTRL</span><span class="p">);</span>

	<span class="cm">/* Notify when the receive stops. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_mask</span> <span class="o">|=</span> <span class="n">KS884X_INT_RX_STOPPED</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">DMA_START</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_RX_START</span><span class="p">);</span>
	<span class="n">hw_ack_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_INT_RX_STOPPED</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_stop</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Variable overflows. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_stop</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_stop</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hw_stop_rx - stop receiving</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine stops the receive function of the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_stop_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw_turn_off_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_INT_RX_STOPPED</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DMA_RX_ENABLE</span><span class="p">),</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_RX_CTRL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_start_tx - start transmitting</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine starts the transmit function of the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_start_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_TX_CTRL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_stop_tx - stop transmitting</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine stops the transmit function of the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_stop_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DMA_TX_ENABLE</span><span class="p">),</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_TX_CTRL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_disable - disable hardware</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine disables the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_stop_rx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">hw_stop_tx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_enable - enable hardware</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine enables the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw_start_tx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">hw_start_rx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_alloc_pkt - allocate enough descriptors for transmission</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @length:	The length of the packet.</span>
<span class="cm"> * @physical:	Number of descriptors required.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates descriptors for transmission.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if not successful; 1 for buffer copy; or number of descriptors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_alloc_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">physical</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Always leave one descriptor free. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">avail</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Allocate a descriptor for transmission and mark it current. */</span>
	<span class="n">get_tx_pkt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">cur</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">tx</span><span class="p">.</span><span class="n">first_seg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Keep track of number of transmit descriptors used so far. */</span>
	<span class="o">++</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_cnt</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_size</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* Cannot hold on too much data. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_size</span> <span class="o">&gt;=</span> <span class="n">MAX_TX_HELD_SIZE</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_cnt</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">physical</span> <span class="o">&gt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">avail</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">avail</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_send_pkt - mark packet for transmission</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine marks the packet for transmission in PCI version.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_send_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">cur</span><span class="p">;</span>

	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">tx</span><span class="p">.</span><span class="n">last_seg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Interrupt only after specified number of descriptors used. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_cnt</span> <span class="o">&gt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">tx</span><span class="p">.</span><span class="n">intr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* KSZ8842 supports port directed transmission. */</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">tx</span><span class="p">.</span><span class="n">dest_port</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dst_ports</span><span class="p">;</span>

	<span class="n">release_desc</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_TX_START</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">empty_addr</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">addr1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">addr2</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span> <span class="o">==</span> <span class="o">*</span><span class="n">addr1</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">==</span> <span class="o">*</span><span class="n">addr2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_set_addr - set MAC address</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine programs the MAC address of the hardware when the address is</span>
<span class="cm"> * overrided.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_set_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ETH_ALEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">[</span><span class="n">MAC_ADDR_ORDER</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_ADDR_0_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">sw_set_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_read_addr - read MAC address</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine retrieves the MAC address of the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_read_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ETH_ALEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">[</span><span class="n">MAC_ADDR_ORDER</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span>
			<span class="n">KS884X_ADDR_0_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_override</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">empty_addr</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">DEFAULT_MAC_ADDRESS</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">,</span> <span class="n">DEFAULT_MAC_ADDRESS</span><span class="p">,</span>
			       <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
			<span class="n">hw_set_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_ena_add_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mac_addr_lo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mac_addr_hi</span><span class="p">;</span>

	<span class="n">mac_addr_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mac_addr_hi</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">mac_addr_hi</span> <span class="o">|=</span> <span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">mac_addr_hi</span> <span class="o">|=</span> <span class="n">ADD_ADDR_ENABLE</span><span class="p">;</span>
	<span class="n">mac_addr_lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mac_addr_lo</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">mac_addr_lo</span> <span class="o">|=</span> <span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">index</span> <span class="o">*=</span> <span class="n">ADD_ADDR_INCR</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">mac_addr_lo</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">index</span> <span class="o">+</span> <span class="n">KS_ADD_ADDR_0_LO</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mac_addr_hi</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">index</span> <span class="o">+</span> <span class="n">KS_ADD_ADDR_0_HI</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_set_add_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ADDITIONAL_ENTRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">empty_addr</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">ADD_ADDR_INCR</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span>
				<span class="n">KS_ADD_ADDR_0_HI</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">hw_ena_add_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_add_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ADDITIONAL_ENTRIES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">,</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_list_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ADDITIONAL_ENTRIES</span> <span class="o">==</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">empty_addr</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">ADDITIONAL_ENTRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">hw_ena_add_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_del_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_list_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">ADD_ADDR_INCR</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span>
				<span class="n">KS_ADD_ADDR_0_HI</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_clr_multicast - clear multicast addresses</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine removes all multicast addresses set in the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_clr_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HW_MULTICAST_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_MULTICAST_0_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_set_grp_addr - set multicast addresses</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine programs multicast addresses for the hardware to accept those</span>
<span class="cm"> * addresses.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_set_grp_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">position</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_bits</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="o">*</span> <span class="n">HW_MULTICAST_SIZE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_list_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="n">ether_crc</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">position</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">position</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_bits</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HW_MULTICAST_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_bits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_MULTICAST_0_OFFSET</span> <span class="o">+</span>
			<span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_set_multicast - enable or disable all multicast receiving</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @multicast:	To turn on or off the all multicast feature.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine enables/disables the hardware to accept all multicast packets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_set_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">multicast</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Stop receiving for reconfiguration. */</span>
	<span class="n">hw_stop_rx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">multicast</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">|=</span> <span class="n">DMA_RX_ALL_MULTICAST</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_RX_ALL_MULTICAST</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">hw_start_rx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hw_set_promiscuous - enable or disable promiscuous receiving</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @prom:	To turn on or off the promiscuous feature.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine enables/disables the hardware to accept all packets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_set_promiscuous</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">prom</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Stop receiving for reconfiguration. */</span>
	<span class="n">hw_stop_rx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prom</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">|=</span> <span class="n">DMA_RX_PROMISCUOUS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_RX_PROMISCUOUS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">hw_start_rx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_enable - enable the switch</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> * @enable:	The flag to enable or disable the switch</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to enable/disable the switch in KSZ8842.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Set port-base vlan membership with host port. */</span>
			<span class="n">sw_cfg_port_base_vlan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span>
				<span class="n">HOST_MASK</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">port</span><span class="p">));</span>
			<span class="n">port_set_stp_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">STP_STATE_DISABLED</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sw_cfg_port_base_vlan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">PORT_MASK</span><span class="p">);</span>
			<span class="n">port_set_stp_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">STP_STATE_FORWARDING</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">port_set_stp_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">,</span> <span class="n">STP_STATE_SIMPLE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">port_set_stp_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">,</span> <span class="n">STP_STATE_FORWARDING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">enable</span> <span class="o">=</span> <span class="n">KS8842_START</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">enable</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS884X_CHIP_ID_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sw_setup - setup the switch</span>
<span class="cm"> * @hw: 	The hardware instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine setup the hardware switch engine for default operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">sw_set_global_ctrl</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Enable switch broadcast storm protection at 10% percent rate. */</span>
	<span class="n">sw_init_broad_storm</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">hw_cfg_broad_storm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BROADCAST_STORM_PROTECTION_RATE</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sw_ena_broad_storm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">sw_init_prio</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">sw_init_mirror</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">sw_init_prio_rate</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">sw_init_vlan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">STP_SUPPORT</span><span class="p">)</span>
		<span class="n">sw_init_stp</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sw_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_1_OFFSET</span><span class="p">,</span>
			<span class="n">SWITCH_TX_FLOW_CTRL</span> <span class="o">|</span> <span class="n">SWITCH_RX_FLOW_CTRL</span><span class="p">))</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">overrides</span> <span class="o">|=</span> <span class="n">PAUSE_FLOW_CTRL</span><span class="p">;</span>
	<span class="n">sw_enable</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ksz_start_timer - start kernel timer</span>
<span class="cm"> * @info:	Kernel timer information.</span>
<span class="cm"> * @time:	The time tick.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine starts the kernel timer after the specified time tick.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ksz_start_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_timer_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">time</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="cm">/* infinity */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ksz_stop_timer - stop kernel timer</span>
<span class="cm"> * @info:	Kernel timer information.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine stops the kernel timer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ksz_stop_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_timer_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ksz_init_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_timer_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">period</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ksz_update_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_timer_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>
			<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ksz_alloc_soft_desc - allocate software descriptors</span>
<span class="cm"> * @desc_info:	Descriptor information structure.</span>
<span class="cm"> * @transmit:	Indication that descriptors are for transmit.</span>
<span class="cm"> *</span>
<span class="cm"> * This local function allocates software descriptors for manipulation in</span>
<span class="cm"> * memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ksz_alloc_soft_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">desc_info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">transmit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">ring</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">,</span>
				  <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hw_init_desc</span><span class="p">(</span><span class="n">desc_info</span><span class="p">,</span> <span class="n">transmit</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ksz_alloc_desc - allocate hardware descriptors</span>
<span class="cm"> * @adapter:	Adapter information structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This local function allocates hardware descriptors for receiving and</span>
<span class="cm"> * transmitting.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ksz_alloc_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for RX &amp; TX descriptors. */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_size</span> <span class="o">=</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">alloc</span> <span class="o">+</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">alloc</span> <span class="o">+</span>
		<span class="n">DESC_ALIGNMENT</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_virt</span> <span class="o">=</span>
		<span class="n">pci_alloc_consistent</span><span class="p">(</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_size</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_virt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_size</span><span class="p">);</span>

	<span class="cm">/* Align to the next cache line boundary. */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">(((</span><span class="n">ulong</span><span class="p">)</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_virt</span> <span class="o">%</span> <span class="n">DESC_ALIGNMENT</span><span class="p">)</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">DESC_ALIGNMENT</span> <span class="o">-</span>
		<span class="p">((</span><span class="n">ulong</span><span class="p">)</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_virt</span> <span class="o">%</span> <span class="n">DESC_ALIGNMENT</span><span class="p">))</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">virt</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_virt</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">phys</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/* Allocate receive/transmit descriptors. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">ring_virt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw_desc</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">ring_phys</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">phys</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">alloc</span> <span class="o">*</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">ring_virt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw_desc</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">virt</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">ring_phys</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">phys</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ksz_alloc_soft_desc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ksz_alloc_soft_desc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_dma_buf - release DMA buffer resources</span>
<span class="cm"> * @adapter:	Adapter information structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is just a helper function to release the DMA buffer resources.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_dma_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ksz_dma_buf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ksz_init_rx_buffers - initialize receive descriptors</span>
<span class="cm"> * @adapter:	Adapter information structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine initializes DMA buffers for receiving.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ksz_init_rx_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_dma_buf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">alloc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_rx_pkt</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span>

		<span class="n">dma_buf</span> <span class="o">=</span> <span class="n">DMA_BUFFER</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">)</span>
			<span class="n">free_dma_buf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">dma_buf</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
			<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">),</span>
				<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Set descriptor. */</span>
		<span class="n">set_rx_buf</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">set_rx_len</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">release_desc</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ksz_alloc_mem - allocate memory for hardware descriptors</span>
<span class="cm"> * @adapter:	Adapter information structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates memory for use by hardware descriptors for receiving</span>
<span class="cm"> * and transmitting.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ksz_alloc_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* Determine the number of receive and transmit descriptors. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">NUM_OF_RX_DESC</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">NUM_OF_TX_DESC</span><span class="p">;</span>

	<span class="cm">/* Determine how many descriptors to skip transmit interrupt. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_mask</span> <span class="o">=</span> <span class="n">NUM_OF_TX_DESC</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_mask</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_mask</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Determine the descriptor size. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span>
		<span class="p">(((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw_desc</span><span class="p">)</span> <span class="o">+</span> <span class="n">DESC_ALIGNMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
		<span class="n">DESC_ALIGNMENT</span><span class="p">)</span> <span class="o">*</span> <span class="n">DESC_ALIGNMENT</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span>
		<span class="p">(((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw_desc</span><span class="p">)</span> <span class="o">+</span> <span class="n">DESC_ALIGNMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
		<span class="n">DESC_ALIGNMENT</span><span class="p">)</span> <span class="o">*</span> <span class="n">DESC_ALIGNMENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw_desc</span><span class="p">))</span>
		<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;Hardware descriptor size not right!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ksz_check_desc_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">);</span>
	<span class="n">ksz_check_desc_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">);</span>

	<span class="cm">/* Allocate descriptors. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ksz_alloc_desc</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ksz_free_desc - free software and hardware descriptors</span>
<span class="cm"> * @adapter:	Adapter information structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This local routine frees the software and hardware descriptors allocated by</span>
<span class="cm"> * ksz_alloc_desc().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ksz_free_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* Reset descriptor. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">ring_virt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">ring_virt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">ring_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">ring_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Free memory. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_virt</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_size</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_virt</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">);</span>

	<span class="cm">/* Reset resource pool. */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">.</span><span class="n">alloc_virt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">ring</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">ring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">ring</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">ring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ksz_free_buffers - free buffers used in the descriptors</span>
<span class="cm"> * @adapter:	Adapter information structure.</span>
<span class="cm"> * @desc_info:	Descriptor information structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This local routine frees buffers used in the DMA buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ksz_free_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">desc_info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_dma_buf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">desc_info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_buf</span> <span class="o">=</span> <span class="n">DMA_BUFFER</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">free_dma_buf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">dma_buf</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ksz_free_mem - free all resources used by descriptors</span>
<span class="cm"> * @adapter:	Adapter information structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This local routine frees all the resources allocated by ksz_alloc_mem().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ksz_free_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Free transmit buffers. */</span>
	<span class="n">ksz_free_buffers</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">tx_desc_info</span><span class="p">,</span>
		<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>

	<span class="cm">/* Free receive buffers. */</span>
	<span class="n">ksz_free_buffers</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rx_desc_info</span><span class="p">,</span>
		<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

	<span class="cm">/* Free descriptors. */</span>
	<span class="n">ksz_free_desc</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_mib_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mib</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port_mib</span> <span class="o">*</span><span class="n">port_mib</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="n">TOTAL_PORT_COUNTER_NUM</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port_mib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">mib</span> <span class="o">=</span> <span class="n">port_mib</span><span class="o">-&gt;</span><span class="n">mib_start</span><span class="p">;</span> <span class="n">mib</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_cnt</span><span class="p">;</span> <span class="n">mib</span><span class="o">++</span><span class="p">)</span>
			<span class="n">counter</span><span class="p">[</span><span class="n">mib</span><span class="p">]</span> <span class="o">+=</span> <span class="n">port_mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">mib</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * send_packet - send packet</span>
<span class="cm"> * @skb:	Socket buffer.</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to send a packet out to the network.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_dma_buf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_frag</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * KSZ8842 with multiple device interfaces needs to be told which port</span>
<span class="cm">	 * to send.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dst_ports</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">first_port</span><span class="p">;</span>

	<span class="cm">/* Hardware will pad the length to 60. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Remember the very first descriptor. */</span>
	<span class="n">first</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>

	<span class="n">dma_buf</span> <span class="o">=</span> <span class="n">DMA_BUFFER</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_frag</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">frag</span><span class="p">;</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">this_frag</span><span class="p">;</span>

		<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
			<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="n">set_tx_buf</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">set_tx_len</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

		<span class="n">frag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">this_frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">frag</span><span class="p">];</span>

			<span class="cm">/* Get a new descriptor. */</span>
			<span class="n">get_tx_pkt</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span>

			<span class="cm">/* Keep track of descriptors used so far. */</span>
			<span class="o">++</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_int_cnt</span><span class="p">;</span>

			<span class="n">dma_buf</span> <span class="o">=</span> <span class="n">DMA_BUFFER</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
			<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">this_frag</span><span class="p">);</span>

			<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span>
				<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">skb_frag_address</span><span class="p">(</span><span class="n">this_frag</span><span class="p">),</span>
				<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">set_tx_buf</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
			<span class="n">set_tx_len</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

			<span class="n">frag</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frag</span> <span class="o">==</span> <span class="n">last_frag</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* Do not release the last descriptor here. */</span>
			<span class="n">release_desc</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* current points to the last descriptor. */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>

		<span class="cm">/* Release the first descriptor. */</span>
		<span class="n">release_desc</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
			<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="n">set_tx_buf</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">set_tx_len</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">tx</span><span class="p">.</span><span class="n">csum_gen_tcp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">tx</span><span class="p">.</span><span class="n">csum_gen_udp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The last descriptor holds the packet so that it can be returned to</span>
<span class="cm">	 * network subsystem after all descriptors are transmitted.</span>
<span class="cm">	 */</span>
	<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="n">hw_send_pkt</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Update transmit statistics. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * transmit_cleanup - clean up transmit descriptors</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to clean up the transmitted buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">transmit_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">normal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">last</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">desc_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_dma_buf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hwlock</span><span class="p">);</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get next descriptor which is not hardware owned. */</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">last</span><span class="p">];</span>
		<span class="n">status</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">tx</span><span class="p">.</span><span class="n">hw_owned</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">normal</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">reset_desc</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">dma_buf</span> <span class="o">=</span> <span class="n">DMA_BUFFER</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
			<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>

		<span class="cm">/* This descriptor contains the last buffer in the packet. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span> <span class="o">=</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

			<span class="cm">/* Release the packet back to network subsystem. */</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Free the transmitted descriptor. */</span>
		<span class="n">last</span><span class="o">++</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">&amp;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">avail</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hwlock</span><span class="p">);</span>

	<span class="cm">/* Notify the network subsystem that the packet has been sent. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * transmit_done - transmit done processing</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called when the transmit interrupt is triggered, indicating</span>
<span class="cm"> * either a packet is sent successfully or there are transmit errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">transmit_cleanup</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">pdev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">copy_old_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">ip_summed</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">;</span>
	<span class="n">skb_set_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">);</span>

	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_tx - send out packet</span>
<span class="cm"> * @skb:	Socket buffer.</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used by the upper network layer to send out a packet.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code indicating failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">netdev_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">SMALL_PACKET_TX_BUG</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">org_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">48</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_end_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">org_skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">org_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
				<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">org_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
					<span class="mi">50</span> <span class="o">-</span> <span class="n">org_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
				<span class="n">copy_old_skb</span><span class="p">(</span><span class="n">org_skb</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hwlock</span><span class="p">);</span>

	<span class="n">num</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">left</span> <span class="o">=</span> <span class="n">hw_alloc_pkt</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">num</span> <span class="o">||</span>
				<span class="p">((</span><span class="n">CHECKSUM_PARTIAL</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">ETH_P_IPV6</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">))))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">org_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">org_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">skb_copy_and_csum_dev</span><span class="p">(</span><span class="n">org_skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
			<span class="n">org_skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">org_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="n">copy_old_skb</span><span class="p">(</span><span class="n">org_skb</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">send_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">)</span>
			<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Stop the transmit queue until packet is allocated. */</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hwlock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_tx_timeout - transmit timeout processing</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called when the transmit timer expires.  That indicates the</span>
<span class="cm"> * hardware is not running correctly because transmit interrupts are not</span>
<span class="cm"> * triggered to free up resources so that the transmit routine can continue</span>
<span class="cm"> * sending out packets.  The hardware is reset to correct the problem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_reset</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Only reset the hardware if time between calls is long</span>
<span class="cm">		 * enough.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">last_reset</span> <span class="o">&lt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span><span class="p">)</span>
			<span class="n">hw_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">last_reset</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_priv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_dis_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">hw_disable</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="n">transmit_cleanup</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">hw_reset_pkts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">);</span>
		<span class="n">hw_reset_pkts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">);</span>
		<span class="n">ksz_init_rx_buffers</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">);</span>

		<span class="n">hw_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="n">hw_set_desc_base</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">ring_phys</span><span class="p">,</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">ring_phys</span><span class="p">);</span>
		<span class="n">hw_set_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">)</span>
			<span class="n">hw_set_multicast</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_list_size</span><span class="p">)</span>
			<span class="n">hw_set_grp_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw_set_add_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">port_dev</span><span class="p">;</span>

				<span class="n">port_set_stp_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span>
					<span class="n">STP_STATE_DISABLED</span><span class="p">);</span>

				<span class="n">port_dev</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">pdev</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">port_dev</span><span class="p">))</span>
					<span class="n">port_set_stp_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span>
						<span class="n">STP_STATE_SIMPLE</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">hw_enable</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">hw_ena_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">csum_verified</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">;</span>

	<span class="n">protocol</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">iph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">protocol</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">tot_len</span><span class="p">;</span>
		<span class="n">skb_set_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">VLAN_HLEN</span><span class="p">);</span>
		<span class="n">iph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rx_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ksz_hw</span><span class="o">*</span> <span class="n">hw</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">union</span> <span class="n">desc_stat</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">packet_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_dma_buf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_status</span><span class="p">;</span>

	<span class="cm">/* Received length includes 4-byte CRC. */</span>
	<span class="n">packet_len</span> <span class="o">=</span> <span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">frame_len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">dma_buf</span> <span class="o">=</span> <span class="n">DMA_BUFFER</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span>
		<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">packet_len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span>
		<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* skb-&gt;data != skb-&gt;head */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">packet_len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Align socket buffer in 4-byte boundary for better</span>
<span class="cm">		 * performance.</span>
<span class="cm">		 */</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">packet_len</span><span class="p">),</span>
			<span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">packet_len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DMA_RX_CSUM_UDP</span> <span class="o">|</span> <span class="n">DMA_RX_CSUM_TCP</span><span class="p">))</span>
		<span class="n">csum_verified</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Update receive statistics. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">packet_len</span><span class="p">;</span>

	<span class="cm">/* Notify upper layer for received packet. */</span>
	<span class="n">rx_status</span> <span class="o">=</span> <span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_rcv_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">desc_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">received</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get next descriptor which is not hardware owned. */</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
		<span class="n">status</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">hw_owned</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Status valid only when last descriptor bit is set. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">last_desc</span> <span class="o">&amp;&amp;</span> <span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">first_desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_proc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">release_packet</span><span class="p">;</span>
			<span class="n">received</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">release_packet:</span>
		<span class="n">release_desc</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">next</span><span class="o">++</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">&amp;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">received</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">port_rcv_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">desc_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">received</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get next descriptor which is not hardware owned. */</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
		<span class="n">status</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">hw_owned</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Get received port number. */</span>
			<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">HW_TO_DEV_PORT</span><span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">src_port</span><span class="p">);</span>

			<span class="n">dev</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">pdev</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">release_packet</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Status valid only when last descriptor bit is set. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">last_desc</span> <span class="o">&amp;&amp;</span> <span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">first_desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_proc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">release_packet</span><span class="p">;</span>
			<span class="n">received</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">release_packet:</span>
		<span class="n">release_desc</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">next</span><span class="o">++</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">&amp;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">received</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_rcv_special</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">desc_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">received</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get next descriptor which is not hardware owned. */</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
		<span class="n">status</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">phw</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">hw_owned</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Get received port number. */</span>
			<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">HW_TO_DEV_PORT</span><span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">src_port</span><span class="p">);</span>

			<span class="n">dev</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">pdev</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">release_packet</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Status valid only when last descriptor bit is set. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">last_desc</span> <span class="o">&amp;&amp;</span> <span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">first_desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Receive without error.  With receive errors</span>
<span class="cm">			 * disabled, packets with receive errors will be</span>
<span class="cm">			 * dropped, so no need to check the error bit.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">error</span> <span class="o">||</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;</span>
					<span class="n">KS_DESC_RX_ERROR_COND</span><span class="p">)</span> <span class="o">==</span>
					<span class="n">KS_DESC_RX_ERROR_TOO_LONG</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rx_proc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">release_packet</span><span class="p">;</span>
				<span class="n">received</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

				<span class="cm">/* Update receive error statistics. */</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">counter</span><span class="p">[</span><span class="n">OID_COUNTER_RCV_ERROR</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

<span class="nl">release_packet:</span>
		<span class="n">release_desc</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">next</span><span class="o">++</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">&amp;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">received</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rx_proc_task</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">dev_rcv</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">)))</span> <span class="p">{</span>

		<span class="cm">/* In case receive process is suspended because of overrun. */</span>
		<span class="n">hw_resume_rx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* tasklets are interruptible. */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hwlock</span><span class="p">);</span>
		<span class="n">hw_turn_on_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_INT_RX_MASK</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hwlock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw_ack_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_INT_RX</span><span class="p">);</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">rx_tasklet</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tx_proc_task</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">hw_ack_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_INT_TX_MASK</span><span class="p">);</span>

	<span class="n">tx_done</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">);</span>

	<span class="cm">/* tasklets are interruptible. */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hwlock</span><span class="p">);</span>
	<span class="n">hw_turn_on_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_INT_TX</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hwlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">handle_rx_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Receive just has been stopped. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_stop</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KS884X_INT_RX_STOPPED</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_stop</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">&amp;</span> <span class="n">DMA_RX_ENABLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hw_start_rx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KS884X_INT_RX_STOPPED</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Receive just has been started. */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_stop</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_intr - interrupt handling</span>
<span class="cm"> * @irq:	Interrupt number.</span>
<span class="cm"> * @dev_id:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by upper network layer to signal interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * Return IRQ_HANDLED if interrupt is handled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">netdev_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uint</span> <span class="n">int_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">hw_read_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">int_enable</span><span class="p">);</span>

	<span class="cm">/* Not our interrupt! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">int_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">hw_ack_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">int_enable</span><span class="p">);</span>
		<span class="n">int_enable</span> <span class="o">&amp;=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">int_enable</span> <span class="o">&amp;</span> <span class="n">KS884X_INT_TX_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hw_dis_intr_bit</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_INT_TX_MASK</span><span class="p">);</span>
			<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">tx_tasklet</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">int_enable</span> <span class="o">&amp;</span> <span class="n">KS884X_INT_RX</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hw_dis_intr_bit</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS884X_INT_RX</span><span class="p">);</span>
			<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">rx_tasklet</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">int_enable</span> <span class="o">&amp;</span> <span class="n">KS884X_INT_RX_OVERRUN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">hw_resume_rx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">int_enable</span> <span class="o">&amp;</span> <span class="n">KS884X_INT_PHY</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">LINK_INT_WORKING</span><span class="p">;</span>
			<span class="n">port_get_link_speed</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">int_enable</span> <span class="o">&amp;</span> <span class="n">KS884X_INT_RX_STOPPED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">handle_rx_stop</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">int_enable</span> <span class="o">&amp;</span> <span class="n">KS884X_INT_TX_STOPPED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>

			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">intr_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KS884X_INT_TX_STOPPED</span><span class="p">;</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tx stopped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_TX_CTRL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">DMA_TX_ENABLE</span><span class="p">))</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tx disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">hw_ena_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Linux network device functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_jiffies</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">hw_dis_intr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">netdev_intr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bridge_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">member</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_switch</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">;</span>

	<span class="cm">/* No ports in forwarding state. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">member</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port_set_stp_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">,</span> <span class="n">STP_STATE_SIMPLE</span><span class="p">);</span>
		<span class="n">sw_block_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">STP_STATE_FORWARDING</span> <span class="o">==</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">port_cfg</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">stp_state</span><span class="p">)</span>
			<span class="n">member</span> <span class="o">=</span> <span class="n">HOST_MASK</span> <span class="o">|</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">member</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">member</span> <span class="o">=</span> <span class="n">HOST_MASK</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">port</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">member</span> <span class="o">!=</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">port_cfg</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">member</span><span class="p">)</span>
			<span class="n">sw_cfg_port_base_vlan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">member</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_close - close network device</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function process the close operation of network device.  This is caused</span>
<span class="cm"> * by the user command &quot;ifconfig ethX down.&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code indicating failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pi</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ksz_stop_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">monitor_timer_info</span><span class="p">);</span>

	<span class="cm">/* Need to shut the port manually in multiple device interfaces mode. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port_set_stp_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">,</span> <span class="n">STP_STATE_DISABLED</span><span class="p">);</span>

		<span class="cm">/* Port is closed.  Need to change bridge setting. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">STP_SUPPORT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pi</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">member</span> <span class="o">&amp;</span> <span class="n">pi</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">member</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">pi</span><span class="p">;</span>
				<span class="n">bridge_change</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hw_del_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_enable</span><span class="p">)</span>
		<span class="n">port_set_power_saving</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">multicast</span><span class="p">)</span>
		<span class="o">--</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">promiscuous</span><span class="p">)</span>
		<span class="o">--</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">promiscuous</span><span class="p">;</span>

	<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">opened</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ksz_stop_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">mib_timer_info</span><span class="p">);</span>
		<span class="n">flush_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">mib_read</span><span class="p">);</span>

		<span class="n">hw_dis_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">hw_disable</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">hw_clr_multicast</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Delay for receive task to stop scheduling itself. */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">2000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>

		<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">rx_tasklet</span><span class="p">);</span>
		<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">tx_tasklet</span><span class="p">);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">transmit_cleanup</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">hw_reset_pkts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">);</span>
		<span class="n">hw_reset_pkts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">);</span>

		<span class="cm">/* Clean out static MAC table when the switch is shutdown. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">STP_SUPPORT</span><span class="p">)</span>
			<span class="n">sw_clr_sta_mac_table</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_cfg_huge_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_2_OFFSET</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">RX_HUGE_FRAME</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="n">SWITCH_HUGE_PACKET</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SWITCH_HUGE_PACKET</span><span class="p">;</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS8842_SWITCH_CTRL_2_OFFSET</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">RX_HUGE_FRAME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">|=</span> <span class="n">DMA_RX_ERROR</span><span class="p">;</span>
		<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">dev_rcv</span> <span class="o">=</span> <span class="n">dev_rcv_special</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_RX_ERROR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">dev_rcv</span> <span class="o">=</span> <span class="n">port_rcv_packets</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">dev_rcv</span> <span class="o">=</span> <span class="n">dev_rcv_packets</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepare_hardware</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Remember the network device that requests interrupts. */</span>
	<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev_intr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">tasklet_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">rx_tasklet</span><span class="p">);</span>
	<span class="n">tasklet_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">tx_tasklet</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">promiscuous</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_list_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hw_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">hw_set_desc_base</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">ring_phys</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">ring_phys</span><span class="p">);</span>
	<span class="n">hw_set_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">hw_cfg_huge_frame</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">,</span> <span class="n">hw</span><span class="p">);</span>
	<span class="n">ksz_init_rx_buffers</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_media_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">media_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">media_state</span> <span class="o">==</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">media_state</span><span class="p">)</span>
		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netif_info</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;link %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">media_state</span> <span class="o">==</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">media_state</span> <span class="o">?</span> <span class="s">&quot;on&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_open - open network device</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function process the open operation of network device.  This is caused</span>
<span class="cm"> * by the user command &quot;ifconfig ethX up.&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code indicating failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">multicast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">promiscuous</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Reset device statistics. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device_stats</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="n">OID_COUNTER_LAST</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">prepare_hardware</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next_jiffies</span> <span class="o">&lt;</span> <span class="n">jiffies</span><span class="p">)</span>
				<span class="n">next_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">next_jiffies</span> <span class="o">+=</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">time</span> <span class="o">=</span> <span class="n">next_jiffies</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">media_disconnected</span><span class="p">;</span>
			<span class="n">port_init_cnt</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">HOST_PORT</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">media_connected</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">hw_add_wol_bcast</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">hw_cfg_wol_pme</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">hw_clr_wol_pme_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">port_set_power_saving</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">port_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Initialize to invalid value so that link detection</span>
<span class="cm">		 * is done.</span>
<span class="cm">		 */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">partner</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">media_disconnected</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Need to open the port in multiple device interfaces mode. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port_set_stp_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">,</span> <span class="n">STP_STATE_SIMPLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">hw_add_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">port_get_link_speed</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">force_link</span><span class="p">)</span>
		<span class="n">port_force_link_speed</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">port_set_link_speed</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hw_setup_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">hw_enable</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">hw_ena_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span><span class="p">)</span>
			<span class="n">ksz_start_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">mib_timer_info</span><span class="p">,</span>
				<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">mib_timer_info</span><span class="p">.</span><span class="n">period</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">opened</span><span class="o">++</span><span class="p">;</span>

	<span class="n">ksz_start_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">monitor_timer_info</span><span class="p">,</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">monitor_timer_info</span><span class="p">.</span><span class="n">period</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">media_state</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">linked</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="n">set_media_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">media_connected</span><span class="p">);</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* RX errors = rx_errors */</span>
<span class="cm">/* RX dropped = rx_dropped */</span>
<span class="cm">/* RX overruns = rx_fifo_errors */</span>
<span class="cm">/* RX frame = rx_crc_errors + rx_frame_errors + rx_length_errors */</span>
<span class="cm">/* TX errors = tx_errors */</span>
<span class="cm">/* TX dropped = tx_dropped */</span>
<span class="cm">/* TX overruns = tx_fifo_errors */</span>
<span class="cm">/* TX carrier = tx_aborted_errors + tx_carrier_errors + tx_window_errors */</span>
<span class="cm">/* collisions = collisions */</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_query_statistics - query network device statistics</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the statistics of the network device.  The device</span>
<span class="cm"> * needs not be opened.</span>
<span class="cm"> *</span>
<span class="cm"> * Return network device statistics.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">netdev_query_statistics</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port_mib</span> <span class="o">*</span><span class="n">mib</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">OID_COUNTER_RCV_ERROR</span><span class="p">];</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">OID_COUNTER_XMIT_ERROR</span><span class="p">];</span>

	<span class="cm">/* Reset to zero to add count later. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">multicast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">multicast</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
			<span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">MIB_COUNTER_RX_MULTICAST</span><span class="p">];</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
			<span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">MIB_COUNTER_TX_TOTAL_COLLISION</span><span class="p">];</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span>
			<span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">MIB_COUNTER_RX_UNDERSIZE</span><span class="p">]</span> <span class="o">+</span>
			<span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">MIB_COUNTER_RX_FRAGMENT</span><span class="p">]</span> <span class="o">+</span>
			<span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">MIB_COUNTER_RX_OVERSIZE</span><span class="p">]</span> <span class="o">+</span>
			<span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">MIB_COUNTER_RX_JABBER</span><span class="p">]);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
			<span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">MIB_COUNTER_RX_CRC_ERR</span><span class="p">];</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span>
			<span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">MIB_COUNTER_RX_ALIGNMENT_ERR</span><span class="p">]</span> <span class="o">+</span>
			<span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">MIB_COUNTER_RX_SYMBOL_ERR</span><span class="p">]);</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
			<span class="n">mib</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">MIB_COUNTER_TX_LATE_COLLISION</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_set_mac_address - set network device MAC address</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @addr:	Buffer of MAC address.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to set the MAC address of the network device.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 to indicate success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">interrupt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">first_port</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hw_del_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_override</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">,</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">interrupt</span> <span class="o">=</span> <span class="n">hw_block_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">first_port</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hw_add_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hw_set_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">hw_restore_intr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_set_promiscuous</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">promiscuous</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">promiscuous</span> <span class="o">!=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">promiscuous</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">prev_state</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">promiscuous</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">promiscuous</span><span class="p">)</span>
			<span class="o">++</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">promiscuous</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">--</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">promiscuous</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">promiscuous</span> <span class="o">=</span> <span class="n">promiscuous</span><span class="p">;</span>

		<span class="cm">/* Turn on/off promiscuous mode. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">promiscuous</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">prev_state</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">hw_set_promiscuous</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">promiscuous</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Port is not in promiscuous mode, meaning it is released</span>
<span class="cm">		 * from the bridge.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">STP_SUPPORT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">promiscuous</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_BRIDGE_PORT</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ksz_switch</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">first_port</span><span class="p">;</span>

			<span class="n">port_set_stp_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">STP_STATE_DISABLED</span><span class="p">);</span>
			<span class="n">port</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">port</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">member</span> <span class="o">&amp;</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sw</span><span class="o">-&gt;</span><span class="n">member</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">port</span><span class="p">;</span>
				<span class="n">bridge_change</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_set_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">multicast</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">multicast</span> <span class="o">!=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">multicast</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">all_multi</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">multicast</span><span class="p">)</span>
			<span class="o">++</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">--</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">multicast</span> <span class="o">=</span> <span class="n">multicast</span><span class="p">;</span>

		<span class="cm">/* Turn on/off all multicast mode. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">all_multi</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">hw_set_multicast</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_set_rx_mode</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to set multicast addresses or put the network device</span>
<span class="cm"> * into promiscuous mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">multicast</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">);</span>

	<span class="n">dev_set_promiscuous</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">multicast</span> <span class="o">|=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_MULTICAST</span><span class="p">);</span>
	<span class="n">dev_set_multicast</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">multicast</span><span class="p">);</span>

	<span class="cm">/* Cannot use different hashes in multiple device interfaces mode. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_MULTICAST</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">netdev_mc_empty</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* List too big to support so turn on all multicast mode. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_MULTICAST_LIST</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">MAX_MULTICAST_LIST</span> <span class="o">!=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_list_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_list_size</span> <span class="o">=</span> <span class="n">MAX_MULTICAST_LIST</span><span class="p">;</span>
				<span class="o">++</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">;</span>
				<span class="n">hw_set_multicast</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">MAX_MULTICAST_LIST</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_list</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_list_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">hw_set_grp_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">MAX_MULTICAST_LIST</span> <span class="o">==</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_list_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">--</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">;</span>
			<span class="n">hw_set_multicast</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">all_multi</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">multi_list_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hw_clr_multicast</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hw_mtu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* Cannot use different MTU in multiple device interfaces mode. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">!=</span> <span class="n">new_mtu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_mtu</span> <span class="o">=</span> <span class="n">new_mtu</span> <span class="o">+</span> <span class="n">ETHERNET_HEADER_SIZE</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw_mtu</span> <span class="o">&gt;</span> <span class="n">MAX_RX_BUF_SIZE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw_mtu</span> <span class="o">&gt;</span> <span class="n">REGULAR_RX_BUF_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">RX_HUGE_FRAME</span><span class="p">;</span>
			<span class="n">hw_mtu</span> <span class="o">=</span> <span class="n">MAX_RX_BUF_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RX_HUGE_FRAME</span><span class="p">;</span>
			<span class="n">hw_mtu</span> <span class="o">=</span> <span class="n">REGULAR_RX_BUF_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hw_mtu</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw_mtu</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">hw_mtu</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_ioctl - I/O control processing</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @ifr:	Interface request structure.</span>
<span class="cm"> * @cmd:	I/O control code.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to process I/O control calls.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 to indicate success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mii_ioctl_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">ifr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">down_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">proc_sem</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>

	<span class="cm">/* assume success */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* Get address of MII PHY in use. */</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

		<span class="cm">/* Fallthrough... */</span>

	<span class="cm">/* Read MII PHY register. */</span>
	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">!=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">||</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hw_r_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">linked</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Write MII PHY register. */</span>
	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">!=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">||</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hw_w_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">linked</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span><span class="p">,</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_in</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">proc_sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * MII support</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * mdio_read - read PHY register</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @phy_id:	The PHY id.</span>
<span class="cm"> * @reg_num:	The register number.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the PHY register value.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the register value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val_out</span><span class="p">;</span>

	<span class="n">hw_r_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">linked</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">reg_num</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val_out</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val_out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mdio_write - set PHY register</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @phy_id:	The PHY id.</span>
<span class="cm"> * @reg_num:	The register number.</span>
<span class="cm"> * @val:	The register value.</span>
<span class="cm"> *</span>
<span class="cm"> * This procedure sets the PHY register value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pi</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">port_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">pi</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hw_w_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">reg_num</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ethtool support</span>
<span class="cm"> */</span>

<span class="cp">#define EEPROM_SIZE			0x40</span>

<span class="k">static</span> <span class="n">u16</span> <span class="n">eeprom_data</span><span class="p">[</span><span class="n">EEPROM_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="cp">#define ADVERTISED_ALL			\</span>
<span class="cp">	(ADVERTISED_10baseT_Half |	\</span>
<span class="cp">	ADVERTISED_10baseT_Full |	\</span>
<span class="cp">	ADVERTISED_100baseT_Half |	\</span>
<span class="cp">	ADVERTISED_100baseT_Full)</span>

<span class="cm">/* These functions use the MII functions in mii.c. */</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_settings - get network device settings</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @cmd:	Ethtool command.</span>
<span class="cm"> *</span>
<span class="cm"> * This function queries the PHY and returns its state in the ethtool command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mii_ethtool_gset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">SUPPORTED_TP</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Save advertised settings for workaround in next function. */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_set_settings - set network device settings</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @cmd:	Ethtool command.</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets the PHY according to the ethtool command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_set_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">speed</span> <span class="o">=</span> <span class="n">ethtool_cmd_speed</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ethtool utility does not change advertised setting if auto</span>
<span class="cm">	 * negotiation is not specified explicitly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">&amp;&amp;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">==</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_ALL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">10</span> <span class="o">==</span> <span class="n">speed</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;=</span>
				<span class="o">~</span><span class="p">(</span><span class="n">ADVERTISED_100baseT_Full</span> <span class="o">|</span>
				<span class="n">ADVERTISED_100baseT_Half</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">100</span> <span class="o">==</span> <span class="n">speed</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;=</span>
				<span class="o">~</span><span class="p">(</span><span class="n">ADVERTISED_10baseT_Full</span> <span class="o">|</span>
				<span class="n">ADVERTISED_10baseT_Half</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;=</span>
				<span class="o">~</span><span class="p">(</span><span class="n">ADVERTISED_100baseT_Full</span> <span class="o">|</span>
				<span class="n">ADVERTISED_10baseT_Full</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;=</span>
				<span class="o">~</span><span class="p">(</span><span class="n">ADVERTISED_100baseT_Half</span> <span class="o">|</span>
				<span class="n">ADVERTISED_10baseT_Half</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISED_ALL</span><span class="p">)</span> <span class="o">==</span>
			<span class="n">ADVERTISED_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">force_link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">!=</span> <span class="n">speed</span><span class="p">)</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">autoneg</span><span class="p">)</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">force_link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">force_link</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mii_ethtool_sset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_nway_reset - restart auto-negotiation</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function restarts the PHY for auto-negotiation.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_nway_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mii_nway_restart</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_link - get network device link status</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function gets the link status from the PHY.</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if PHY is linked and false otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">netdev_get_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">mii_link_ok</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_drvinfo - get network driver information</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @info:	Ethtool driver info data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This procedure returns the driver information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_regs_len - get length of register dump</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the length of the register dump.</span>
<span class="cm"> *</span>
<span class="cm"> * Return length of the register dump.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hw_regs</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span> <span class="n">hw_regs_range</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">KS_DMA_TX_CTRL</span><span class="p">,</span>	<span class="n">KS884X_INTERRUPTS_STATUS</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">KS_ADD_ADDR_0_LO</span><span class="p">,</span>	<span class="n">KS_ADD_ADDR_F_HI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">KS884X_ADDR_0_OFFSET</span><span class="p">,</span>	<span class="n">KS8841_WOL_FRAME_BYTE2_OFFSET</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">KS884X_SIDER_P</span><span class="p">,</span>	<span class="n">KS8842_SGCR7_P</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">KS8842_MACAR1_P</span><span class="p">,</span>	<span class="n">KS8842_TOSR8_P</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">KS884X_P1MBCR_P</span><span class="p">,</span>	<span class="n">KS8842_P3ERCR_P</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_get_regs_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_regs</span> <span class="o">*</span><span class="n">range</span> <span class="o">=</span> <span class="n">hw_regs_range</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">regs_len</span> <span class="o">=</span> <span class="mh">0x10</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">range</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">regs_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_regs - get register dump</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @regs:	Ethtool registers data structure.</span>
<span class="cm"> * @ptr:	Buffer to store the register values.</span>
<span class="cm"> *</span>
<span class="cm"> * This procedure dumps the register values in the provided buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_regs</span> <span class="o">*</span><span class="n">range</span> <span class="o">=</span> <span class="n">hw_regs_range</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mh">0x40</span><span class="p">;</span> <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="n">buf</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">len</span> <span class="o">=</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span> <span class="n">len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">buf</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">range</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define WOL_SUPPORT			\</span>
<span class="cp">	(WAKE_PHY | WAKE_MAGIC |	\</span>
<span class="cp">	WAKE_UCAST | WAKE_MCAST |	\</span>
<span class="cp">	WAKE_BCAST | WAKE_ARP)</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_wol - get Wake-on-LAN support</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @wol:	Ethtool Wake-on-LAN data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This procedure returns Wake-on-LAN support.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_get_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">wol</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">=</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_support</span><span class="p">;</span>
	<span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">=</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_enable</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">sopass</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">sopass</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_set_wol - set Wake-on-LAN support</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @wol:	Ethtool Wake-on-LAN data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets Wake-on-LAN support.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_set_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="cm">/* Need to find a way to retrieve the device IP address. */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">net_addr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">168</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_support</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_enable</span> <span class="o">=</span> <span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span><span class="p">;</span>

	<span class="cm">/* Link wakeup cannot really be disabled. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span><span class="p">)</span>
		<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_enable</span> <span class="o">|=</span> <span class="n">WAKE_PHY</span><span class="p">;</span>
	<span class="n">hw_enable_wol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_enable</span><span class="p">,</span> <span class="n">net_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_msglevel - get debug message level</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns current debug message level.</span>
<span class="cm"> *</span>
<span class="cm"> * Return current debug message flags.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">netdev_get_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_set_msglevel - set debug message level</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @value:	Debug message flags.</span>
<span class="cm"> *</span>
<span class="cm"> * This procedure sets debug message level.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_set_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_eeprom_len - get EEPROM length</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the length of the EEPROM.</span>
<span class="cm"> *</span>
<span class="cm"> * Return length of the EEPROM.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_get_eeprom_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">EEPROM_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_eeprom - get EEPROM data</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @eeprom:	Ethtool EEPROM data structure.</span>
<span class="cm"> * @data:	Buffer to store the EEPROM data.</span>
<span class="cm"> *</span>
<span class="cm"> * This function dumps the EEPROM data in the provided buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code.</span>
<span class="cm"> */</span>
<span class="cp">#define EEPROM_MAGIC			0x10A18842</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_get_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_eeprom</span> <span class="o">*</span><span class="n">eeprom</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">eeprom_byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">eeprom_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">eeprom_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eeprom_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">EEPROM_MAGIC</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_byte</span><span class="p">[</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">],</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_set_eeprom - write EEPROM data</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @eeprom:	Ethtool EEPROM data structure.</span>
<span class="cm"> * @data:	Data buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function modifies the EEPROM data one byte at a time.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_set_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_eeprom</span> <span class="o">*</span><span class="n">eeprom</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_word</span><span class="p">[</span><span class="n">EEPROM_SIZE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">eeprom_byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">eeprom_word</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">EEPROM_MAGIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">eeprom_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eeprom_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">eeprom_word</span><span class="p">,</span> <span class="n">eeprom_data</span><span class="p">,</span> <span class="n">EEPROM_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eeprom_byte</span><span class="p">[</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EEPROM_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eeprom_word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">eeprom_data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">eeprom_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eeprom_word</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">eeprom_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">eeprom_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_pauseparam - get flow control parameters</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @pause:	Ethtool PAUSE settings data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This procedure returns the PAUSE control flow settings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_get_pauseparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_pauseparam</span> <span class="o">*</span><span class="n">pause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">pause</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">overrides</span> <span class="o">&amp;</span> <span class="n">PAUSE_FLOW_CTRL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pause</span><span class="o">-&gt;</span><span class="n">rx_pause</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">&amp;</span> <span class="n">DMA_RX_FLOW_ENABLE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pause</span><span class="o">-&gt;</span><span class="n">tx_pause</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_cfg</span> <span class="o">&amp;</span> <span class="n">DMA_TX_FLOW_ENABLE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pause</span><span class="o">-&gt;</span><span class="n">rx_pause</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">sw_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_1_OFFSET</span><span class="p">,</span>
				<span class="n">SWITCH_RX_FLOW_CTRL</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pause</span><span class="o">-&gt;</span><span class="n">tx_pause</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">sw_chk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_1_OFFSET</span><span class="p">,</span>
				<span class="n">SWITCH_TX_FLOW_CTRL</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_set_pauseparam - set flow control parameters</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @pause:	Ethtool PAUSE settings data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets the PAUSE control flow settings.</span>
<span class="cm"> * Not implemented yet.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_set_pauseparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_pauseparam</span> <span class="o">*</span><span class="n">pause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pause</span><span class="o">-&gt;</span><span class="n">autoneg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pause</span><span class="o">-&gt;</span><span class="n">rx_pause</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pause</span><span class="o">-&gt;</span><span class="n">tx_pause</span><span class="p">)</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">flow_ctrl</span> <span class="o">=</span> <span class="n">PHY_NO_FLOW_CTRL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">flow_ctrl</span> <span class="o">=</span> <span class="n">PHY_FLOW_CTRL</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">overrides</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAUSE_FLOW_CTRL</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">force_link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sw_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_1_OFFSET</span><span class="p">,</span>
				<span class="n">SWITCH_RX_FLOW_CTRL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">sw_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_1_OFFSET</span><span class="p">,</span>
				<span class="n">SWITCH_TX_FLOW_CTRL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">port_set_link_speed</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">overrides</span> <span class="o">|=</span> <span class="n">PAUSE_FLOW_CTRL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sw_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_1_OFFSET</span><span class="p">,</span>
				<span class="n">SWITCH_RX_FLOW_CTRL</span><span class="p">,</span> <span class="n">pause</span><span class="o">-&gt;</span><span class="n">rx_pause</span><span class="p">);</span>
			<span class="n">sw_cfg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">KS8842_SWITCH_CTRL_1_OFFSET</span><span class="p">,</span>
				<span class="n">SWITCH_TX_FLOW_CTRL</span><span class="p">,</span> <span class="n">pause</span><span class="o">-&gt;</span><span class="n">tx_pause</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">set_flow_ctrl</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">pause</span><span class="o">-&gt;</span><span class="n">rx_pause</span><span class="p">,</span> <span class="n">pause</span><span class="o">-&gt;</span><span class="n">tx_pause</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_ringparam - get tx/rx ring parameters</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @pause:	Ethtool RING settings data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This procedure returns the TX/RX ring settings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_get_ringparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_ringparam</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">tx_max_pending</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">tx_pending</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_desc_info</span><span class="p">.</span><span class="n">alloc</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_max_pending</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_pending</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_desc_info</span><span class="p">.</span><span class="n">alloc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define STATS_LEN			(TOTAL_PORT_COUNTER_NUM)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">string</span><span class="p">[</span><span class="n">ETH_GSTRING_LEN</span><span class="p">];</span>
<span class="p">}</span> <span class="n">ethtool_stats_keys</span><span class="p">[</span><span class="n">STATS_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;rx_lo_priority_octets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_hi_priority_octets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_undersize_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_fragments&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_oversize_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_jabbers&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_symbol_errors&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_crc_errors&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_align_errors&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_mac_ctrl_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_pause_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_bcast_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_mcast_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_ucast_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_64_or_less_octet_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_65_to_127_octet_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_128_to_255_octet_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_256_to_511_octet_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_512_to_1023_octet_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rx_1024_to_1522_octet_packets&quot;</span> <span class="p">},</span>

	<span class="p">{</span> <span class="s">&quot;tx_lo_priority_octets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_hi_priority_octets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_late_collisions&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_pause_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_bcast_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_mcast_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_ucast_packets&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_deferred&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_total_collisions&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_excessive_collisions&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_single_collisions&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_mult_collisions&quot;</span> <span class="p">},</span>

	<span class="p">{</span> <span class="s">&quot;rx_discards&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tx_discards&quot;</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_strings - get statistics identity strings</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @stringset:	String set identifier.</span>
<span class="cm"> * @buf:	Buffer to store the strings.</span>
<span class="cm"> *</span>
<span class="cm"> * This procedure returns the strings used to identify the statistics.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_get_strings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">stringset</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ETH_SS_STATS</span> <span class="o">==</span> <span class="n">stringset</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ethtool_stats_keys</span><span class="p">,</span>
			<span class="n">ETH_GSTRING_LEN</span> <span class="o">*</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_sset_count - get statistics size</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @sset:	The statistics set number.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the size of the statistics to be reported.</span>
<span class="cm"> *</span>
<span class="cm"> * Return size of the statistics to be reported.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_get_sset_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sset</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETH_SS_STATS</span>:
		<span class="k">return</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_cnt</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_get_ethtool_stats - get network device statistics</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @stats:	Ethtool statistics data structure.</span>
<span class="cm"> * @data:	Buffer to store the statistics.</span>
<span class="cm"> *</span>
<span class="cm"> * This procedure returns the statistics.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_get_ethtool_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_stats</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">n_stats</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">counter</span><span class="p">[</span><span class="n">TOTAL_PORT_COUNTER_NUM</span><span class="p">];</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">media_connected</span> <span class="o">==</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">read</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* Remember first port that requests read. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">)</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">mib_read</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">counter</span><span class="p">,</span>
			<span class="mi">2</span> <span class="o">==</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">read</span><span class="p">,</span>
			<span class="n">HZ</span> <span class="o">*</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span> <span class="o">-</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span>
					<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">counter</span><span class="p">,</span>
					<span class="mi">2</span> <span class="o">==</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">read</span><span class="p">,</span>
					<span class="n">HZ</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">cnt_ptr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span>
					<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">counter</span><span class="p">,</span>
					<span class="mi">2</span> <span class="o">==</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">read</span><span class="p">,</span>
					<span class="n">HZ</span> <span class="o">*</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="n">get_mib_counters</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_cnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">n_stats</span><span class="p">)</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">n_stats</span><span class="p">;</span>
	<span class="n">n_stats</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">data</span><span class="o">++</span> <span class="o">=</span> <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_set_features - set receive checksum support</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> * @features:	New device features (offloads).</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets receive checksum support setting.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_set_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* see note in hw_setup() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">|=</span> <span class="n">DMA_RX_CSUM_TCP</span> <span class="o">|</span> <span class="n">DMA_RX_CSUM_IP</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DMA_RX_CSUM_TCP</span> <span class="o">|</span> <span class="n">DMA_RX_CSUM_IP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_cfg</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">+</span> <span class="n">KS_DMA_RX_CTRL</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">netdev_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_settings</span>		<span class="o">=</span> <span class="n">netdev_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span>		<span class="o">=</span> <span class="n">netdev_set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nway_reset</span>		<span class="o">=</span> <span class="n">netdev_nway_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span>		<span class="o">=</span> <span class="n">netdev_get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_drvinfo</span>		<span class="o">=</span> <span class="n">netdev_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs_len</span>		<span class="o">=</span> <span class="n">netdev_get_regs_len</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs</span>		<span class="o">=</span> <span class="n">netdev_get_regs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_wol</span>		<span class="o">=</span> <span class="n">netdev_get_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_wol</span>		<span class="o">=</span> <span class="n">netdev_set_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span>		<span class="o">=</span> <span class="n">netdev_get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span>		<span class="o">=</span> <span class="n">netdev_set_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_eeprom_len</span>		<span class="o">=</span> <span class="n">netdev_get_eeprom_len</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_eeprom</span>		<span class="o">=</span> <span class="n">netdev_get_eeprom</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_eeprom</span>		<span class="o">=</span> <span class="n">netdev_set_eeprom</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_pauseparam</span>		<span class="o">=</span> <span class="n">netdev_get_pauseparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_pauseparam</span>		<span class="o">=</span> <span class="n">netdev_set_pauseparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ringparam</span>		<span class="o">=</span> <span class="n">netdev_get_ringparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_strings</span>		<span class="o">=</span> <span class="n">netdev_get_strings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_sset_count</span>		<span class="o">=</span> <span class="n">netdev_get_sset_count</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ethtool_stats</span>	<span class="o">=</span> <span class="n">netdev_get_ethtool_stats</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Hardware monitoring</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">media_state</span> <span class="o">!=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">linked</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">media_state</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">linked</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">set_media_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">media_connected</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mib_read_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dev_info</span><span class="p">,</span> <span class="n">mib_read</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port_mib</span> <span class="o">*</span><span class="n">mib</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">next_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* Reading MIB counters or requested to read. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span> <span class="o">||</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Need to process receive interrupt. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">port_r_cnt</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Finish reading counters. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">mib</span><span class="o">-&gt;</span><span class="n">cnt_ptr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">read</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">wake_up_interruptible</span><span class="p">(</span>
					<span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">counter</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">&gt;=</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">time</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Only read MIB counters when the port is connected. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">media_connected</span> <span class="o">==</span> <span class="n">mib</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span>
				<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">read</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">next_jiffies</span> <span class="o">+=</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span><span class="p">;</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">time</span> <span class="o">=</span> <span class="n">next_jiffies</span><span class="p">;</span>

		<span class="cm">/* Port is just disconnected. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mib</span><span class="o">-&gt;</span><span class="n">link_down</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mib</span><span class="o">-&gt;</span><span class="n">link_down</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Read counters one last time after link is lost. */</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">read</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mib_monitor</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">mib_read_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">mib_read</span><span class="p">);</span>

	<span class="cm">/* This is used to verify Wake-on-LAN is working. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pme_wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pme_wait</span> <span class="o">&lt;=</span> <span class="n">jiffies</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw_clr_wol_pme_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pme_wait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw_chk_wol_pme_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* PME is asserted.  Wait 2 seconds to clear it. */</span>
		<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pme_wait</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ksz_update_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">mib_timer_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dev_monitor - periodic monitoring</span>
<span class="cm"> * @ptr:	Network device pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is run in a kernel timer to monitor the network device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_monitor</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">LINK_INT_WORKING</span><span class="p">))</span>
		<span class="n">port_get_link_speed</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="n">update_link</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">ksz_update_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">monitor_timer_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Linux network device interface functions</span>
<span class="cm"> */</span>

<span class="cm">/* Driver exported variables */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">msg_enable</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">macaddr</span> <span class="o">=</span> <span class="s">&quot;:&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mac1addr</span> <span class="o">=</span> <span class="s">&quot;:&quot;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This enables multiple network device mode for KSZ8842, which contains a</span>
<span class="cm"> * switch with two physical ports.  Some users like to take control of the</span>
<span class="cm"> * ports for running Spanning Tree Protocol.  The driver will create an</span>
<span class="cm"> * additional eth? device for the other port.</span>
<span class="cm"> *</span>
<span class="cm"> * Some limitations are the network devices cannot have different MTU and</span>
<span class="cm"> * multicast hash tables.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">multi_dev</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * As most users select multiple network device mode to use Spanning Tree</span>
<span class="cm"> * Protocol, this enables a feature in which most unicast and multicast packets</span>
<span class="cm"> * are forwarded inside the switch and not passed to the host.  Only packets</span>
<span class="cm"> * that need the host&#39;s attention are passed to it.  This prevents the host</span>
<span class="cm"> * wasting CPU time to examine each and every incoming packets and do the</span>
<span class="cm"> * forwarding itself.</span>
<span class="cm"> *</span>
<span class="cm"> * As the hack requires the private bridge header, the driver cannot compile</span>
<span class="cm"> * with just the kernel headers.</span>
<span class="cm"> *</span>
<span class="cm"> * Enabling STP support also turns on multiple network device mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">stp</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This enables fast aging in the KSZ8842 switch.  Not sure what situation</span>
<span class="cm"> * needs that.  However, fast aging is used to flush the dynamic MAC table when</span>
<span class="cm"> * STP suport is enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fast_aging</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_init - initialize network device.</span>
<span class="cm"> * @dev:	Network device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function initializes the network device.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if successful; otherwise an error code indicating failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">netdev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* 500 ms timeout */</span>
	<span class="n">ksz_init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">monitor_timer_info</span><span class="p">,</span> <span class="mi">500</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span>
		<span class="n">dev_monitor</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* 500 ms timeout */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">=</span> <span class="n">NETIF_F_IP_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hardware does not really support IPv6 checksum generation, but</span>
<span class="cm">	 * driver actually runs faster with this on.</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_IPV6_CSUM</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_features</span><span class="p">;</span>

	<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">proc_sem</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id_mask</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">reg_num_mask</span> <span class="o">=</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">mdio_read</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">mdio_write</span> <span class="o">=</span> <span class="n">mdio_write</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">first_port</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">netif_msg_init</span><span class="p">(</span><span class="n">msg_enable</span><span class="p">,</span>
		<span class="p">(</span><span class="n">NETIF_MSG_DRV</span> <span class="o">|</span> <span class="n">NETIF_MSG_PROBE</span> <span class="o">|</span> <span class="n">NETIF_MSG_LINK</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_init</span>		<span class="o">=</span> <span class="n">netdev_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">netdev_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">netdev_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">netdev_query_statistics</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">netdev_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">netdev_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">netdev_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_features</span>	<span class="o">=</span> <span class="n">netdev_set_features</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">netdev_set_mac_address</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">netdev_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">netdev_set_rx_mode</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">netdev_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span><span class="p">)</span>
		<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">platform_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="n">dev_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">[</span><span class="n">SWITCH_PORT_NUM</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">net_device_present</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">macaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">got_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="n">num</span> <span class="o">=</span> <span class="n">got_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">ETH_ALEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">macaddr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">digit</span><span class="p">;</span>

			<span class="n">got_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">digit</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="n">macaddr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">digit</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">digit</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="sc">&#39;:&#39;</span> <span class="o">==</span> <span class="n">macaddr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">got_num</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">got_num</span><span class="p">)</span>
			<span class="n">got_num</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">==</span> <span class="n">got_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">MAIN_PORT</span> <span class="o">==</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">override_addr</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">num</span><span class="p">;</span>
				<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">override_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span>
					<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">other_addr</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
					<span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">num</span><span class="p">;</span>
				<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">ksz_switch</span><span class="o">-&gt;</span><span class="n">other_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span>
					<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">num</span> <span class="o">=</span> <span class="n">got_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ETH_ALEN</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">MAIN_PORT</span> <span class="o">==</span> <span class="n">port</span><span class="p">)</span>
			<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac_override</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define KS884X_DMA_MASK			(~0x0UL)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_other_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ksz_switch</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eeprom_read</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">EEPROM_DATA_OTHER_MAC_ADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sw</span><span class="o">-&gt;</span><span class="n">other_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">sw</span><span class="o">-&gt;</span><span class="n">other_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">sw</span><span class="o">-&gt;</span><span class="n">other_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">sw</span><span class="o">-&gt;</span><span class="n">other_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">sw</span><span class="o">-&gt;</span><span class="n">other_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">sw</span><span class="o">-&gt;</span><span class="n">other_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifndef PCI_VENDOR_ID_MICREL_KS</span>
<span class="cp">#define PCI_VENDOR_ID_MICREL_KS		0x16c6</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pcidev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mib_port_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">banner</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">version</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">ksz_switch</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">||</span>
			<span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">reg_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">reg_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_IO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">reg_base</span><span class="p">,</span> <span class="n">reg_len</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">pcidev_init_dev_err</span><span class="p">;</span>

	<span class="n">hw_priv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev_info</span><span class="p">;</span>
	<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">reg_base</span><span class="p">,</span> <span class="n">reg_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">pcidev_init_io_err</span><span class="p">;</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="n">hw_init</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_enable</span> <span class="o">&amp;</span> <span class="n">NETIF_MSG_PROBE</span><span class="p">)</span>
			<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;chip not detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">pcidev_init_alloc_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">banner</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">banner</span><span class="p">),</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
	<span class="n">banner</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>		<span class="cm">/* Replace x in &quot;Micrel KSZ884x&quot; */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">banner</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Mem = %p; IRQ = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="cm">/* Assume device is KSZ8841. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">port_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mib_port_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_list_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_cnt</span> <span class="o">=</span> <span class="n">PORT_COUNTER_NUM</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* KSZ8842 has a switch with multiple ports. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">==</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fast_aging</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">overrides</span> <span class="o">|=</span> <span class="n">FAST_AGING</span><span class="p">;</span>

		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_cnt</span> <span class="o">=</span> <span class="n">TOTAL_PORT_COUNTER_NUM</span><span class="p">;</span>

		<span class="cm">/* Multiple network device interfaces are required. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">multi_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">=</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">addr_list_size</span> <span class="o">=</span> <span class="n">SWITCH_PORT_NUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Single network device has multiple ports. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">port_count</span> <span class="o">=</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">;</span>
			<span class="n">mib_port_count</span> <span class="o">=</span> <span class="n">SWITCH_PORT_NUM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span> <span class="o">=</span> <span class="n">TOTAL_PORT_NUM</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ksz_switch</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">pcidev_init_alloc_err</span><span class="p">;</span>

		<span class="n">sw</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_mib</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mib_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">hw_priv</span><span class="p">;</span>

	<span class="cm">/* Default MTU is 1500. */</span>
	<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="p">(</span><span class="n">REGULAR_RX_BUF_SIZE</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ksz_alloc_mem</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">pcidev_init_mem_err</span><span class="p">;</span>

	<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">net_device_present</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hwlock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* tasklet is enabled. */</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">rx_tasklet</span><span class="p">,</span> <span class="n">rx_proc_task</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">hw_priv</span><span class="p">);</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">tx_tasklet</span><span class="p">,</span> <span class="n">tx_proc_task</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">hw_priv</span><span class="p">);</span>

	<span class="cm">/* tasklet_enable will decrement the atomic counter. */</span>
	<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">rx_tasklet</span><span class="p">);</span>
	<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">tx_tasklet</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TOTAL_PORT_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">counter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">macaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span>
		<span class="n">get_mac_addr</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">,</span> <span class="n">macaddr</span><span class="p">,</span> <span class="n">MAIN_PORT</span><span class="p">);</span>

	<span class="cm">/* Read MAC address and initialize override address if not overrided. */</span>
	<span class="n">hw_read_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Multiple device interfaces mode requires a second MAC address. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">other_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">read_other_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mac1addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span>
			<span class="n">get_mac_addr</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">,</span> <span class="n">mac1addr</span><span class="p">,</span> <span class="n">OTHER_PORT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hw_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">)</span>
		<span class="n">sw_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_support</span> <span class="o">=</span> <span class="n">WOL_SUPPORT</span><span class="p">;</span>
		<span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">mib_read</span><span class="p">,</span> <span class="n">mib_read_work</span><span class="p">);</span>

	<span class="cm">/* 500 ms timeout */</span>
	<span class="n">ksz_init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">mib_timer_info</span><span class="p">,</span> <span class="mi">500</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span>
		<span class="n">mib_monitor</span><span class="p">,</span> <span class="n">hw_priv</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_priv</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">pcidev_init_reg_err</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

		<span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw_priv</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">net_device_present</span><span class="o">++</span><span class="p">;</span>

		<span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">port_cnt</span> <span class="o">=</span> <span class="n">port_count</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">mib_port_cnt</span> <span class="o">=</span> <span class="n">mib_port_count</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">flow_ctrl</span> <span class="o">=</span> <span class="n">PHY_FLOW_CTRL</span><span class="p">;</span>

		<span class="n">port</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">=</span> <span class="n">hw</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">linked</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">port_count</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">,</span> <span class="n">pi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">pi</span><span class="p">].</span><span class="n">port_id</span> <span class="o">=</span> <span class="n">pi</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">pi</span><span class="p">].</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_info</span><span class="p">[</span><span class="n">pi</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">media_disconnected</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="n">reg_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">MAIN_PORT</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">override_addr</span><span class="p">,</span>
			       <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">other_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">other_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">override_addr</span><span class="p">,</span>
				    <span class="n">ETH_ALEN</span><span class="p">))</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">first_port</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">netdev_ops</span><span class="p">;</span>
		<span class="n">SET_ETHTOOL_OPS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netdev_ethtool_ops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">pcidev_init_reg_err</span><span class="p">;</span>
		<span class="n">port_set_power_saving</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_dev_get</span><span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">pcidev_init_reg_err:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">netdev_free</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">pcidev_init_mem_err:</span>
	<span class="n">ksz_free_mem</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ksz_switch</span><span class="p">);</span>

<span class="nl">pcidev_init_alloc_err:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">);</span>

<span class="nl">pcidev_init_io_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

<span class="nl">pcidev_init_dev_err:</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">reg_base</span><span class="p">,</span> <span class="n">reg_len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcidev_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev_info</span><span class="p">;</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">dev_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">netdev_free</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">io</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">io</span><span class="p">);</span>
	<span class="n">ksz_free_mem</span><span class="p">(</span><span class="n">hw_priv</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">ksz_switch</span><span class="p">);</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcidev_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_enable</span><span class="p">)</span>
		<span class="n">hw_cfg_wol_pme</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">netdev_open</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcidev_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span> <span class="o">*</span><span class="n">hw_priv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ksz_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* Need to find a way to retrieve the device IP address. */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">net_addr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">168</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">netdev_close</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_enable_wol</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw_priv</span><span class="o">-&gt;</span><span class="n">wol_enable</span><span class="p">,</span> <span class="n">net_addr</span><span class="p">);</span>
		<span class="n">hw_cfg_wol_pme</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">pcidev_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;ksz884xp&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">pcidev_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_MICREL_KS</span><span class="p">,</span> <span class="mh">0x8841</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_MICREL_KS</span><span class="p">,</span> <span class="mh">0x8842</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pcidev_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">pci_device_driver</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">pcidev_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">pcidev_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">pcidev_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">pcidev_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">pcidev_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">pcidev_exit</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ksz884x_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_device_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ksz884x_cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_device_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">ksz884x_init_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ksz884x_cleanup_module</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;KSZ8841/2 PCI network driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Tristram Ha &lt;Tristram.Ha@micrel.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">msg_enable</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="s">&quot;Message verbosity level (0=none, 31=all)&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">macaddr</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">mac1addr</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">fast_aging</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">multi_dev</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">stp</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">macaddr</span><span class="p">,</span> <span class="s">&quot;MAC address&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">mac1addr</span><span class="p">,</span> <span class="s">&quot;Second MAC address&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">fast_aging</span><span class="p">,</span> <span class="s">&quot;Fast aging&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">multi_dev</span><span class="p">,</span> <span class="s">&quot;Multiple device interfaces&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">stp</span><span class="p">,</span> <span class="s">&quot;STP support&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
