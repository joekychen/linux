<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › cisco › enic › enic_main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>enic_main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.</span>
<span class="cm"> * Copyright 2007 Nuova Systems, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you may redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;net/ip6_checksum.h&gt;</span>

<span class="cp">#include &quot;cq_enet_desc.h&quot;</span>
<span class="cp">#include &quot;vnic_dev.h&quot;</span>
<span class="cp">#include &quot;vnic_intr.h&quot;</span>
<span class="cp">#include &quot;vnic_stats.h&quot;</span>
<span class="cp">#include &quot;vnic_vic.h&quot;</span>
<span class="cp">#include &quot;enic_res.h&quot;</span>
<span class="cp">#include &quot;enic.h&quot;</span>
<span class="cp">#include &quot;enic_dev.h&quot;</span>
<span class="cp">#include &quot;enic_pp.h&quot;</span>

<span class="cp">#define ENIC_NOTIFY_TIMER_PERIOD	(2 * HZ)</span>
<span class="cp">#define WQ_ENET_MAX_DESC_LEN		(1 &lt;&lt; WQ_ENET_LEN_BITS)</span>
<span class="cp">#define MAX_TSO				(1 &lt;&lt; 16)</span>
<span class="cp">#define ENIC_DESC_MAX_SPLITS		(MAX_TSO / WQ_ENET_MAX_DESC_LEN + 1)</span>

<span class="cp">#define PCI_DEVICE_ID_CISCO_VIC_ENET         0x0043  </span><span class="cm">/* ethernet vnic */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_CISCO_VIC_ENET_DYN     0x0044  </span><span class="cm">/* enet dynamic vnic */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_CISCO_VIC_ENET_VF      0x0071  </span><span class="cm">/* enet SRIOV VF */</span><span class="cp"></span>

<span class="cm">/* Supported devices */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">enic_id_table</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">CISCO</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_CISCO_VIC_ENET</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">CISCO</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_CISCO_VIC_ENET_DYN</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">CISCO</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_CISCO_VIC_ENET_VF</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>	<span class="cm">/* end of table */</span>
<span class="p">};</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRV_DESCRIPTION</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Scott Feldman &lt;scofeldm@cisco.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">enic_id_table</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">enic_stat</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">ETH_GSTRING_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define ENIC_TX_STAT(stat)	\</span>
<span class="cp">	{ .name = #stat, .offset = offsetof(struct vnic_tx_stats, stat) / 8 }</span>
<span class="cp">#define ENIC_RX_STAT(stat)	\</span>
<span class="cp">	{ .name = #stat, .offset = offsetof(struct vnic_rx_stats, stat) / 8 }</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">enic_stat</span> <span class="n">enic_tx_stats</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ENIC_TX_STAT</span><span class="p">(</span><span class="n">tx_frames_ok</span><span class="p">),</span>
	<span class="n">ENIC_TX_STAT</span><span class="p">(</span><span class="n">tx_unicast_frames_ok</span><span class="p">),</span>
	<span class="n">ENIC_TX_STAT</span><span class="p">(</span><span class="n">tx_multicast_frames_ok</span><span class="p">),</span>
	<span class="n">ENIC_TX_STAT</span><span class="p">(</span><span class="n">tx_broadcast_frames_ok</span><span class="p">),</span>
	<span class="n">ENIC_TX_STAT</span><span class="p">(</span><span class="n">tx_bytes_ok</span><span class="p">),</span>
	<span class="n">ENIC_TX_STAT</span><span class="p">(</span><span class="n">tx_unicast_bytes_ok</span><span class="p">),</span>
	<span class="n">ENIC_TX_STAT</span><span class="p">(</span><span class="n">tx_multicast_bytes_ok</span><span class="p">),</span>
	<span class="n">ENIC_TX_STAT</span><span class="p">(</span><span class="n">tx_broadcast_bytes_ok</span><span class="p">),</span>
	<span class="n">ENIC_TX_STAT</span><span class="p">(</span><span class="n">tx_drops</span><span class="p">),</span>
	<span class="n">ENIC_TX_STAT</span><span class="p">(</span><span class="n">tx_errors</span><span class="p">),</span>
	<span class="n">ENIC_TX_STAT</span><span class="p">(</span><span class="n">tx_tso</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">enic_stat</span> <span class="n">enic_rx_stats</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_frames_ok</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_frames_total</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_unicast_frames_ok</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_multicast_frames_ok</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_broadcast_frames_ok</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_bytes_ok</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_unicast_bytes_ok</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_multicast_bytes_ok</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_broadcast_bytes_ok</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_drop</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_no_bufs</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_errors</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_rss</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_crc_errors</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_frames_64</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_frames_127</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_frames_255</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_frames_511</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_frames_1023</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_frames_1518</span><span class="p">),</span>
	<span class="n">ENIC_RX_STAT</span><span class="p">(</span><span class="n">rx_frames_to_max</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enic_n_tx_stats</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">enic_tx_stats</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enic_n_rx_stats</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">enic_rx_stats</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">enic_is_dynamic</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_CISCO_VIC_ENET_DYN</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">enic_sriov_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">ENIC_SRIOV_ENABLED</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_is_sriov_vf</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_CISCO_VIC_ENET_VF</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">enic_is_valid_vf</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI_IOV</span>
	<span class="k">return</span> <span class="n">vf</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">vf</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">num_vfs</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">enic_cq_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">enic_cq_wq</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">+</span> <span class="n">wq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">enic_legacy_io_intr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">enic_legacy_err_intr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">enic_legacy_notify_intr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">enic_msix_rq_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq</span><span class="p">[</span><span class="n">enic_cq_rq</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">rq</span><span class="p">)].</span><span class="n">interrupt_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">enic_msix_wq_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq</span><span class="p">[</span><span class="n">enic_cq_wq</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">wq</span><span class="p">)].</span><span class="n">interrupt_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">enic_msix_err_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">+</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">enic_msix_notify_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">+</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">=</span> <span class="p">(</span><span class="n">SUPPORTED_10000baseT_Full</span> <span class="o">|</span> <span class="n">SUPPORTED_FIBRE</span><span class="p">);</span>
	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADVERTISED_10000baseT_Full</span> <span class="o">|</span> <span class="n">ADVERTISED_FIBRE</span><span class="p">);</span>
	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">PORT_FIBRE</span><span class="p">;</span>
	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">XCVR_EXTERNAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">ecmd</span><span class="p">,</span> <span class="n">vnic_dev_port_speed</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">));</span>
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">DUPLEX_FULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">ecmd</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="n">AUTONEG_DISABLE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">drvinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vnic_devcmd_fw_info</span> <span class="o">*</span><span class="n">fw_info</span><span class="p">;</span>

	<span class="n">enic_dev_fw_info</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fw_info</span><span class="p">);</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="n">fw_info</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_get_strings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">stringset</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">stringset</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETH_SS_STATS</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic_n_tx_stats</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">enic_tx_stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">ETH_GSTRING_LEN</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">+=</span> <span class="n">ETH_GSTRING_LEN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic_n_rx_stats</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">enic_rx_stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">ETH_GSTRING_LEN</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">+=</span> <span class="n">ETH_GSTRING_LEN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_get_sset_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sset</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETH_SS_STATS</span>:
		<span class="k">return</span> <span class="n">enic_n_tx_stats</span> <span class="o">+</span> <span class="n">enic_n_rx_stats</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_get_ethtool_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vnic_stats</span> <span class="o">*</span><span class="n">vstats</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">enic_dev_stats_dump</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vstats</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic_n_tx_stats</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="n">data</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vstats</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">)[</span><span class="n">enic_tx_stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic_n_rx_stats</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="n">data</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vstats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">)[</span><span class="n">enic_rx_stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">enic_get_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_set_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_get_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_coalesce</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">tx_coalesce_usecs</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">tx_coalesce_usecs</span><span class="p">;</span>
	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_set_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ethtool_coalesce</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">tx_coalesce_usecs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_coalesce_usecs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">intr</span><span class="p">;</span>

	<span class="n">tx_coalesce_usecs</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">tx_coalesce_usecs</span><span class="p">,</span>
		<span class="n">vnic_dev_get_intr_coal_timer_max</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">));</span>
	<span class="n">rx_coalesce_usecs</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span><span class="p">,</span>
		<span class="n">vnic_dev_get_intr_coal_timer_max</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">));</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vnic_dev_get_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_INTX</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_coalesce_usecs</span> <span class="o">!=</span> <span class="n">rx_coalesce_usecs</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">intr</span> <span class="o">=</span> <span class="n">enic_legacy_io_intr</span><span class="p">();</span>
		<span class="n">vnic_intr_coalescing_timer_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">intr</span><span class="p">],</span>
			<span class="n">tx_coalesce_usecs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_coalesce_usecs</span> <span class="o">!=</span> <span class="n">rx_coalesce_usecs</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">vnic_intr_coalescing_timer_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">tx_coalesce_usecs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSIX</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_wq_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">vnic_intr_coalescing_timer_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">intr</span><span class="p">],</span>
				<span class="n">tx_coalesce_usecs</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_rq_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">vnic_intr_coalescing_timer_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">intr</span><span class="p">],</span>
				<span class="n">rx_coalesce_usecs</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">tx_coalesce_usecs</span> <span class="o">=</span> <span class="n">tx_coalesce_usecs</span><span class="p">;</span>
	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span> <span class="o">=</span> <span class="n">rx_coalesce_usecs</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">enic_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_settings</span> <span class="o">=</span> <span class="n">enic_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_drvinfo</span> <span class="o">=</span> <span class="n">enic_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span> <span class="o">=</span> <span class="n">enic_get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span> <span class="o">=</span> <span class="n">enic_set_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span> <span class="o">=</span> <span class="n">ethtool_op_get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_strings</span> <span class="o">=</span> <span class="n">enic_get_strings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_sset_count</span> <span class="o">=</span> <span class="n">enic_get_sset_count</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ethtool_stats</span> <span class="o">=</span> <span class="n">enic_get_ethtool_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_coalesce</span> <span class="o">=</span> <span class="n">enic_get_coalesce</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_coalesce</span> <span class="o">=</span> <span class="n">enic_set_coalesce</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_free_wq_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vnic_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vnic_wq_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">vnic_dev_priv</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sop</span><span class="p">)</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">os_buf</span><span class="p">)</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">os_buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_wq_free_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vnic_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cq_desc</span> <span class="o">*</span><span class="n">cq_desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vnic_wq_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">enic_free_wq_buf</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_wq_service</span><span class="p">(</span><span class="k">struct</span> <span class="n">vnic_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cq_desc</span> <span class="o">*</span><span class="n">cq_desc</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">q_number</span><span class="p">,</span> <span class="n">u16</span> <span class="n">completed_index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">vnic_dev_priv</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_lock</span><span class="p">[</span><span class="n">q_number</span><span class="p">]);</span>

	<span class="n">vnic_wq_service</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">[</span><span class="n">q_number</span><span class="p">],</span> <span class="n">cq_desc</span><span class="p">,</span>
		<span class="n">completed_index</span><span class="p">,</span> <span class="n">enic_wq_free_buf</span><span class="p">,</span>
		<span class="n">opaque</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">vnic_wq_desc_avail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">[</span><span class="n">q_number</span><span class="p">])</span> <span class="o">&gt;=</span>
	    <span class="p">(</span><span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="n">ENIC_DESC_MAX_SPLITS</span><span class="p">))</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_lock</span><span class="p">[</span><span class="n">q_number</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_log_q_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">error_status</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error_status</span> <span class="o">=</span> <span class="n">vnic_wq_error_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error_status</span><span class="p">)</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;WQ[%d] error_status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">error_status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error_status</span> <span class="o">=</span> <span class="n">vnic_rq_error_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error_status</span><span class="p">)</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;RQ[%d] error_status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">error_status</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_msglvl_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">msg_enable</span> <span class="o">=</span> <span class="n">vnic_dev_msg_lvl</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg_enable</span> <span class="o">!=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;msg lvl changed from 0x%x to 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">,</span> <span class="n">msg_enable</span><span class="p">);</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">msg_enable</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_mtu_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mtu</span> <span class="o">=</span> <span class="n">vnic_dev_mtu</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mtu</span> <span class="o">&amp;&amp;</span> <span class="n">mtu</span> <span class="o">!=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">port_mtu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">port_mtu</span> <span class="o">=</span> <span class="n">mtu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enic_is_dynamic</span><span class="p">(</span><span class="n">enic</span><span class="p">)</span> <span class="o">||</span> <span class="n">enic_is_sriov_vf</span><span class="p">(</span><span class="n">enic</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mtu</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">ENIC_MIN_MTU</span><span class="p">,</span>
				<span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">ENIC_MAX_MTU</span><span class="p">,</span> <span class="n">mtu</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mtu</span> <span class="o">!=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">)</span>
				<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">change_mtu_work</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mtu</span> <span class="o">&lt;</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">)</span>
				<span class="n">netdev_warn</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span>
					<span class="s">&quot;interface MTU (%d) set higher &quot;</span>
					<span class="s">&quot;than switch port MTU (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span> <span class="n">mtu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_link_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">link_status</span> <span class="o">=</span> <span class="n">vnic_dev_link_status</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">carrier_ok</span> <span class="o">=</span> <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link_status</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">carrier_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Link UP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link_status</span> <span class="o">&amp;&amp;</span> <span class="n">carrier_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Link DOWN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_notify_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">enic_msglvl_check</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">enic_mtu_check</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">enic_link_check</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define ENIC_TEST_INTR(pba, i) (pba &amp; (1 &lt;&lt; i))</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">enic_isr_legacy</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_intr</span> <span class="o">=</span> <span class="n">enic_legacy_io_intr</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_intr</span> <span class="o">=</span> <span class="n">enic_legacy_err_intr</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">notify_intr</span> <span class="o">=</span> <span class="n">enic_legacy_notify_intr</span><span class="p">();</span>
	<span class="n">u32</span> <span class="n">pba</span><span class="p">;</span>

	<span class="n">vnic_intr_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">io_intr</span><span class="p">]);</span>

	<span class="n">pba</span> <span class="o">=</span> <span class="n">vnic_intr_legacy_pba</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">legacy_pba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pba</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vnic_intr_unmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">io_intr</span><span class="p">]);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>	<span class="cm">/* not our interrupt */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ENIC_TEST_INTR</span><span class="p">(</span><span class="n">pba</span><span class="p">,</span> <span class="n">notify_intr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vnic_intr_return_all_credits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">notify_intr</span><span class="p">]);</span>
		<span class="n">enic_notify_check</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ENIC_TEST_INTR</span><span class="p">(</span><span class="n">pba</span><span class="p">,</span> <span class="n">err_intr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vnic_intr_return_all_credits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">err_intr</span><span class="p">]);</span>
		<span class="n">enic_log_q_error</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
		<span class="cm">/* schedule recovery from WQ/RQ error */</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ENIC_TEST_INTR</span><span class="p">(</span><span class="n">pba</span><span class="p">,</span> <span class="n">io_intr</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
			<span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vnic_intr_unmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">io_intr</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">enic_isr_msi</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* With MSI, there is no sharing of interrupts, so this is</span>
<span class="cm">	 * our interrupt and there is no need to ack it.  The device</span>
<span class="cm">	 * is not providing per-vector masking, so the OS will not</span>
<span class="cm">	 * write to PCI config space to mask/unmask the interrupt.</span>
<span class="cm">	 * We&#39;re using mask_on_assertion for MSI, so the device</span>
<span class="cm">	 * automatically masks the interrupt when the interrupt is</span>
<span class="cm">	 * generated.  Later, when exiting polling, the interrupt</span>
<span class="cm">	 * will be unmasked (see enic_poll).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also, the device uses the same PCIe Traffic Class (TC)</span>
<span class="cm">	 * for Memory Write data and MSI, so there are no ordering</span>
<span class="cm">	 * issues; the MSI will always arrive at the Root Complex</span>
<span class="cm">	 * _after_ corresponding Memory Writes (i.e. descriptor</span>
<span class="cm">	 * writes).</span>
<span class="cm">	 */</span>

	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">enic_isr_msix_rq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* schedule NAPI polling for RQ cleanup */</span>
	<span class="n">napi_schedule</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">enic_isr_msix_wq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cq</span> <span class="o">=</span> <span class="n">enic_cq_wq</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_wq_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wq_work_to_do</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* no limit */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wq_work_done</span><span class="p">;</span>

	<span class="n">wq_work_done</span> <span class="o">=</span> <span class="n">vnic_cq_service</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq</span><span class="p">[</span><span class="n">cq</span><span class="p">],</span>
		<span class="n">wq_work_to_do</span><span class="p">,</span> <span class="n">enic_wq_service</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">vnic_intr_return_credits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">intr</span><span class="p">],</span>
		<span class="n">wq_work_done</span><span class="p">,</span>
		<span class="mi">1</span> <span class="cm">/* unmask intr */</span><span class="p">,</span>
		<span class="mi">1</span> <span class="cm">/* reset intr timer */</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">enic_isr_msix_err</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_err_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="n">vnic_intr_return_all_credits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">intr</span><span class="p">]);</span>

	<span class="n">enic_log_q_error</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="cm">/* schedule recovery from WQ/RQ error */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">enic_isr_msix_notify</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_notify_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="n">vnic_intr_return_all_credits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">intr</span><span class="p">]);</span>
	<span class="n">enic_notify_check</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enic_queue_wq_skb_cont</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vnic_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len_left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loopback</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>

	<span class="cm">/* Queue additional data fragments */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">frag</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">;</span> <span class="n">len_left</span><span class="p">;</span> <span class="n">frag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len_left</span> <span class="o">-=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="n">enic_queue_wq_desc_cont</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
			<span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="n">frag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">),</span>
					 <span class="n">DMA_TO_DEVICE</span><span class="p">),</span>
			<span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">),</span>
			<span class="p">(</span><span class="n">len_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* EOP? */</span>
			<span class="n">loopback</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enic_queue_wq_skb_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vnic_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">vlan_tag_insert</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vlan_tag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loopback</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head_len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len_left</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">head_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eop</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Queue the main skb fragment. The fragments are no larger</span>
<span class="cm">	 * than max MTU(9000)+ETH_HDR_LEN(14) bytes, which is less</span>
<span class="cm">	 * than WQ_ENET_MAX_DESC_LEN length. So only one descriptor</span>
<span class="cm">	 * per fragment is queued.</span>
<span class="cm">	 */</span>
	<span class="n">enic_queue_wq_desc</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
		<span class="n">pci_map_single</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			<span class="n">head_len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">),</span>
		<span class="n">head_len</span><span class="p">,</span>
		<span class="n">vlan_tag_insert</span><span class="p">,</span> <span class="n">vlan_tag</span><span class="p">,</span>
		<span class="n">eop</span><span class="p">,</span> <span class="n">loopback</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eop</span><span class="p">)</span>
		<span class="n">enic_queue_wq_skb_cont</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">wq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">len_left</span><span class="p">,</span> <span class="n">loopback</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enic_queue_wq_skb_csum_l4</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vnic_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">vlan_tag_insert</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vlan_tag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loopback</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head_len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len_left</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">head_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hdr_len</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">csum_offset</span> <span class="o">=</span> <span class="n">hdr_len</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eop</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Queue the main skb fragment. The fragments are no larger</span>
<span class="cm">	 * than max MTU(9000)+ETH_HDR_LEN(14) bytes, which is less</span>
<span class="cm">	 * than WQ_ENET_MAX_DESC_LEN length. So only one descriptor</span>
<span class="cm">	 * per fragment is queued.</span>
<span class="cm">	 */</span>
	<span class="n">enic_queue_wq_desc_csum_l4</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
		<span class="n">pci_map_single</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			<span class="n">head_len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">),</span>
		<span class="n">head_len</span><span class="p">,</span>
		<span class="n">csum_offset</span><span class="p">,</span>
		<span class="n">hdr_len</span><span class="p">,</span>
		<span class="n">vlan_tag_insert</span><span class="p">,</span> <span class="n">vlan_tag</span><span class="p">,</span>
		<span class="n">eop</span><span class="p">,</span> <span class="n">loopback</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eop</span><span class="p">)</span>
		<span class="n">enic_queue_wq_skb_cont</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">wq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">len_left</span><span class="p">,</span> <span class="n">loopback</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enic_queue_wq_skb_tso</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vnic_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">vlan_tag_insert</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vlan_tag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loopback</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag_len_left</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len_left</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">frag_len_left</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hdr_len</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">eop</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>

	<span class="cm">/* Preload TCP csum field with IP pseudo hdr calculated</span>
<span class="cm">	 * with IP length set to zero.  HW will later add in length</span>
<span class="cm">	 * to each TCP segment resulting from the TSO.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_tcpudp_magic</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
			<span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_ipv6_magic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Queue WQ_ENET_MAX_DESC_LEN length descriptors</span>
<span class="cm">	 * for the main skb fragment</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">frag_len_left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">frag_len_left</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">WQ_ENET_MAX_DESC_LEN</span><span class="p">);</span>
		<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
				<span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="n">enic_queue_wq_desc_tso</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
			<span class="n">dma_addr</span><span class="p">,</span>
			<span class="n">len</span><span class="p">,</span>
			<span class="n">mss</span><span class="p">,</span> <span class="n">hdr_len</span><span class="p">,</span>
			<span class="n">vlan_tag_insert</span><span class="p">,</span> <span class="n">vlan_tag</span><span class="p">,</span>
			<span class="n">eop</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">frag_len_left</span><span class="p">),</span> <span class="n">loopback</span><span class="p">);</span>
		<span class="n">frag_len_left</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eop</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Queue WQ_ENET_MAX_DESC_LEN length descriptors</span>
<span class="cm">	 * for additional data fragments</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">frag</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">;</span> <span class="n">len_left</span><span class="p">;</span> <span class="n">frag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len_left</span> <span class="o">-=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="n">frag_len_left</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">frag_len_left</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">frag_len_left</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">WQ_ENET_MAX_DESC_LEN</span><span class="p">);</span>
			<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span>
						    <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
						    <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="n">enic_queue_wq_desc_cont</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
				<span class="n">dma_addr</span><span class="p">,</span>
				<span class="n">len</span><span class="p">,</span>
				<span class="p">(</span><span class="n">len_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">frag_len_left</span><span class="p">),</span>		<span class="cm">/* EOP? */</span>
				<span class="n">loopback</span><span class="p">);</span>
			<span class="n">frag_len_left</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enic_queue_wq_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vnic_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vlan_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vlan_tag_insert</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loopback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* VLAN tag from trunking driver */</span>
		<span class="n">vlan_tag_insert</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vlan_tag</span> <span class="o">=</span> <span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">loop_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vlan_tag</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">loop_tag</span><span class="p">;</span>
		<span class="n">loopback</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mss</span><span class="p">)</span>
		<span class="n">enic_queue_wq_skb_tso</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">wq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mss</span><span class="p">,</span>
			<span class="n">vlan_tag_insert</span><span class="p">,</span> <span class="n">vlan_tag</span><span class="p">,</span> <span class="n">loopback</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
		<span class="n">enic_queue_wq_skb_csum_l4</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">wq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
			<span class="n">vlan_tag_insert</span><span class="p">,</span> <span class="n">vlan_tag</span><span class="p">,</span> <span class="n">loopback</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">enic_queue_wq_skb_vlan</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">wq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
			<span class="n">vlan_tag_insert</span><span class="p">,</span> <span class="n">vlan_tag</span><span class="p">,</span> <span class="n">loopback</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* netif_tx_lock held, process context with BHs disabled, or BH */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">enic_hard_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vnic_wq</span> <span class="o">*</span><span class="n">wq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Non-TSO sends must fit within ENIC_NON_TSO_MAX_DESC descs,</span>
<span class="cm">	 * which is very likely.  In the off chance it&#39;s going to take</span>
<span class="cm">	 * more than * ENIC_NON_TSO_MAX_DESC, linearize the skb.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">ENIC_NON_TSO_MAX_DESC</span> <span class="o">&amp;&amp;</span>
	    <span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vnic_wq_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">)</span> <span class="o">&lt;</span>
	    <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="n">ENIC_DESC_MAX_SPLITS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="cm">/* This is a hard error, log it */</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;BUG! Tx ring full when queue awake!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">enic_queue_wq_skb</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">wq</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vnic_wq_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="n">ENIC_DESC_MAX_SPLITS</span><span class="p">)</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* dev_base_lock rwlock held, nominally process context */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="nf">enic_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">net_stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vnic_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>

	<span class="n">enic_dev_stats_dump</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stats</span><span class="p">);</span>

	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">tx_frames_ok</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">tx_bytes_ok</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">tx_errors</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">tx_errors</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">tx_dropped</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">tx_drops</span><span class="p">;</span>

	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">rx_frames_ok</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">rx_bytes_ok</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_errors</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">rx_errors</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">multicast</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">rx_multicast_frames_ok</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_over_errors</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_truncated_pkts</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_bad_fcs</span><span class="p">;</span>
	<span class="n">net_stats</span><span class="o">-&gt;</span><span class="n">rx_dropped</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">rx_no_bufs</span> <span class="o">+</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">rx_drop</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">net_stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">enic_reset_addr_lists</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">mc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">uc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_set_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enic_is_dynamic</span><span class="p">(</span><span class="n">enic</span><span class="p">)</span> <span class="o">||</span> <span class="n">enic_is_sriov_vf</span><span class="p">(</span><span class="n">enic</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_assign_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NET_ADDR_RANDOM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_set_mac_address_dynamic</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">saddr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">enic_dev_del_station_addr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_set_mac_addr</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">enic_dev_add_station_addr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">saddr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_dev_del_station_addr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_set_mac_addr</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">enic_dev_add_station_addr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_update_multicast_addr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mc_count</span> <span class="o">=</span> <span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">mc_addr</span><span class="p">[</span><span class="n">ENIC_MULTICAST_PERFECT_FILTERS</span><span class="p">][</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mc_count</span> <span class="o">&gt;</span> <span class="n">ENIC_MULTICAST_PERFECT_FILTERS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_warn</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Registering only %d out of %d &quot;</span>
			<span class="s">&quot;multicast addresses</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ENIC_MULTICAST_PERFECT_FILTERS</span><span class="p">,</span> <span class="n">mc_count</span><span class="p">);</span>
		<span class="n">mc_count</span> <span class="o">=</span> <span class="n">ENIC_MULTICAST_PERFECT_FILTERS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is there an easier way?  Trying to minimize to</span>
<span class="cm">	 * calls to add/del multicast addrs.  We keep the</span>
<span class="cm">	 * addrs from the last call in enic-&gt;mc_addr and</span>
<span class="cm">	 * look for changes to add/del.</span>
<span class="cm">	 */</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">mc_count</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mc_addr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">mc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">mc_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">mc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mc_addr</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">mc_count</span><span class="p">)</span>
			<span class="n">enic_dev_del_addr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">mc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">mc_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">mc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">mc_addr</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">mc_count</span><span class="p">)</span>
			<span class="n">enic_dev_add_addr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">mc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* Save the list to compare against next time</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">mc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">mc_count</span> <span class="o">=</span> <span class="n">mc_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_update_unicast_addr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uc_count</span> <span class="o">=</span> <span class="n">netdev_uc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">uc_addr</span><span class="p">[</span><span class="n">ENIC_UNICAST_PERFECT_FILTERS</span><span class="p">][</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uc_count</span> <span class="o">&gt;</span> <span class="n">ENIC_UNICAST_PERFECT_FILTERS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_warn</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Registering only %d out of %d &quot;</span>
			<span class="s">&quot;unicast addresses</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ENIC_UNICAST_PERFECT_FILTERS</span><span class="p">,</span> <span class="n">uc_count</span><span class="p">);</span>
		<span class="n">uc_count</span> <span class="o">=</span> <span class="n">ENIC_UNICAST_PERFECT_FILTERS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is there an easier way?  Trying to minimize to</span>
<span class="cm">	 * calls to add/del unicast addrs.  We keep the</span>
<span class="cm">	 * addrs from the last call in enic-&gt;uc_addr and</span>
<span class="cm">	 * look for changes to add/del.</span>
<span class="cm">	 */</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netdev_for_each_uc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">uc_count</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">uc_addr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">uc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">uc_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">uc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">uc_addr</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">uc_count</span><span class="p">)</span>
			<span class="n">enic_dev_del_addr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">uc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">uc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">uc_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">uc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">uc_addr</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">uc_count</span><span class="p">)</span>
			<span class="n">enic_dev_add_addr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">uc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* Save the list to compare against next time</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">uc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">uc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">uc_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">uc_count</span> <span class="o">=</span> <span class="n">uc_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* netif_tx_lock held, BHs disabled */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">directed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">multicast</span> <span class="o">=</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_MULTICAST</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">broadcast</span> <span class="o">=</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_BROADCAST</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">promisc</span> <span class="o">=</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">netdev_uc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ENIC_UNICAST_PERFECT_FILTERS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">allmulti</span> <span class="o">=</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ENIC_MULTICAST_PERFECT_FILTERS</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">allmulti</span> <span class="o">?</span> <span class="n">IFF_ALLMULTI</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">promisc</span> <span class="o">?</span> <span class="n">IFF_PROMISC</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">!=</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">enic_dev_packet_filter</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">directed</span><span class="p">,</span>
			<span class="n">multicast</span><span class="p">,</span> <span class="n">broadcast</span><span class="p">,</span> <span class="n">promisc</span><span class="p">,</span> <span class="n">allmulti</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">promisc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enic_update_unicast_addr_list</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allmulti</span><span class="p">)</span>
			<span class="n">enic_update_multicast_addr_list</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* netif_tx_lock held, BHs disabled */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_set_vf_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">enic_port_profile</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ENIC_PP_BY_INDEX</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">mac</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">mac</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vf</span> <span class="o">==</span> <span class="n">PORT_SELF_VF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">vf_mac</span><span class="p">,</span> <span class="n">mac</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * For sriov vf&#39;s set the mac in hw</span>
<span class="cm">			 */</span>
			<span class="n">ENIC_DEVCMD_PROXY_BY_INDEX</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">enic</span><span class="p">,</span>
				<span class="n">vnic_dev_set_mac_addr</span><span class="p">,</span> <span class="n">mac</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">enic_dev_status_to_errno</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_set_vf_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">port</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">enic_port_profile</span> <span class="n">prev_pp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enic_port_profile</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">restore_pp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ENIC_PP_BY_INDEX</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">[</span><span class="n">IFLA_PORT_REQUEST</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prev_pp</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">));</span>

	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">|=</span> <span class="n">ENIC_SET_REQUEST</span><span class="p">;</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">request</span> <span class="o">=</span> <span class="n">nla_get_u8</span><span class="p">(</span><span class="n">port</span><span class="p">[</span><span class="n">IFLA_PORT_REQUEST</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="p">[</span><span class="n">IFLA_PORT_PROFILE</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">|=</span> <span class="n">ENIC_SET_NAME</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">port</span><span class="p">[</span><span class="n">IFLA_PORT_PROFILE</span><span class="p">]),</span>
			<span class="n">PORT_PROFILE_MAX</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="p">[</span><span class="n">IFLA_PORT_INSTANCE_UUID</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">|=</span> <span class="n">ENIC_SET_INSTANCE</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">instance_uuid</span><span class="p">,</span>
			<span class="n">nla_data</span><span class="p">(</span><span class="n">port</span><span class="p">[</span><span class="n">IFLA_PORT_INSTANCE_UUID</span><span class="p">]),</span> <span class="n">PORT_UUID_MAX</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="p">[</span><span class="n">IFLA_PORT_HOST_UUID</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">|=</span> <span class="n">ENIC_SET_HOST</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">host_uuid</span><span class="p">,</span>
			<span class="n">nla_data</span><span class="p">(</span><span class="n">port</span><span class="p">[</span><span class="n">IFLA_PORT_HOST_UUID</span><span class="p">]),</span> <span class="n">PORT_UUID_MAX</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vf</span> <span class="o">==</span> <span class="n">PORT_SELF_VF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Special case handling: mac came from IFLA_VF_MAC */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">prev_pp</span><span class="p">.</span><span class="n">vf_mac</span><span class="p">))</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">prev_pp</span><span class="p">.</span><span class="n">vf_mac</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span>
			<span class="n">eth_hw_addr_random</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* SR-IOV VF: get mac from adapter */</span>
		<span class="n">ENIC_DEVCMD_PROXY_BY_INDEX</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">enic</span><span class="p">,</span>
			<span class="n">vnic_dev_get_mac_addr</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Error getting mac for vf %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vf</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev_pp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">));</span>
			<span class="k">return</span> <span class="n">enic_dev_status_to_errno</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_process_set_pp_request</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev_pp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">restore_pp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">restore_pp</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Things are still the way they were: Implicit</span>
<span class="cm">			 * DISASSOCIATE failed</span>
<span class="cm">			 */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev_pp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vf</span> <span class="o">==</span> <span class="n">PORT_SELF_VF</span><span class="p">)</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Set flag to indicate that the port assoc/disassoc</span>
<span class="cm">		 * request has been sent out to fw</span>
<span class="cm">		 */</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">|=</span> <span class="n">ENIC_PORT_REQUEST_APPLIED</span><span class="p">;</span>

		<span class="cm">/* If DISASSOCIATE, clean up all assigned/saved macaddresses */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">request</span> <span class="o">==</span> <span class="n">PORT_REQUEST_DISASSOCIATE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vf</span> <span class="o">==</span> <span class="n">PORT_SELF_VF</span><span class="p">)</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vf</span> <span class="o">==</span> <span class="n">PORT_SELF_VF</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">vf_mac</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_get_vf_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">response</span> <span class="o">=</span> <span class="n">PORT_PROFILE_RESPONSE_SUCCESS</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enic_port_profile</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ENIC_PP_BY_INDEX</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">&amp;</span> <span class="n">ENIC_PORT_REQUEST_APPLIED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_process_get_pp_request</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_u16</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IFLA_PORT_REQUEST</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">nla_put_u16</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IFLA_PORT_RESPONSE</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">&amp;</span> <span class="n">ENIC_SET_NAME</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IFLA_PORT_PROFILE</span><span class="p">,</span> <span class="n">PORT_PROFILE_MAX</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">&amp;</span> <span class="n">ENIC_SET_INSTANCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IFLA_PORT_INSTANCE_UUID</span><span class="p">,</span> <span class="n">PORT_UUID_MAX</span><span class="p">,</span>
		     <span class="n">pp</span><span class="o">-&gt;</span><span class="n">instance_uuid</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">&amp;</span> <span class="n">ENIC_SET_HOST</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IFLA_PORT_HOST_UUID</span><span class="p">,</span> <span class="n">PORT_UUID_MAX</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">host_uuid</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_free_rq_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vnic_rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vnic_rq_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">vnic_dev_priv</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">os_buf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">os_buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_rq_alloc_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vnic_rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">vnic_dev_priv</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">VLAN_ETH_HLEN</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">os_buf_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
		<span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

	<span class="n">enic_queue_rq_desc</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">os_buf_index</span><span class="p">,</span>
		<span class="n">dma_addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_rq_indicate_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vnic_rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cq_desc</span> <span class="o">*</span><span class="n">cq_desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vnic_rq_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">skipped</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">vnic_dev_priv</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">eop</span><span class="p">,</span> <span class="n">sop</span><span class="p">,</span> <span class="n">ingress_port</span><span class="p">,</span> <span class="n">vlan_stripped</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fcoe</span><span class="p">,</span> <span class="n">fcoe_sof</span><span class="p">,</span> <span class="n">fcoe_fc_crc_ok</span><span class="p">,</span> <span class="n">fcoe_enc_error</span><span class="p">,</span> <span class="n">fcoe_eof</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tcp_udp_csum_ok</span><span class="p">,</span> <span class="n">udp</span><span class="p">,</span> <span class="n">tcp</span><span class="p">,</span> <span class="n">ipv4_csum_ok</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipv6</span><span class="p">,</span> <span class="n">ipv4</span><span class="p">,</span> <span class="n">ipv4_fragment</span><span class="p">,</span> <span class="n">fcs_ok</span><span class="p">,</span> <span class="n">rss_type</span><span class="p">,</span> <span class="n">csum_not_calc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">packet_error</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">q_number</span><span class="p">,</span> <span class="n">completed_index</span><span class="p">,</span> <span class="n">bytes_written</span><span class="p">,</span> <span class="n">vlan_tci</span><span class="p">,</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rss_hash</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skipped</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">os_buf</span><span class="p">;</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
	<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

	<span class="n">cq_enet_rq_desc_dec</span><span class="p">((</span><span class="k">struct</span> <span class="n">cq_enet_rq_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">cq_desc</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">color</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q_number</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completed_index</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">ingress_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rss_type</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">csum_not_calc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rss_hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytes_written</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">packet_error</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vlan_stripped</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vlan_tci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">checksum</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">fcoe_sof</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_fc_crc_ok</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcoe_enc_error</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">fcoe_eof</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcp_udp_csum_ok</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcp</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">ipv4_csum_ok</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipv6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipv4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipv4_fragment</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">fcs_ok</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packet_error</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcs_ok</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes_written</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_bad_fcs</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes_written</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_truncated_pkts</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eop</span> <span class="o">&amp;&amp;</span> <span class="n">bytes_written</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Good receive</span>
<span class="cm">		 */</span>

		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bytes_written</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">csum_not_calc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">checksum</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_COMPLETE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vlan_stripped</span><span class="p">)</span>
			<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vlan_tci</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_GRO</span><span class="p">)</span>
			<span class="n">napi_gro_receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="n">q_number</span><span class="p">],</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/* Buffer overflow</span>
<span class="cm">		 */</span>

		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_rq_service</span><span class="p">(</span><span class="k">struct</span> <span class="n">vnic_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cq_desc</span> <span class="o">*</span><span class="n">cq_desc</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">q_number</span><span class="p">,</span> <span class="n">u16</span> <span class="n">completed_index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">vnic_dev_priv</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

	<span class="n">vnic_rq_service</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="n">q_number</span><span class="p">],</span> <span class="n">cq_desc</span><span class="p">,</span>
		<span class="n">completed_index</span><span class="p">,</span> <span class="n">VNIC_RQ_RETURN_DESC</span><span class="p">,</span>
		<span class="n">enic_rq_indicate_buf</span><span class="p">,</span> <span class="n">opaque</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cq_rq</span> <span class="o">=</span> <span class="n">enic_cq_rq</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cq_wq</span> <span class="o">=</span> <span class="n">enic_cq_wq</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intr</span> <span class="o">=</span> <span class="n">enic_legacy_io_intr</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rq_work_to_do</span> <span class="o">=</span> <span class="n">budget</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wq_work_to_do</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* no limit */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">work_done</span><span class="p">,</span> <span class="n">rq_work_done</span><span class="p">,</span> <span class="n">wq_work_done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Service RQ (first) and WQ</span>
<span class="cm">	 */</span>

	<span class="n">rq_work_done</span> <span class="o">=</span> <span class="n">vnic_cq_service</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq</span><span class="p">[</span><span class="n">cq_rq</span><span class="p">],</span>
		<span class="n">rq_work_to_do</span><span class="p">,</span> <span class="n">enic_rq_service</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">wq_work_done</span> <span class="o">=</span> <span class="n">vnic_cq_service</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq</span><span class="p">[</span><span class="n">cq_wq</span><span class="p">],</span>
		<span class="n">wq_work_to_do</span><span class="p">,</span> <span class="n">enic_wq_service</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Accumulate intr event credits for this polling</span>
<span class="cm">	 * cycle.  An intr event is the completion of a</span>
<span class="cm">	 * a WQ or RQ packet.</span>
<span class="cm">	 */</span>

	<span class="n">work_done</span> <span class="o">=</span> <span class="n">rq_work_done</span> <span class="o">+</span> <span class="n">wq_work_done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vnic_intr_return_credits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">intr</span><span class="p">],</span>
			<span class="n">work_done</span><span class="p">,</span>
			<span class="mi">0</span> <span class="cm">/* don&#39;t unmask intr */</span><span class="p">,</span>
			<span class="mi">0</span> <span class="cm">/* don&#39;t reset intr timer */</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">vnic_rq_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">enic_rq_alloc_buf</span><span class="p">);</span>

	<span class="cm">/* Buffer allocation failed. Stay in polling</span>
<span class="cm">	 * mode so we can try to fill the ring again.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">rq_work_done</span> <span class="o">=</span> <span class="n">rq_work_to_do</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq_work_done</span> <span class="o">&lt;</span> <span class="n">rq_work_to_do</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Some work done, but not enough to stay in polling,</span>
<span class="cm">		 * exit polling</span>
<span class="cm">		 */</span>

		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">vnic_intr_unmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">intr</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rq_work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_poll_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rq</span> <span class="o">=</span> <span class="p">(</span><span class="n">napi</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cq</span> <span class="o">=</span> <span class="n">enic_cq_rq</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_rq_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">work_to_do</span> <span class="o">=</span> <span class="n">budget</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">work_done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Service RQ</span>
<span class="cm">	 */</span>

	<span class="n">work_done</span> <span class="o">=</span> <span class="n">vnic_cq_service</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq</span><span class="p">[</span><span class="n">cq</span><span class="p">],</span>
		<span class="n">work_to_do</span><span class="p">,</span> <span class="n">enic_rq_service</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Return intr event credits for this polling</span>
<span class="cm">	 * cycle.  An intr event is the completion of a</span>
<span class="cm">	 * RQ packet.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vnic_intr_return_credits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">intr</span><span class="p">],</span>
			<span class="n">work_done</span><span class="p">,</span>
			<span class="mi">0</span> <span class="cm">/* don&#39;t unmask intr */</span><span class="p">,</span>
			<span class="mi">0</span> <span class="cm">/* don&#39;t reset intr timer */</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">vnic_rq_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="n">rq</span><span class="p">],</span> <span class="n">enic_rq_alloc_buf</span><span class="p">);</span>

	<span class="cm">/* Buffer allocation failed. Stay in polling mode</span>
<span class="cm">	 * so we can try to fill the ring again.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">work_done</span> <span class="o">=</span> <span class="n">work_to_do</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">work_to_do</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Some work done, but not enough to stay in polling,</span>
<span class="cm">		 * exit polling</span>
<span class="cm">		 */</span>

		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">vnic_intr_unmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">intr</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_notify_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="n">enic_notify_check</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">notify_timer</span><span class="p">,</span>
		<span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">ENIC_NOTIFY_TIMER_PERIOD</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_free_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vnic_dev_get_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_INTX</span>:
		<span class="n">free_irq</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSI</span>:
		<span class="n">free_irq</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">enic</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSIX</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">requested</span><span class="p">)</span>
				<span class="n">free_irq</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix_entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
					<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">devid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_request_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">intr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vnic_dev_get_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">))</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_INTX</span>:

		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">enic_isr_legacy</span><span class="p">,</span>
			<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSI</span>:

		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">enic_isr_msi</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">enic</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSIX</span>:

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_rq_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">devname</span><span class="p">,</span>
				<span class="s">&quot;%.11s-rx-%d&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">isr</span> <span class="o">=</span> <span class="n">enic_isr_msix_rq</span><span class="p">;</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">devid</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_wq_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">devname</span><span class="p">,</span>
				<span class="s">&quot;%.11s-tx-%d&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">isr</span> <span class="o">=</span> <span class="n">enic_isr_msix_wq</span><span class="p">;</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">devid</span> <span class="o">=</span> <span class="n">enic</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_err_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">devname</span><span class="p">,</span>
			<span class="s">&quot;%.11s-err&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">isr</span> <span class="o">=</span> <span class="n">enic_isr_msix_err</span><span class="p">;</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">devid</span> <span class="o">=</span> <span class="n">enic</span><span class="p">;</span>

		<span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_notify_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">devname</span><span class="p">,</span>
			<span class="s">&quot;%.11s-notify&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">isr</span> <span class="o">=</span> <span class="n">enic_isr_msix_notify</span><span class="p">;</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">devid</span> <span class="o">=</span> <span class="n">enic</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">requested</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix_entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">devname</span><span class="p">,</span>
				<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">devid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">enic_free_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">requested</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_synchronize_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vnic_dev_get_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_INTX</span>:
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSI</span>:
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSIX</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix_entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_dev_notify_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">devcmd_lock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">vnic_dev_get_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_INTX</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">vnic_dev_notify_set</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span>
			<span class="n">enic_legacy_notify_intr</span><span class="p">());</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSIX</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">vnic_dev_notify_set</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span>
			<span class="n">enic_msix_notify_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vnic_dev_notify_set</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="cm">/* no intr */</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">devcmd_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_notify_timer_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">vnic_dev_get_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSI</span>:
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">notify_timer</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Using intr for notification for INTx/MSI-X */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* rtnl lock is held, process context */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_request_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Unable to request irq.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_dev_notify_set</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span>
			<span class="s">&quot;Failed to alloc notify buffer, aborting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_free_intr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vnic_rq_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">enic_rq_alloc_buf</span><span class="p">);</span>
		<span class="cm">/* Need at least one buffer on ring to get going */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vnic_rq_desc_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Unable to alloc receive buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out_notify_unset</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vnic_wq_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vnic_rq_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enic_is_dynamic</span><span class="p">(</span><span class="n">enic</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">enic_is_sriov_vf</span><span class="p">(</span><span class="n">enic</span><span class="p">))</span>
		<span class="n">enic_dev_add_station_addr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="n">enic_set_rx_mode</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">enic_dev_enable</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vnic_intr_unmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">enic_notify_timer_start</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_notify_unset:</span>
	<span class="n">enic_dev_notify_unset</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
<span class="nl">err_out_free_intr:</span>
	<span class="n">enic_free_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* rtnl lock is held, process context */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vnic_intr_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">vnic_intr_masked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="cm">/* flush write */</span>
	<span class="p">}</span>

	<span class="n">enic_synchronize_irqs</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">notify_timer</span><span class="p">);</span>

	<span class="n">enic_dev_disable</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">netif_tx_disable</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enic_is_dynamic</span><span class="p">(</span><span class="n">enic</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">enic_is_sriov_vf</span><span class="p">(</span><span class="n">enic</span><span class="p">))</span>
		<span class="n">enic_dev_del_station_addr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vnic_wq_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vnic_rq_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">enic_dev_notify_unset</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">enic_free_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vnic_wq_clean</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">enic_free_wq_buf</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vnic_rq_clean</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">enic_free_rq_buf</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vnic_cq_clean</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vnic_intr_clean</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">running</span> <span class="o">=</span> <span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="n">ENIC_MIN_MTU</span> <span class="o">||</span> <span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="n">ENIC_MAX_MTU</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enic_is_dynamic</span><span class="p">(</span><span class="n">enic</span><span class="p">)</span> <span class="o">||</span> <span class="n">enic_is_sriov_vf</span><span class="p">(</span><span class="n">enic</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
		<span class="n">enic_stop</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">port_mtu</span><span class="p">)</span>
		<span class="n">netdev_warn</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span>
			<span class="s">&quot;interface MTU (%d) set higher than port MTU (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">port_mtu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
		<span class="n">enic_open</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_change_mtu_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enic</span><span class="p">,</span> <span class="n">change_mtu_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_mtu</span> <span class="o">=</span> <span class="n">vnic_dev_mtu</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">new_mtu</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">ENIC_MIN_MTU</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">ENIC_MAX_MTU</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">));</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>

	<span class="cm">/* Stop RQ */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">notify_timer</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">vnic_intr_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">enic_synchronize_irqs</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vnic_rq_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Unable to disable RQ.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vnic_rq_clean</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">enic_free_rq_buf</span><span class="p">);</span>
	<span class="n">vnic_cq_clean</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">vnic_intr_clean</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* Fill RQ with new_mtu-sized buffers */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>
	<span class="n">vnic_rq_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">enic_rq_alloc_buf</span><span class="p">);</span>
	<span class="cm">/* Need at least one buffer on ring to get going */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vnic_rq_desc_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Unable to alloc receive buffers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Start RQ */</span>
	<span class="n">vnic_rq_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">vnic_intr_unmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">enic_notify_timer_start</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="n">netdev_info</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;interface MTU set as %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_poll_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vnic_dev</span> <span class="o">*</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">intr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vnic_dev_get_intr_mode</span><span class="p">(</span><span class="n">vdev</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSIX</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_rq_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">enic_isr_msix_rq</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix_entry</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intr</span> <span class="o">=</span> <span class="n">enic_msix_wq_intr</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">enic_isr_msix_wq</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix_entry</span><span class="p">[</span><span class="n">intr</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">enic</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSI</span>:
		<span class="n">enic_isr_msi</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">enic</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_INTX</span>:
		<span class="n">enic_isr_legacy</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_dev_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">vnic_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vnic_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">finished</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vnic_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">),</span>
	<span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">start</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Wait for func to complete...2 seconds max</span>
<span class="cm">	 */</span>

	<span class="n">time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">finished</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">));</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_dev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_dev_wait</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">vnic_dev_open</span><span class="p">,</span>
		<span class="n">vnic_dev_open_done</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">enic_get_dev</span><span class="p">(</span><span class="n">enic</span><span class="p">),</span> <span class="s">&quot;vNIC device open failed, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_dev_hang_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_dev_wait</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">vnic_dev_hang_reset</span><span class="p">,</span>
		<span class="n">vnic_dev_hang_reset_done</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;vNIC hang reset failed, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_set_rsskey</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">rss_key_buf_pa</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">vnic_rss_key</span> <span class="o">*</span><span class="n">rss_key_buf_va</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">vnic_rss_key</span> <span class="n">rss_key</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">85</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">119</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">101</span><span class="p">},</span>
		<span class="p">.</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">80</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">117</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">113</span><span class="p">,</span> <span class="mi">117</span><span class="p">,</span> <span class="mi">101</span><span class="p">},</span>
		<span class="p">.</span><span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">76</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">107</span><span class="p">,</span> <span class="mi">115</span><span class="p">},</span>
		<span class="p">.</span><span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">69</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">108</span><span class="p">},</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rss_key_buf_va</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">vnic_rss_key</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">rss_key_buf_pa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rss_key_buf_va</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">rss_key_buf_va</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rss_key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">vnic_rss_key</span><span class="p">));</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">devcmd_lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_set_rss_key</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span>
		<span class="n">rss_key_buf_pa</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">vnic_rss_key</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">devcmd_lock</span><span class="p">);</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">vnic_rss_key</span><span class="p">),</span>
		<span class="n">rss_key_buf_va</span><span class="p">,</span> <span class="n">rss_key_buf_pa</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_set_rsscpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span> <span class="n">u8</span> <span class="n">rss_hash_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">rss_cpu_buf_pa</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">vnic_rss_cpu</span> <span class="o">*</span><span class="n">rss_cpu_buf_va</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rss_cpu_buf_va</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">vnic_rss_cpu</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">rss_cpu_buf_pa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rss_cpu_buf_va</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">rss_hash_bits</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">rss_cpu_buf_va</span><span class="p">).</span><span class="n">cpu</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">4</span><span class="p">].</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">devcmd_lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_set_rss_cpu</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span>
		<span class="n">rss_cpu_buf_pa</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">vnic_rss_cpu</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">devcmd_lock</span><span class="p">);</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">vnic_rss_cpu</span><span class="p">),</span>
		<span class="n">rss_cpu_buf_va</span><span class="p">,</span> <span class="n">rss_cpu_buf_pa</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_set_niccfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">,</span> <span class="n">u8</span> <span class="n">rss_default_cpu</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">rss_hash_type</span><span class="p">,</span> <span class="n">u8</span> <span class="n">rss_hash_bits</span><span class="p">,</span> <span class="n">u8</span> <span class="n">rss_base_cpu</span><span class="p">,</span> <span class="n">u8</span> <span class="n">rss_enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">tso_ipid_split_en</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">ig_vlan_strip_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Enable VLAN tag stripping.</span>
<span class="cm">	*/</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">devcmd_lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_set_nic_cfg</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span>
		<span class="n">rss_default_cpu</span><span class="p">,</span> <span class="n">rss_hash_type</span><span class="p">,</span>
		<span class="n">rss_hash_bits</span><span class="p">,</span> <span class="n">rss_base_cpu</span><span class="p">,</span>
		<span class="n">rss_enable</span><span class="p">,</span> <span class="n">tso_ipid_split_en</span><span class="p">,</span>
		<span class="n">ig_vlan_strip_en</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">devcmd_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_set_rss_nic_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">enic_get_dev</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">rss_default_cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">rss_hash_type</span> <span class="o">=</span> <span class="n">NIC_CFG_RSS_HASH_TYPE_IPV4</span> <span class="o">|</span>
		<span class="n">NIC_CFG_RSS_HASH_TYPE_TCP_IPV4</span> <span class="o">|</span>
		<span class="n">NIC_CFG_RSS_HASH_TYPE_IPV6</span> <span class="o">|</span>
		<span class="n">NIC_CFG_RSS_HASH_TYPE_TCP_IPV6</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">rss_hash_bits</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">rss_base_cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rss_enable</span> <span class="o">=</span> <span class="n">ENIC_SETTING</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">RSS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rss_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enic_set_rsskey</span><span class="p">(</span><span class="n">enic</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">enic_set_rsscpu</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">rss_hash_bits</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">rss_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RSS disabled, &quot;</span>
					<span class="s">&quot;Failed to set RSS cpu indirection table.&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rss_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RSS disabled, Failed to set RSS key.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">enic_set_niccfg</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">rss_default_cpu</span><span class="p">,</span> <span class="n">rss_hash_type</span><span class="p">,</span>
		<span class="n">rss_hash_bits</span><span class="p">,</span> <span class="n">rss_base_cpu</span><span class="p">,</span> <span class="n">rss_enable</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enic</span><span class="p">,</span> <span class="n">reset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>

	<span class="n">enic_dev_hang_notify</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">enic_stop</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">enic_dev_hang_reset</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">enic_reset_addr_lists</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">enic_init_vnic_resources</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">enic_set_rss_nic_cfg</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">enic_dev_set_ig_vlan_rewrite_mode</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">enic_open</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">rtnl_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_set_intr_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">,</span> <span class="n">ENIC_RQ_MAX</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span><span class="p">,</span> <span class="n">ENIC_WQ_MAX</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Set interrupt mode (INTx, MSI, MSI-X) depending</span>
<span class="cm">	 * on system capabilities.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Try MSI-X first</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need n RQs, m WQs, n+m CQs, and n+m+2 INTRs</span>
<span class="cm">	 * (the second to last INTR is used for WQ/RQ errors)</span>
<span class="cm">	 * (the last INTR is used for notifications)</span>
<span class="cm">	 */</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix_entry</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix_entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Use multiple RQs if RSS is enabled</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ENIC_SETTING</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">RSS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">intr_mode</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq_count</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix_entry</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq_count</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="p">;</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

			<span class="n">vnic_dev_set_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span>
				<span class="n">VNIC_DEV_INTR_MODE_MSIX</span><span class="p">);</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">intr_mode</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq_count</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">m</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">msix_entry</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq_count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">m</span><span class="p">;</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

			<span class="n">vnic_dev_set_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span>
				<span class="n">VNIC_DEV_INTR_MODE_MSIX</span><span class="p">);</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Next try MSI</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need 1 RQ, 1 WQ, 2 CQs, and 1 INTR</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">intr_mode</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq_count</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq_count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">vnic_dev_set_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">VNIC_DEV_INTR_MODE_MSI</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Next try INTx</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need 1 RQ, 1 WQ, 2 CQs, and 3 INTRs</span>
<span class="cm">	 * (the first INTR is used for WQ/RQ)</span>
<span class="cm">	 * (the second INTR is used for WQ/RQ errors)</span>
<span class="cm">	 * (the last INTR is used for notifications)</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">intr_mode</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq_count</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
	    <span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">cq_count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">intr_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

		<span class="n">vnic_dev_set_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">VNIC_DEV_INTR_MODE_INTX</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vnic_dev_set_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">VNIC_DEV_INTR_MODE_UNKNOWN</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_clear_intr_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">vnic_dev_get_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSIX</span>:
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSI</span>:
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vnic_dev_set_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">VNIC_DEV_INTR_MODE_UNKNOWN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">enic_netdev_dynamic_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">enic_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">enic_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">enic_hard_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats64</span>	<span class="o">=</span> <span class="n">enic_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">enic_set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">enic_set_mac_address_dynamic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">enic_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_add_vid</span>	<span class="o">=</span> <span class="n">enic_vlan_rx_add_vid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_kill_vid</span>	<span class="o">=</span> <span class="n">enic_vlan_rx_kill_vid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">enic_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_vf_port</span>	<span class="o">=</span> <span class="n">enic_set_vf_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_vf_port</span>	<span class="o">=</span> <span class="n">enic_get_vf_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_vf_mac</span>		<span class="o">=</span> <span class="n">enic_set_vf_mac</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">enic_poll_controller</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">enic_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">enic_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">enic_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">enic_hard_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats64</span>	<span class="o">=</span> <span class="n">enic_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">enic_set_mac_address</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">enic_set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">enic_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_add_vid</span>	<span class="o">=</span> <span class="n">enic_vlan_rx_add_vid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_kill_vid</span>	<span class="o">=</span> <span class="n">enic_vlan_rx_kill_vid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">enic_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_vf_port</span>	<span class="o">=</span> <span class="n">enic_set_vf_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_vf_port</span>	<span class="o">=</span> <span class="n">enic_get_vf_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_vf_mac</span>		<span class="o">=</span> <span class="n">enic_set_vf_mac</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">enic_poll_controller</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_dev_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">netif_napi_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">enic_free_vnic_resources</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">enic_clear_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enic_dev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">enic_get_dev</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Get interrupt coalesce timer info */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_dev_intr_coal_timer_info</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Using default conversion factor for &quot;</span>
			<span class="s">&quot;interrupt coalesce timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">vnic_dev_intr_coal_timer_info_default</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Get vNIC configuration</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_get_vnic_config</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Get vNIC configuration failed, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get available resource counts</span>
<span class="cm">	 */</span>

	<span class="n">enic_get_res_counts</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="cm">/* Set interrupt mode based on resource counts and system</span>
<span class="cm">	 * capabilities</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_set_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to set intr mode based on resource &quot;</span>
			<span class="s">&quot;counts and system capabilities, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate and configure vNIC resources</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_alloc_vnic_resources</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to alloc vNIC resources, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_free_vnic_resources</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">enic_init_vnic_resources</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_set_rss_nic_cfg</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to config nic, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_free_vnic_resources</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vnic_dev_get_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">))</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">enic_poll</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VNIC_DEV_INTR_MODE_MSIX</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				<span class="n">enic_poll_msix</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_free_vnic_resources:</span>
	<span class="n">enic_clear_intr_mode</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="n">enic_free_vnic_resources</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enic_iounmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">)</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">enic_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">using_dac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PCI_IOV</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">num_pps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Allocate net device structure and initialize.  Private</span>
<span class="cm">	 * instance data is initialized to zero.</span>
<span class="cm">	 */</span>

	<span class="n">netdev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">enic</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* Setup PCI resources</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot enable PCI device, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_free_netdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot request PCI regions, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_disable_device</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Query PCI controller on system for DMA addressing</span>
<span class="cm">	 * limitation for the device.  Try 40-bit first, and</span>
<span class="cm">	 * fail to 32-bit.</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">40</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No usable DMA configuration, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out_release_regions</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to obtain %u-bit DMA &quot;</span>
				<span class="s">&quot;for consistent allocations, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out_release_regions</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">40</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to obtain %u-bit DMA &quot;</span>
				<span class="s">&quot;for consistent allocations, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out_release_regions</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">using_dac</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Map vNIC resources from BAR0-5</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot memory-map BAR %d, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out_iounmap</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bus_addr</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Register vNIC device</span>
<span class="cm">	 */</span>

	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">vnic_dev_register</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">enic</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">,</span>
		<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vNIC registration failed, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_iounmap</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PCI_IOV</span>
	<span class="cm">/* Get number of subvnics */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_EXT_CAP_ID_SRIOV</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_SRIOV_TOTAL_VF</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">num_vfs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">num_vfs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_sriov</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">num_vfs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SRIOV enable failed, aborting.&quot;</span>
					<span class="s">&quot; pci_enable_sriov() returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">err</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err_out_vnic_unregister</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">ENIC_SRIOV_ENABLED</span><span class="p">;</span>
			<span class="n">num_pps</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">num_vfs</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Allocate structure for port profiles */</span>
	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">pp</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num_pps</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_disable_sriov_pp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Issue device open to get device in known state</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_dev_open</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vNIC dev open failed, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_disable_sriov</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup devcmd lock</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">devcmd_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set ingress vlan rewrite mode before vnic initialization</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_dev_set_ig_vlan_rewrite_mode</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Failed to set ingress vlan rewrite mode, aborting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_dev_close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Issue device init to initialize the vnic-to-switch link.</span>
<span class="cm">	 * We&#39;ll start with carrier off and wait for link UP</span>
<span class="cm">	 * notification later to turn on carrier.  We don&#39;t need</span>
<span class="cm">	 * to wait here for the vnic-to-switch link initialization</span>
<span class="cm">	 * to complete; link UP notification is the indication that</span>
<span class="cm">	 * the process is complete.</span>
<span class="cm">	 */</span>

	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Do not call dev_init for a dynamic vnic.</span>
<span class="cm">	 * For a dynamic vnic, init_prov_info will be</span>
<span class="cm">	 * called later by an upper layer.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enic_is_dynamic</span><span class="p">(</span><span class="n">enic</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vnic_dev_init</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vNIC dev init failed, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out_dev_close</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_dev_init</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device initialization failed, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_dev_close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup notification timer, HW reset task, and wq locks</span>
<span class="cm">	 */</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">notify_timer</span><span class="p">);</span>
	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">notify_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">enic_notify_timer</span><span class="p">;</span>
	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">notify_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">enic</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">,</span> <span class="n">enic_reset</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">change_mtu_work</span><span class="p">,</span> <span class="n">enic_change_mtu_work</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">wq_lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* Register net device</span>
<span class="cm">	 */</span>

	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">port_mtu</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">mtu</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">enic_change_mtu</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">port_mtu</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">enic_set_mac_addr</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid MAC address, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_dev_deinit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">tx_coalesce_usecs</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">intr_timer_usec</span><span class="p">;</span>
	<span class="n">enic</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">tx_coalesce_usecs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enic_is_dynamic</span><span class="p">(</span><span class="n">enic</span><span class="p">)</span> <span class="o">||</span> <span class="n">enic_is_sriov_vf</span><span class="p">(</span><span class="n">enic</span><span class="p">))</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">enic_netdev_dynamic_ops</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">enic_netdev_ops</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">enic_ethtool_ops</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_VLAN_TX</span> <span class="o">|</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ENIC_SETTING</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">LOOP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">;</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">loop_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">loop_tag</span> <span class="o">=</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">loop_tag</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;loopback tag=0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">enic</span><span class="o">-&gt;</span><span class="n">loop_tag</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ENIC_SETTING</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">TXCSUM</span><span class="p">))</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span> <span class="n">NETIF_F_HW_CSUM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ENIC_SETTING</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">TSO</span><span class="p">))</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO</span> <span class="o">|</span>
			<span class="n">NETIF_F_TSO6</span> <span class="o">|</span> <span class="n">NETIF_F_TSO_ECN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ENIC_SETTING</span><span class="p">(</span><span class="n">enic</span><span class="p">,</span> <span class="n">RXCSUM</span><span class="p">))</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">using_dac</span><span class="p">)</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">IFF_UNICAST_FLT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot register net device, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_dev_deinit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_dev_deinit:</span>
	<span class="n">enic_dev_deinit</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
<span class="nl">err_out_dev_close:</span>
	<span class="n">vnic_dev_close</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
<span class="nl">err_out_disable_sriov:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">);</span>
<span class="nl">err_out_disable_sriov_pp:</span>
<span class="cp">#ifdef CONFIG_PCI_IOV</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enic_sriov_enabled</span><span class="p">(</span><span class="n">enic</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pci_disable_sriov</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">enic</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ENIC_SRIOV_ENABLED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">err_out_vnic_unregister:</span>
<span class="cp">#endif</span>
	<span class="n">vnic_dev_unregister</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
<span class="nl">err_out_iounmap:</span>
	<span class="n">enic_iounmap</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
<span class="nl">err_out_release_regions:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">err_out_disable_device:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">err_out_free_netdev:</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">enic_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">enic</span> <span class="o">*</span><span class="n">enic</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">);</span>
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">change_mtu_work</span><span class="p">);</span>
		<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">enic_dev_deinit</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
		<span class="n">vnic_dev_close</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PCI_IOV</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enic_sriov_enabled</span><span class="p">(</span><span class="n">enic</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pci_disable_sriov</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
			<span class="n">enic</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ENIC_SRIOV_ENABLED</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">);</span>
		<span class="n">vnic_dev_unregister</span><span class="p">(</span><span class="n">enic</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
		<span class="n">enic_iounmap</span><span class="p">(</span><span class="n">enic</span><span class="p">);</span>
		<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">enic_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">enic_id_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">enic_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">enic_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">enic_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s, ver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DRV_DESCRIPTION</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">enic_cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enic_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">enic_init_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">enic_cleanup_module</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
