<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › 3com › 3c501.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>3c501.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* 3c501.c: A 3Com 3c501 Ethernet driver for Linux. */</span>
<span class="cm">/*</span>
<span class="cm">    Written 1992,1993,1994  Donald Becker</span>

<span class="cm">    Copyright 1993 United States Government as represented by the</span>
<span class="cm">    Director, National Security Agency.  This software may be used and</span>
<span class="cm">    distributed according to the terms of the GNU General Public License,</span>
<span class="cm">    incorporated herein by reference.</span>

<span class="cm">    This is a device driver for the 3Com Etherlink 3c501.</span>
<span class="cm">    Do not purchase this card, even as a joke.  It&#39;s performance is horrible,</span>
<span class="cm">    and it breaks in many ways.</span>

<span class="cm">    The original author may be reached as becker@scyld.com, or C/O</span>
<span class="cm">	Scyld Computing Corporation</span>
<span class="cm">	410 Severn Ave., Suite 210</span>
<span class="cm">	Annapolis MD 21403</span>

<span class="cm">    Fixed (again!) the missing interrupt locking on TX/RX shifting.</span>
<span class="cm">	Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</span>

<span class="cm">    Removed calls to init_etherdev since they are no longer needed, and</span>
<span class="cm">    cleaned up modularization just a bit. The driver still allows only</span>
<span class="cm">    the default address for cards when loaded as a module, but that&#39;s</span>
<span class="cm">    really less braindead than anyone using a 3c501 board. :)</span>
<span class="cm">		    19950208 (invid@msen.com)</span>

<span class="cm">    Added traps for interrupts hitting the window as we clear and TX load</span>
<span class="cm">    the board. Now getting 150K/second FTP with a 3c501 card. Still playing</span>
<span class="cm">    with a TX-TX optimisation to see if we can touch 180-200K/second as seems</span>
<span class="cm">    theoretically maximum.</span>
<span class="cm">		19950402 Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</span>

<span class="cm">    Cleaned up for 2.3.x because we broke SMP now.</span>
<span class="cm">		20000208 Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</span>

<span class="cm">    Check up pass for 2.5. Nothing significant changed</span>
<span class="cm">		20021009 Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</span>

<span class="cm">    Fixed zero fill corner case</span>
<span class="cm">		20030104 Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</span>


<span class="cm">   For the avoidance of doubt the &quot;preferred form&quot; of this code is one which</span>
<span class="cm">   is in an open non patent encumbered format. Where cryptographic key signing</span>
<span class="cm">   forms part of the process of creating an executable the information</span>
<span class="cm">   including keys needed to generate an equivalently functional executable</span>
<span class="cm">   are deemed to be part of the source code.</span>

<span class="cm">*/</span>


<span class="cm">/**</span>
<span class="cm"> * DOC: 3c501 Card Notes</span>
<span class="cm"> *</span>
<span class="cm"> *  Some notes on this thing if you have to hack it.  [Alan]</span>
<span class="cm"> *</span>
<span class="cm"> *  Some documentation is available from 3Com. Due to the boards age</span>
<span class="cm"> *  standard responses when you ask for this will range from &#39;be serious&#39;</span>
<span class="cm"> *  to &#39;give it to a museum&#39;. The documentation is incomplete and mostly</span>
<span class="cm"> *  of historical interest anyway.</span>
<span class="cm"> *</span>
<span class="cm"> *  The basic system is a single buffer which can be used to receive or</span>
<span class="cm"> *  transmit a packet. A third command mode exists when you are setting</span>
<span class="cm"> *  things up.</span>
<span class="cm"> *</span>
<span class="cm"> *  If it&#39;s transmitting it&#39;s not receiving and vice versa. In fact the</span>
<span class="cm"> *  time to get the board back into useful state after an operation is</span>
<span class="cm"> *  quite large.</span>
<span class="cm"> *</span>
<span class="cm"> *  The driver works by keeping the board in receive mode waiting for a</span>
<span class="cm"> *  packet to arrive. When one arrives it is copied out of the buffer</span>
<span class="cm"> *  and delivered to the kernel. The card is reloaded and off we go.</span>
<span class="cm"> *</span>
<span class="cm"> *  When transmitting lp-&gt;txing is set and the card is reset (from</span>
<span class="cm"> *  receive mode) [possibly losing a packet just received] to command</span>
<span class="cm"> *  mode. A packet is loaded and transmit mode triggered. The interrupt</span>
<span class="cm"> *  handler runs different code for transmit interrupts and can handle</span>
<span class="cm"> *  returning to receive mode or retransmissions (yes you have to help</span>
<span class="cm"> *  out with those too).</span>
<span class="cm"> *</span>
<span class="cm"> * DOC: Problems</span>
<span class="cm"> *</span>
<span class="cm"> *  There are a wide variety of undocumented error returns from the card</span>
<span class="cm"> *  and you basically have to kick the board and pray if they turn up. Most</span>
<span class="cm"> *  only occur under extreme load or if you do something the board doesn&#39;t</span>
<span class="cm"> *  like (eg touching a register at the wrong time).</span>
<span class="cm"> *</span>
<span class="cm"> *  The driver is less efficient than it could be. It switches through</span>
<span class="cm"> *  receive mode even if more transmits are queued. If this worries you buy</span>
<span class="cm"> *  a real Ethernet card.</span>
<span class="cm"> *</span>
<span class="cm"> *  The combination of slow receive restart and no real multicast</span>
<span class="cm"> *  filter makes the board unusable with a kernel compiled for IP</span>
<span class="cm"> *  multicasting in a real multicast environment. That&#39;s down to the board,</span>
<span class="cm"> *  but even with no multicast programs running a multicast IP kernel is</span>
<span class="cm"> *  in group 224.0.0.1 and you will therefore be listening to all multicasts.</span>
<span class="cm"> *  One nv conference running over that Ethernet and you can give up.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define DRV_NAME	&quot;3c501&quot;</span>
<span class="cp">#define DRV_VERSION	&quot;2002/10/09&quot;</span>


<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="o">=</span>
	<span class="n">DRV_NAME</span> <span class="s">&quot;.c: &quot;</span> <span class="n">DRV_VERSION</span> <span class="s">&quot; Alan Cox (alan@lxorguk.ukuu.org.uk).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	Braindamage remaining:</span>
<span class="cm"> *	The 3c501 board.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &quot;3c501.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *	The boilerplate probe code.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">io</span> <span class="o">=</span> <span class="mh">0x280</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mem_start</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * el1_probe:		-	probe for a 3c501</span>
<span class="cm"> * @dev: The device structure passed in to probe.</span>
<span class="cm"> *</span>
<span class="cm"> * This can be called from two places. The network layer will probe using</span>
<span class="cm"> * a device structure passed in with the probe information completed. For a</span>
<span class="cm"> * modular driver we use #init_module to fill in our own structure and probe</span>
<span class="cm"> * for it.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success. ENXIO if asked not to probe and ENODEV if asked to</span>
<span class="cm"> * probe and failing to find anything.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">el1_probe</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_local</span><span class="p">));</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">ports</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x280</span><span class="p">,</span> <span class="mh">0x300</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unit</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;eth%d&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
		<span class="n">netdev_boot_setup_check</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">io</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="n">mem_start</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">io</span> <span class="o">&gt;</span> <span class="mh">0x1ff</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Check a single specified location. */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">el1_probe1</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">io</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">io</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>		<span class="cm">/* Don&#39;t probe at all. */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="n">ports</span><span class="p">;</span> <span class="o">*</span><span class="n">port</span> <span class="o">&amp;&amp;</span> <span class="n">el1_probe1</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span>
			<span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">port</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="nl">out1:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">EL1_IO_EXTENT</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">el_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">el_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">el1_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> 	<span class="o">=</span> <span class="n">el_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">el_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">set_multicast_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">eth_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> 	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	el1_probe1:</span>
<span class="cm"> *	@dev: The device structure to use</span>
<span class="cm"> *	@ioaddr: An I/O address to probe at.</span>
<span class="cm"> *</span>
<span class="cm"> *	The actual probe. This is iterated over by #el1_probe in order to</span>
<span class="cm"> *	check all the applicable device locations.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 for a success, in which case the device is activated,</span>
<span class="cm"> *	EAGAIN if the IRQ is in use by another driver, and ENODEV if the</span>
<span class="cm"> *	board cannot be found.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">el1_probe1</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mname</span><span class="p">;</span>		<span class="cm">/* Vendor name */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">station_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">autoirq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Reserve I/O resource for exclusive use by this driver</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">EL1_IO_EXTENT</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Read the station address PROM data from the special port.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EL1_DATAPTR</span><span class="p">);</span>
		<span class="n">station_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EL1_SAPROM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Check the first three octets of the S.A. for 3Com&#39;s prefix, or</span>
<span class="cm">	 *	for the Sager NP943 prefix.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">station_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x02</span> <span class="o">&amp;&amp;</span> <span class="n">station_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x60</span> <span class="o">&amp;&amp;</span>
	    <span class="n">station_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x8c</span><span class="p">)</span>
		<span class="n">mname</span> <span class="o">=</span> <span class="s">&quot;3c501&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">station_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span> <span class="n">station_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x80</span> <span class="o">&amp;&amp;</span>
		 <span class="n">station_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xC8</span><span class="p">)</span>
		<span class="n">mname</span> <span class="o">=</span> <span class="s">&quot;NP943&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">EL1_IO_EXTENT</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	We auto-IRQ by shutting off the interrupt line and letting it</span>
<span class="cm">	 *	float high.</span>
<span class="cm">	 */</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_mask</span><span class="p">;</span>

		<span class="n">irq_mask</span> <span class="o">=</span> <span class="n">probe_irq_on</span><span class="p">();</span>
		<span class="n">inb</span><span class="p">(</span><span class="n">RX_STATUS</span><span class="p">);</span>		<span class="cm">/* Clear pending interrupts. */</span>
		<span class="n">inb</span><span class="p">(</span><span class="n">TX_STATUS</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">AX_LOOP</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>

		<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>

		<span class="n">mdelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="n">autoirq</span> <span class="o">=</span> <span class="n">probe_irq_off</span><span class="p">(</span><span class="n">irq_mask</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">autoirq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s probe at %#x failed to detect IRQ line.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mname</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">);</span>
			<span class="n">release_region</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">EL1_IO_EXTENT</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">AX_RESET</span><span class="o">+</span><span class="n">AX_LOOP</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>			<span class="cm">/* Loopback mode. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">station_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_start</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span>
		<span class="n">el_debug</span> <span class="o">=</span> <span class="n">mem_start</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">autoirq</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">autoirq</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: %s EtherLink at %#lx, using %sIRQ %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mname</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span>
			<span class="n">autoirq</span> <span class="o">?</span> <span class="s">&quot;auto&quot;</span><span class="o">:</span><span class="s">&quot;assigned &quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IP_MULTICAST</span>
	<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;WARNING: Use of the 3c501 in a multicast kernel is NOT recommended.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_local</span><span class="p">));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	The EL1-specific entries in the device structure.</span>
<span class="cm">	 */</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">el_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">netdev_ethtool_ops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	el1_open:</span>
<span class="cm"> *	@dev: device that is being opened</span>
<span class="cm"> *</span>
<span class="cm"> *	When an ifconfig is issued which changes the device flags to include</span>
<span class="cm"> *	IFF_UP this function is called. It is only called when the change</span>
<span class="cm"> *	occurs, not when the interface remains up. #el1_close will be called</span>
<span class="cm"> *	when it goes down.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 for a successful open, or -EAGAIN if someone has run off</span>
<span class="cm"> *	with our interrupt line.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">el_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Doing el_open()...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">el_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">el_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">txing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Board in RX mode */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">AX_RX</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>	<span class="cm">/* Aux control, irq and receive enabled */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * el_timeout:</span>
<span class="cm"> * @dev: The 3c501 card that has timed out</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to restart the board. This is basically a mixture of extreme</span>
<span class="cm"> * violence and prayer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">el_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: transmit timed out, txsr %#2x axsr=%02x rxsr=%02x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">inb</span><span class="p">(</span><span class="n">TX_STATUS</span><span class="p">),</span>
			<span class="n">inb</span><span class="p">(</span><span class="n">AX_STATUS</span><span class="p">),</span> <span class="n">inb</span><span class="p">(</span><span class="n">RX_STATUS</span><span class="p">));</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">TX_NORM</span><span class="p">,</span> <span class="n">TX_CMD</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">RX_NORM</span><span class="p">,</span> <span class="n">RX_CMD</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">AX_OFF</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>	<span class="cm">/* Just trigger a false interrupt. */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">AX_RX</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>	<span class="cm">/* Aux control, irq and receive enabled */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">txing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Ripped back in to RX */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * el_start_xmit:</span>
<span class="cm"> * @skb: The packet that is queued to be sent</span>
<span class="cm"> * @dev: The 3c501 card we want to throw it down</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to send a packet to a 3c501 card. There are some interesting</span>
<span class="cm"> * catches here because the 3c501 is an extremely old and therefore</span>
<span class="cm"> * stupid piece of technology.</span>
<span class="cm"> *</span>
<span class="cm"> * If we are handling an interrupt on the other CPU we cannot load a packet</span>
<span class="cm"> * as we may still be attempting to retrieve the last RX packet buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * When a transmit times out we dump the card into control mode and just</span>
<span class="cm"> * start again. It happens enough that it isn&#39;t worth logging.</span>
<span class="cm"> *</span>
<span class="cm"> * We avoid holding the spin locks when doing the packet load to the board.</span>
<span class="cm"> * The device is very slow, and its DMA mode is even slower. If we held the</span>
<span class="cm"> * lock while loading 1500 bytes onto the controller we would drop a lot of</span>
<span class="cm"> * serial port characters. This requires we do extra locking, but we have</span>
<span class="cm"> * no real choice.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">el_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Avoid incoming interrupts between us flipping txing and flipping</span>
<span class="cm">	 *	mode as the driver assumes txing is a faithful indicator of card</span>
<span class="cm">	 *	state</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Avoid timer-based retransmission conflicts.</span>
<span class="cm">	 */</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">gp_start</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ETH_ZLEN</span><span class="p">)</span>
			<span class="n">pad</span> <span class="o">=</span> <span class="n">ETH_ZLEN</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">gp_start</span> <span class="o">=</span> <span class="mh">0x800</span> <span class="o">-</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">pad</span><span class="p">);</span>

		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_pkt_start</span> <span class="o">=</span> <span class="n">gp_start</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">collisions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	Command mode with status cleared should [in theory]</span>
<span class="cm">		 *	mean no more interrupts can be pending on the card.</span>
<span class="cm">		 */</span>

		<span class="n">outb_p</span><span class="p">(</span><span class="n">AX_SYS</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>
		<span class="n">inb_p</span><span class="p">(</span><span class="n">RX_STATUS</span><span class="p">);</span>
		<span class="n">inb_p</span><span class="p">(</span><span class="n">TX_STATUS</span><span class="p">);</span>

		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">loading</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">txing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	Turn interrupts back on while we spend a pleasant</span>
<span class="cm">		 *	afternoon loading bytes into the board</span>
<span class="cm">		 */</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Set rx packet area to 0. */</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">RX_BUF_CLR</span><span class="p">);</span>
		<span class="cm">/* aim - packet will be loaded into buffer start */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">gp_start</span><span class="p">,</span> <span class="n">GP_LOW</span><span class="p">);</span>
		<span class="cm">/* load buffer (usual thing each byte increments the pointer) */</span>
		<span class="n">outsb</span><span class="p">(</span><span class="n">DATAPORT</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pad</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">pad</span><span class="o">--</span><span class="p">)</span>		<span class="cm">/* Zero fill buffer tail */</span>
				<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">DATAPORT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* the board reuses the same register */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">gp_start</span><span class="p">,</span> <span class="n">GP_LOW</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">loading</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* fire ... Trigger xmit.  */</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">AX_XMIT</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">loading</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; queued xmit.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* A receive upset our load, despite our best efforts */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: burped during tx load.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * el_interrupt:</span>
<span class="cm"> * @irq: Interrupt number</span>
<span class="cm"> * @dev_id: The 3c501 that burped</span>
<span class="cm"> *</span>
<span class="cm"> * Handle the ether interface interrupts. The 3c501 needs a lot more</span>
<span class="cm"> * hand holding than most cards. In particular we get a transmit interrupt</span>
<span class="cm"> * with a collision error because the board firmware isn&#39;t capable of rewinding</span>
<span class="cm"> * its own transmit buffer pointers. It can however count to 16 for us.</span>
<span class="cm"> *</span>
<span class="cm"> * On the receive side the card is also very dumb. It has no buffering to</span>
<span class="cm"> * speak of. We simply pull the packet out of its PIO buffer (which is slow)</span>
<span class="cm"> * and queue it for the kernel. Then we reset the card for the next packet.</span>
<span class="cm"> *</span>
<span class="cm"> * We sometimes get surprise interrupts late both because the SMP IRQ delivery</span>
<span class="cm"> * is message passing and because the card sometimes seems to deliver late. I</span>
<span class="cm"> * think if it is part way through a receive and the mode is changed it carries</span>
<span class="cm"> * on receiving and sends us an interrupt. We have to band aid all these cases</span>
<span class="cm"> * to get a sensible 150kBytes/second performance. Even then you want a small</span>
<span class="cm"> * TCP window.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">el_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">axsr</span><span class="p">;</span>			<span class="cm">/* Aux. status reg. */</span>

	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	What happened ?</span>
<span class="cm">	 */</span>

	<span class="n">axsr</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">AX_STATUS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Log it</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: el_interrupt() aux=%#02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">axsr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">loading</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">txing</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Inconsistent state loading while not in tx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">txing</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Board in transmit mode. May be loading. If we are</span>
<span class="cm">		 *	loading we shouldn&#39;t have got this.</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">txsr</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">TX_STATUS</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">loading</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Interrupt while loading [txsr=%02x gp=%04x rp=%04x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">txsr</span><span class="p">,</span> <span class="n">inw</span><span class="p">(</span><span class="n">GP_LOW</span><span class="p">),</span> <span class="n">inw</span><span class="p">(</span><span class="n">RX_LOW</span><span class="p">));</span>

			<span class="cm">/* Force a reload */</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">loading</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: txsr=%02x gp=%04x rp=%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="n">txsr</span><span class="p">,</span> <span class="n">inw</span><span class="p">(</span><span class="n">GP_LOW</span><span class="p">),</span> <span class="n">inw</span><span class="p">(</span><span class="n">RX_LOW</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">axsr</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">txsr</span> <span class="o">&amp;</span> <span class="n">TX_READY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *	FIXME: is there a logic to whether to keep</span>
<span class="cm">			 *	on trying or reset immediately ?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Unusual interrupt during Tx, txsr=%02x axsr=%02x gp=%03x rp=%03x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">txsr</span><span class="p">,</span> <span class="n">axsr</span><span class="p">,</span>
					<span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EL1_DATAPTR</span><span class="p">),</span>
					<span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EL1_RXPTR</span><span class="p">));</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">txing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">txsr</span> <span class="o">&amp;</span> <span class="n">TX_16COLLISIONS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *	Timed out</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span><span class="p">)</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Transmit failed 16 times, Ethernet jammed?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">AX_SYS</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">txing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">txsr</span> <span class="o">&amp;</span> <span class="n">TX_COLLISION</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *	Retrigger xmit.</span>
<span class="cm">			 */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: retransmitting after a collision.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 *	Poor little chip can&#39;t reset its own start</span>
<span class="cm">			 *	pointer</span>
<span class="cm">			 */</span>

			<span class="n">outb</span><span class="p">(</span><span class="n">AX_SYS</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_pkt_start</span><span class="p">,</span> <span class="n">GP_LOW</span><span class="p">);</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">AX_XMIT</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *	It worked.. we will now fall through and receive</span>
<span class="cm">			 */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Tx succeeded %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="p">(</span><span class="n">txsr</span> <span class="o">&amp;</span> <span class="n">TX_RDY</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;.&quot;</span> <span class="o">:</span> <span class="s">&quot;but tx is busy!&quot;</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 *	This is safe the interrupt is atomic WRT itself.</span>
<span class="cm">			 */</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">txing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* In case more to transmit */</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	In receive mode.</span>
<span class="cm">		 */</span>

		<span class="kt">int</span> <span class="n">rxsr</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">RX_STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: rxsr=%02x txsr=%02x rp=%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rxsr</span><span class="p">,</span> <span class="n">inb</span><span class="p">(</span><span class="n">TX_STATUS</span><span class="p">),</span> <span class="n">inw</span><span class="p">(</span><span class="n">RX_LOW</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Just reading rx_status fixes most errors.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rxsr</span> <span class="o">&amp;</span> <span class="n">RX_MISSED</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_missed_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rxsr</span> <span class="o">&amp;</span> <span class="n">RX_RUNT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Handled to avoid board lock-up. */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: runt.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rxsr</span> <span class="o">&amp;</span> <span class="n">RX_GOOD</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *	Receive worked.</span>
<span class="cm">			 */</span>
			<span class="n">el_receive</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *	Nothing?  Something is broken!</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: No packet seen, rxsr=%02x **resetting 3c501***</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rxsr</span><span class="p">);</span>
			<span class="n">el_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Move into receive mode</span>
<span class="cm">	 */</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">AX_RX</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">RX_BUF_CLR</span><span class="p">);</span>
	<span class="n">inb</span><span class="p">(</span><span class="n">RX_STATUS</span><span class="p">);</span>		<span class="cm">/* Be certain that interrupts are cleared. */</span>
	<span class="n">inb</span><span class="p">(</span><span class="n">TX_STATUS</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * el_receive:</span>
<span class="cm"> * @dev: Device to pull the packets from</span>
<span class="cm"> *</span>
<span class="cm"> * We have a good packet. Well, not really &quot;good&quot;, just mostly not broken.</span>
<span class="cm"> * We must check everything to see if it is good. In particular we occasionally</span>
<span class="cm"> * get wild packet sizes from the card. If the packet seems sane we PIO it</span>
<span class="cm"> * off the card and queue it for the protocol layers.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">el_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pkt_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">pkt_len</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">RX_LOW</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; el_receive %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&lt;</span> <span class="mi">60</span> <span class="o">||</span> <span class="n">pkt_len</span> <span class="o">&gt;</span> <span class="mi">1536</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: bogus packet, length=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Command mode so we can empty the buffer</span>
<span class="cm">	 */</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">AX_SYS</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pkt_len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Start of frame</span>
<span class="cm">	 */</span>

	<span class="n">outw</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">GP_LOW</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: Memory squeeze, dropping packet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* Force 16 byte alignment */</span>
		<span class="cm">/*</span>
<span class="cm">		 *	The read increments through the bytes. The interrupt</span>
<span class="cm">		 *	handler will fix the pointer when it returns to</span>
<span class="cm">		 *	receive mode.</span>
<span class="cm">		 */</span>
		<span class="n">insb</span><span class="p">(</span><span class="n">DATAPORT</span><span class="p">,</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">),</span> <span class="n">pkt_len</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">pkt_len</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * el_reset: Reset a 3c501 card</span>
<span class="cm"> * @dev: The 3c501 card about to get zapped</span>
<span class="cm"> *</span>
<span class="cm"> * Even resetting a 3c501 isn&#39;t simple. When you activate reset it loses all</span>
<span class="cm"> * its configuration. You must hold the lock when doing this. The function</span>
<span class="cm"> * cannot take the lock itself as it is callable from the irq handler.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>  <span class="nf">el_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;3c501 reset...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">AX_RESET</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>		<span class="cm">/* Reset the chip */</span>
	<span class="cm">/* Aux control, irq and loopback enabled */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">AX_LOOP</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>	<span class="cm">/* Set the station address. */</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">RX_BUF_CLR</span><span class="p">);</span>		<span class="cm">/* Set rx packet area to 0. */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">TX_NORM</span><span class="p">,</span> <span class="n">TX_CMD</span><span class="p">);</span>		<span class="cm">/* tx irq on done, collision */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">RX_NORM</span><span class="p">,</span> <span class="n">RX_CMD</span><span class="p">);</span>		<span class="cm">/* Set Rx commands. */</span>
	<span class="n">inb</span><span class="p">(</span><span class="n">RX_STATUS</span><span class="p">);</span>			<span class="cm">/* Clear status. */</span>
	<span class="n">inb</span><span class="p">(</span><span class="n">TX_STATUS</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">txing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * el1_close:</span>
<span class="cm"> * @dev: 3c501 card to shut down</span>
<span class="cm"> *</span>
<span class="cm"> * Close a 3c501 card. The IFF_UP flag has been cleared by the user via</span>
<span class="cm"> * the SIOCSIFFLAGS ioctl. We stop any further transmissions being queued,</span>
<span class="cm"> * and then disable the interrupts. Finally we reset the chip. The effects</span>
<span class="cm"> * of the rest will be cleaned up by #el1_open. Always returns 0 indicating</span>
<span class="cm"> * a success.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">el1_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">el_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: Shutting down Ethernet card at %#x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Free and disable the IRQ.</span>
<span class="cm">	 */</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">AX_RESET</span><span class="p">,</span> <span class="n">AX_CMD</span><span class="p">);</span>		<span class="cm">/* Reset the chip */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * set_multicast_list:</span>
<span class="cm"> * @dev: The device to adjust</span>
<span class="cm"> *</span>
<span class="cm"> * Set or clear the multicast filter for this adaptor to use the best-effort</span>
<span class="cm"> * filtering supported. The 3c501 supports only three modes of filtering.</span>
<span class="cm"> * It always receives broadcasts and packets for itself. You can choose to</span>
<span class="cm"> * optionally receive all packets, or all multicast packets on top of this.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">RX_PROM</span><span class="p">,</span> <span class="n">RX_CMD</span><span class="p">);</span>
		<span class="n">inb</span><span class="p">(</span><span class="n">RX_STATUS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev_mc_empty</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Multicast or all multicast is the same */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">RX_MULT</span><span class="p">,</span> <span class="n">RX_CMD</span><span class="p">);</span>
		<span class="n">inb</span><span class="p">(</span><span class="n">RX_STATUS</span><span class="p">);</span>		<span class="cm">/* Clear status. */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">RX_NORM</span><span class="p">,</span> <span class="n">RX_CMD</span><span class="p">);</span>
		<span class="n">inb</span><span class="p">(</span><span class="n">RX_STATUS</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">);</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="s">&quot;ISA 0x%lx&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">netdev_get_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">debug</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_set_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">netdev_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_drvinfo</span>		<span class="o">=</span> <span class="n">netdev_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span>		<span class="o">=</span> <span class="n">netdev_get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span>		<span class="o">=</span> <span class="n">netdev_set_msglevel</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef MODULE</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev_3c501</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;EtherLink I/O base address&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="s">&quot;EtherLink IRQ number&quot;</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * init_module:</span>
<span class="cm"> *</span>
<span class="cm"> * When the driver is loaded as a module this function is called. We fake up</span>
<span class="cm"> * a device structure with the base I/O and interrupt set as if it were being</span>
<span class="cm"> * called from Space.c. This minimises the extra code that would otherwise</span>
<span class="cm"> * be required.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success or -EIO if a card is not found. Returning an error</span>
<span class="cm"> * here also causes the module to be unloaded</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_3c501</span> <span class="o">=</span> <span class="n">el1_probe</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_3c501</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dev_3c501</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cleanup_module:</span>
<span class="cm"> *</span>
<span class="cm"> * The module is being unloaded. We unhook our network device from the system</span>
<span class="cm"> * and then free up the resources we took when the card was found.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_3c501</span><span class="p">;</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">EL1_IO_EXTENT</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* MODULE */</span><span class="cp"></span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Donald Becker, Alan Cox&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Support for the ancient 3Com 3c501 ethernet card&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
