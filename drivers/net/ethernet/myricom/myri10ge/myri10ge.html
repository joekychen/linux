<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › myricom › myri10ge › myri10ge.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>myri10ge.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*************************************************************************</span>
<span class="cm"> * myri10ge.c: Myricom Myri-10G Ethernet driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005 - 2011 Myricom, Inc.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *    documentation and/or other materials provided with the distribution.</span>
<span class="cm"> * 3. Neither the name of Myricom, Inc. nor the names of its contributors</span>
<span class="cm"> *    may be used to endorse or promote products derived from this software</span>
<span class="cm"> *    without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="cm"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="cm"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="cm"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="cm"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="cm"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="cm"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="cm"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * If the eeprom on your board is not recent enough, you will need to get a</span>
<span class="cm"> * newer firmware image at:</span>
<span class="cm"> *   http://www.myri.com/scs/download-Myri10GE.html</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> *   &lt;help@myri.com&gt;</span>
<span class="cm"> *   Myricom, Inc., 325N Santa Anita Avenue, Arcadia, CA 91006</span>
<span class="cm"> *************************************************************************/</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/inet_lro.h&gt;</span>
<span class="cp">#include &lt;linux/dca.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#ifdef CONFIG_MTRR</span>
<span class="cp">#include &lt;asm/mtrr.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &quot;myri10ge_mcp.h&quot;</span>
<span class="cp">#include &quot;myri10ge_mcp_gen_header.h&quot;</span>

<span class="cp">#define MYRI10GE_VERSION_STR &quot;1.5.3-1.534&quot;</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Myricom 10G driver (10GbE)&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Maintainer: help@myri.com&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">MYRI10GE_VERSION_STR</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;Dual BSD/GPL&quot;</span><span class="p">);</span>

<span class="cp">#define MYRI10GE_MAX_ETHER_MTU 9014</span>

<span class="cp">#define MYRI10GE_ETH_STOPPED 0</span>
<span class="cp">#define MYRI10GE_ETH_STOPPING 1</span>
<span class="cp">#define MYRI10GE_ETH_STARTING 2</span>
<span class="cp">#define MYRI10GE_ETH_RUNNING 3</span>
<span class="cp">#define MYRI10GE_ETH_OPEN_FAILED 4</span>

<span class="cp">#define MYRI10GE_EEPROM_STRINGS_SIZE 256</span>
<span class="cp">#define MYRI10GE_MAX_SEND_DESC_TSO ((65536 / 2048) * 2)</span>
<span class="cp">#define MYRI10GE_MAX_LRO_DESCRIPTORS 8</span>
<span class="cp">#define MYRI10GE_LRO_MAX_PKTS 64</span>

<span class="cp">#define MYRI10GE_NO_CONFIRM_DATA htonl(0xffffffff)</span>
<span class="cp">#define MYRI10GE_NO_RESPONSE_RESULT 0xffffffff</span>

<span class="cp">#define MYRI10GE_ALLOC_ORDER 0</span>
<span class="cp">#define MYRI10GE_ALLOC_SIZE ((1 &lt;&lt; MYRI10GE_ALLOC_ORDER) * PAGE_SIZE)</span>
<span class="cp">#define MYRI10GE_MAX_FRAGS_PER_FRAME (MYRI10GE_MAX_ETHER_MTU/MYRI10GE_ALLOC_SIZE + 1)</span>

<span class="cp">#define MYRI10GE_MAX_SLICES 32</span>

<span class="k">struct</span> <span class="n">myri10ge_rx_buffer_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_offset</span><span class="p">;</span>
	<span class="n">DEFINE_DMA_UNMAP_ADDR</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">DEFINE_DMA_UNMAP_LEN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">myri10ge_tx_buffer_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last</span><span class="p">;</span>
	<span class="n">DEFINE_DMA_UNMAP_ADDR</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">DEFINE_DMA_UNMAP_LEN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">data0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">myri10ge_rx_buf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp_kreq_ether_recv</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">lanai</span><span class="p">;</span>	<span class="cm">/* lanai ptr for recv ring */</span>
	<span class="k">struct</span> <span class="n">mcp_kreq_ether_recv</span> <span class="o">*</span><span class="n">shadow</span><span class="p">;</span>	<span class="cm">/* host shadow of recv ring */</span>
	<span class="k">struct</span> <span class="n">myri10ge_rx_buffer_state</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fill_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alloc_fail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>		<span class="cm">/* number of rx slots -1 */</span>
	<span class="kt">int</span> <span class="n">watchdog_needed</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">myri10ge_tx_buf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp_kreq_ether_send</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">lanai</span><span class="p">;</span>	<span class="cm">/* lanai ptr for sendq */</span>
	<span class="n">__be32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">send_go</span><span class="p">;</span>	<span class="cm">/* &quot;go&quot; doorbell ptr */</span>
	<span class="n">__be32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">send_stop</span><span class="p">;</span>	<span class="cm">/* &quot;stop&quot; doorbell ptr */</span>
	<span class="k">struct</span> <span class="n">mcp_kreq_ether_send</span> <span class="o">*</span><span class="n">req_list</span><span class="p">;</span>	<span class="cm">/* host shadow of sendq */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">req_bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_tx_buffer_state</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>		<span class="cm">/* number of transmit slots -1  */</span>
	<span class="kt">int</span> <span class="n">req</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>	<span class="cm">/* transmit slots submitted     */</span>
	<span class="kt">int</span> <span class="n">pkt_start</span><span class="p">;</span>		<span class="cm">/* packets started */</span>
	<span class="kt">int</span> <span class="n">stop_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">linearized</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>	<span class="cm">/* transmit slots completed     */</span>
	<span class="kt">int</span> <span class="n">pkt_done</span><span class="p">;</span>		<span class="cm">/* packets completed */</span>
	<span class="kt">int</span> <span class="n">wake_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">queue_active</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">myri10ge_rx_done</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp_slot</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_lro_mgr</span> <span class="n">lro_mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_lro_desc</span> <span class="n">lro_desc</span><span class="p">[</span><span class="n">MYRI10GE_MAX_LRO_DESCRIPTORS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">myri10ge_slice_netstats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_packets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tx_packets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tx_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_dropped</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tx_dropped</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_tx_buf</span> <span class="n">tx</span><span class="p">;</span>	<span class="cm">/* transmit ring        */</span>
	<span class="k">struct</span> <span class="n">myri10ge_rx_buf</span> <span class="n">rx_small</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_rx_buf</span> <span class="n">rx_big</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_rx_done</span> <span class="n">rx_done</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_netstats</span> <span class="n">stats</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">irq_claim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp_irq_data</span> <span class="o">*</span><span class="n">fw_stats</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">fw_stats_bus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">watchdog_tx_done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">watchdog_tx_req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">watchdog_rx_done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stuck</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
	<span class="kt">int</span> <span class="n">cached_dca_tag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">dca_tag</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">char</span> <span class="n">irq_desc</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_boundary</span><span class="p">;</span>	<span class="cm">/* boundary transmits cannot cross */</span>
	<span class="kt">int</span> <span class="n">num_slices</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">running</span><span class="p">;</span>		<span class="cm">/* running?             */</span>
	<span class="kt">int</span> <span class="n">small_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">big_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_intr_slots</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sram</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sram_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">board_span</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iomem_base</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">irq_deassert</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mac_addr_string</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp_cmd_response</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">cmd_bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">msi_enabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">msix_enabled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="o">*</span><span class="n">msix_vectors</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
	<span class="kt">int</span> <span class="n">dca_enabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">relaxed_order</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">u32</span> <span class="n">link_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rdma_tags_available</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">intr_coal_delay</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">intr_coal_delay_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtrr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wc_enabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">down_cnt</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">down_wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">watchdog_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">watchdog_timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">watchdog_resets</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">watchdog_pause</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pause</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fw_name_allocated</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fw_name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">eeprom_strings</span><span class="p">[</span><span class="n">MYRI10GE_EEPROM_STRINGS_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">product_code_string</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">fw_version</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">fw_ver_major</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fw_ver_minor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fw_ver_tiny</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">adopted_rx_filter_bug</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>		<span class="cm">/* eeprom mac address */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">serial_number</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vendor_specific_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fw_multicast_support</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">features</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_tso6</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">read_dma</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">write_dma</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">read_write_dma</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">link_changes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_enable</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">board_number</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rebooted</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">myri10ge_fw_unaligned</span> <span class="o">=</span> <span class="s">&quot;myri10ge_ethp_z8e.dat&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">myri10ge_fw_aligned</span> <span class="o">=</span> <span class="s">&quot;myri10ge_eth_z8e.dat&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">myri10ge_fw_rss_unaligned</span> <span class="o">=</span> <span class="s">&quot;myri10ge_rss_ethp_z8e.dat&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">myri10ge_fw_rss_aligned</span> <span class="o">=</span> <span class="s">&quot;myri10ge_rss_eth_z8e.dat&quot;</span><span class="p">;</span>
<span class="n">MODULE_FIRMWARE</span><span class="p">(</span><span class="s">&quot;myri10ge_ethp_z8e.dat&quot;</span><span class="p">);</span>
<span class="n">MODULE_FIRMWARE</span><span class="p">(</span><span class="s">&quot;myri10ge_eth_z8e.dat&quot;</span><span class="p">);</span>
<span class="n">MODULE_FIRMWARE</span><span class="p">(</span><span class="s">&quot;myri10ge_rss_ethp_z8e.dat&quot;</span><span class="p">);</span>
<span class="n">MODULE_FIRMWARE</span><span class="p">(</span><span class="s">&quot;myri10ge_rss_eth_z8e.dat&quot;</span><span class="p">);</span>

<span class="cm">/* Careful: must be accessed under kparam_block_sysfs_write */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">myri10ge_fw_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_fw_name</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_fw_name</span><span class="p">,</span> <span class="s">&quot;Firmware image name&quot;</span><span class="p">);</span>

<span class="cp">#define MYRI10GE_MAX_BOARDS 8</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">myri10ge_fw_names</span><span class="p">[</span><span class="n">MYRI10GE_MAX_BOARDS</span><span class="p">]</span> <span class="o">=</span>
    <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="p">(</span><span class="n">MYRI10GE_MAX_BOARDS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">};</span>
<span class="n">module_param_array_named</span><span class="p">(</span><span class="n">myri10ge_fw_names</span><span class="p">,</span> <span class="n">myri10ge_fw_names</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			 <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_fw_name</span><span class="p">,</span> <span class="s">&quot;Firmware image names per board&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_ecrc_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_ecrc_enable</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_ecrc_enable</span><span class="p">,</span> <span class="s">&quot;Enable Extended CRC on PCI-E&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_small_bytes</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* -1 == auto */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_small_bytes</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_small_bytes</span><span class="p">,</span> <span class="s">&quot;Threshold of small packets&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_msi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* enable msi by default */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_msi</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_msi</span><span class="p">,</span> <span class="s">&quot;Enable Message Signalled Interrupts&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_intr_coal_delay</span> <span class="o">=</span> <span class="mi">75</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_intr_coal_delay</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_intr_coal_delay</span><span class="p">,</span> <span class="s">&quot;Interrupt coalescing delay&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_flow_control</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_flow_control</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_flow_control</span><span class="p">,</span> <span class="s">&quot;Pause parameter&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_deassert_wait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_deassert_wait</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_deassert_wait</span><span class="p">,</span>
		 <span class="s">&quot;Wait when deasserting legacy interrupts&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_force_firmware</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_force_firmware</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_force_firmware</span><span class="p">,</span>
		 <span class="s">&quot;Force firmware to assume aligned completions&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_initial_mtu</span> <span class="o">=</span> <span class="n">MYRI10GE_MAX_ETHER_MTU</span> <span class="o">-</span> <span class="n">ETH_HLEN</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_initial_mtu</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_initial_mtu</span><span class="p">,</span> <span class="s">&quot;Initial MTU&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_napi_weight</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_napi_weight</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_napi_weight</span><span class="p">,</span> <span class="s">&quot;Set NAPI weight&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_watchdog_timeout</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_watchdog_timeout</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_watchdog_timeout</span><span class="p">,</span> <span class="s">&quot;Set watchdog timeout&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_max_irq_loops</span> <span class="o">=</span> <span class="mi">1048576</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_max_irq_loops</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_max_irq_loops</span><span class="p">,</span>
		 <span class="s">&quot;Set stuck legacy IRQ detection threshold&quot;</span><span class="p">);</span>

<span class="cp">#define MYRI10GE_MSG_DEFAULT NETIF_MSG_LINK</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_debug</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* defaults above */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_debug</span><span class="p">,</span> <span class="s">&quot;Debug level (0=none,...,16=all)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_lro_max_pkts</span> <span class="o">=</span> <span class="n">MYRI10GE_LRO_MAX_PKTS</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_lro_max_pkts</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_lro_max_pkts</span><span class="p">,</span>
		 <span class="s">&quot;Number of LRO packets to be aggregated&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_fill_thresh</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_fill_thresh</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_fill_thresh</span><span class="p">,</span> <span class="s">&quot;Number of empty rx slots allowed&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_reset_recover</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_max_slices</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_max_slices</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_max_slices</span><span class="p">,</span> <span class="s">&quot;Max tx/rx queues&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_rss_hash</span> <span class="o">=</span> <span class="n">MXGEFW_RSS_HASH_TYPE_SRC_DST_PORT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_rss_hash</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_rss_hash</span><span class="p">,</span> <span class="s">&quot;Type of RSS hashing to do&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">myri10ge_dca</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">myri10ge_dca</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">myri10ge_dca</span><span class="p">,</span> <span class="s">&quot;Enable DCA if possible&quot;</span><span class="p">);</span>

<span class="cp">#define MYRI10GE_FW_OFFSET 1024*1024</span>
<span class="cp">#define MYRI10GE_HIGHPART_TO_U32(X) \</span>
<span class="cp">(sizeof (X) == 8) ? ((u32)((u64)(X) &gt;&gt; 32)) : (0)</span>
<span class="cp">#define MYRI10GE_LOWPART_TO_U32(X) ((u32)(X))</span>

<span class="cp">#define myri10ge_pio_copy(to,from,size) __iowrite64_copy(to,from,size/8)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">myri10ge_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">myri10ge_sw_tso</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_be32</span><span class="p">(</span><span class="n">__be32</span> <span class="n">val</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writel</span><span class="p">((</span><span class="n">__force</span> <span class="n">__u32</span><span class="p">)</span> <span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">myri10ge_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_fw_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">bool</span> <span class="n">allocated</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name_allocated</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name_allocated</span> <span class="o">=</span> <span class="n">allocated</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">myri10ge_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cmd</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">atomic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp_cmd</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf_bytes</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">mcp_cmd_response</span> <span class="o">*</span><span class="n">response</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">cmd_addr</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">MXGEFW_ETH_CMD</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dma_low</span><span class="p">,</span> <span class="n">dma_high</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sleep_total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ensure buf is aligned to 8 bytes */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mcp_cmd</span> <span class="o">*</span><span class="p">)</span><span class="n">ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buf_bytes</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">data0</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">data0</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">data1</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">data1</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">data2</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">data2</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">dma_low</span> <span class="o">=</span> <span class="n">MYRI10GE_LOWPART_TO_U32</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd_bus</span><span class="p">);</span>
	<span class="n">dma_high</span> <span class="o">=</span> <span class="n">MYRI10GE_HIGHPART_TO_U32</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd_bus</span><span class="p">);</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">response_addr</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">dma_low</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">response_addr</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">dma_high</span><span class="p">);</span>
	<span class="n">response</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">MYRI10GE_NO_RESPONSE_RESULT</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">myri10ge_pio_copy</span><span class="p">(</span><span class="n">cmd_addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="p">));</span>

	<span class="cm">/* wait up to 15ms. Longest command is the DMA benchmark,</span>
<span class="cm">	 * which is capped at 5ms, but runs from a timeout handler</span>
<span class="cm">	 * that runs every 7.8ms. So a 15ms timeout leaves us with</span>
<span class="cm">	 * a 2.2ms margin</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if atomic is set, do not sleep,</span>
<span class="cm">		 * and try to get the completion quickly</span>
<span class="cm">		 * (1ms will be enough for those commands) */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">sleep_total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">sleep_total</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="o">&amp;&amp;</span>
		     <span class="n">response</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">htonl</span><span class="p">(</span><span class="n">MYRI10GE_NO_RESPONSE_RESULT</span><span class="p">);</span>
		     <span class="n">sleep_total</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">mb</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* use msleep for most command */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">sleep_total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">sleep_total</span> <span class="o">&lt;</span> <span class="mi">15</span> <span class="o">&amp;&amp;</span>
		     <span class="n">response</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">htonl</span><span class="p">(</span><span class="n">MYRI10GE_NO_RESPONSE_RESULT</span><span class="p">);</span>
		     <span class="n">sleep_total</span><span class="o">++</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">MYRI10GE_NO_RESPONSE_RESULT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">data0</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">MXGEFW_CMD_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">MXGEFW_CMD_ERROR_UNALIGNED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">MXGEFW_CMD_ERROR_RANGE</span> <span class="o">&amp;&amp;</span>
			   <span class="n">cmd</span> <span class="o">==</span> <span class="n">MXGEFW_CMD_ENABLE_RSS_QUEUES</span> <span class="o">&amp;&amp;</span>
			   <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span>
			    <span class="n">data1</span> <span class="o">&amp;</span> <span class="n">MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES</span><span class="p">)</span> <span class="o">!=</span>
			   <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;command %d failed, result = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;command %d timed out, result = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The eeprom strings on the lanaiX have the format</span>
<span class="cm"> * SN=x\0</span>
<span class="cm"> * MAC=x:x:x:x:x:x\0</span>
<span class="cm"> * PT:ddd mmm xx xx:xx:xx xx\0</span>
<span class="cm"> * PV:ddd mmm xx xx:xx:xx xx\0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_read_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">limit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">eeprom_strings</span><span class="p">;</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">eeprom_strings</span> <span class="o">+</span> <span class="n">MYRI10GE_EEPROM_STRINGS_SIZE</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">&quot;MAC=&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mac_addr_string</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
				<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				    <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
				<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">&quot;PC=&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">product_code_string</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">((</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span> <span class="s">&quot;SN=&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">serial_number</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">abort:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to parse eeprom_strings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable or disable periodic RDMAs from the host to make certain</span>
<span class="cm"> * chipsets resend dropped PCIe messages</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_dummy_rdma</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">submit</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
	<span class="n">u32</span> <span class="n">dma_low</span><span class="p">,</span> <span class="n">dma_high</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* clear confirmation addr */</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="cm">/* send a rdma command to the PCIe engine, and wait for the</span>
<span class="cm">	 * response in the confirmation address.  The firmware should</span>
<span class="cm">	 * write a -1 there to indicate it is alive and well</span>
<span class="cm">	 */</span>
	<span class="n">dma_low</span> <span class="o">=</span> <span class="n">MYRI10GE_LOWPART_TO_U32</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd_bus</span><span class="p">);</span>
	<span class="n">dma_high</span> <span class="o">=</span> <span class="n">MYRI10GE_HIGHPART_TO_U32</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd_bus</span><span class="p">);</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">dma_high</span><span class="p">);</span>	<span class="cm">/* confirm addr MSW */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">dma_low</span><span class="p">);</span>	<span class="cm">/* confirm addr LSW */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">MYRI10GE_NO_CONFIRM_DATA</span><span class="p">;</span>	<span class="cm">/* confirm data */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">dma_high</span><span class="p">);</span>	<span class="cm">/* dummy addr MSW */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">dma_low</span><span class="p">);</span>	<span class="cm">/* dummy addr LSW */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">enable</span><span class="p">);</span>	<span class="cm">/* enable? */</span>

	<span class="n">submit</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">MXGEFW_BOOT_DUMMY_RDMA</span><span class="p">;</span>

	<span class="n">myri10ge_pio_copy</span><span class="p">(</span><span class="n">submit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">MYRI10GE_NO_CONFIRM_DATA</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">MYRI10GE_NO_CONFIRM_DATA</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;dummy rdma %s failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">enable</span> <span class="o">?</span> <span class="s">&quot;enable&quot;</span> <span class="o">:</span> <span class="s">&quot;disable&quot;</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">myri10ge_validate_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">mcp_gen_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* check firmware type */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">mcp_type</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MCP_TYPE_ETH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Bad firmware type: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">mcp_type</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* save firmware version for ethtool */</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">));</span>

	<span class="n">sscanf</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="s">&quot;%d.%d.%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_major</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_minor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_tiny</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_major</span> <span class="o">==</span> <span class="n">MXGEFW_VERSION_MAJOR</span> <span class="o">&amp;&amp;</span>
	      <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_minor</span> <span class="o">==</span> <span class="n">MXGEFW_VERSION_MINOR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Found firmware version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Driver needs %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MXGEFW_VERSION_MAJOR</span><span class="p">,</span>
			<span class="n">MXGEFW_VERSION_MINOR</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_load_hotplug_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">crc</span><span class="p">,</span> <span class="n">reread_crc</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fw_readback</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp_gen_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hdr_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to load %s firmware image via hotplug</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort_with_nothing</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check size */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram_size</span> <span class="o">-</span> <span class="n">MYRI10GE_FW_OFFSET</span> <span class="o">||</span>
	    <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">MCP_HEADER_PTR_OFFSET</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Firmware size invalid:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort_with_fw</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check id */</span>
	<span class="n">hdr_offset</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">MCP_HEADER_PTR_OFFSET</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hdr_offset</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="n">hdr_offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Bad firmware file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort_with_fw</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">hdr_offset</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_validate_firmware</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_fw</span><span class="p">;</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">256</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">myri10ge_pio_copy</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">MYRI10GE_FW_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				  <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				  <span class="n">min</span><span class="p">(</span><span class="mi">256U</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">i</span><span class="p">)));</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="n">readb</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fw_readback</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_readback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort_with_fw</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* corruption checking is good for parity recovery and buggy chipset */</span>
	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">fw_readback</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">MYRI10GE_FW_OFFSET</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">reread_crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">fw_readback</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">fw_readback</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">reread_crc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CRC failed(fw-len=%u), got 0x%x (expect 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">reread_crc</span><span class="p">,</span> <span class="n">crc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort_with_fw</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

<span class="nl">abort_with_fw:</span>
	<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>

<span class="nl">abort_with_nothing:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_adopt_running_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp_gen_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_gen_header</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">hdr_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* find running firmware header */</span>
	<span class="n">hdr_offset</span> <span class="o">=</span> <span class="n">swab32</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">MCP_HEADER_PTR_OFFSET</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hdr_offset</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="n">hdr_offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Running firmware has bad header offset (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">hdr_offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* copy header of running firmware from SRAM to host memory to</span>
<span class="cm">	 * validate firmware */</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not malloc firmware hdr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">hdr_offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_validate_firmware</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>

	<span class="cm">/* check to see if adopted firmware has bug where adopting</span>
<span class="cm">	 * it will cause broadcasts to be filtered unless the NIC</span>
<span class="cm">	 * is kept in ALLMULTI mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_major</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_minor</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_tiny</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_tiny</span> <span class="o">&lt;=</span> <span class="mi">11</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">adopted_rx_filter_bug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Adopting fw %d.%d.%d: &quot;</span>
			 <span class="s">&quot;working around rx filter bug</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_major</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_minor</span><span class="p">,</span>
			 <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_tiny</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_get_firmware_capabilities</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* probe for IPv6 TSO support */</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span> <span class="n">NETIF_F_HW_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_TSO</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_MAX_TSO6_HDR_SIZE</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">max_tso6</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span><span class="p">;</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO6</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_RX_RING_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;failed MXGEFW_CMD_GET_RX_RING_SIZE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">max_intr_slots</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_dma_addr</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_load_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">adopt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">submit</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
	<span class="n">u32</span> <span class="n">dma_low</span><span class="p">,</span> <span class="n">dma_high</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_load_hotplug_firmware</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adopt</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hotplug firmware loading failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Do not attempt to adopt firmware if there</span>
<span class="cm">		 * was a bad crc */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_adopt_running_firmware</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;failed to adopt running firmware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;Successfully adopted running firmware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Using firmware currently running on NIC&quot;</span>
				 <span class="s">&quot;.  For optimal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;performance consider loading optimized &quot;</span>
				 <span class="s">&quot;firmware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;via hotplug</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="s">&quot;adopted&quot;</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
		<span class="n">myri10ge_dummy_rdma</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_get_firmware_capabilities</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear confirmation addr */</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="cm">/* send a reload command to the bootstrap MCP, and wait for the</span>
<span class="cm">	 *  response in the confirmation address.  The firmware should</span>
<span class="cm">	 * write a -1 there to indicate it is alive and well</span>
<span class="cm">	 */</span>
	<span class="n">dma_low</span> <span class="o">=</span> <span class="n">MYRI10GE_LOWPART_TO_U32</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd_bus</span><span class="p">);</span>
	<span class="n">dma_high</span> <span class="o">=</span> <span class="n">MYRI10GE_HIGHPART_TO_U32</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd_bus</span><span class="p">);</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">dma_high</span><span class="p">);</span>	<span class="cm">/* confirm addr MSW */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">dma_low</span><span class="p">);</span>	<span class="cm">/* confirm addr LSW */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">MYRI10GE_NO_CONFIRM_DATA</span><span class="p">;</span>	<span class="cm">/* confirm data */</span>

	<span class="cm">/* FIX: All newest firmware should un-protect the bottom of</span>
<span class="cm">	 * the sram before handoff. However, the very first interfaces</span>
<span class="cm">	 * do not. Therefore the handoff copy must skip the first 8 bytes</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">MYRI10GE_FW_OFFSET</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>	<span class="cm">/* where the code starts */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>	<span class="cm">/* length of code */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>	<span class="cm">/* where to copy to */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* where to jump to */</span>

	<span class="n">submit</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">MXGEFW_BOOT_HANDOFF</span><span class="p">;</span>

	<span class="n">myri10ge_pio_copy</span><span class="p">(</span><span class="n">submit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">MYRI10GE_NO_CONFIRM_DATA</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">MYRI10GE_NO_CONFIRM_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;handoff failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">myri10ge_dummy_rdma</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_get_firmware_capabilities</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_update_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="p">((</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
		     <span class="o">|</span> <span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="p">((</span><span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]));</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_SET_MAC_ADDRESS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_change_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">ctl</span><span class="p">;</span>

	<span class="n">ctl</span> <span class="o">=</span> <span class="n">pause</span> <span class="o">?</span> <span class="n">MXGEFW_ENABLE_FLOW_CONTROL</span> <span class="o">:</span> <span class="n">MXGEFW_DISABLE_FLOW_CONTROL</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">ctl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to set flow control mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pause</span> <span class="o">=</span> <span class="n">pause</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">myri10ge_change_promisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">promisc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">atomic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">ctl</span><span class="p">;</span>

	<span class="n">ctl</span> <span class="o">=</span> <span class="n">promisc</span> <span class="o">?</span> <span class="n">MXGEFW_ENABLE_PROMISC</span> <span class="o">:</span> <span class="n">MXGEFW_DISABLE_PROMISC</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">ctl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">atomic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to set promisc mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_dma_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">test_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dmatest_page</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dmatest_bus</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">test</span> <span class="o">=</span> <span class="s">&quot; &quot;</span><span class="p">;</span>

	<span class="n">dmatest_page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmatest_page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">dmatest_bus</span> <span class="o">=</span> <span class="n">pci_map_page</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dmatest_page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				   <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>

	<span class="cm">/* Run a small DMA test.</span>
<span class="cm">	 * The magic multipliers to the length tell the firmware</span>
<span class="cm">	 * to do DMA read, write, or read+write tests.  The</span>
<span class="cm">	 * results are returned in cmd.data0.  The upper 16</span>
<span class="cm">	 * bits or the return is the number of transfers completed.</span>
<span class="cm">	 * The lower 16 bits is the time in 0.5us ticks that the</span>
<span class="cm">	 * transfers took to complete.</span>
<span class="cm">	 */</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span><span class="p">;</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">MYRI10GE_LOWPART_TO_U32</span><span class="p">(</span><span class="n">dmatest_bus</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="n">MYRI10GE_HIGHPART_TO_U32</span><span class="p">(</span><span class="n">dmatest_bus</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data2</span> <span class="o">=</span> <span class="n">len</span> <span class="o">*</span> <span class="mh">0x10000</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">test_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">test</span> <span class="o">=</span> <span class="s">&quot;read&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">read_dma</span> <span class="o">=</span> <span class="p">((</span><span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="n">len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">MYRI10GE_LOWPART_TO_U32</span><span class="p">(</span><span class="n">dmatest_bus</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="n">MYRI10GE_HIGHPART_TO_U32</span><span class="p">(</span><span class="n">dmatest_bus</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data2</span> <span class="o">=</span> <span class="n">len</span> <span class="o">*</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">test_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">test</span> <span class="o">=</span> <span class="s">&quot;write&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">write_dma</span> <span class="o">=</span> <span class="p">((</span><span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="n">len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">MYRI10GE_LOWPART_TO_U32</span><span class="p">(</span><span class="n">dmatest_bus</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="n">MYRI10GE_HIGHPART_TO_U32</span><span class="p">(</span><span class="n">dmatest_bus</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data2</span> <span class="o">=</span> <span class="n">len</span> <span class="o">*</span> <span class="mh">0x10001</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">test_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">test</span> <span class="o">=</span> <span class="s">&quot;read/write&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">read_write_dma</span> <span class="o">=</span> <span class="p">((</span><span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="n">len</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
	    <span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>

<span class="nl">abort:</span>
	<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dmatest_bus</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">dmatest_page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">test_type</span> <span class="o">!=</span> <span class="n">MXGEFW_CMD_UNALIGNED_TEST</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA %s benchmark failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">test</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dca_tag_off</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* try to send a reset command to the card to see if it</span>
<span class="cm">	 * is alive */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_RESET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">myri10ge_dma_test</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_DMA_TEST</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Use non-ndis mcp_slot (eg, 4 bytes total,</span>
<span class="cm">	 * no toeplitz hash value returned.  Older firmware will</span>
<span class="cm">	 * not understand this command, but will use the correct</span>
<span class="cm">	 * sized mcp_slot, so we ignore error returns</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">MXGEFW_RSS_MCP_SLOT_TYPE_MIN</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_SET_RSS_MCP_SLOT_TYPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Now exchange information about interrupts  */</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">max_intr_slots</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_done</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_SET_INTRQ_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Even though we already know how many slices are supported</span>
<span class="cm">	 * via myri10ge_probe_slices() MXGEFW_CMD_GET_MAX_RSS_QUEUES</span>
<span class="cm">	 * has magic side effects, and must be called after a reset.</span>
<span class="cm">	 * It must be called prior to calling any RSS related cmds,</span>
<span class="cm">	 * including assigning an interrupt queue for anything but</span>
<span class="cm">	 * slice 0.  It must also be called *after*</span>
<span class="cm">	 * MXGEFW_CMD_SET_INTRQ_SIZE, since the intrq size is used by</span>
<span class="cm">	 * the firmware to compute offsets.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* ask the maximum number of slices it supports */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_MAX_RSS_QUEUES</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;failed to get number of slices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * MXGEFW_CMD_ENABLE_RSS_QUEUES must be called prior</span>
<span class="cm">		 * to setting up the interrupt queue DMA</span>
<span class="cm">		 */</span>

		<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="n">MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">|=</span> <span class="n">MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_ENABLE_RSS_QUEUES</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Firmware older than 1.4.32 only supports multiple</span>
<span class="cm">		 * RX queues, so if we get an error, first retry using a</span>
<span class="cm">		 * single TX queue before giving up */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_set_real_num_tx_queues</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span>
			<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="n">MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span>
						   <span class="n">MXGEFW_CMD_ENABLE_RSS_QUEUES</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;failed to set number of slices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">MYRI10GE_LOWPART_TO_U32</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">bus</span><span class="p">);</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="n">MYRI10GE_HIGHPART_TO_U32</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">bus</span><span class="p">);</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data2</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_SET_INTRQ_DMA</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">|=</span>
	    <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_IRQ_ACK_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">irq_claim</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">__iomem</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">|=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_IRQ_DEASSERT_OFFSET</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">irq_deassert</span> <span class="o">=</span> <span class="p">(</span><span class="n">__iomem</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">|=</span> <span class="n">myri10ge_send_cmd</span>
	    <span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_INTR_COAL_DELAY_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">intr_coal_delay_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__iomem</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed set interrupt parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">put_be32</span><span class="p">(</span><span class="n">htonl</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">intr_coal_delay</span><span class="p">),</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">intr_coal_delay_ptr</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_DCA_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">dca_tag_off</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">dca_tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">__iomem</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">)</span>
			    <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">dca_tag_off</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">dca_tag</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_MYRI10GE_DCA */</span><span class="cp"></span>

	<span class="cm">/* reset mcp/driver shared state back to 0 */</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">link_changes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">pkt_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">pkt_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">wake_queue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">stop_queue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_update_mac_address</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="n">myri10ge_change_pause</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">);</span>
	<span class="n">myri10ge_set_multicast_list</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_toggle_relaxed</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctl</span><span class="p">;</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_DEVCTL_RELAX_EN</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_EXP_DEVCTL_RELAX_EN</span><span class="p">;</span>
		<span class="n">ctl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">on</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="n">ctl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">myri10ge_write_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">cached_dca_tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">put_be32</span><span class="p">(</span><span class="n">htonl</span><span class="p">(</span><span class="n">tag</span><span class="p">),</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">dca_tag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">myri10ge_update_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">dca3_get_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">cached_dca_tag</span> <span class="o">!=</span> <span class="n">tag</span><span class="p">)</span>
			<span class="n">myri10ge_write_dca</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_setup_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dca_tag</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dca_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">myri10ge_dca</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;dca disabled by administrator</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dca_add_requester</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;dca_add_requester() failed, err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">relaxed_order</span> <span class="o">=</span> <span class="n">myri10ge_toggle_relaxed</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dca_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cached_dca_tag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">myri10ge_update_dca</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_teardown_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dca_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dca_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">relaxed_order</span><span class="p">)</span>
		<span class="n">myri10ge_toggle_relaxed</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">dca_remove_requester</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_notify_dca_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">;</span>

	<span class="n">mgp</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">event</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">DCA_PROVIDER_ADD</span><span class="p">)</span>
		<span class="n">myri10ge_setup_dca</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">DCA_PROVIDER_REMOVE</span><span class="p">)</span>
		<span class="n">myri10ge_teardown_dca</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_MYRI10GE_DCA */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">myri10ge_submit_8rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_kreq_ether_recv</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">dst</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">mcp_kreq_ether_recv</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">low</span><span class="p">;</span>

	<span class="n">low</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">addr_low</span><span class="p">;</span>
	<span class="n">src</span><span class="o">-&gt;</span><span class="n">addr_low</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
	<span class="n">myri10ge_pio_copy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">));</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">myri10ge_pio_copy</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">src</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">));</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">src</span><span class="o">-&gt;</span><span class="n">addr_low</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
	<span class="n">put_be32</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">addr_low</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">myri10ge_vlan_ip_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">__wsum</span> <span class="n">hw_csum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vlan_hdr</span> <span class="o">*</span><span class="n">vh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vlan_hdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">vh</span><span class="o">-&gt;</span><span class="n">h_vlan_encapsulated_proto</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">vh</span><span class="o">-&gt;</span><span class="n">h_vlan_encapsulated_proto</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">hw_csum</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_COMPLETE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">myri10ge_rx_skb_build</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span> <span class="n">va</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">rx_frags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">skb_frags</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="cm">/* attach the page(s) */</span>

	<span class="n">skb_frags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_frags</span><span class="p">,</span> <span class="n">rx_frags</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">skb_frags</span><span class="p">));</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">rx_frags</span><span class="p">);</span>
		<span class="n">skb_frags</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rx_frags</span><span class="o">++</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* pskb_may_pull is not available in irq context, but</span>
<span class="cm">	 * skb_pull() (for ether_pad and eth_type_trans()) requires</span>
<span class="cm">	 * the beginning of the packet in skb_headlen(), move it</span>
<span class="cm">	 * manually */</span>
	<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">hlen</span><span class="p">;</span>
	<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hlen</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">-=</span> <span class="n">hlen</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+=</span> <span class="n">hlen</span><span class="p">;</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">MXGEFW_PAD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">myri10ge_alloc_rx_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">myri10ge_rx_buf</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">watchdog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
<span class="cp">#if MYRI10GE_ALLOC_SIZE &gt; 4096</span>
	<span class="kt">int</span> <span class="n">end_offset</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">watchdog_needed</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">watchdog</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* try to refill entire ring */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">fill_cnt</span> <span class="o">!=</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">+</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">fill_cnt</span> <span class="o">&amp;</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span> <span class="n">bytes</span> <span class="o">&lt;=</span> <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we can use part of previous page */</span>
			<span class="n">get_page</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* we need a new page */</span>
			<span class="n">page</span> <span class="o">=</span>
			    <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_COMP</span><span class="p">,</span>
					<span class="n">MYRI10GE_ALLOC_ORDER</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">fill_cnt</span> <span class="o">-</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
					<span class="n">rx</span><span class="o">-&gt;</span><span class="n">watchdog_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rx</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
			<span class="n">rx</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">rx</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">pci_map_page</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">,</span>
					       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page_offset</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">;</span>
		<span class="cm">/* note that this is the address of the start of the</span>
<span class="cm">		 * page */</span>
		<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">bus</span><span class="p">,</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">addr_low</span> <span class="o">=</span>
		    <span class="n">htonl</span><span class="p">(</span><span class="n">MYRI10GE_LOWPART_TO_U32</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span> <span class="o">+</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">);</span>
		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">addr_high</span> <span class="o">=</span>
		    <span class="n">htonl</span><span class="p">(</span><span class="n">MYRI10GE_HIGHPART_TO_U32</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">));</span>

		<span class="cm">/* start next packet on a cacheline boundary */</span>
		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>

<span class="cp">#if MYRI10GE_ALLOC_SIZE &gt; 4096</span>
		<span class="cm">/* don&#39;t cross a 4KB boundary */</span>
		<span class="n">end_offset</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span> <span class="n">bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">^</span> <span class="n">end_offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4095</span><span class="p">)</span>
			<span class="n">rx</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="n">end_offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">4095</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">fill_cnt</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* copy 8 descriptors to the firmware at a time */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">idx</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">myri10ge_submit_8rx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">lanai</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">7</span><span class="p">],</span>
					    <span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">7</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">myri10ge_unmap_rx_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">myri10ge_rx_buffer_state</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* unmap the recvd page if we&#39;re the only or last user of it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;=</span> <span class="n">MYRI10GE_ALLOC_SIZE</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="p">(</span><span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">bus</span><span class="p">)</span>
				      <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MYRI10GE_ALLOC_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
			       <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define MYRI10GE_HLEN 64	</span><span class="cm">/* The number of bytes to copy from a</span>
<span class="cm">				 * page into an skb */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">myri10ge_rx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">__wsum</span> <span class="n">csum</span><span class="p">,</span>
		 <span class="n">bool</span> <span class="n">lro_enabled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="n">rx_frags</span><span class="p">[</span><span class="n">MYRI10GE_MAX_FRAGS_PER_FRAME</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">myri10ge_rx_buf</span> <span class="o">*</span><span class="n">rx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">big_bytes</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">MXGEFW_PAD</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&amp;</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">va</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page_offset</span><span class="p">;</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
	<span class="cm">/* Fill skb_frag_struct(s) with data from our receive */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span> <span class="n">remainder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">myri10ge_unmap_rx_page</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">__skb_frag_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_frags</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
		<span class="n">rx_frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">page_offset</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page_offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remainder</span> <span class="o">&lt;</span> <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">)</span>
			<span class="n">skb_frag_size_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_frags</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">remainder</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">skb_frag_size_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_frags</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">);</span>
		<span class="n">rx</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&amp;</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">remainder</span> <span class="o">-=</span> <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lro_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_frags</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">MXGEFW_PAD</span><span class="p">;</span>
		<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_frags</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">MXGEFW_PAD</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">MXGEFW_PAD</span><span class="p">;</span>
		<span class="n">lro_receive_frags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">lro_mgr</span><span class="p">,</span> <span class="n">rx_frags</span><span class="p">,</span>
				  <span class="cm">/* opaque, will come back in get_frag_header */</span>
				  <span class="n">len</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">__force</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">csum</span><span class="p">,</span> <span class="n">csum</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hlen</span> <span class="o">=</span> <span class="n">MYRI10GE_HLEN</span> <span class="o">&gt;</span> <span class="n">len</span> <span class="o">?</span> <span class="n">len</span> <span class="o">:</span> <span class="n">MYRI10GE_HLEN</span><span class="p">;</span>

	<span class="cm">/* allocate an skb to attach the page(s) to. This is done</span>
<span class="cm">	 * after trying LRO, so as to avoid skb allocation overheads */</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MYRI10GE_HLEN</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">--</span><span class="p">;</span>
			<span class="n">__skb_frag_unref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_frags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Attach the pages to the skb, and trim off any padding */</span>
	<span class="n">myri10ge_rx_skb_build</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">rx_frags</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_frag_unref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">bytes</span> <span class="o">*</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">skb_record_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ss</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">csum</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_COMPLETE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">myri10ge_vlan_ip_csum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">csum</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">myri10ge_tx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mcp_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_tx_buf</span> <span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">dev_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">pkt_done</span> <span class="o">!=</span> <span class="n">mcp_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">&amp;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">skb</span><span class="p">;</span>

		<span class="cm">/* Mark as free */</span>
		<span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx</span><span class="o">-&gt;</span><span class="n">pkt_done</span><span class="o">++</span><span class="p">;</span>
			<span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tx</span><span class="o">-&gt;</span><span class="n">done</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">dma_unmap_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
				<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
						 <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
								<span class="n">bus</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span>
						 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
				<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
					       <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
							      <span class="n">bus</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span>
					       <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dev_queue</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ss</span> <span class="o">-</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make a minimal effort to prevent the NIC from polling an</span>
<span class="cm">	 * idle tx queue.  If we can&#39;t get the lock we leave the queue</span>
<span class="cm">	 * active. In this case, either a thread was about to start</span>
<span class="cm">	 * using the queue anyway, or we lost a race and the NIC will</span>
<span class="cm">	 * waste some of its resources polling an inactive queue for a</span>
<span class="cm">	 * while.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">__netif_tx_trylock</span><span class="p">(</span><span class="n">dev_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">==</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx</span><span class="o">-&gt;</span><span class="n">queue_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">put_be32</span><span class="p">(</span><span class="n">htonl</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">send_stop</span><span class="p">);</span>
			<span class="n">mb</span><span class="p">();</span>
			<span class="n">mmiowb</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">__netif_tx_unlock</span><span class="p">(</span><span class="n">dev_queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* start the queue if we&#39;ve stopped it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_tx_queue_stopped</span><span class="p">(</span><span class="n">dev_queue</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tx</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">-</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">==</span> <span class="n">MYRI10GE_ETH_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx</span><span class="o">-&gt;</span><span class="n">wake_queue</span><span class="o">++</span><span class="p">;</span>
		<span class="n">netif_tx_wake_queue</span><span class="p">(</span><span class="n">dev_queue</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">myri10ge_clean_rx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_rx_done</span> <span class="o">*</span><span class="n">rx_done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_ok</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">rx_done</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">rx_done</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__wsum</span> <span class="n">checksum</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent compiler from generating more than one -&gt;features memory</span>
<span class="cm">	 * access to avoid theoretical race condition with functions that</span>
<span class="cm">	 * change NETIF_F_LRO flag at runtime.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">lro_enabled</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NETIF_F_LRO</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rx_done</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">rx_done</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">length</span><span class="p">);</span>
		<span class="n">rx_done</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">checksum</span> <span class="o">=</span> <span class="n">csum_unfold</span><span class="p">(</span><span class="n">rx_done</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">checksum</span><span class="p">);</span>
		<span class="n">rx_ok</span> <span class="o">=</span> <span class="n">myri10ge_rx_done</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">checksum</span><span class="p">,</span> <span class="n">lro_enabled</span><span class="p">);</span>
		<span class="n">rx_packets</span> <span class="o">+=</span> <span class="n">rx_ok</span><span class="p">;</span>
		<span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">rx_ok</span> <span class="o">*</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">length</span><span class="p">;</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">max_intr_slots</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">work_done</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rx_done</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">rx_done</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span> <span class="o">+=</span> <span class="n">rx_packets</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">rx_bytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lro_enabled</span><span class="p">)</span>
		<span class="n">lro_flush_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_done</span><span class="o">-&gt;</span><span class="n">lro_mgr</span><span class="p">);</span>

	<span class="cm">/* restock receive rings if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">-</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">myri10ge_fill_thresh</span><span class="p">)</span>
		<span class="n">myri10ge_alloc_rx_pages</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">,</span>
					<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span> <span class="o">+</span> <span class="n">MXGEFW_PAD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">-</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">myri10ge_fill_thresh</span><span class="p">)</span>
		<span class="n">myri10ge_alloc_rx_pages</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">big_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">myri10ge_check_statblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp_irq_data</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fw_stats</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">stats_updated</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">link_up</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">link_up</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">!=</span> <span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">link_up</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">MXGEFW_LINK_UP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">netif_info</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;link up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">link_changes</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">netif_info</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;link %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">link_up</span> <span class="o">==</span> <span class="n">MXGEFW_LINK_MYRINET</span> <span class="o">?</span>
					    <span class="s">&quot;mismatch (Myrinet detected)&quot;</span> <span class="o">:</span>
					    <span class="s">&quot;down&quot;</span><span class="p">));</span>
				<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">link_changes</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">rdma_tags_available</span> <span class="o">!=</span>
		    <span class="n">ntohl</span><span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rdma_tags_available</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">rdma_tags_available</span> <span class="o">=</span>
			    <span class="n">ntohl</span><span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rdma_tags_available</span><span class="p">);</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RDMA timed out! %d tags left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">rdma_tags_available</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">down_cnt</span> <span class="o">+=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">link_down</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">link_down</span><span class="p">)</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">down_wq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span>
	    <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">myri10ge_slice_state</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">work_done</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dca_enabled</span><span class="p">)</span>
		<span class="n">myri10ge_update_dca</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* process as many rx events as NAPI will allow */</span>
	<span class="n">work_done</span> <span class="o">=</span> <span class="n">myri10ge_clean_rx_done</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">put_be32</span><span class="p">(</span><span class="n">htonl</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">irq_claim</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">myri10ge_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp_irq_data</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_tx_buf</span> <span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">send_done_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* an interrupt on a non-zero receive-only slice is implicitly</span>
<span class="cm">	 * valid  since MSI-X irqs are not shared */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ss</span> <span class="o">!=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* make sure it is our IRQ, and that the DMA has finished */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* low bit indicates receives are present, so schedule</span>
<span class="cm">	 * napi poll handler */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msi_enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_be32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">irq_deassert</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">myri10ge_deassert_wait</span><span class="p">)</span>
			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mb</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait for IRQ line to go low, if using INTx */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* check for transmit completes and receives */</span>
		<span class="n">send_done_count</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">send_done_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">send_done_count</span> <span class="o">!=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">pkt_done</span><span class="p">)</span>
			<span class="n">myri10ge_tx_done</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">send_done_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">myri10ge_max_irq_loops</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;irq stuck?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_work</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Only slice 0 updates stats */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">)</span>
		<span class="n">myri10ge_check_statblock</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>

	<span class="n">put_be32</span><span class="p">(</span><span class="n">htonl</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">irq_claim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">myri10ge_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="n">AUTONEG_DISABLE</span><span class="p">;</span>
	<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SPEED_10000</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">DUPLEX_FULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * parse the product code to deterimine the interface type</span>
<span class="cm">	 * (CX4, XFP, Quad Ribbon Fiber) by looking at the character</span>
<span class="cm">	 * after the 3rd dash in the driver&#39;s cached copy of the</span>
<span class="cm">	 * EEPROM&#39;s product code string.</span>
<span class="cm">	 */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">product_code_string</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Missing product code</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Invalid product code %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">product_code_string</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">==</span> <span class="sc">&#39;2&#39;</span><span class="p">)</span>
		<span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">==</span> <span class="sc">&#39;R&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">==</span> <span class="sc">&#39;Q&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">==</span> <span class="sc">&#39;S&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We&#39;ve found either an XFP, quad ribbon fiber, or SFP+ */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">PORT_FIBRE</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">|=</span> <span class="n">SUPPORTED_FIBRE</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_FIBRE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">PORT_OTHER</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">==</span> <span class="sc">&#39;R&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">==</span> <span class="sc">&#39;S&#39;</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">XCVR_EXTERNAL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">XCVR_INTERNAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">myri10ge_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="s">&quot;myri10ge&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">MYRI10GE_VERSION_STR</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">myri10ge_get_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_coalesce</span> <span class="o">*</span><span class="n">coal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">coal</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">intr_coal_delay</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">myri10ge_set_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_coalesce</span> <span class="o">*</span><span class="n">coal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">intr_coal_delay</span> <span class="o">=</span> <span class="n">coal</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span><span class="p">;</span>
	<span class="n">put_be32</span><span class="p">(</span><span class="n">htonl</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">intr_coal_delay</span><span class="p">),</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">intr_coal_delay_ptr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">myri10ge_get_pauseparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ethtool_pauseparam</span> <span class="o">*</span><span class="n">pause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">pause</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pause</span><span class="o">-&gt;</span><span class="n">rx_pause</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">;</span>
	<span class="n">pause</span><span class="o">-&gt;</span><span class="n">tx_pause</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">myri10ge_set_pauseparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ethtool_pauseparam</span> <span class="o">*</span><span class="n">pause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pause</span><span class="o">-&gt;</span><span class="n">tx_pause</span> <span class="o">!=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">myri10ge_change_pause</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">pause</span><span class="o">-&gt;</span><span class="n">tx_pause</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pause</span><span class="o">-&gt;</span><span class="n">rx_pause</span> <span class="o">!=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">myri10ge_change_pause</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">pause</span><span class="o">-&gt;</span><span class="n">rx_pause</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pause</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">myri10ge_get_ringparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ethtool_ringparam</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_mini_max_pending</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_small</span><span class="p">.</span><span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_max_pending</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_big</span><span class="p">.</span><span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_jumbo_max_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">tx_max_pending</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx</span><span class="p">.</span><span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_mini_pending</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_mini_max_pending</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_pending</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_max_pending</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_jumbo_pending</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">rx_jumbo_max_pending</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">tx_pending</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">tx_max_pending</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">myri10ge_gstrings_main_stats</span><span class="p">[][</span><span class="n">ETH_GSTRING_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;rx_packets&quot;</span><span class="p">,</span> <span class="s">&quot;tx_packets&quot;</span><span class="p">,</span> <span class="s">&quot;rx_bytes&quot;</span><span class="p">,</span> <span class="s">&quot;tx_bytes&quot;</span><span class="p">,</span> <span class="s">&quot;rx_errors&quot;</span><span class="p">,</span>
	<span class="s">&quot;tx_errors&quot;</span><span class="p">,</span> <span class="s">&quot;rx_dropped&quot;</span><span class="p">,</span> <span class="s">&quot;tx_dropped&quot;</span><span class="p">,</span> <span class="s">&quot;multicast&quot;</span><span class="p">,</span> <span class="s">&quot;collisions&quot;</span><span class="p">,</span>
	<span class="s">&quot;rx_length_errors&quot;</span><span class="p">,</span> <span class="s">&quot;rx_over_errors&quot;</span><span class="p">,</span> <span class="s">&quot;rx_crc_errors&quot;</span><span class="p">,</span>
	<span class="s">&quot;rx_frame_errors&quot;</span><span class="p">,</span> <span class="s">&quot;rx_fifo_errors&quot;</span><span class="p">,</span> <span class="s">&quot;rx_missed_errors&quot;</span><span class="p">,</span>
	<span class="s">&quot;tx_aborted_errors&quot;</span><span class="p">,</span> <span class="s">&quot;tx_carrier_errors&quot;</span><span class="p">,</span> <span class="s">&quot;tx_fifo_errors&quot;</span><span class="p">,</span>
	<span class="s">&quot;tx_heartbeat_errors&quot;</span><span class="p">,</span> <span class="s">&quot;tx_window_errors&quot;</span><span class="p">,</span>
	<span class="cm">/* device-specific stats */</span>
	<span class="s">&quot;tx_boundary&quot;</span><span class="p">,</span> <span class="s">&quot;WC&quot;</span><span class="p">,</span> <span class="s">&quot;irq&quot;</span><span class="p">,</span> <span class="s">&quot;MSI&quot;</span><span class="p">,</span> <span class="s">&quot;MSIX&quot;</span><span class="p">,</span>
	<span class="s">&quot;read_dma_bw_MBs&quot;</span><span class="p">,</span> <span class="s">&quot;write_dma_bw_MBs&quot;</span><span class="p">,</span> <span class="s">&quot;read_write_dma_bw_MBs&quot;</span><span class="p">,</span>
	<span class="s">&quot;serial_number&quot;</span><span class="p">,</span> <span class="s">&quot;watchdog_resets&quot;</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
	<span class="s">&quot;dca_capable_firmware&quot;</span><span class="p">,</span> <span class="s">&quot;dca_device_present&quot;</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="s">&quot;link_changes&quot;</span><span class="p">,</span> <span class="s">&quot;link_up&quot;</span><span class="p">,</span> <span class="s">&quot;dropped_link_overflow&quot;</span><span class="p">,</span>
	<span class="s">&quot;dropped_link_error_or_filtered&quot;</span><span class="p">,</span>
	<span class="s">&quot;dropped_pause&quot;</span><span class="p">,</span> <span class="s">&quot;dropped_bad_phy&quot;</span><span class="p">,</span> <span class="s">&quot;dropped_bad_crc32&quot;</span><span class="p">,</span>
	<span class="s">&quot;dropped_unicast_filtered&quot;</span><span class="p">,</span> <span class="s">&quot;dropped_multicast_filtered&quot;</span><span class="p">,</span>
	<span class="s">&quot;dropped_runt&quot;</span><span class="p">,</span> <span class="s">&quot;dropped_overrun&quot;</span><span class="p">,</span> <span class="s">&quot;dropped_no_small_buffer&quot;</span><span class="p">,</span>
	<span class="s">&quot;dropped_no_big_buffer&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">myri10ge_gstrings_slice_stats</span><span class="p">[][</span><span class="n">ETH_GSTRING_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;----------- slice ---------&quot;</span><span class="p">,</span>
	<span class="s">&quot;tx_pkt_start&quot;</span><span class="p">,</span> <span class="s">&quot;tx_pkt_done&quot;</span><span class="p">,</span> <span class="s">&quot;tx_req&quot;</span><span class="p">,</span> <span class="s">&quot;tx_done&quot;</span><span class="p">,</span>
	<span class="s">&quot;rx_small_cnt&quot;</span><span class="p">,</span> <span class="s">&quot;rx_big_cnt&quot;</span><span class="p">,</span>
	<span class="s">&quot;wake_queue&quot;</span><span class="p">,</span> <span class="s">&quot;stop_queue&quot;</span><span class="p">,</span> <span class="s">&quot;tx_linearized&quot;</span><span class="p">,</span>
	<span class="s">&quot;LRO aggregated&quot;</span><span class="p">,</span> <span class="s">&quot;LRO flushed&quot;</span><span class="p">,</span> <span class="s">&quot;LRO avg aggr&quot;</span><span class="p">,</span> <span class="s">&quot;LRO no_desc&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define MYRI10GE_NET_STATS_LEN      21</span>
<span class="cp">#define MYRI10GE_MAIN_STATS_LEN  ARRAY_SIZE(myri10ge_gstrings_main_stats)</span>
<span class="cp">#define MYRI10GE_SLICE_STATS_LEN  ARRAY_SIZE(myri10ge_gstrings_slice_stats)</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">myri10ge_get_strings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">stringset</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">stringset</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETH_SS_STATS</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">myri10ge_gstrings_main_stats</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">myri10ge_gstrings_main_stats</span><span class="p">));</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">myri10ge_gstrings_main_stats</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">myri10ge_gstrings_slice_stats</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="n">myri10ge_gstrings_slice_stats</span><span class="p">));</span>
			<span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">myri10ge_gstrings_slice_stats</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_get_sset_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sset</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETH_SS_STATS</span>:
		<span class="k">return</span> <span class="n">MYRI10GE_MAIN_STATS_LEN</span> <span class="o">+</span>
		    <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">*</span> <span class="n">MYRI10GE_SLICE_STATS_LEN</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">myri10ge_get_ethtool_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ethtool_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="n">link_stats</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slice</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* force stats update */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link_stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">link_stats</span><span class="p">));</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">myri10ge_get_stats</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link_stats</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MYRI10GE_NET_STATS_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">link_stats</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">wc_enabled</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msi_enabled</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">read_dma</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">write_dma</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">read_write_dma</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">serial_number</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_resets</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dca_tag</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dca_enabled</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">link_changes</span><span class="p">;</span>

	<span class="cm">/* firmware stats are useful only in the first slice */</span>
	<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">link_up</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_link_overflow</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_link_error_or_filtered</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_pause</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_bad_phy</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_bad_crc32</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_unicast_filtered</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_multicast_filtered</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_runt</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_overrun</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_no_small_buffer</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_no_big_buffer</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">slice</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slice</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">slice</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">slice</span><span class="p">];</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">slice</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">pkt_start</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">pkt_done</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">done</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">wake_queue</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">stop_queue</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">linearized</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">lro_mgr</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">aggregated</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">lro_mgr</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">flushed</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">lro_mgr</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">flushed</span><span class="p">)</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">lro_mgr</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">aggregated</span> <span class="o">/</span>
			    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">lro_mgr</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">flushed</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">lro_mgr</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">no_desc</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_set_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">myri10ge_get_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use a low-level command to change the LED behavior. Rather than</span>
<span class="cm"> * blinking (which is the normal case), when identify is used, the</span>
<span class="cm"> * yellow LED turns solid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_led</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp_gen_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hdr_off</span><span class="p">,</span> <span class="n">pattern_off</span><span class="p">,</span> <span class="n">hdr_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pattern</span> <span class="o">=</span> <span class="mh">0xfffffffe</span><span class="p">;</span>

	<span class="cm">/* find running firmware header */</span>
	<span class="n">hdr_off</span> <span class="o">=</span> <span class="n">swab32</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">MCP_HEADER_PTR_OFFSET</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hdr_off</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="n">hdr_off</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Running firmware has bad header offset (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">hdr_off</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hdr_len</span> <span class="o">=</span> <span class="n">swab32</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">hdr_off</span> <span class="o">+</span>
			       <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_gen_header</span><span class="p">,</span> <span class="n">header_length</span><span class="p">)));</span>
	<span class="n">pattern_off</span> <span class="o">=</span> <span class="n">hdr_off</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_gen_header</span><span class="p">,</span> <span class="n">led_pattern</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pattern_off</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">hdr_len</span> <span class="o">+</span> <span class="n">hdr_off</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Firmware does not support LED identification</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">on</span><span class="p">)</span>
		<span class="n">pattern</span> <span class="o">=</span> <span class="n">swab32</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">pattern_off</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">htonl</span><span class="p">(</span><span class="n">pattern</span><span class="p">),</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">pattern_off</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">myri10ge_phys_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ethtool_phys_id_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETHTOOL_ID_ACTIVE</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">myri10ge_led</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ETHTOOL_ID_INACTIVE</span>:
		<span class="n">rc</span> <span class="o">=</span>  <span class="n">myri10ge_led</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">myri10ge_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_settings</span> <span class="o">=</span> <span class="n">myri10ge_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_drvinfo</span> <span class="o">=</span> <span class="n">myri10ge_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_coalesce</span> <span class="o">=</span> <span class="n">myri10ge_get_coalesce</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_coalesce</span> <span class="o">=</span> <span class="n">myri10ge_set_coalesce</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_pauseparam</span> <span class="o">=</span> <span class="n">myri10ge_get_pauseparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_pauseparam</span> <span class="o">=</span> <span class="n">myri10ge_set_pauseparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ringparam</span> <span class="o">=</span> <span class="n">myri10ge_get_ringparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span> <span class="o">=</span> <span class="n">ethtool_op_get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_strings</span> <span class="o">=</span> <span class="n">myri10ge_get_strings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_sset_count</span> <span class="o">=</span> <span class="n">myri10ge_get_sset_count</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ethtool_stats</span> <span class="o">=</span> <span class="n">myri10ge_get_ethtool_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span> <span class="o">=</span> <span class="n">myri10ge_set_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span> <span class="o">=</span> <span class="n">myri10ge_get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_phys_id</span> <span class="o">=</span> <span class="n">myri10ge_phys_id</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_allocate_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_ring_size</span><span class="p">,</span> <span class="n">rx_ring_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_ring_entries</span><span class="p">,</span> <span class="n">rx_ring_entries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">slice</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="cm">/* get ring sizes */</span>
	<span class="n">slice</span> <span class="o">=</span> <span class="n">ss</span> <span class="o">-</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">slice</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_SEND_RING_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tx_ring_size</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">slice</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">|=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_RX_RING_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">rx_ring_size</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span><span class="p">;</span>

	<span class="n">tx_ring_entries</span> <span class="o">=</span> <span class="n">tx_ring_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_kreq_ether_send</span><span class="p">);</span>
	<span class="n">rx_ring_entries</span> <span class="o">=</span> <span class="n">rx_ring_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_dma_addr</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">tx_ring_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">rx_ring_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* allocate the host shadow rings */</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">+</span> <span class="p">(</span><span class="n">MYRI10GE_MAX_SEND_DESC_TSO</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
	    <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_list</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_bytes</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_bytes</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_nothing</span><span class="p">;</span>

	<span class="cm">/* ensure req_list entries are aligned to 8 bytes */</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_list</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mcp_kreq_ether_send</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_bytes</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">queue_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="n">rx_ring_entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">shadow</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">shadow</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">shadow</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_tx_req_bytes</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="n">rx_ring_entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">shadow</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">shadow</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">shadow</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_rx_small_shadow</span><span class="p">;</span>

	<span class="cm">/* allocate the host info rings */</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="n">tx_ring_entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_rx_big_shadow</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="n">rx_ring_entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_tx_info</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="n">rx_ring_entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_rx_small_info</span><span class="p">;</span>

	<span class="cm">/* Fill the receive rings */</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">page_offset</span> <span class="o">=</span> <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">page_offset</span> <span class="o">=</span> <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">watchdog_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">watchdog_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">myri10ge_alloc_rx_pages</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">,</span>
					<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span> <span class="o">+</span> <span class="n">MXGEFW_PAD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">&lt;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;slice-%d: alloced only %d small bufs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">slice</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">fill_cnt</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_rx_small_ring</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">myri10ge_alloc_rx_pages</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">big_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">&lt;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;slice-%d: alloced only %d big bufs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">slice</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">fill_cnt</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_rx_big_ring</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">abort_with_rx_big_ring:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">fill_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">myri10ge_unmap_rx_page</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
				       <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">big_bytes</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">abort_with_rx_small_ring:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">fill_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">myri10ge_unmap_rx_page</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
				       <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span> <span class="o">+</span> <span class="n">MXGEFW_PAD</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>

<span class="nl">abort_with_rx_small_info:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>

<span class="nl">abort_with_tx_info:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>

<span class="nl">abort_with_rx_big_shadow:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">shadow</span><span class="p">);</span>

<span class="nl">abort_with_rx_small_shadow:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">shadow</span><span class="p">);</span>

<span class="nl">abort_with_tx_req_bytes:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_bytes</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_bytes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">abort_with_nothing:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_free_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_tx_buf</span> <span class="o">*</span><span class="n">tx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="cm">/* If not allocated, skip it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">fill_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page_offset</span> <span class="o">=</span> <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">;</span>
		<span class="n">myri10ge_unmap_rx_page</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
				       <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">big_bytes</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">fill_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page_offset</span> <span class="o">=</span>
			    <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">;</span>
		<span class="n">myri10ge_unmap_rx_page</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
				       <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span> <span class="o">+</span> <span class="n">MXGEFW_PAD</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">!=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">&amp;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">skb</span><span class="p">;</span>

		<span class="cm">/* Mark as free */</span>
		<span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tx</span><span class="o">-&gt;</span><span class="n">done</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">dma_unmap_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
				<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						 <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
								<span class="n">bus</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span>
						 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
				<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					       <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
							      <span class="n">bus</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span>
					       <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">shadow</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">shadow</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_bytes</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_bytes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_request_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msi_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_msi</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">,</span>
					    <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Error %d setting up MSI-X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_enabled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Error %d setting up MSI; falling back to xPIC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">status</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msi_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">irq_desc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">irq_desc</span><span class="p">),</span>
				 <span class="s">&quot;%s:slice-%d&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
					     <span class="n">myri10ge_intr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">irq_desc</span><span class="p">,</span>
					     <span class="n">ss</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;slice %d failed to allocate IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">i</span><span class="o">--</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">free_irq</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
					<span class="n">i</span><span class="o">--</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">myri10ge_intr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
				     <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to allocate IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msi_enabled</span><span class="p">)</span>
				<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_free_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msi_enabled</span><span class="p">)</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">)</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">myri10ge_get_frag_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">frag</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">mac_hdr</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">**</span><span class="n">ip_hdr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">tcpudp_hdr</span><span class="p">,</span>
			 <span class="n">u64</span> <span class="o">*</span> <span class="n">hdr_flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vlan_ethhdr</span> <span class="o">*</span><span class="n">veh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">va</span> <span class="o">=</span> <span class="n">skb_frag_address</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ll_hlen</span><span class="p">;</span>
	<span class="cm">/* passed opaque through lro_receive_frags() */</span>
	<span class="n">__wsum</span> <span class="n">csum</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__wsum</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">priv</span><span class="p">;</span>

	<span class="cm">/* find the mac header, aborting if not IPv4 */</span>

	<span class="n">eh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">va</span><span class="p">;</span>
	<span class="o">*</span><span class="n">mac_hdr</span> <span class="o">=</span> <span class="n">eh</span><span class="p">;</span>
	<span class="n">ll_hlen</span> <span class="o">=</span> <span class="n">ETH_HLEN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">h_proto</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">h_proto</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">veh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vlan_ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">va</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">veh</span><span class="o">-&gt;</span><span class="n">h_vlan_encapsulated_proto</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="n">ll_hlen</span> <span class="o">+=</span> <span class="n">VLAN_HLEN</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 *  HW checksum starts ETH_HLEN bytes into</span>
<span class="cm">			 *  frame, so we must subtract off the VLAN</span>
<span class="cm">			 *  header&#39;s checksum before csum can be used</span>
<span class="cm">			 */</span>
			<span class="n">csum</span> <span class="o">=</span> <span class="n">csum_sub</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span> <span class="n">csum_partial</span><span class="p">(</span><span class="n">va</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">,</span>
							   <span class="n">VLAN_HLEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">hdr_flags</span> <span class="o">=</span> <span class="n">LRO_IPV4</span><span class="p">;</span>

	<span class="n">iph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">va</span> <span class="o">+</span> <span class="n">ll_hlen</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ip_hdr</span> <span class="o">=</span> <span class="n">iph</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip_is_fragment</span><span class="p">(</span><span class="n">iph</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">hdr_flags</span> <span class="o">|=</span> <span class="n">LRO_TCP</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tcpudp_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">ip_hdr</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* verify the IP checksum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ip_fast_csum</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">iph</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* verify the  checksum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">csum_tcpudp_magic</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span>
				       <span class="n">ntohs</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">tot_len</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
				       <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="n">csum</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_get_txrx</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">slice</span><span class="p">];</span>
	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slice</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">slice</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_SEND_OFFSET</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">lanai</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mcp_kreq_ether_send</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
		    <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">slice</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">|=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_SMALL_RX_OFFSET</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">lanai</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mcp_kreq_ether_recv</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
	    <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span><span class="p">);</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">slice</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">|=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_BIG_RX_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">lanai</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mcp_kreq_ether_recv</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
	    <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span><span class="p">);</span>

	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">send_go</span> <span class="o">=</span> <span class="p">(</span><span class="n">__iomem</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">)</span>
	    <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">MXGEFW_ETH_SEND_GO</span> <span class="o">+</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">slice</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">send_stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">__iomem</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">)</span>
	    <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">MXGEFW_ETH_SEND_STOP</span> <span class="o">+</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">slice</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_set_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">slice</span><span class="p">];</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">MYRI10GE_LOWPART_TO_U32</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats_bus</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="n">MYRI10GE_HIGHPART_TO_U32</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats_bus</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data2</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_irq_data</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">slice</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_SET_STATS_DMA_V2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">bus</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats_bus</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slice</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">bus</span> <span class="o">+=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_irq_data</span><span class="p">,</span> <span class="n">send_done_count</span><span class="p">);</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">MYRI10GE_LOWPART_TO_U32</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="n">MYRI10GE_HIGHPART_TO_U32</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span>
					   <span class="n">MXGEFW_CMD_SET_STATS_DMA_OBSOLETE</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Firmware cannot support multicast without STATS_DMA_V2 */</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_multicast_support</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_multicast_support</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">big_pow2</span><span class="p">,</span> <span class="n">slice</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">itable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_lro_mgr</span> <span class="o">*</span><span class="n">lro_mgr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">!=</span> <span class="n">MYRI10GE_ETH_STOPPED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="n">MYRI10GE_ETH_STARTING</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_reset</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_nothing</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="n">MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">|=</span> <span class="n">MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_ENABLE_RSS_QUEUES</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to set number of slices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">abort_with_nothing</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* setup the indirection table */</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_SET_RSS_TABLE_SIZE</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">|=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span>
					    <span class="n">MXGEFW_CMD_GET_RSS_TABLE_OFFSET</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to setup rss tables</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">abort_with_nothing</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* just enable an identity mapping */</span>
		<span class="n">itable</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">__raw_writeb</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">itable</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="n">myri10ge_rss_hash</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_SET_RSS_ENABLE</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to enable slices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">abort_with_nothing</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_request_irq</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_nothing</span><span class="p">;</span>

	<span class="cm">/* decide what small buffer size to use.  For good TCP rx</span>
<span class="cm">	 * performance, it is important to not receive 1514 byte</span>
<span class="cm">	 * frames into jumbo buffers, as it confuses the socket buffer</span>
<span class="cm">	 * accounting code, leading to drops and erratic performance.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&lt;=</span> <span class="n">ETH_DATA_LEN</span><span class="p">)</span>
		<span class="cm">/* enough for a TCP header */</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">128</span> <span class="o">&gt;</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">)</span>
		    <span class="o">?</span> <span class="p">(</span><span class="mi">128</span> <span class="o">-</span> <span class="n">MXGEFW_PAD</span><span class="p">)</span>
		    <span class="o">:</span> <span class="p">(</span><span class="n">SMP_CACHE_BYTES</span> <span class="o">-</span> <span class="n">MXGEFW_PAD</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* enough for a vlan encapsulated ETH_DATA_LEN frame */</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span> <span class="o">=</span> <span class="n">VLAN_ETH_FRAME_LEN</span><span class="p">;</span>

	<span class="cm">/* Override the small buffer size? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_small_bytes</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span> <span class="o">=</span> <span class="n">myri10ge_small_bytes</span><span class="p">;</span>

	<span class="cm">/* Firmware needs the big buff size as a power of 2.  Lie and</span>
<span class="cm">	 * tell him the buffer is larger, because we only use 1</span>
<span class="cm">	 * buffer/pkt, and the mtu will prevent overruns.</span>
<span class="cm">	 */</span>
	<span class="n">big_pow2</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span> <span class="o">+</span> <span class="n">MXGEFW_PAD</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">big_pow2</span> <span class="o">&lt;</span> <span class="n">MYRI10GE_ALLOC_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">big_pow2</span><span class="p">))</span>
			<span class="n">big_pow2</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">big_bytes</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span> <span class="o">+</span> <span class="n">MXGEFW_PAD</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">big_pow2</span> <span class="o">=</span> <span class="n">MYRI10GE_ALLOC_SIZE</span><span class="p">;</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">big_bytes</span> <span class="o">=</span> <span class="n">big_pow2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* setup the per-slice data structures */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">slice</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slice</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">slice</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">slice</span><span class="p">];</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_get_txrx</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">slice</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to get ring sizes or locations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">abort_with_rings</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_allocate_rings</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort_with_rings</span><span class="p">;</span>

		<span class="cm">/* only firmware which supports multiple TX queues</span>
<span class="cm">		 * supports setting up the tx stats on non-zero</span>
<span class="cm">		 * slices */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slice</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_set_stats</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">slice</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t set stats DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">abort_with_rings</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lro_mgr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">lro_mgr</span><span class="p">;</span>
		<span class="n">lro_mgr</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">lro_mgr</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">LRO_F_NAPI</span><span class="p">;</span>
		<span class="n">lro_mgr</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_COMPLETE</span><span class="p">;</span>
		<span class="n">lro_mgr</span><span class="o">-&gt;</span><span class="n">ip_summed_aggr</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
		<span class="n">lro_mgr</span><span class="o">-&gt;</span><span class="n">max_desc</span> <span class="o">=</span> <span class="n">MYRI10GE_MAX_LRO_DESCRIPTORS</span><span class="p">;</span>
		<span class="n">lro_mgr</span><span class="o">-&gt;</span><span class="n">lro_arr</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">lro_desc</span><span class="p">;</span>
		<span class="n">lro_mgr</span><span class="o">-&gt;</span><span class="n">get_frag_header</span> <span class="o">=</span> <span class="n">myri10ge_get_frag_header</span><span class="p">;</span>
		<span class="n">lro_mgr</span><span class="o">-&gt;</span><span class="n">max_aggr</span> <span class="o">=</span> <span class="n">myri10ge_lro_max_pkts</span><span class="p">;</span>
		<span class="n">lro_mgr</span><span class="o">-&gt;</span><span class="n">frag_align_pad</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lro_mgr</span><span class="o">-&gt;</span><span class="n">max_aggr</span> <span class="o">&gt;</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span>
			<span class="n">lro_mgr</span><span class="o">-&gt;</span><span class="n">max_aggr</span> <span class="o">=</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">;</span>

		<span class="cm">/* must happen prior to any irq */</span>
		<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now give firmware buffers sizes, and MTU */</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_SET_MTU</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">|=</span>
	    <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_SET_SMALL_BUFFER_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">big_pow2</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">|=</span>
	    <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_SET_BIG_BUFFER_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t set buffer sizes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_rings</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set Linux style TSO mode; this is needed only on newer</span>
<span class="cm">	 *  firmware versions.  Older versions default to Linux</span>
<span class="cm">	 *  style TSO</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_SET_TSO_MODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t set TSO mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_rings</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">rdma_tags_available</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_ETHERNET_UP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t bring up link</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_rings</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="n">MYRI10GE_ETH_RUNNING</span><span class="p">;</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">myri10ge_watchdog_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">netif_tx_wake_all_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">abort_with_rings:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">slice</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slice</span><span class="o">--</span><span class="p">;</span>
		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">slice</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">myri10ge_free_rings</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">myri10ge_free_irq</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>

<span class="nl">abort_with_nothing:</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="n">MYRI10GE_ETH_STOPPED</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">old_down_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">!=</span> <span class="n">MYRI10GE_ETH_RUNNING</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx</span><span class="p">.</span><span class="n">req_bytes</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="n">MYRI10GE_ETH_STOPPING</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netif_tx_stop_all_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">rebooted</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">old_down_cnt</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">down_cnt</span><span class="p">;</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_ETHERNET_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t bring down link</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">down_wq</span><span class="p">,</span> <span class="n">old_down_cnt</span> <span class="o">!=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">down_cnt</span><span class="p">,</span>
				   <span class="n">HZ</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_down_cnt</span> <span class="o">==</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">down_cnt</span><span class="p">)</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;never got down irq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">netif_tx_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">myri10ge_free_irq</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">myri10ge_free_rings</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="n">MYRI10GE_ETH_STOPPED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* copy an array of struct mcp_kreq_ether_send&#39;s to the mcp.  Copy</span>
<span class="cm"> * backwards one at a time and handle ring wraps */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">myri10ge_submit_req_backwards</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_tx_buf</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">mcp_kreq_ether_send</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">starting_slot</span><span class="p">;</span>
	<span class="n">starting_slot</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">starting_slot</span> <span class="o">+</span> <span class="n">cnt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">myri10ge_pio_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">lanai</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">));</span>
		<span class="n">mb</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * copy an array of struct mcp_kreq_ether_send&#39;s to the mcp.  Copy</span>
<span class="cm"> * at most 32 bytes at a time, so as to avoid involving the software</span>
<span class="cm"> * pio handler in the nic.   We re-write the first segment&#39;s flags</span>
<span class="cm"> * to mark them valid only after writing the entire chain.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">myri10ge_submit_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_tx_buf</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcp_kreq_ether_send</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp_kreq_ether_send</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp_kreq_ether_send</span> <span class="o">*</span><span class="n">srcp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">last_flags</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">&amp;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>

	<span class="n">last_flags</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">src</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">dst</span> <span class="o">=</span> <span class="n">dstp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">lanai</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">srcp</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">idx</span> <span class="o">+</span> <span class="n">cnt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">myri10ge_pio_copy</span><span class="p">(</span><span class="n">dstp</span><span class="p">,</span> <span class="n">srcp</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">));</span>
			<span class="n">mb</span><span class="p">();</span>	<span class="cm">/* force write every 32 bytes */</span>
			<span class="n">srcp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">dstp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* submit all but the first request, and ensure</span>
<span class="cm">		 * that it is submitted below */</span>
		<span class="n">myri10ge_submit_req_backwards</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* submit the first request */</span>
		<span class="n">myri10ge_pio_copy</span><span class="p">(</span><span class="n">dstp</span><span class="p">,</span> <span class="n">srcp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">));</span>
		<span class="n">mb</span><span class="p">();</span>		<span class="cm">/* barrier before setting valid flag */</span>
	<span class="p">}</span>

	<span class="cm">/* re-write the last 32-bits with the valid flags */</span>
	<span class="n">src</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">last_flags</span><span class="p">;</span>
	<span class="n">put_be32</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="n">src</span> <span class="o">+</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="n">__be32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="n">dst</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transmit a packet.  We need to split the packet so that a single</span>
<span class="cm"> * segment does not cross myri10ge-&gt;tx_boundary, so this makes segment</span>
<span class="cm"> * counting tricky.  So rather than try to count segments up front, we</span>
<span class="cm"> * just give up if there are too few segments to hold a reasonably</span>
<span class="cm"> * fragmented packet currently available.  If we run</span>
<span class="cm"> * out of segments while preparing a packet for DMA, we just linearize</span>
<span class="cm"> * it and try again.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">myri10ge_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp_kreq_ether_send</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_tx_buf</span> <span class="o">*</span><span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">netdev_queue</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bus</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">low</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">high_swapped</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">last_idx</span><span class="p">,</span> <span class="n">avail</span><span class="p">,</span> <span class="n">frag_cnt</span><span class="p">,</span> <span class="n">frag_idx</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">mss</span><span class="p">,</span> <span class="n">max_segments</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pseudo_hdr_offset</span><span class="p">,</span> <span class="n">cksum_offset</span><span class="p">,</span> <span class="n">queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cum_len</span><span class="p">,</span> <span class="n">seglen</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">rdma_count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">odd_flag</span><span class="p">;</span>

	<span class="n">queue</span> <span class="o">=</span> <span class="n">skb_get_queue_mapping</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">queue</span><span class="p">];</span>
	<span class="n">netdev_queue</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="n">tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">req_list</span><span class="p">;</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">-</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>

	<span class="n">mss</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">max_segments</span> <span class="o">=</span> <span class="n">MXGEFW_MAX_SEND_DESC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
		<span class="n">max_segments</span> <span class="o">=</span> <span class="n">MYRI10GE_MAX_SEND_DESC_TSO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">unlikely</span><span class="p">(</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="n">max_segments</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* we are out of transmit resources */</span>
		<span class="n">tx</span><span class="o">-&gt;</span><span class="n">stop_queue</span><span class="o">++</span><span class="p">;</span>
		<span class="n">netif_tx_stop_queue</span><span class="p">(</span><span class="n">netdev_queue</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup checksum offloading, if needed */</span>
	<span class="n">cksum_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pseudo_hdr_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">odd_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">MXGEFW_FLAGS_NO_TSO</span> <span class="o">|</span> <span class="n">MXGEFW_FLAGS_FIRST</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cksum_offset</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">pseudo_hdr_offset</span> <span class="o">=</span> <span class="n">cksum_offset</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>
		<span class="cm">/* If the headers are excessively large, then we must</span>
<span class="cm">		 * fall back to a software checksum */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mss</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cksum_offset</span> <span class="o">&gt;</span> <span class="mi">255</span> <span class="o">||</span>
				      <span class="n">pseudo_hdr_offset</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_checksum_help</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
			<span class="n">cksum_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pseudo_hdr_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">odd_flag</span> <span class="o">=</span> <span class="n">MXGEFW_FLAGS_ALIGN_ODD</span><span class="p">;</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">MXGEFW_FLAGS_CKSUM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cum_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mss</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* TSO */</span>
		<span class="cm">/* this removes any CKSUM flag from before */</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">MXGEFW_FLAGS_TSO_HDR</span> <span class="o">|</span> <span class="n">MXGEFW_FLAGS_FIRST</span><span class="p">);</span>

		<span class="cm">/* negative cum_len signifies to the</span>
<span class="cm">		 * send loop that we are still in the</span>
<span class="cm">		 * header portion of the TSO packet.</span>
<span class="cm">		 * TSO header can be at most 1KB long */</span>
		<span class="n">cum_len</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

		<span class="cm">/* for IPv6 TSO, the checksum offset stores the</span>
<span class="cm">		 * TCP header length, to save the firmware from</span>
<span class="cm">		 * the need to parse the headers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cksum_offset</span> <span class="o">=</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="cm">/* Can only handle headers &lt;= max_tso6 long */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">-</span><span class="n">cum_len</span> <span class="o">&gt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">max_tso6</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">myri10ge_sw_tso</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* for TSO, pseudo_hdr_offset holds mss.</span>
<span class="cm">		 * The firmware figures out where to put</span>
<span class="cm">		 * the checksum by parsing the header. */</span>
		<span class="n">pseudo_hdr_offset</span> <span class="o">=</span> <span class="n">mss</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Mark small packets, and pad out tiny packets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">MXGEFW_SEND_SMALL_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">MXGEFW_FLAGS_SMALL</span><span class="p">;</span>

		<span class="cm">/* pad frames to at least ETH_ZLEN bytes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ETH_ZLEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_padto</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_ZLEN</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* The packet is gone, so we must</span>
<span class="cm">				 * return 0 */</span>
				<span class="n">ss</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* adjust the len to account for the zero pad</span>
<span class="cm">			 * so that the nic can know how long it is */</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">ETH_ZLEN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* map the skb for DMA */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">&amp;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">bus</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">bus</span><span class="p">,</span> <span class="n">bus</span><span class="p">);</span>
	<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">len</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">frag_cnt</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="n">frag_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rdma_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* &quot;rdma_count&quot; is the number of RDMAs belonging to the</span>
<span class="cm">	 * current packet BEFORE the current send request. For</span>
<span class="cm">	 * non-TSO packets, this is equal to &quot;count&quot;.</span>
<span class="cm">	 * For TSO packets, rdma_count needs to be reset</span>
<span class="cm">	 * to 0 after a segment cut.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The rdma_count field of the send request is</span>
<span class="cm">	 * the number of RDMAs of the packet starting at</span>
<span class="cm">	 * that request. For TSO send requests with one ore more cuts</span>
<span class="cm">	 * in the middle, this is the number of RDMAs starting</span>
<span class="cm">	 * after the last cut in the request. All previous</span>
<span class="cm">	 * segments before the last cut implicitly have 1 RDMA.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Since the number of RDMAs is not known beforehand,</span>
<span class="cm">	 * it must be filled-in retroactively - after each</span>
<span class="cm">	 * segmentation cut or at the end of the entire packet.</span>
<span class="cm">	 */</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Break the SKB or Fragment up into pieces which</span>
<span class="cm">		 * do not cross mgp-&gt;tx_boundary */</span>
		<span class="n">low</span> <span class="o">=</span> <span class="n">MYRI10GE_LOWPART_TO_U32</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
		<span class="n">high_swapped</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">MYRI10GE_HIGHPART_TO_U32</span><span class="p">(</span><span class="n">bus</span><span class="p">));</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">flags_next</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">cum_len_next</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">max_segments</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">abort_linearize</span><span class="p">;</span>

			<span class="n">boundary</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">seglen</span> <span class="o">=</span> <span class="n">boundary</span> <span class="o">-</span> <span class="n">low</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">seglen</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">seglen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">flags_next</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MXGEFW_FLAGS_FIRST</span><span class="p">;</span>
			<span class="n">cum_len_next</span> <span class="o">=</span> <span class="n">cum_len</span> <span class="o">+</span> <span class="n">seglen</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mss</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* TSO */</span>
				<span class="p">(</span><span class="n">req</span> <span class="o">-</span> <span class="n">rdma_count</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rdma_count</span> <span class="o">=</span> <span class="n">rdma_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cum_len</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* payload */</span>
					<span class="kt">int</span> <span class="n">next_is_first</span><span class="p">,</span> <span class="n">chop</span><span class="p">;</span>

					<span class="n">chop</span> <span class="o">=</span> <span class="p">(</span><span class="n">cum_len_next</span> <span class="o">&gt;</span> <span class="n">mss</span><span class="p">);</span>
					<span class="n">cum_len_next</span> <span class="o">=</span> <span class="n">cum_len_next</span> <span class="o">%</span> <span class="n">mss</span><span class="p">;</span>
					<span class="n">next_is_first</span> <span class="o">=</span> <span class="p">(</span><span class="n">cum_len_next</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
					<span class="n">flags</span> <span class="o">|=</span> <span class="n">chop</span> <span class="o">*</span> <span class="n">MXGEFW_FLAGS_TSO_CHOP</span><span class="p">;</span>
					<span class="n">flags_next</span> <span class="o">|=</span> <span class="n">next_is_first</span> <span class="o">*</span>
					    <span class="n">MXGEFW_FLAGS_FIRST</span><span class="p">;</span>
					<span class="n">rdma_count</span> <span class="o">|=</span> <span class="o">-</span><span class="p">(</span><span class="n">chop</span> <span class="o">|</span> <span class="n">next_is_first</span><span class="p">);</span>
					<span class="n">rdma_count</span> <span class="o">+=</span> <span class="n">chop</span> <span class="o">&amp;</span> <span class="o">!</span><span class="n">next_is_first</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cum_len_next</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* header ends */</span>
					<span class="kt">int</span> <span class="n">small</span><span class="p">;</span>

					<span class="n">rdma_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
					<span class="n">cum_len_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">seglen</span> <span class="o">=</span> <span class="o">-</span><span class="n">cum_len</span><span class="p">;</span>
					<span class="n">small</span> <span class="o">=</span> <span class="p">(</span><span class="n">mss</span> <span class="o">&lt;=</span> <span class="n">MXGEFW_SEND_SMALL_SIZE</span><span class="p">);</span>
					<span class="n">flags_next</span> <span class="o">=</span> <span class="n">MXGEFW_FLAGS_TSO_PLD</span> <span class="o">|</span>
					    <span class="n">MXGEFW_FLAGS_FIRST</span> <span class="o">|</span>
					    <span class="p">(</span><span class="n">small</span> <span class="o">*</span> <span class="n">MXGEFW_FLAGS_SMALL</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">addr_high</span> <span class="o">=</span> <span class="n">high_swapped</span><span class="p">;</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">addr_low</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">low</span><span class="p">);</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">pseudo_hdr_offset</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">pseudo_hdr_offset</span><span class="p">);</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* complete solid 16-byte block; does this matter? */</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">rdma_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">seglen</span><span class="p">);</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">cksum_offset</span> <span class="o">=</span> <span class="n">cksum_offset</span><span class="p">;</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">|</span> <span class="p">((</span><span class="n">cum_len</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">odd_flag</span><span class="p">);</span>

			<span class="n">low</span> <span class="o">+=</span> <span class="n">seglen</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">seglen</span><span class="p">;</span>
			<span class="n">cum_len</span> <span class="o">=</span> <span class="n">cum_len_next</span><span class="p">;</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">flags_next</span><span class="p">;</span>
			<span class="n">req</span><span class="o">++</span><span class="p">;</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rdma_count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cksum_offset</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">mss</span> <span class="o">&amp;&amp;</span> <span class="n">skb_is_gso_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cksum_offset</span> <span class="o">&gt;</span> <span class="n">seglen</span><span class="p">))</span>
					<span class="n">cksum_offset</span> <span class="o">-=</span> <span class="n">seglen</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">cksum_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frag_idx</span> <span class="o">==</span> <span class="n">frag_cnt</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* map next fragment for DMA */</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">frag_idx</span><span class="p">];</span>
		<span class="n">frag_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="n">bus</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				       <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">bus</span><span class="p">,</span> <span class="n">bus</span><span class="p">);</span>
		<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">len</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="n">req</span> <span class="o">-</span> <span class="n">rdma_count</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rdma_count</span> <span class="o">=</span> <span class="n">rdma_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mss</span><span class="p">)</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">--</span><span class="p">;</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MXGEFW_FLAGS_TSO_LAST</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MXGEFW_FLAGS_TSO_CHOP</span> <span class="o">|</span>
					 <span class="n">MXGEFW_FLAGS_FIRST</span><span class="p">)));</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="p">((</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">myri10ge_submit_req</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">req_list</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="cm">/* if using multiple tx queues, make sure NIC polls the</span>
<span class="cm">	 * current slice */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">queue_active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx</span><span class="o">-&gt;</span><span class="n">queue_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">put_be32</span><span class="p">(</span><span class="n">htonl</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">send_go</span><span class="p">);</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="n">mmiowb</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">pkt_start</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">avail</span> <span class="o">-</span> <span class="n">count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MXGEFW_MAX_SEND_DESC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx</span><span class="o">-&gt;</span><span class="n">stop_queue</span><span class="o">++</span><span class="p">;</span>
		<span class="n">netif_tx_stop_queue</span><span class="p">(</span><span class="n">netdev_queue</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

<span class="nl">abort_linearize:</span>
	<span class="cm">/* Free any DMA resources we&#39;ve alloced and clear out the skb</span>
<span class="cm">	 * slot so as to not trip up assertions, and to avoid a</span>
<span class="cm">	 * double-free if linearizing fails */</span>

	<span class="n">last_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">&amp;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">dma_unmap_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						 <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
								<span class="n">bus</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span>
						 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					       <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
							      <span class="n">bus</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span>
					       <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">tx</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="n">last_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TSO but wanted to linearize?!?!?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">linearized</span><span class="o">++</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

<span class="nl">drop:</span>
	<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">myri10ge_sw_tso</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">segs</span><span class="p">,</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="n">netdev_tx_t</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">segs</span> <span class="o">=</span> <span class="n">skb_gso_segment</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">NETIF_F_TSO6</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">segs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">segs</span><span class="p">;</span>
		<span class="n">segs</span> <span class="o">=</span> <span class="n">segs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_xmit</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">segs</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curr</span> <span class="o">=</span> <span class="n">segs</span><span class="p">;</span>
				<span class="n">segs</span> <span class="o">=</span> <span class="n">segs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">segs</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

<span class="nl">drop:</span>
	<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">skb_get_queue_mapping</span><span class="p">(</span><span class="n">skb</span><span class="p">)];</span>
	<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="nf">myri10ge_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">myri10ge_slice_netstats</span> <span class="o">*</span><span class="n">slice_stats</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slice_stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stats</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span> <span class="o">+=</span> <span class="n">slice_stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span> <span class="o">+=</span> <span class="n">slice_stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">slice_stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">slice_stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_dropped</span> <span class="o">+=</span> <span class="n">slice_stats</span><span class="o">-&gt;</span><span class="n">rx_dropped</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_dropped</span> <span class="o">+=</span> <span class="n">slice_stats</span><span class="o">-&gt;</span><span class="n">tx_dropped</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* can be called from atomic contexts,</span>
<span class="cm">	 * pass 1 to force atomicity in myri10ge_send_cmd() */</span>
	<span class="n">myri10ge_change_promisc</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* This firmware is known to not support multicast */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_multicast_support</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Disable multicast filtering */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_ENABLE_ALLMULTI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed MXGEFW_ENABLE_ALLMULTI, error status: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="o">||</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">adopted_rx_filter_bug</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* request to disable multicast filtering, so quit here */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Flush the filters */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_LEAVE_ALL_MULTICAST_GROUPS</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed MXGEFW_LEAVE_ALL_MULTICAST_GROUPS, error status: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Walk the multicast list, and add each address */</span>
	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_JOIN_MULTICAST_GROUP</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed MXGEFW_JOIN_MULTICAST_GROUP, error status:%d %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">err</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Enable multicast filtering */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_DISABLE_ALLMULTI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed MXGEFW_DISABLE_ALLMULTI, error status: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">abort:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_update_mac_address</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;changing mac address failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* change the dev structure */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_features_t</span> <span class="nf">myri10ge_fix_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">))</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_LRO</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">features</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="mi">68</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="n">MYRI10GE_MAX_ETHER_MTU</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;new mtu (%d) is not valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;changing mtu from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if we change the mtu on an active device, we must</span>
<span class="cm">		 * reset the device so the firmware sees the change */</span>
		<span class="n">myri10ge_close</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>
		<span class="n">myri10ge_open</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable ECRC to align PCI-E Completion packets on an 8-byte boundary.</span>
<span class="cm"> * Only do it if the bridge is a root port since we don&#39;t want to disturb</span>
<span class="cm"> * any other device, except if forced with myri10ge_ecrc_enable &gt; 1.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_enable_ecrc</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">err_cap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ext_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">myri10ge_ecrc_enable</span> <span class="o">||</span> <span class="o">!</span><span class="n">bridge</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* check that the bridge is a root port */</span>
	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_CAP_FLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="n">ext_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_FLAGS_TYPE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext_type</span> <span class="o">!=</span> <span class="n">PCI_EXP_TYPE_ROOT_PORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_ecrc_enable</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">prev_bridge</span><span class="p">,</span> <span class="o">*</span><span class="n">old_bridge</span> <span class="o">=</span> <span class="n">bridge</span><span class="p">;</span>

			<span class="cm">/* Walk the hierarchy up to the root port</span>
<span class="cm">			 * where ECRC has to be enabled */</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">prev_bridge</span> <span class="o">=</span> <span class="n">bridge</span><span class="p">;</span>
				<span class="n">bridge</span> <span class="o">=</span> <span class="n">bridge</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bridge</span> <span class="o">||</span> <span class="n">prev_bridge</span> <span class="o">==</span> <span class="n">bridge</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;Failed to find root port&quot;</span>
						<span class="s">&quot; to force ECRC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>
				<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span>
						     <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_CAP_FLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
				<span class="n">ext_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_FLAGS_TYPE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ext_type</span> <span class="o">!=</span> <span class="n">PCI_EXP_TYPE_ROOT_PORT</span><span class="p">);</span>

			<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Forcing ECRC on non-root port %s&quot;</span>
				 <span class="s">&quot; (enabling on root port %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">pci_name</span><span class="p">(</span><span class="n">old_bridge</span><span class="p">),</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">bridge</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Not enabling ECRC on non-root port %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pci_name</span><span class="p">(</span><span class="n">bridge</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">PCI_EXT_CAP_ID_ERR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_ERR_CAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err_cap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed reading ext-conf-space of %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">bridge</span><span class="p">));</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s"> pci=nommconf in use? &quot;</span>
			<span class="s">&quot;or buggy/incomplete/absent ACPI MCFG attr?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">err_cap</span> <span class="o">&amp;</span> <span class="n">PCI_ERR_CAP_ECRC_GENC</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">err_cap</span> <span class="o">|=</span> <span class="n">PCI_ERR_CAP_ECRC_GENE</span><span class="p">;</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_ERR_CAP</span><span class="p">,</span> <span class="n">err_cap</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enabled ECRC on upstream bridge %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">bridge</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The Lanai Z8E PCI-E interface achieves higher Read-DMA throughput</span>
<span class="cm"> * when the PCI-E Completion packets are aligned on an 8-byte</span>
<span class="cm"> * boundary.  Some PCI-E chip sets always align Completion packets; on</span>
<span class="cm"> * the ones that do not, the alignment can be enforced by enabling</span>
<span class="cm"> * ECRC generation (if supported).</span>
<span class="cm"> *</span>
<span class="cm"> * When PCI-E Completion packets are not aligned, it is actually more</span>
<span class="cm"> * efficient to limit Read-DMA transactions to 2KB, rather than 4KB.</span>
<span class="cm"> *</span>
<span class="cm"> * If the driver can neither enable ECRC nor verify that it has</span>
<span class="cm"> * already been enabled, then it must use a firmware image which works</span>
<span class="cm"> * around unaligned completion packets (myri10ge_rss_ethp_z8e.dat), and it</span>
<span class="cm"> * should also ensure that it never gives the device a Read-DMA which is</span>
<span class="cm"> * larger than 2KB by setting the tx_boundary to 2KB.  If ECRC is</span>
<span class="cm"> * enabled, then the driver should use the aligned (myri10ge_rss_eth_z8e.dat)</span>
<span class="cm"> * firmware image, and set tx_boundary to 4KB.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_firmware_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Verify the max read request size was set to 4KB</span>
<span class="cm">	 * before trying the test with 4KB.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">pcie_get_readrq</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t read max read req size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">4096</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Max Read Request size != 4096 (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * load the optimized firmware (which assumes aligned PCIe</span>
<span class="cm">	 * completions) in order to see if it works on this host.</span>
<span class="cm">	 */</span>
	<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">myri10ge_fw_aligned</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_load_firmware</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable ECRC if possible</span>
<span class="cm">	 */</span>
	<span class="n">myri10ge_enable_ecrc</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Run a DMA test which watches for unaligned completions and</span>
<span class="cm">	 * aborts on the first one seen.</span>
<span class="cm">	 */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_dma_test</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_UNALIGNED_TEST</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* keep the aligned firmware */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA test failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Falling back to ethp! &quot;</span>
			 <span class="s">&quot;Please install up to date fw</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">abort:</span>
	<span class="cm">/* fall back to using the unaligned firmware */</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
	<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">myri10ge_fw_unaligned</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_select_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">overridden</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_force_firmware</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">link_width</span><span class="p">,</span> <span class="n">exp_cap</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">lnk</span><span class="p">;</span>

		<span class="n">exp_cap</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">exp_cap</span> <span class="o">+</span> <span class="n">PCI_EXP_LNKSTA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnk</span><span class="p">);</span>
		<span class="n">link_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">lnk</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>

		<span class="cm">/* Check to see if Link is less than 8 or if the</span>
<span class="cm">		 * upstream bridge is known to provide aligned</span>
<span class="cm">		 * completions */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">link_width</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCIE x%d Link</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">link_width</span><span class="p">);</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
			<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">myri10ge_fw_aligned</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">myri10ge_firmware_probe</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_force_firmware</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Assuming aligned completions (forced)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
			<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">myri10ge_fw_aligned</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Assuming unaligned completions (forced)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
			<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">myri10ge_fw_unaligned</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kparam_block_sysfs_write</span><span class="p">(</span><span class="n">myri10ge_fw_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_fw_name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">fw_name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">myri10ge_fw_name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fw_name</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">overridden</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">fw_name</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kparam_unblock_sysfs_write</span><span class="p">(</span><span class="n">myri10ge_fw_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_number</span> <span class="o">&lt;</span> <span class="n">MYRI10GE_MAX_BOARDS</span> <span class="o">&amp;&amp;</span>
	    <span class="n">myri10ge_fw_names</span><span class="p">[</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_number</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">strlen</span><span class="p">(</span><span class="n">myri10ge_fw_names</span><span class="p">[</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_number</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">myri10ge_fw_names</span><span class="p">[</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_number</span><span class="p">],</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">overridden</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">overridden</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;overriding firmware to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_mask_surprise_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bridge</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">PCI_EXT_CAP_ID_ERR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* a sram parity error can cause a surprise link</span>
<span class="cm">		 * down; since we expect and can recover from sram</span>
<span class="cm">		 * parity errors, mask surprise link down events */</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_MASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="mh">0x20</span><span class="p">;</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_MASK</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">mgp</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">netdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;closing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="n">myri10ge_close</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">myri10ge_dummy_rdma</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vendor</span><span class="p">;</span>

	<span class="n">mgp</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">netdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* zeros conf space as a side effect */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>		<span class="cm">/* give card time to respond */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_VENDOR_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vendor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vendor</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device disappeared!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to enable device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">myri10ge_reset</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="n">myri10ge_dummy_rdma</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Save configuration space to be restored if the</span>
<span class="cm">	 * nic resets due to a parity error */</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_open</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort_with_enabled</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">abort_with_enabled:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">myri10ge_read_reboot</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vs</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">vendor_specific_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reboot</span><span class="p">;</span>

	<span class="cm">/*enter read32 mode */</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">vs</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">);</span>

	<span class="cm">/*read REBOOT_STATUS (0xfffffff0) */</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">vs</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0xfffffff0</span><span class="p">);</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">vs</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reboot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">reboot</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">myri10ge_check_slice</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">reset_needed</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="o">*</span><span class="n">busy_slice_cnt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx_pause_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">ss</span> <span class="o">-</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req</span> <span class="o">!=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">done</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">done</span> <span class="o">==</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">watchdog_tx_done</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">watchdog_tx_req</span> <span class="o">!=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">watchdog_tx_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* nic seems like it might be stuck.. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_pause_cnt</span> <span class="o">!=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_pause</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
				<span class="n">netdev_warn</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;slice %d: TX paused, &quot;</span>
					    <span class="s">&quot;check link partner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slice</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="s">&quot;slice %d: TX stuck %d %d %d %d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">slice</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">queue_active</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req</span><span class="p">,</span>
				    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">done</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">pkt_start</span><span class="p">,</span>
				    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">pkt_done</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ntohl</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">slice</span><span class="p">].</span><span class="n">fw_stats</span><span class="o">-&gt;</span>
					       <span class="n">send_done_count</span><span class="p">));</span>
			<span class="o">*</span><span class="n">reset_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">stuck</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">watchdog_tx_done</span> <span class="o">!=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">done</span> <span class="o">||</span>
	    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">watchdog_rx_done</span> <span class="o">!=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">busy_slice_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">watchdog_tx_done</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">done</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">watchdog_tx_req</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">req</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">watchdog_rx_done</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This watchdog is used to check whether the board has suffered</span>
<span class="cm"> * from a parity error and needs to be recovered.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span> <span class="o">=</span>
	    <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">myri10ge_priv</span><span class="p">,</span> <span class="n">watchdog_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reboot</span><span class="p">,</span> <span class="n">rx_pause_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">rebooted</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">busy_slice_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">vendor</span><span class="p">;</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_resets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">rebooted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_MASTER</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Bus master DMA disabled?  Check to see</span>
<span class="cm">		 * if the card rebooted due to a parity error</span>
<span class="cm">		 * For now, just report it */</span>
		<span class="n">reboot</span> <span class="o">=</span> <span class="n">myri10ge_read_reboot</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NIC rebooted (0x%x),%s resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">reboot</span><span class="p">,</span> <span class="n">myri10ge_reset_recover</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot; not&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_reset_recover</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">rebooted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rebooted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">myri10ge_close</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">myri10ge_reset_recover</span><span class="o">--</span><span class="p">;</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">rebooted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * A rebooted nic will come back with config space as</span>
<span class="cm">		 * it was after power was applied to PCIe bus.</span>
<span class="cm">		 * Attempt to restore config space which was saved</span>
<span class="cm">		 * when the driver was loaded, or the last time the</span>
<span class="cm">		 * nic was resumed from power saving mode.</span>
<span class="cm">		 */</span>
		<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

		<span class="cm">/* save state again for accounting reasons */</span>
		<span class="n">pci_save_state</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* if we get back -1&#39;s from our slot, perhaps somebody</span>
<span class="cm">		 * powered off our card.  Don&#39;t try to reset it in</span>
<span class="cm">		 * this case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_VENDOR_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vendor</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vendor</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">netdev_err</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device disappeared!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Perhaps it is a software error. See if stuck slice</span>
<span class="cm">		 * has recovered, reset if not */</span>
		<span class="n">rx_pause_cnt</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_pause</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ss</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">stuck</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">myri10ge_check_slice</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reset_needed</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">busy_slice_cnt</span><span class="p">,</span>
						     <span class="n">rx_pause_cnt</span><span class="p">);</span>
				<span class="n">ss</span><span class="o">-&gt;</span><span class="n">stuck</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reset_needed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;not resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">netdev_err</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device timeout, resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rebooted</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="n">myri10ge_close</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_load_firmware</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to load firmware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">myri10ge_open</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We use our own timer routine rather than relying upon</span>
<span class="cm"> * netdev-&gt;tx_timeout because we have a very large hardware transmit</span>
<span class="cm"> * queue.  Due to the large queue, the netdev-&gt;tx_timeout function</span>
<span class="cm"> * cannot detect a NIC with a parity error in a timely fashion if the</span>
<span class="cm"> * NIC is lightly loaded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_watchdog_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">reset_needed</span><span class="p">,</span> <span class="n">busy_slice_cnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_pause_cnt</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">mgp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="n">rx_pause_cnt</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fw_stats</span><span class="o">-&gt;</span><span class="n">dropped_pause</span><span class="p">);</span>
	<span class="n">busy_slice_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reset_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">&amp;&amp;</span> <span class="n">reset_needed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">watchdog_needed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">myri10ge_alloc_rx_pages</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">,</span>
						<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">small_bytes</span> <span class="o">+</span> <span class="n">MXGEFW_PAD</span><span class="p">,</span>
						<span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">-</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">cnt</span> <span class="o">&gt;=</span>
			    <span class="n">myri10ge_fill_thresh</span><span class="p">)</span>
				<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_small</span><span class="p">.</span><span class="n">watchdog_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">watchdog_needed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">myri10ge_alloc_rx_pages</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">,</span>
						<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">big_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">fill_cnt</span> <span class="o">-</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">cnt</span> <span class="o">&gt;=</span>
			    <span class="n">myri10ge_fill_thresh</span><span class="p">)</span>
				<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_big</span><span class="p">.</span><span class="n">watchdog_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">myri10ge_check_slice</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reset_needed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">busy_slice_cnt</span><span class="p">,</span>
				     <span class="n">rx_pause_cnt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* if we&#39;ve sent or received no traffic, poll the NIC to</span>
<span class="cm">	 * ensure it is still there.  Otherwise, we risk not noticing</span>
<span class="cm">	 * an error in a timely fashion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busy_slice_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_MASTER</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reset_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_pause</span> <span class="o">=</span> <span class="n">rx_pause_cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reset_needed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* rearm timer */</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span>
			  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">myri10ge_watchdog_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_free_slices</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">entry</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">max_intr_slots</span> <span class="o">*</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span>
					  <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">entry</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">bus</span><span class="p">);</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="p">);</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span>
					  <span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats_bus</span><span class="p">);</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">netif_napi_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_alloc_slices</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_slice_state</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">max_intr_slots</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">entry</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">bus</span><span class="p">,</span>
						       <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_done</span><span class="p">.</span><span class="n">entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span><span class="p">);</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats_bus</span><span class="p">,</span>
						  <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fw_stats</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">mgp</span> <span class="o">=</span> <span class="n">mgp</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">myri10ge_poll</span><span class="p">,</span>
			       <span class="n">myri10ge_napi_weight</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">abort:</span>
	<span class="n">myri10ge_free_slices</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function determines the number of slices supported.</span>
<span class="cm"> * The number slices is the minimum of the number of CPUS,</span>
<span class="cm"> * the number of MSI-X irqs supported, the number of slices</span>
<span class="cm"> * supported by the firmware</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_probe_slices</span><span class="p">(</span><span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">old_fw</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">old_allocated</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">ncpus</span><span class="p">,</span> <span class="n">msix_cap</span><span class="p">;</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">msix_cap</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_MSIX</span><span class="p">);</span>
	<span class="n">ncpus</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_max_slices</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">msix_cap</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">myri10ge_max_slices</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">ncpus</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* try to load the slice aware rss firmware */</span>
	<span class="n">old_fw</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">;</span>
	<span class="n">old_allocated</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name_allocated</span><span class="p">;</span>
	<span class="cm">/* don&#39;t free old_fw if we override it. */</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name_allocated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_fw_name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;overriding rss firmware to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">myri10ge_fw_name</span><span class="p">);</span>
		<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">myri10ge_fw_name</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_fw</span> <span class="o">==</span> <span class="n">myri10ge_fw_aligned</span><span class="p">)</span>
		<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">myri10ge_fw_rss_aligned</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">myri10ge_fw_rss_unaligned</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_load_firmware</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Rss firmware not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_allocated</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">old_fw</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* hit the board with a reset to ensure it is alive */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_RESET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_fw</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">max_intr_slots</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_slot</span><span class="p">);</span>

	<span class="cm">/* tell it the size of the interrupt queues */</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">data0</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">max_intr_slots</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_slot</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_SET_INTRQ_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed MXGEFW_CMD_SET_INTRQ_SIZE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_fw</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ask the maximum number of slices it supports */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_send_cmd</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">MXGEFW_CMD_GET_MAX_RSS_QUEUES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_fw</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">data0</span><span class="p">;</span>

	<span class="cm">/* Only allow multiple slices if MSI-X is usable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">myri10ge_msi</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">abort_with_fw</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if the admin did not specify a limit to how many</span>
<span class="cm">	 * slices we should use, cap it automatically to the</span>
<span class="cm">	 * number of CPUs currently online */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_max_slices</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">myri10ge_max_slices</span> <span class="o">=</span> <span class="n">ncpus</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">&gt;</span> <span class="n">myri10ge_max_slices</span><span class="p">)</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">=</span> <span class="n">myri10ge_max_slices</span><span class="p">;</span>

	<span class="cm">/* Now try to allocate as many MSI-X vectors as we have</span>
<span class="cm">	 * slices. We give up on MSI-X if we can only get a single</span>
<span class="cm">	 * vector. */</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">),</span>
				    <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">disable_msix</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* make sure it is a power of two */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">))</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">disable_msix</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">,</span>
					 <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old_allocated</span><span class="p">)</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">old_fw</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">disable_msix</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">disable_msix:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">);</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">abort_with_fw:</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="n">old_fw</span><span class="p">,</span> <span class="n">old_allocated</span><span class="p">);</span>
	<span class="n">myri10ge_load_firmware</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">myri10ge_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">myri10ge_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">myri10ge_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">myri10ge_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats64</span>	<span class="o">=</span> <span class="n">myri10ge_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">myri10ge_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_fix_features</span>	<span class="o">=</span> <span class="n">myri10ge_fix_features</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">myri10ge_set_multicast_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">myri10ge_set_mac_address</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">myri10ge_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dac_enabled</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">hdr_offset</span><span class="p">,</span> <span class="n">ss_offset</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">board_number</span><span class="p">;</span>

	<span class="n">netdev</span> <span class="o">=</span> <span class="n">alloc_etherdev_mq</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mgp</span><span class="p">),</span> <span class="n">MYRI10GE_MAX_SLICES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">mgp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">pause</span> <span class="o">=</span> <span class="n">myri10ge_flow_control</span><span class="p">;</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">intr_coal_delay</span> <span class="o">=</span> <span class="n">myri10ge_intr_coal_delay</span><span class="p">;</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">netif_msg_init</span><span class="p">(</span><span class="n">myri10ge_debug</span><span class="p">,</span> <span class="n">MYRI10GE_MSG_DEFAULT</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_number</span> <span class="o">=</span> <span class="n">board_number</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">down_wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci_enable_device call failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort_with_netdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find the vendor-specific cap so we can check</span>
<span class="cm">	 * the reboot register later on */</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">vendor_specific_offset</span>
	    <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_VNDR</span><span class="p">);</span>

	<span class="cm">/* Set our max read request to 4KB */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">pcie_set_readrq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error %d writing PCI_EXP_DEVCTL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_enabled</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">myri10ge_mask_surprise_down</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">dac_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dac_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;64-bit pci address mask was refused, &quot;</span>
			<span class="s">&quot;trying 32-bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error %d setting DMA mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_enabled</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">),</span>
				      <span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd_bus</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_enabled</span><span class="p">;</span>

	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_span</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">iomem_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mtrr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">wc_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MTRR</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mtrr</span> <span class="o">=</span> <span class="n">mtrr_add</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">iomem_base</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_span</span><span class="p">,</span>
			     <span class="n">MTRR_TYPE_WRCOMB</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mtrr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">wc_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">=</span> <span class="n">ioremap_wc</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">iomem_base</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_span</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ioremap failed for %ld bytes at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_span</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">iomem_base</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort_with_mtrr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hdr_offset</span> <span class="o">=</span>
	    <span class="n">ntohl</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">MCP_HEADER_PTR_OFFSET</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xffffc</span><span class="p">;</span>
	<span class="n">ss_offset</span> <span class="o">=</span> <span class="n">hdr_offset</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp_gen_header</span><span class="p">,</span> <span class="n">string_specs</span><span class="p">);</span>
	<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram_size</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">ss_offset</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram_size</span> <span class="o">&gt;</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_span</span> <span class="o">||</span>
	    <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram_size</span> <span class="o">&lt;=</span> <span class="n">MYRI10GE_FW_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;invalid sram_size %dB or board span %ldB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram_size</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_span</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_ioremap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">eeprom_strings</span><span class="p">,</span>
		      <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span> <span class="o">+</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram_size</span><span class="p">,</span> <span class="n">MYRI10GE_EEPROM_STRINGS_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">eeprom_strings</span> <span class="o">+</span> <span class="n">MYRI10GE_EEPROM_STRINGS_SIZE</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_read_mac_addr</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_ioremap</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ETH_ALEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">myri10ge_select_firmware</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_load_firmware</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to load firmware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_ioremap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">myri10ge_probe_slices</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_alloc_slices</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to alloc slice state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_firmware</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">netif_set_real_num_tx_queues</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">);</span>
	<span class="n">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_reset</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_slices</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
	<span class="n">myri10ge_setup_dca</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">mgp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">myri10ge_initial_mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MYRI10GE_MAX_ETHER_MTU</span><span class="p">)</span>
		<span class="n">myri10ge_initial_mtu</span> <span class="o">=</span> <span class="n">MYRI10GE_MAX_ETHER_MTU</span> <span class="o">-</span> <span class="n">ETH_HLEN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">myri10ge_initial_mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">68</span><span class="p">)</span>
		<span class="n">myri10ge_initial_mtu</span> <span class="o">=</span> <span class="mi">68</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">myri10ge_netdev_ops</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">myri10ge_initial_mtu</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|</span> <span class="n">NETIF_F_LRO</span> <span class="o">|</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dac_enabled</span><span class="p">)</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_tiny</span> <span class="o">&lt;</span> <span class="mi">37</span><span class="p">)</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_TSO6</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_ver_tiny</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_TSO</span><span class="p">;</span>

	<span class="cm">/* make sure we can get an irq, and that MSI can be</span>
<span class="cm">	 * setup (if available). */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">myri10ge_request_irq</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_with_firmware</span><span class="p">;</span>
	<span class="n">myri10ge_free_irq</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>

	<span class="cm">/* Save configuration space to be restored if the</span>
<span class="cm">	 * nic resets due to a parity error */</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Setup the watchdog timer */</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">myri10ge_watchdog_timer</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mgp</span><span class="p">);</span>

	<span class="n">SET_ETHTOOL_OPS</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myri10ge_ethtool_ops</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_work</span><span class="p">,</span> <span class="n">myri10ge_watchdog</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;register_netdev failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_with_state</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%d MSI-X IRQs, tx bndry %d, fw %s, WC %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">num_slices</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">wc_enabled</span> <span class="o">?</span> <span class="s">&quot;Enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;Disabled&quot;</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s IRQ %d, tx bndry %d, fw %s, WC %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msi_enabled</span> <span class="o">?</span> <span class="s">&quot;MSI&quot;</span> <span class="o">:</span> <span class="s">&quot;xPIC&quot;</span><span class="p">,</span>
			 <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">tx_boundary</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">wc_enabled</span> <span class="o">?</span> <span class="s">&quot;Enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;Disabled&quot;</span><span class="p">));</span>

	<span class="n">board_number</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">abort_with_state:</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

<span class="nl">abort_with_slices:</span>
	<span class="n">myri10ge_free_slices</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>

<span class="nl">abort_with_firmware:</span>
	<span class="n">myri10ge_dummy_rdma</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">abort_with_ioremap:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mac_addr_string</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;myri10ge_probe() failed: MAC=%s, SN=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mac_addr_string</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">serial_number</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span><span class="p">);</span>

<span class="nl">abort_with_mtrr:</span>
<span class="cp">#ifdef CONFIG_MTRR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mtrr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mtrr_del</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mtrr</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">iomem_base</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_span</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">),</span>
			  <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd_bus</span><span class="p">);</span>

<span class="nl">abort_with_enabled:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

<span class="nl">abort_with_netdev:</span>
	<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * myri10ge_remove</span>
<span class="cm"> *</span>
<span class="cm"> * Does what is necessary to shutdown one Myrinet device. Called</span>
<span class="cm"> *   once for each Myrinet card by the kernel when a module is</span>
<span class="cm"> *   unloaded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">myri10ge_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">myri10ge_priv</span> <span class="o">*</span><span class="n">mgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">mgp</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">watchdog_work</span><span class="p">);</span>
	<span class="n">netdev</span> <span class="o">=</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
	<span class="n">myri10ge_teardown_dca</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">myri10ge_dummy_rdma</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* avoid a memory leak */</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">sram</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MTRR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mtrr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mtrr_del</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">mtrr</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">iomem_base</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">board_span</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">myri10ge_free_slices</span><span class="p">(</span><span class="n">mgp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">);</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">),</span>
			  <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">mgp</span><span class="o">-&gt;</span><span class="n">cmd_bus</span><span class="p">);</span>

	<span class="n">set_fw_name</span><span class="p">(</span><span class="n">mgp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define PCI_DEVICE_ID_MYRICOM_MYRI10GE_Z8E 	0x0008</span>
<span class="cp">#define PCI_DEVICE_ID_MYRICOM_MYRI10GE_Z8E_9	0x0009</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">myri10ge_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_MYRICOM</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_MYRICOM_MYRI10GE_Z8E</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span>
	 <span class="p">(</span><span class="n">PCI_VENDOR_ID_MYRICOM</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_MYRICOM_MYRI10GE_Z8E_9</span><span class="p">)},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">myri10ge_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">myri10ge_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;myri10ge&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">myri10ge_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">myri10ge_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">myri10ge_pci_tbl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">myri10ge_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">myri10ge_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">myri10ge_notify_dca</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">driver_for_each_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myri10ge_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
					 <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span>
					 <span class="n">myri10ge_notify_dca_device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_BAD</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">myri10ge_dca_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">myri10ge_notify_dca</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_MYRI10GE_DCA */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">myri10ge_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MYRI10GE_VERSION_STR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_rss_hash</span> <span class="o">&gt;</span> <span class="n">MXGEFW_RSS_HASH_TYPE_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Illegal rssh hash type %d, defaulting to source port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">myri10ge_rss_hash</span><span class="p">);</span>
		<span class="n">myri10ge_rss_hash</span> <span class="o">=</span> <span class="n">MXGEFW_RSS_HASH_TYPE_SRC_PORT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
	<span class="n">dca_register_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myri10ge_dca_notifier</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">myri10ge_max_slices</span> <span class="o">&gt;</span> <span class="n">MYRI10GE_MAX_SLICES</span><span class="p">)</span>
		<span class="n">myri10ge_max_slices</span> <span class="o">=</span> <span class="n">MYRI10GE_MAX_SLICES</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myri10ge_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">myri10ge_init_module</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__exit</span> <span class="kt">void</span> <span class="nf">myri10ge_cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MYRI10GE_DCA</span>
	<span class="n">dca_unregister_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myri10ge_dca_notifier</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myri10ge_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">myri10ge_cleanup_module</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
