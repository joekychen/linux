<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › myricom › myri10ge › myri10ge_mcp.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>myri10ge_mcp.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __MYRI10GE_MCP_H__</span>
<span class="cp">#define __MYRI10GE_MCP_H__</span>

<span class="cp">#define MXGEFW_VERSION_MAJOR	1</span>
<span class="cp">#define MXGEFW_VERSION_MINOR	4</span>

<span class="cm">/* 8 Bytes */</span>
<span class="k">struct</span> <span class="n">mcp_dma_addr</span> <span class="p">{</span>
	<span class="n">__be32</span> <span class="n">high</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">low</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* 4 Bytes */</span>
<span class="k">struct</span> <span class="n">mcp_slot</span> <span class="p">{</span>
	<span class="n">__sum16</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* 64 Bytes */</span>
<span class="k">struct</span> <span class="n">mcp_cmd</span> <span class="p">{</span>
	<span class="n">__be32</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">data0</span><span class="p">;</span>		<span class="cm">/* will be low portion if data &gt; 32 bits */</span>
	<span class="cm">/* 8 */</span>
	<span class="n">__be32</span> <span class="n">data1</span><span class="p">;</span>		<span class="cm">/* will be high portion if data &gt; 32 bits */</span>
	<span class="n">__be32</span> <span class="n">data2</span><span class="p">;</span>		<span class="cm">/* currently unused.. */</span>
	<span class="cm">/* 16 */</span>
	<span class="k">struct</span> <span class="n">mcp_dma_addr</span> <span class="n">response_addr</span><span class="p">;</span>
	<span class="cm">/* 24 */</span>
	<span class="n">u8</span> <span class="n">pad</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* 8 Bytes */</span>
<span class="k">struct</span> <span class="n">mcp_cmd_response</span> <span class="p">{</span>
	<span class="n">__be32</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * flags used in mcp_kreq_ether_send_t:</span>
<span class="cm"> *</span>
<span class="cm"> * The SMALL flag is only needed in the first segment. It is raised</span>
<span class="cm"> * for packets that are total less or equal 512 bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * The CKSUM flag must be set in all segments.</span>
<span class="cm"> *</span>
<span class="cm"> * The PADDED flags is set if the packet needs to be padded, and it</span>
<span class="cm"> * must be set for all segments.</span>
<span class="cm"> *</span>
<span class="cm"> * The  MXGEFW_FLAGS_ALIGN_ODD must be set if the cumulative</span>
<span class="cm"> * length of all previous segments was odd.</span>
<span class="cm"> */</span>

<span class="cp">#define MXGEFW_FLAGS_SMALL      0x1</span>
<span class="cp">#define MXGEFW_FLAGS_TSO_HDR    0x1</span>
<span class="cp">#define MXGEFW_FLAGS_FIRST      0x2</span>
<span class="cp">#define MXGEFW_FLAGS_ALIGN_ODD  0x4</span>
<span class="cp">#define MXGEFW_FLAGS_CKSUM      0x8</span>
<span class="cp">#define MXGEFW_FLAGS_TSO_LAST   0x8</span>
<span class="cp">#define MXGEFW_FLAGS_NO_TSO     0x10</span>
<span class="cp">#define MXGEFW_FLAGS_TSO_CHOP   0x10</span>
<span class="cp">#define MXGEFW_FLAGS_TSO_PLD    0x20</span>

<span class="cp">#define MXGEFW_SEND_SMALL_SIZE  1520</span>
<span class="cp">#define MXGEFW_MAX_MTU          9400</span>

<span class="k">union</span> <span class="n">mcp_pso_or_cumlen</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">pseudo_hdr_offset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cum_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define	MXGEFW_MAX_SEND_DESC 12</span>
<span class="cp">#define MXGEFW_PAD	    2</span>

<span class="cm">/* 16 Bytes */</span>
<span class="k">struct</span> <span class="n">mcp_kreq_ether_send</span> <span class="p">{</span>
	<span class="n">__be32</span> <span class="n">addr_high</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">addr_low</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">pseudo_hdr_offset</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rdma_count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cksum_offset</span><span class="p">;</span>	<span class="cm">/* where to start computing cksum */</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* as defined above */</span>
<span class="p">};</span>

<span class="cm">/* 8 Bytes */</span>
<span class="k">struct</span> <span class="n">mcp_kreq_ether_recv</span> <span class="p">{</span>
	<span class="n">__be32</span> <span class="n">addr_high</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">addr_low</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Commands */</span>

<span class="cp">#define	MXGEFW_BOOT_HANDOFF	0xfc0000</span>
<span class="cp">#define	MXGEFW_BOOT_DUMMY_RDMA	0xfc01c0</span>

<span class="cp">#define	MXGEFW_ETH_CMD		0xf80000</span>
<span class="cp">#define	MXGEFW_ETH_SEND_4	0x200000</span>
<span class="cp">#define	MXGEFW_ETH_SEND_1	0x240000</span>
<span class="cp">#define	MXGEFW_ETH_SEND_2	0x280000</span>
<span class="cp">#define	MXGEFW_ETH_SEND_3	0x2c0000</span>
<span class="cp">#define	MXGEFW_ETH_RECV_SMALL	0x300000</span>
<span class="cp">#define	MXGEFW_ETH_RECV_BIG	0x340000</span>
<span class="cp">#define	MXGEFW_ETH_SEND_GO	0x380000</span>
<span class="cp">#define	MXGEFW_ETH_SEND_STOP	0x3C0000</span>

<span class="cp">#define	MXGEFW_ETH_SEND(n)		(0x200000 + (((n) &amp; 0x03) * 0x40000))</span>
<span class="cp">#define	MXGEFW_ETH_SEND_OFFSET(n)	(MXGEFW_ETH_SEND(n) - MXGEFW_ETH_SEND_4)</span>

<span class="k">enum</span> <span class="n">myri10ge_mcp_cmd_type</span> <span class="p">{</span>
	<span class="n">MXGEFW_CMD_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* Reset the mcp, it is left in a safe state, waiting</span>
<span class="cm">	 * for the driver to set all its parameters */</span>
	<span class="n">MXGEFW_CMD_RESET</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* get the version number of the current firmware..</span>
<span class="cm">	 * (may be available in the eeprom strings..? */</span>
	<span class="n">MXGEFW_GET_MCP_VERSION</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

	<span class="cm">/* Parameters which must be set by the driver before it can</span>
<span class="cm">	 * issue MXGEFW_CMD_ETHERNET_UP. They persist until the next</span>
<span class="cm">	 * MXGEFW_CMD_RESET is issued */</span>

	<span class="n">MXGEFW_CMD_SET_INTRQ_DMA</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="cm">/* data0 = LSW of the host address</span>
<span class="cm">	 * data1 = MSW of the host address</span>
<span class="cm">	 * data2 = slice number if multiple slices are used</span>
<span class="cm">	 */</span>

	<span class="n">MXGEFW_CMD_SET_BIG_BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* in bytes, power of 2 */</span>
	<span class="n">MXGEFW_CMD_SET_SMALL_BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>	<span class="cm">/* in bytes */</span>

	<span class="cm">/* Parameters which refer to lanai SRAM addresses where the</span>
<span class="cm">	 * driver must issue PIO writes for various things */</span>

	<span class="n">MXGEFW_CMD_GET_SEND_OFFSET</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_GET_SMALL_RX_OFFSET</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_GET_BIG_RX_OFFSET</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="cm">/* data0 = slice number if multiple slices are used */</span>

	<span class="n">MXGEFW_CMD_GET_IRQ_ACK_OFFSET</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_GET_IRQ_DEASSERT_OFFSET</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>

	<span class="cm">/* Parameters which refer to rings stored on the MCP,</span>
<span class="cm">	 * and whose size is controlled by the mcp */</span>

	<span class="n">MXGEFW_CMD_GET_SEND_RING_SIZE</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>	<span class="cm">/* in bytes */</span>
	<span class="n">MXGEFW_CMD_GET_RX_RING_SIZE</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>	<span class="cm">/* in bytes */</span>

	<span class="cm">/* Parameters which refer to rings stored in the host,</span>
<span class="cm">	 * and whose size is controlled by the host.  Note that</span>
<span class="cm">	 * all must be physically contiguous and must contain</span>
<span class="cm">	 * a power of 2 number of entries.  */</span>

	<span class="n">MXGEFW_CMD_SET_INTRQ_SIZE</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>	<span class="cm">/* in bytes */</span>
<span class="cp">#define MXGEFW_CMD_SET_INTRQ_SIZE_FLAG_NO_STRICT_SIZE_CHECK  (1 &lt;&lt; 31)</span>

	<span class="cm">/* command to bring ethernet interface up.  Above parameters</span>
<span class="cm">	 * (plus mtu &amp; mac address) must have been exchanged prior</span>
<span class="cm">	 * to issuing this command  */</span>
	<span class="n">MXGEFW_CMD_ETHERNET_UP</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>

	<span class="cm">/* command to bring ethernet interface down.  No further sends</span>
<span class="cm">	 * or receives may be processed until an MXGEFW_CMD_ETHERNET_UP</span>
<span class="cm">	 * is issued, and all interrupt queues must be flushed prior</span>
<span class="cm">	 * to ack&#39;ing this command */</span>

	<span class="n">MXGEFW_CMD_ETHERNET_DOWN</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>

	<span class="cm">/* commands the driver may issue live, without resetting</span>
<span class="cm">	 * the nic.  Note that increasing the mtu &quot;live&quot; should</span>
<span class="cm">	 * only be done if the driver has already supplied buffers</span>
<span class="cm">	 * sufficiently large to handle the new mtu.  Decreasing</span>
<span class="cm">	 * the mtu live is safe */</span>

	<span class="n">MXGEFW_CMD_SET_MTU</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_GET_INTR_COAL_DELAY_OFFSET</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>	<span class="cm">/* in microseconds */</span>
	<span class="n">MXGEFW_CMD_SET_STATS_INTERVAL</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>	<span class="cm">/* in microseconds */</span>
	<span class="n">MXGEFW_CMD_SET_STATS_DMA_OBSOLETE</span> <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>	<span class="cm">/* replaced by SET_STATS_DMA_V2 */</span>

	<span class="n">MXGEFW_ENABLE_PROMISC</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
	<span class="n">MXGEFW_DISABLE_PROMISC</span> <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>
	<span class="n">MXGEFW_SET_MAC_ADDRESS</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>

	<span class="n">MXGEFW_ENABLE_FLOW_CONTROL</span> <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>
	<span class="n">MXGEFW_DISABLE_FLOW_CONTROL</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>

	<span class="cm">/* do a DMA test</span>
<span class="cm">	 * data0,data1 = DMA address</span>
<span class="cm">	 * data2       = RDMA length (MSH), WDMA length (LSH)</span>
<span class="cm">	 * command return data = repetitions (MSH), 0.5-ms ticks (LSH)</span>
<span class="cm">	 */</span>
	<span class="n">MXGEFW_DMA_TEST</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>

	<span class="n">MXGEFW_ENABLE_ALLMULTI</span> <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>
	<span class="n">MXGEFW_DISABLE_ALLMULTI</span> <span class="o">=</span> <span class="mi">27</span><span class="p">,</span>

	<span class="cm">/* returns MXGEFW_CMD_ERROR_MULTICAST</span>
<span class="cm">	 * if there is no room in the cache</span>
<span class="cm">	 * data0,MSH(data1) = multicast group address */</span>
	<span class="n">MXGEFW_JOIN_MULTICAST_GROUP</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span>
	<span class="cm">/* returns MXGEFW_CMD_ERROR_MULTICAST</span>
<span class="cm">	 * if the address is not in the cache,</span>
<span class="cm">	 * or is equal to FF-FF-FF-FF-FF-FF</span>
<span class="cm">	 * data0,MSH(data1) = multicast group address */</span>
	<span class="n">MXGEFW_LEAVE_MULTICAST_GROUP</span> <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>
	<span class="n">MXGEFW_LEAVE_ALL_MULTICAST_GROUPS</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>

	<span class="n">MXGEFW_CMD_SET_STATS_DMA_V2</span> <span class="o">=</span> <span class="mi">31</span><span class="p">,</span>
	<span class="cm">/* data0, data1 = bus addr,</span>
<span class="cm">	 * data2 = sizeof(struct mcp_irq_data) from driver point of view, allows</span>
<span class="cm">	 * adding new stuff to mcp_irq_data without changing the ABI</span>
<span class="cm">	 *</span>
<span class="cm">	 * If multiple slices are used, data2 contains both the size of the</span>
<span class="cm">	 * structure (in the lower 16 bits) and the slice number</span>
<span class="cm">	 * (in the upper 16 bits).</span>
<span class="cm">	 */</span>

	<span class="n">MXGEFW_CMD_UNALIGNED_TEST</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	<span class="cm">/* same than DMA_TEST (same args) but abort with UNALIGNED on unaligned</span>
<span class="cm">	 * chipset */</span>

	<span class="n">MXGEFW_CMD_UNALIGNED_STATUS</span> <span class="o">=</span> <span class="mi">33</span><span class="p">,</span>
	<span class="cm">/* return data = boolean, true if the chipset is known to be unaligned */</span>

	<span class="n">MXGEFW_CMD_ALWAYS_USE_N_BIG_BUFFERS</span> <span class="o">=</span> <span class="mi">34</span><span class="p">,</span>
	<span class="cm">/* data0 = number of big buffers to use.  It must be 0 or a power of 2.</span>
<span class="cm">	 * 0 indicates that the NIC consumes as many buffers as they are required</span>
<span class="cm">	 * for packet. This is the default behavior.</span>
<span class="cm">	 * A power of 2 number indicates that the NIC always uses the specified</span>
<span class="cm">	 * number of buffers for each big receive packet.</span>
<span class="cm">	 * It is up to the driver to ensure that this value is big enough for</span>
<span class="cm">	 * the NIC to be able to receive maximum-sized packets.</span>
<span class="cm">	 */</span>

	<span class="n">MXGEFW_CMD_GET_MAX_RSS_QUEUES</span> <span class="o">=</span> <span class="mi">35</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ENABLE_RSS_QUEUES</span> <span class="o">=</span> <span class="mi">36</span><span class="p">,</span>
	<span class="cm">/* data0 = number of slices n (0, 1, ..., n-1) to enable</span>
<span class="cm">	 * data1 = interrupt mode | use of multiple transmit queues.</span>
<span class="cm">	 * 0=share one INTx/MSI.</span>
<span class="cm">	 * 1=use one MSI-X per queue.</span>
<span class="cm">	 * If all queues share one interrupt, the driver must have set</span>
<span class="cm">	 * RSS_SHARED_INTERRUPT_DMA before enabling queues.</span>
<span class="cm">	 * 2=enable both receive and send queues.</span>
<span class="cm">	 * Without this bit set, only one send queue (slice 0&#39;s send queue)</span>
<span class="cm">	 * is enabled.  The receive queues are always enabled.</span>
<span class="cm">	 */</span>
<span class="cp">#define MXGEFW_SLICE_INTR_MODE_SHARED          0x0</span>
<span class="cp">#define MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE   0x1</span>
<span class="cp">#define MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES 0x2</span>

	<span class="n">MXGEFW_CMD_GET_RSS_SHARED_INTERRUPT_MASK_OFFSET</span> <span class="o">=</span> <span class="mi">37</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_SET_RSS_SHARED_INTERRUPT_DMA</span> <span class="o">=</span> <span class="mi">38</span><span class="p">,</span>
	<span class="cm">/* data0, data1 = bus address lsw, msw */</span>
	<span class="n">MXGEFW_CMD_GET_RSS_TABLE_OFFSET</span> <span class="o">=</span> <span class="mi">39</span><span class="p">,</span>
	<span class="cm">/* get the offset of the indirection table */</span>
	<span class="n">MXGEFW_CMD_SET_RSS_TABLE_SIZE</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
	<span class="cm">/* set the size of the indirection table */</span>
	<span class="n">MXGEFW_CMD_GET_RSS_KEY_OFFSET</span> <span class="o">=</span> <span class="mi">41</span><span class="p">,</span>
	<span class="cm">/* get the offset of the secret key */</span>
	<span class="n">MXGEFW_CMD_RSS_KEY_UPDATED</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
	<span class="cm">/* tell nic that the secret key&#39;s been updated */</span>
	<span class="n">MXGEFW_CMD_SET_RSS_ENABLE</span> <span class="o">=</span> <span class="mi">43</span><span class="p">,</span>
	<span class="cm">/* data0 = enable/disable rss</span>
<span class="cm">	 * 0: disable rss.  nic does not distribute receive packets.</span>
<span class="cm">	 * 1: enable rss.  nic distributes receive packets among queues.</span>
<span class="cm">	 * data1 = hash type</span>
<span class="cm">	 * 1: IPV4            (required by RSS)</span>
<span class="cm">	 * 2: TCP_IPV4        (required by RSS)</span>
<span class="cm">	 * 3: IPV4 | TCP_IPV4 (required by RSS)</span>
<span class="cm">	 * 4: source port</span>
<span class="cm">	 * 5: source port + destination port</span>
<span class="cm">	 */</span>
<span class="cp">#define MXGEFW_RSS_HASH_TYPE_IPV4      0x1</span>
<span class="cp">#define MXGEFW_RSS_HASH_TYPE_TCP_IPV4  0x2</span>
<span class="cp">#define MXGEFW_RSS_HASH_TYPE_SRC_PORT  0x4</span>
<span class="cp">#define MXGEFW_RSS_HASH_TYPE_SRC_DST_PORT 0x5</span>
<span class="cp">#define MXGEFW_RSS_HASH_TYPE_MAX 0x5</span>

	<span class="n">MXGEFW_CMD_GET_MAX_TSO6_HDR_SIZE</span> <span class="o">=</span> <span class="mi">44</span><span class="p">,</span>
	<span class="cm">/* Return data = the max. size of the entire headers of a IPv6 TSO packet.</span>
<span class="cm">	 * If the header size of a IPv6 TSO packet is larger than the specified</span>
<span class="cm">	 * value, then the driver must not use TSO.</span>
<span class="cm">	 * This size restriction only applies to IPv6 TSO.</span>
<span class="cm">	 * For IPv4 TSO, the maximum size of the headers is fixed, and the NIC</span>
<span class="cm">	 * always has enough header buffer to store maximum-sized headers.</span>
<span class="cm">	 */</span>

	<span class="n">MXGEFW_CMD_SET_TSO_MODE</span> <span class="o">=</span> <span class="mi">45</span><span class="p">,</span>
	<span class="cm">/* data0 = TSO mode.</span>
<span class="cm">	 * 0: Linux/FreeBSD style (NIC default)</span>
<span class="cm">	 * 1: NDIS/NetBSD style</span>
<span class="cm">	 */</span>
<span class="cp">#define MXGEFW_TSO_MODE_LINUX  0</span>
<span class="cp">#define MXGEFW_TSO_MODE_NDIS   1</span>

	<span class="n">MXGEFW_CMD_MDIO_READ</span> <span class="o">=</span> <span class="mi">46</span><span class="p">,</span>
	<span class="cm">/* data0 = dev_addr (PMA/PMD or PCS ...), data1 = register/addr */</span>
	<span class="n">MXGEFW_CMD_MDIO_WRITE</span> <span class="o">=</span> <span class="mi">47</span><span class="p">,</span>
	<span class="cm">/* data0 = dev_addr,  data1 = register/addr, data2 = value  */</span>

	<span class="n">MXGEFW_CMD_I2C_READ</span> <span class="o">=</span> <span class="mi">48</span><span class="p">,</span>
	<span class="cm">/* Starts to get a fresh copy of one byte or of the module i2c table, the</span>
<span class="cm">	 * obtained data is cached inside the xaui-xfi chip :</span>
<span class="cm">	 *   data0 :  0 =&gt; get one byte, 1=&gt; get 256 bytes</span>
<span class="cm">	 *   data1 :  If data0 == 0: location to refresh</span>
<span class="cm">	 *               bit 7:0  register location</span>
<span class="cm">	 *               bit 8:15 is the i2c slave addr (0 is interpreted as 0xA1)</span>
<span class="cm">	 *               bit 23:16 is the i2c bus number (for multi-port NICs)</span>
<span class="cm">	 *            If data0 == 1: unused</span>
<span class="cm">	 * The operation might take ~1ms for a single byte or ~65ms when refreshing all 256 bytes</span>
<span class="cm">	 * During the i2c operation,  MXGEFW_CMD_I2C_READ or MXGEFW_CMD_I2C_BYTE attempts</span>
<span class="cm">	 *  will return MXGEFW_CMD_ERROR_BUSY</span>
<span class="cm">	 */</span>
	<span class="n">MXGEFW_CMD_I2C_BYTE</span> <span class="o">=</span> <span class="mi">49</span><span class="p">,</span>
	<span class="cm">/* Return the last obtained copy of a given byte in the xfp i2c table</span>
<span class="cm">	 * (copy cached during the last relevant MXGEFW_CMD_I2C_READ)</span>
<span class="cm">	 *   data0 : index of the desired table entry</span>
<span class="cm">	 *  Return data = the byte stored at the requested index in the table</span>
<span class="cm">	 */</span>

	<span class="n">MXGEFW_CMD_GET_VPUMP_OFFSET</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
	<span class="cm">/* Return data = NIC memory offset of mcp_vpump_public_global */</span>
	<span class="n">MXGEFW_CMD_RESET_VPUMP</span> <span class="o">=</span> <span class="mi">51</span><span class="p">,</span>
	<span class="cm">/* Resets the VPUMP state */</span>

	<span class="n">MXGEFW_CMD_SET_RSS_MCP_SLOT_TYPE</span> <span class="o">=</span> <span class="mi">52</span><span class="p">,</span>
	<span class="cm">/* data0 = mcp_slot type to use.</span>
<span class="cm">	 * 0 = the default 4B mcp_slot</span>
<span class="cm">	 * 1 = 8B mcp_slot_8</span>
<span class="cm">	 */</span>
<span class="cp">#define MXGEFW_RSS_MCP_SLOT_TYPE_MIN        0</span>
<span class="cp">#define MXGEFW_RSS_MCP_SLOT_TYPE_WITH_HASH  1</span>

	<span class="n">MXGEFW_CMD_SET_THROTTLE_FACTOR</span> <span class="o">=</span> <span class="mi">53</span><span class="p">,</span>
	<span class="cm">/* set the throttle factor for ethp_z8e</span>
<span class="cm">	 * data0 = throttle_factor</span>
<span class="cm">	 * throttle_factor = 256 * pcie-raw-speed / tx_speed</span>
<span class="cm">	 * tx_speed = 256 * pcie-raw-speed / throttle_factor</span>
<span class="cm">	 *</span>
<span class="cm">	 * For PCI-E x8: pcie-raw-speed == 16Gb/s</span>
<span class="cm">	 * For PCI-E x4: pcie-raw-speed == 8Gb/s</span>
<span class="cm">	 *</span>
<span class="cm">	 * ex1: throttle_factor == 0x1a0 (416), tx_speed == 1.23GB/s == 9.846 Gb/s</span>
<span class="cm">	 * ex2: throttle_factor == 0x200 (512), tx_speed == 1.0GB/s == 8 Gb/s</span>
<span class="cm">	 *</span>
<span class="cm">	 * with tx_boundary == 2048, max-throttle-factor == 8191 =&gt; min-speed == 500Mb/s</span>
<span class="cm">	 * with tx_boundary == 4096, max-throttle-factor == 4095 =&gt; min-speed == 1Gb/s</span>
<span class="cm">	 */</span>

	<span class="n">MXGEFW_CMD_VPUMP_UP</span> <span class="o">=</span> <span class="mi">54</span><span class="p">,</span>
	<span class="cm">/* Allocates VPump Connection, Send Request and Zero copy buffer address tables */</span>
	<span class="n">MXGEFW_CMD_GET_VPUMP_CLK</span> <span class="o">=</span> <span class="mi">55</span><span class="p">,</span>
	<span class="cm">/* Get the lanai clock */</span>

	<span class="n">MXGEFW_CMD_GET_DCA_OFFSET</span> <span class="o">=</span> <span class="mi">56</span><span class="p">,</span>
	<span class="cm">/* offset of dca control for WDMAs */</span>

	<span class="cm">/* VMware NetQueue commands */</span>
	<span class="n">MXGEFW_CMD_NETQ_GET_FILTERS_PER_QUEUE</span> <span class="o">=</span> <span class="mi">57</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_NETQ_ADD_FILTER</span> <span class="o">=</span> <span class="mi">58</span><span class="p">,</span>
	<span class="cm">/* data0 = filter_id &lt;&lt; 16 | queue &lt;&lt; 8 | type */</span>
	<span class="cm">/* data1 = MS4 of MAC Addr */</span>
	<span class="cm">/* data2 = LS2_MAC &lt;&lt; 16 | VLAN_tag */</span>
	<span class="n">MXGEFW_CMD_NETQ_DEL_FILTER</span> <span class="o">=</span> <span class="mi">59</span><span class="p">,</span>
	<span class="cm">/* data0 = filter_id */</span>
	<span class="n">MXGEFW_CMD_NETQ_QUERY1</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_NETQ_QUERY2</span> <span class="o">=</span> <span class="mi">61</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_NETQ_QUERY3</span> <span class="o">=</span> <span class="mi">62</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_NETQ_QUERY4</span> <span class="o">=</span> <span class="mi">63</span><span class="p">,</span>

	<span class="n">MXGEFW_CMD_RELAX_RXBUFFER_ALIGNMENT</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
	<span class="cm">/* When set, small receive buffers can cross page boundaries.</span>
<span class="cm">	 * Both small and big receive buffers may start at any address.</span>
<span class="cm">	 * This option has performance implications, so use with caution.</span>
<span class="cm">	 */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">myri10ge_mcp_cmd_status</span> <span class="p">{</span>
	<span class="n">MXGEFW_CMD_OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_UNKNOWN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_RANGE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_BUSY</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_EMPTY</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_CLOSED</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_HASH_ERROR</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_BAD_PORT</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_RESOURCES</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_MULTICAST</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_UNALIGNED</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_NO_MDIO</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_I2C_FAILURE</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_I2C_ABSENT</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">MXGEFW_CMD_ERROR_BAD_PCIE_LINK</span> <span class="o">=</span> <span class="mi">14</span>
<span class="p">};</span>

<span class="cp">#define MXGEFW_OLD_IRQ_DATA_LEN 40</span>

<span class="k">struct</span> <span class="n">mcp_irq_data</span> <span class="p">{</span>
	<span class="cm">/* add new counters at the beginning */</span>
	<span class="n">__be32</span> <span class="n">future_use</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">__be32</span> <span class="n">dropped_pause</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">dropped_unicast_filtered</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">dropped_bad_crc32</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">dropped_bad_phy</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">dropped_multicast_filtered</span><span class="p">;</span>
	<span class="cm">/* 40 Bytes */</span>
	<span class="n">__be32</span> <span class="n">send_done_count</span><span class="p">;</span>

<span class="cp">#define MXGEFW_LINK_DOWN 0</span>
<span class="cp">#define MXGEFW_LINK_UP 1</span>
<span class="cp">#define MXGEFW_LINK_MYRINET 2</span>
<span class="cp">#define MXGEFW_LINK_UNKNOWN 3</span>
	<span class="n">__be32</span> <span class="n">link_up</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">dropped_link_overflow</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">dropped_link_error_or_filtered</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">dropped_runt</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">dropped_overrun</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">dropped_no_small_buffer</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">dropped_no_big_buffer</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">rdma_tags_available</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">tx_stopped</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">link_down</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">stats_updated</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">valid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* definitions for NETQ filter type */</span>
<span class="cp">#define MXGEFW_NETQ_FILTERTYPE_NONE 0</span>
<span class="cp">#define MXGEFW_NETQ_FILTERTYPE_MACADDR 1</span>
<span class="cp">#define MXGEFW_NETQ_FILTERTYPE_VLAN 2</span>
<span class="cp">#define MXGEFW_NETQ_FILTERTYPE_VLANMACADDR 3</span>

<span class="cp">#endif				</span><span class="cm">/* __MYRI10GE_MCP_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
