<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sis › sis900.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>sis900.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* sis900.c: A SiS 900/7016 PCI Fast Ethernet driver for Linux.</span>
<span class="cm">   Copyright 1999 Silicon Integrated System Corporation</span>
<span class="cm">   Revision:	1.08.10 Apr. 2 2006</span>

<span class="cm">   Modified from the driver which is originally written by Donald Becker.</span>

<span class="cm">   This software may be used and distributed according to the terms</span>
<span class="cm">   of the GNU General Public License (GPL), incorporated herein by reference.</span>
<span class="cm">   Drivers based on this skeleton fall under the GPL and must retain</span>
<span class="cm">   the authorship (implicit copyright) notice.</span>

<span class="cm">   References:</span>
<span class="cm">   SiS 7016 Fast Ethernet PCI Bus 10/100 Mbps LAN Controller with OnNow Support,</span>
<span class="cm">   preliminary Rev. 1.0 Jan. 14, 1998</span>
<span class="cm">   SiS 900 Fast Ethernet PCI Bus 10/100 Mbps LAN Single Chip with OnNow Support,</span>
<span class="cm">   preliminary Rev. 1.0 Nov. 10, 1998</span>
<span class="cm">   SiS 7014 Single Chip 100BASE-TX/10BASE-T Physical Layer Solution,</span>
<span class="cm">   preliminary Rev. 1.0 Jan. 18, 1998</span>

<span class="cm">   Rev 1.08.10 Apr.  2 2006 Daniele Venzano add vlan (jumbo packets) support</span>
<span class="cm">   Rev 1.08.09 Sep. 19 2005 Daniele Venzano add Wake on LAN support</span>
<span class="cm">   Rev 1.08.08 Jan. 22 2005 Daniele Venzano use netif_msg for debugging messages</span>
<span class="cm">   Rev 1.08.07 Nov.  2 2003 Daniele Venzano &lt;venza@brownhat.org&gt; add suspend/resume support</span>
<span class="cm">   Rev 1.08.06 Sep. 24 2002 Mufasa Yang bug fix for Tx timeout &amp; add SiS963 support</span>
<span class="cm">   Rev 1.08.05 Jun.  6 2002 Mufasa Yang bug fix for read_eeprom &amp; Tx descriptor over-boundary</span>
<span class="cm">   Rev 1.08.04 Apr. 25 2002 Mufasa Yang &lt;mufasa@sis.com.tw&gt; added SiS962 support</span>
<span class="cm">   Rev 1.08.03 Feb.  1 2002 Matt Domsch &lt;Matt_Domsch@dell.com&gt; update to use library crc32 function</span>
<span class="cm">   Rev 1.08.02 Nov. 30 2001 Hui-Fen Hsu workaround for EDB &amp; bug fix for dhcp problem</span>
<span class="cm">   Rev 1.08.01 Aug. 25 2001 Hui-Fen Hsu update for 630ET &amp; workaround for ICS1893 PHY</span>
<span class="cm">   Rev 1.08.00 Jun. 11 2001 Hui-Fen Hsu workaround for RTL8201 PHY and some bug fix</span>
<span class="cm">   Rev 1.07.11 Apr.  2 2001 Hui-Fen Hsu updates PCI drivers to use the new pci_set_dma_mask for kernel 2.4.3</span>
<span class="cm">   Rev 1.07.10 Mar.  1 2001 Hui-Fen Hsu &lt;hfhsu@sis.com.tw&gt; some bug fix &amp; 635M/B support</span>
<span class="cm">   Rev 1.07.09 Feb.  9 2001 Dave Jones &lt;davej@suse.de&gt; PCI enable cleanup</span>
<span class="cm">   Rev 1.07.08 Jan.  8 2001 Lei-Chun Chang added RTL8201 PHY support</span>
<span class="cm">   Rev 1.07.07 Nov. 29 2000 Lei-Chun Chang added kernel-doc extractable documentation and 630 workaround fix</span>
<span class="cm">   Rev 1.07.06 Nov.  7 2000 Jeff Garzik &lt;jgarzik@pobox.com&gt; some bug fix and cleaning</span>
<span class="cm">   Rev 1.07.05 Nov.  6 2000 metapirat&lt;metapirat@gmx.de&gt; contribute media type select by ifconfig</span>
<span class="cm">   Rev 1.07.04 Sep.  6 2000 Lei-Chun Chang added ICS1893 PHY support</span>
<span class="cm">   Rev 1.07.03 Aug. 24 2000 Lei-Chun Chang (lcchang@sis.com.tw) modified 630E equalizer workaround rule</span>
<span class="cm">   Rev 1.07.01 Aug. 08 2000 Ollie Lho minor update for SiS 630E and SiS 630E A1</span>
<span class="cm">   Rev 1.07    Mar. 07 2000 Ollie Lho bug fix in Rx buffer ring</span>
<span class="cm">   Rev 1.06.04 Feb. 11 2000 Jeff Garzik &lt;jgarzik@pobox.com&gt; softnet and init for kernel 2.4</span>
<span class="cm">   Rev 1.06.03 Dec. 23 1999 Ollie Lho Third release</span>
<span class="cm">   Rev 1.06.02 Nov. 23 1999 Ollie Lho bug in mac probing fixed</span>
<span class="cm">   Rev 1.06.01 Nov. 16 1999 Ollie Lho CRC calculation provide by Joseph Zbiciak (im14u2c@primenet.com)</span>
<span class="cm">   Rev 1.06 Nov. 4 1999 Ollie Lho (ollie@sis.com.tw) Second release</span>
<span class="cm">   Rev 1.05.05 Oct. 29 1999 Ollie Lho (ollie@sis.com.tw) Single buffer Tx/Rx</span>
<span class="cm">   Chin-Shan Li (lcs@sis.com.tw) Added AMD Am79c901 HomePNA PHY support</span>
<span class="cm">   Rev 1.05 Aug. 7 1999 Jim Huang (cmhuang@sis.com.tw) Initial release</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;      </span><span class="cm">/* Processor type for cache alignment. */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;	</span><span class="cm">/* User space memory access functions */</span><span class="cp"></span>

<span class="cp">#include &quot;sis900.h&quot;</span>

<span class="cp">#define SIS900_MODULE_NAME &quot;sis900&quot;</span>
<span class="cp">#define SIS900_DRV_VERSION &quot;v1.08.10 Apr. 2 2006&quot;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="n">__devinitconst</span> <span class="o">=</span>
	<span class="n">KERN_INFO</span> <span class="s">&quot;sis900.c: &quot;</span> <span class="n">SIS900_DRV_VERSION</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">max_interrupt_work</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">multicast_filter_limit</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sis900_debug</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Use SIS900_DEF_MSG as value */</span>

<span class="cp">#define SIS900_DEF_MSG \</span>
<span class="cp">	(NETIF_MSG_DRV		| \</span>
<span class="cp">	 NETIF_MSG_LINK		| \</span>
<span class="cp">	 NETIF_MSG_RX_ERR	| \</span>
<span class="cp">	 NETIF_MSG_TX_ERR)</span>

<span class="cm">/* Time in jiffies before concluding the transmitter is hung. */</span>
<span class="cp">#define TX_TIMEOUT  (4*HZ)</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SIS_900</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SIS_7016</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">card_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;SiS 900 PCI Fast Ethernet&quot;</span><span class="p">,</span>
	<span class="s">&quot;SiS 7016 PCI Fast Ethernet&quot;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">sis900_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SI_900</span><span class="p">,</span>
	 <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SIS_900</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SI_7016</span><span class="p">,</span>
	 <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SIS_7016</span><span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span> <span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">sis900_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_read_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">speed</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">duplex</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mii_chip_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_id0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_id1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">phy_types</span><span class="p">;</span>
<span class="cp">#define	HOME 	0x0001</span>
<span class="cp">#define LAN	0x0002</span>
<span class="cp">#define MIX	0x0003</span>
<span class="cp">#define UNKNOWN	0x0</span>
<span class="p">}</span> <span class="n">mii_chip_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;SiS 900 Internal MII PHY&quot;</span><span class="p">,</span> 		<span class="mh">0x001d</span><span class="p">,</span> <span class="mh">0x8000</span><span class="p">,</span> <span class="n">LAN</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SiS 7014 Physical Layer Solution&quot;</span><span class="p">,</span> 	<span class="mh">0x0016</span><span class="p">,</span> <span class="mh">0xf830</span><span class="p">,</span> <span class="n">LAN</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SiS 900 on Foxconn 661 7MI&quot;</span><span class="p">,</span>         <span class="mh">0x0143</span><span class="p">,</span> <span class="mh">0xBC70</span><span class="p">,</span> <span class="n">LAN</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;Altimata AC101LF PHY&quot;</span><span class="p">,</span>               <span class="mh">0x0022</span><span class="p">,</span> <span class="mh">0x5520</span><span class="p">,</span> <span class="n">LAN</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ADM 7001 LAN PHY&quot;</span><span class="p">,</span>			<span class="mh">0x002e</span><span class="p">,</span> <span class="mh">0xcc60</span><span class="p">,</span> <span class="n">LAN</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;AMD 79C901 10BASE-T PHY&quot;</span><span class="p">,</span>  		<span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x6B70</span><span class="p">,</span> <span class="n">LAN</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;AMD 79C901 HomePNA PHY&quot;</span><span class="p">,</span>		<span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x6B90</span><span class="p">,</span> <span class="n">HOME</span><span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ICS LAN PHY&quot;</span><span class="p">,</span>			<span class="mh">0x0015</span><span class="p">,</span> <span class="mh">0xF440</span><span class="p">,</span> <span class="n">LAN</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ICS LAN PHY&quot;</span><span class="p">,</span>			<span class="mh">0x0143</span><span class="p">,</span> <span class="mh">0xBC70</span><span class="p">,</span> <span class="n">LAN</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;NS 83851 PHY&quot;</span><span class="p">,</span>			<span class="mh">0x2000</span><span class="p">,</span> <span class="mh">0x5C20</span><span class="p">,</span> <span class="n">MIX</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;NS 83847 PHY&quot;</span><span class="p">,</span>                       <span class="mh">0x2000</span><span class="p">,</span> <span class="mh">0x5C30</span><span class="p">,</span> <span class="n">MIX</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;Realtek RTL8201 PHY&quot;</span><span class="p">,</span>		<span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x8200</span><span class="p">,</span> <span class="n">LAN</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;VIA 6103 PHY&quot;</span><span class="p">,</span>			<span class="mh">0x0101</span><span class="p">,</span> <span class="mh">0x8f20</span><span class="p">,</span> <span class="n">LAN</span> <span class="p">},</span>
	<span class="p">{</span><span class="nb">NULL</span><span class="p">,},</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mii_phy</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">phy_addr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_id0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_id1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">phy_types</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_BufferDesc</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">link</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmdsts</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bufptr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">BufferDesc</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">sis900_private</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">pci_dev</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span> <span class="n">mii</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span> <span class="n">first_mii</span><span class="p">;</span> <span class="cm">/* record the first mii structure */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_phy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mii_if_info</span> <span class="n">mii_info</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span> <span class="cm">/* Link status detection timer. */</span>
	<span class="n">u8</span> <span class="n">autong_complete</span><span class="p">;</span> <span class="cm">/* 1: auto-negotiate complete  */</span>

	<span class="n">u32</span> <span class="n">msg_enable</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_rx</span><span class="p">,</span> <span class="n">dirty_rx</span><span class="p">;</span> <span class="cm">/* producer/comsumer pointers for Tx/Rx ring */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_tx</span><span class="p">,</span> <span class="n">dirty_tx</span><span class="p">;</span>

	<span class="cm">/* The saved address of a sent/receive-in-place packet buffer */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">NUM_TX_DESC</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">NUM_RX_DESC</span><span class="p">];</span>
	<span class="n">BufferDesc</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="n">BufferDesc</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">;</span>

	<span class="n">dma_addr_t</span> <span class="n">tx_ring_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rx_ring_dma</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_full</span><span class="p">;</span> <span class="cm">/* The Tx queue is full. */</span>
	<span class="n">u8</span> <span class="n">host_bridge_rev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">chipset_rev</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Jim Huang &lt;cmhuang@sis.com.tw&gt;, Ollie Lho &lt;ollie@sis.com.tw&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SiS 900 PCI Fast Ethernet driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">multicast_filter_limit</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_interrupt_work</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">sis900_debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">multicast_filter_limit</span><span class="p">,</span> <span class="s">&quot;SiS 900/7016 maximum number of filtered multicast addresses&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_interrupt_work</span><span class="p">,</span> <span class="s">&quot;SiS 900/7016 maximum events handled per interrupt&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">sis900_debug</span><span class="p">,</span> <span class="s">&quot;SiS 900/7016 bitmapped debugging message level&quot;</span><span class="p">);</span>

<span class="cp">#define sw32(reg, val)	iowrite32(val, ioaddr + (reg))</span>
<span class="cp">#define sw8(reg, val)	iowrite8(val, ioaddr + (reg))</span>
<span class="cp">#define sr32(reg)	ioread32(ioaddr + (reg))</span>
<span class="cp">#define sr16(reg)	ioread16(ioaddr + (reg))</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sis900_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sis900_mii_probe</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_init_rxfilter</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">read_eeprom</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_check_mode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span><span class="n">mii_phy</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_init_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_init_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">sis900_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sis900_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_finish_xmit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">sis900_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sis900_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mii_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">sis900_mcast_bitnr</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">revision</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis630_set_eq</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">revision</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sis900_set_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifmap</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">sis900_default_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">net_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_set_capability</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="p">,</span><span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">sis900_reset_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_auto_negotiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sis900_set_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">,</span> <span class="kt">int</span> <span class="n">duplex</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">sis900_ethtool_ops</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_get_mac_addr - Get MAC address for stand alone SiS900 model</span>
<span class="cm"> *	@pci_dev: the sis900 pci device</span>
<span class="cm"> *	@net_dev: the net device to get address for</span>
<span class="cm"> *</span>
<span class="cm"> *	Older SiS900 and friends, use EEPROM to store MAC address.</span>
<span class="cm"> *	MAC address is read from read_eeprom() into @net_dev-&gt;dev_addr and</span>
<span class="cm"> *	@net_dev-&gt;perm_addr.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sis900_get_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">pci_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">signature</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* check to see if we have sane EEPROM */</span>
	<span class="n">signature</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">read_eeprom</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">EEPROMSignature</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signature</span> <span class="o">==</span> <span class="mh">0xffff</span> <span class="o">||</span> <span class="n">signature</span> <span class="o">==</span> <span class="mh">0x0000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Error EERPOM read %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">),</span> <span class="n">signature</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get MAC address from EEPROM */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	        <span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_eeprom</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">EEPROMMACAddr</span><span class="p">);</span>

	<span class="cm">/* Store MAC Address in perm_addr */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis630e_get_mac_addr - Get MAC address for SiS630E model</span>
<span class="cm"> *	@pci_dev: the sis900 pci device</span>
<span class="cm"> *	@net_dev: the net device to get address for</span>
<span class="cm"> *</span>
<span class="cm"> *	SiS630E model, use APC CMOS RAM to store MAC address.</span>
<span class="cm"> *	APC CMOS RAM is accessed through ISA bridge.</span>
<span class="cm"> *	MAC address is read into @net_dev-&gt;dev_addr and</span>
<span class="cm"> *	@net_dev-&gt;perm_addr.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sis630e_get_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">pci_dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">isa_bridge</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">isa_bridge</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span> <span class="mh">0x0008</span><span class="p">,</span> <span class="n">isa_bridge</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isa_bridge</span><span class="p">)</span>
		<span class="n">isa_bridge</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span> <span class="mh">0x0018</span><span class="p">,</span> <span class="n">isa_bridge</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isa_bridge</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Can not find ISA bridge</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pci_name</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">isa_bridge</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">isa_bridge</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="n">reg</span> <span class="o">|</span> <span class="mh">0x40</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x09</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mh">0x70</span><span class="p">);</span>
		<span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0x71</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Store MAC Address in perm_addr */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">isa_bridge</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x40</span><span class="p">);</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">isa_bridge</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	sis635_get_mac_addr - Get MAC address for SIS635 model</span>
<span class="cm"> *	@pci_dev: the sis900 pci device</span>
<span class="cm"> *	@net_dev: the net device to get address for</span>
<span class="cm"> *</span>
<span class="cm"> *	SiS635 model, set MAC Reload Bit to load Mac address from APC</span>
<span class="cm"> *	to rfdr. rfdr is accessed through rfcr. MAC address is read into</span>
<span class="cm"> *	@net_dev-&gt;dev_addr and @net_dev-&gt;perm_addr.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sis635_get_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">pci_dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rfcrSave</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rfcrSave</span> <span class="o">=</span> <span class="n">sr32</span><span class="p">(</span><span class="n">rfcr</span><span class="p">);</span>

	<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">rfcrSave</span> <span class="o">|</span> <span class="n">RELOAD</span><span class="p">);</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* disable packet filtering before setting filter */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">rfcr</span><span class="p">,</span> <span class="n">rfcrSave</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RFEN</span><span class="p">);</span>

	<span class="cm">/* load MAC addr to filter data register */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">rfcr</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">RFADDR_shift</span><span class="p">));</span>
		<span class="o">*</span><span class="p">(</span> <span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">sr16</span><span class="p">(</span><span class="n">rfdr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Store MAC Address in perm_addr */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="cm">/* enable packet filtering */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">rfcr</span><span class="p">,</span> <span class="n">rfcrSave</span> <span class="o">|</span> <span class="n">RFEN</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis96x_get_mac_addr - Get MAC address for SiS962 or SiS963 model</span>
<span class="cm"> *	@pci_dev: the sis900 pci device</span>
<span class="cm"> *	@net_dev: the net device to get address for</span>
<span class="cm"> *</span>
<span class="cm"> *	SiS962 or SiS963 model, use EEPROM to store MAC address. And EEPROM</span>
<span class="cm"> *	is shared by</span>
<span class="cm"> *	LAN and 1394. When access EEPROM, send EEREQ signal to hardware first</span>
<span class="cm"> *	and wait for EEGNT. If EEGNT is ON, EEPROM is permitted to be access</span>
<span class="cm"> *	by LAN, otherwise is not. After MAC address is read from EEPROM, send</span>
<span class="cm"> *	EEDONE signal to refuse EEPROM access by LAN.</span>
<span class="cm"> *	The EEPROM map of SiS962 or SiS963 is different to SiS900.</span>
<span class="cm"> *	The signature field in SiS962 or SiS963 spec is meaningless.</span>
<span class="cm"> *	MAC address is read into @net_dev-&gt;dev_addr and @net_dev-&gt;perm_addr.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sis96x_get_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">pci_dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wait</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">EEREQ</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">wait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">wait</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span> <span class="n">wait</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sr32</span><span class="p">(</span><span class="n">mear</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EEGNT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="cm">/* get MAC address from EEPROM */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			        <span class="n">mac</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_eeprom</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">EEPROMMACAddr</span><span class="p">);</span>

			<span class="cm">/* Store MAC Address in perm_addr */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

			<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">EEDONE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">sis900_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		 <span class="o">=</span> <span class="n">sis900_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">sis900_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">sis900_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_config</span>		<span class="o">=</span> <span class="n">sis900_set_config</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">eth_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> 	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">mii_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">sis900_tx_timeout</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
        <span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">sis900_poll</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_probe - Probe for sis900 device</span>
<span class="cm"> *	@pci_dev: the sis900 pci device</span>
<span class="cm"> *	@pci_id: the pci device ID</span>
<span class="cm"> *</span>
<span class="cm"> *	Check and probe sis900 net device for @pci_dev.</span>
<span class="cm"> *	Get mac address according to the chip revision,</span>
<span class="cm"> *	and assign SiS900-specific entries in the device structure.</span>
<span class="cm"> *	ie: sis900_open(), sis900_start_xmit(), sis900_close(), etc.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sis900_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">pci_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">ring_dma</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ring_space</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">card_name</span> <span class="o">=</span> <span class="n">card_names</span><span class="p">[</span><span class="n">pci_id</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span> <span class="o">=</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

<span class="cm">/* when built into the kernel, we only print version if device is found */</span>
<span class="cp">#ifndef MODULE</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">printed_version</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printed_version</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* setup various bits in PCI command register */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sis900.c: architecture does not support &quot;</span>
			<span class="s">&quot;32bit PCI busmaster DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="n">net_dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sis900_private</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* We do a request_region() to register /proc/ioports info. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="s">&quot;sis900&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="cm">/* IO region. */</span>
	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioaddr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_cleardev</span><span class="p">;</span>

	<span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>

	<span class="n">ring_space</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">TX_TOTAL_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_space</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_unmap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">ring_space</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span> <span class="o">=</span> <span class="n">ring_dma</span><span class="p">;</span>

	<span class="n">ring_space</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">RX_TOTAL_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_space</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_unmap_tx</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">ring_space</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span> <span class="o">=</span> <span class="n">ring_dma</span><span class="p">;</span>

	<span class="cm">/* The SiS900-specific entries in the device structure. */</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sis900_netdev_ops</span><span class="p">;</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TX_TIMEOUT</span><span class="p">;</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sis900_ethtool_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sis900_debug</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">sis900_debug</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">SIS900_DEF_MSG</span><span class="p">;</span>

	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii_info</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">net_dev</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii_info</span><span class="p">.</span><span class="n">mdio_read</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii_info</span><span class="p">.</span><span class="n">mdio_write</span> <span class="o">=</span> <span class="n">mdio_write</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii_info</span><span class="p">.</span><span class="n">phy_id_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii_info</span><span class="p">.</span><span class="n">reg_num_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>

	<span class="cm">/* Get Mac address according to the chip revision */</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">netif_msg_probe</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: detected revision %2.2x, &quot;</span>
				<span class="s">&quot;trying to get MAC address...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_name</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span> <span class="o">==</span> <span class="n">SIS630E_900_REV</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sis630e_get_mac_addr</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span> <span class="o">&gt;</span> <span class="mh">0x81</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span> <span class="o">&lt;=</span> <span class="mh">0x90</span><span class="p">)</span> <span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sis635_get_mac_addr</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span> <span class="o">==</span> <span class="n">SIS96x_900_REV</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sis96x_get_mac_addr</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sis900_get_mac_addr</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">eth_hw_addr_random</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Unreadable or invalid MAC address,&quot;</span>
				<span class="s">&quot;using random generated one</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* 630ET : set the mii access mode as software-mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span> <span class="o">==</span> <span class="n">SIS630ET_900_REV</span><span class="p">)</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">ACCESSMODE</span> <span class="o">|</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cr</span><span class="p">));</span>

	<span class="cm">/* probe for mii transceiver */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sis900_mii_probe</span><span class="p">(</span><span class="n">net_dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Error probing MII device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev_name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_unmap_rx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* save our host bridge revision */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SI_630</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">host_bridge_rev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">;</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unmap_rx</span><span class="p">;</span>

	<span class="cm">/* print some information about our NIC */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: %s at 0x%p, IRQ %d, %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">card_name</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">,</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
	       <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="cm">/* Detect Wake on Lan support */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">sr32</span><span class="p">(</span><span class="n">CFGPMC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PMESP</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">27</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_probe</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">PME_D3C</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Wake on LAN only available from suspend to RAM.&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_unmap_rx:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">RX_TOTAL_SIZE</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">,</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">);</span>
<span class="nl">err_unmap_tx:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">TX_TOTAL_SIZE</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">,</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">);</span>
<span class="nl">err_out_unmap:</span>
	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">);</span>
<span class="nl">err_out_cleardev:</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
 <span class="nl">err_out:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_mii_probe - Probe MII PHY for sis900</span>
<span class="cm"> *	@net_dev: the net device to probe for</span>
<span class="cm"> *</span>
<span class="cm"> *	Search for total of 32 possible mii phy addresses.</span>
<span class="cm"> *	Identify and set current phy if found one,</span>
<span class="cm"> *	return error if it failed to found.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sis900_mii_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span> <span class="o">=</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">poll_bit</span> <span class="o">=</span> <span class="n">MII_STAT_LINK</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">phy_addr</span><span class="p">;</span>

	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* search for total of 32 possible mii phy addresses */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">phy_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">phy_addr</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">phy_addr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span> <span class="n">mii_phy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">mii_status</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">mii_phy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">mii_status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mii_status</span> <span class="o">==</span> <span class="mh">0xffff</span> <span class="o">||</span> <span class="n">mii_status</span> <span class="o">==</span> <span class="mh">0x0000</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_probe</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: MII at address %d&quot;</span>
						<span class="s">&quot; not accessible</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">dev_name</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mii_phy</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_phy</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mii_phy</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">first_mii</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">mii_phy</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">;</span>
				<span class="n">phy</span> <span class="o">=</span> <span class="n">mii_phy</span><span class="p">;</span>
				<span class="n">mii_phy</span> <span class="o">=</span> <span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">phy</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_id0</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_PHY_ID0</span><span class="p">);</span>
		<span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_id1</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_PHY_ID1</span><span class="p">);</span>
		<span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">=</span> <span class="n">phy_addr</span><span class="p">;</span>
		<span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">mii_status</span><span class="p">;</span>
		<span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">;</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span> <span class="o">=</span> <span class="n">mii_phy</span><span class="p">;</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">first_mii</span> <span class="o">=</span> <span class="n">mii_phy</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mii_chip_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phy_id1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_id0</span> <span class="o">==</span> <span class="n">mii_chip_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phy_id0</span> <span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">((</span><span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_id1</span> <span class="o">&amp;</span> <span class="mh">0xFFF0</span><span class="p">)</span> <span class="o">==</span> <span class="n">mii_chip_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phy_id1</span><span class="p">)){</span>
				<span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_types</span> <span class="o">=</span> <span class="n">mii_chip_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phy_types</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mii_chip_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phy_types</span> <span class="o">==</span> <span class="n">MIX</span><span class="p">)</span>
					<span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_types</span> <span class="o">=</span>
					    <span class="p">(</span><span class="n">mii_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MII_STAT_CAN_TX_FDX</span> <span class="o">|</span> <span class="n">MII_STAT_CAN_TX</span><span class="p">))</span> <span class="o">?</span> <span class="n">LAN</span> <span class="o">:</span> <span class="n">HOME</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: %s transceiver found &quot;</span>
							<span class="s">&quot;at address %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">dev_name</span><span class="p">,</span>
							<span class="n">mii_chip_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
							<span class="n">phy_addr</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">mii_chip_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phy_id1</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Unknown PHY transceiver found at address %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dev_name</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">);</span>
			<span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_types</span> <span class="o">=</span> <span class="n">UNKNOWN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: No MII transceivers found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* select default PHY for mac */</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sis900_default_phy</span><span class="p">(</span> <span class="n">net_dev</span> <span class="p">);</span>

	<span class="cm">/* Reset phy if default phy is internal sis900 */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="o">-&gt;</span><span class="n">phy_id0</span> <span class="o">==</span> <span class="mh">0x001D</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="o">-&gt;</span><span class="n">phy_id1</span><span class="o">&amp;</span><span class="mh">0xFFF0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x8000</span><span class="p">))</span>
        	<span class="n">status</span> <span class="o">=</span> <span class="n">sis900_reset_phy</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">);</span>

        <span class="cm">/* workaround for ICS1893 PHY */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="o">-&gt;</span><span class="n">phy_id0</span> <span class="o">==</span> <span class="mh">0x0015</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">((</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="o">-&gt;</span><span class="n">phy_id1</span><span class="o">&amp;</span><span class="mh">0xFFF0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xF440</span><span class="p">))</span>
            	<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="mh">0x0018</span><span class="p">,</span> <span class="mh">0xD200</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MII_STAT_LINK</span><span class="p">){</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">poll_bit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">yield</span><span class="p">();</span>

			<span class="n">poll_bit</span> <span class="o">^=</span> <span class="p">(</span><span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">poll_bit</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: reset phy and link down now</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">dev_name</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span> <span class="o">==</span> <span class="n">SIS630E_900_REV</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* SiS 630E has some bugs on default value of PHY registers */</span>
		<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_ANADV</span><span class="p">,</span> <span class="mh">0x05e1</span><span class="p">);</span>
		<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_CONFIG1</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">);</span>
		<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_CONFIG2</span><span class="p">,</span> <span class="mh">0xff00</span><span class="p">);</span>
		<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_MASK</span><span class="p">,</span> <span class="mh">0xffc0</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>mdio<em>write(net</em>dev, sis<em>priv->cur</em>phy, MII_CONTROL, 0x1000);</p></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MII_STAT_LINK</span><span class="p">)</span>
		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_default_phy - Select default PHY for sis900 mac.</span>
<span class="cm"> *	@net_dev: the net device to probe for</span>
<span class="cm"> *</span>
<span class="cm"> *	Select first detected PHY with link as default.</span>
<span class="cm"> *	If no one is link on, select PHY whose types is HOME as default.</span>
<span class="cm"> *	If HOME doesn&#39;t exist, select LAN.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">sis900_default_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
 	<span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">phy_home</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="o">*</span><span class="n">default_phy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">phy_lan</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">phy</span><span class="o">=</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">first_mii</span><span class="p">;</span> <span class="n">phy</span><span class="p">;</span> <span class="n">phy</span><span class="o">=</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>

		<span class="cm">/* Link ON &amp; Not select default PHY &amp; not ghost PHY */</span>
		 <span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MII_STAT_LINK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">default_phy</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_types</span> <span class="o">!=</span> <span class="n">UNKNOWN</span><span class="p">))</span>
		 	<span class="n">default_phy</span> <span class="o">=</span> <span class="n">phy</span><span class="p">;</span>
		 <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_CONTROL</span><span class="p">);</span>
			<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_CONTROL</span><span class="p">,</span>
				<span class="n">status</span> <span class="o">|</span> <span class="n">MII_CNTL_AUTO</span> <span class="o">|</span> <span class="n">MII_CNTL_ISOLATE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_types</span> <span class="o">==</span> <span class="n">HOME</span><span class="p">)</span>
				<span class="n">phy_home</span> <span class="o">=</span> <span class="n">phy</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_types</span> <span class="o">==</span> <span class="n">LAN</span><span class="p">)</span>
				<span class="n">phy_lan</span> <span class="o">=</span> <span class="n">phy</span><span class="p">;</span>
		 <span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">default_phy</span> <span class="o">&amp;&amp;</span> <span class="n">phy_home</span><span class="p">)</span>
		<span class="n">default_phy</span> <span class="o">=</span> <span class="n">phy_home</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">default_phy</span> <span class="o">&amp;&amp;</span> <span class="n">phy_lan</span><span class="p">)</span>
		<span class="n">default_phy</span> <span class="o">=</span> <span class="n">phy_lan</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">default_phy</span><span class="p">)</span>
		<span class="n">default_phy</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">first_mii</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span> <span class="o">!=</span> <span class="n">default_phy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span> <span class="o">=</span> <span class="n">default_phy</span><span class="p">;</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span> <span class="o">=</span> <span class="n">default_phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Using transceiver found at address %d as default</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pci_name</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii_info</span><span class="p">.</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_CONTROL</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">MII_CNTL_ISOLATE</span><span class="p">);</span>

	<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_CONTROL</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * 	sis900_set_capability - set the media capability of network adapter.</span>
<span class="cm"> *	@net_dev : the net device to probe for</span>
<span class="cm"> *	@phy : default PHY</span>
<span class="cm"> *</span>
<span class="cm"> *	Set the media capability of network adapter according to</span>
<span class="cm"> *	mii status register. It&#39;s necessary before auto-negotiate.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_set_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">MII_NWAY_CSMA_CD</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MII_STAT_CAN_TX_FDX</span><span class="p">)</span><span class="o">?</span> <span class="n">MII_NWAY_TX_FDX</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MII_STAT_CAN_TX</span><span class="p">)</span>    <span class="o">?</span> <span class="n">MII_NWAY_TX</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MII_STAT_CAN_T_FDX</span><span class="p">)</span> <span class="o">?</span> <span class="n">MII_NWAY_T_FDX</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span><span class="o">|</span>
		<span class="p">((</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MII_STAT_CAN_T</span><span class="p">)</span>     <span class="o">?</span> <span class="n">MII_NWAY_T</span><span class="o">:</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_ANADV</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Delay between EEPROM clock transitions. */</span>
<span class="cp">#define eeprom_delay()	sr32(mear)</span>

<span class="cm">/**</span>
<span class="cm"> *	read_eeprom - Read Serial EEPROM</span>
<span class="cm"> *	@ioaddr: base i/o address</span>
<span class="cm"> *	@location: the EEPROM location to read</span>
<span class="cm"> *</span>
<span class="cm"> *	Read Serial EEPROM through EEPROM Access Register.</span>
<span class="cm"> *	Note that location is in word (16 bits) unit</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u16</span> <span class="n">__devinit</span> <span class="nf">read_eeprom</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">read_cmd</span> <span class="o">=</span> <span class="n">location</span> <span class="o">|</span> <span class="n">EEread</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">eeprom_delay</span><span class="p">();</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">EECS</span><span class="p">);</span>
	<span class="n">eeprom_delay</span><span class="p">();</span>

	<span class="cm">/* Shift the read command (9) bits out. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">dataval</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_cmd</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="n">EEDI</span> <span class="o">|</span> <span class="n">EECS</span> <span class="o">:</span> <span class="n">EECS</span><span class="p">;</span>

		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">dataval</span><span class="p">);</span>
		<span class="n">eeprom_delay</span><span class="p">();</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">dataval</span> <span class="o">|</span> <span class="n">EECLK</span><span class="p">);</span>
		<span class="n">eeprom_delay</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">EECS</span><span class="p">);</span>
	<span class="n">eeprom_delay</span><span class="p">();</span>

	<span class="cm">/* read the 16-bits data in */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">EECS</span><span class="p">);</span>
		<span class="n">eeprom_delay</span><span class="p">();</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">EECS</span> <span class="o">|</span> <span class="n">EECLK</span><span class="p">);</span>
		<span class="n">eeprom_delay</span><span class="p">();</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">sr32</span><span class="p">(</span><span class="n">mear</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EEDO</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">eeprom_delay</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Terminate the EEPROM access. */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">eeprom_delay</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Read and write the MII management registers using software-generated</span>
<span class="cm">   serial MDIO protocol. Note that the command bits and data bits are</span>
<span class="cm">   send out separately */</span>
<span class="cp">#define mdio_delay()	sr32(mear)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mdio_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">MDIO</span> <span class="o">|</span> <span class="n">MDDIR</span><span class="p">);</span>
	<span class="n">mdio_delay</span><span class="p">();</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">MDIO</span> <span class="o">|</span> <span class="n">MDDIR</span> <span class="o">|</span> <span class="n">MDC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Synchronize the MII management interface by shifting 32 one bits out. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mdio_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">MDDIR</span> <span class="o">|</span> <span class="n">MDIO</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">MDDIR</span> <span class="o">|</span> <span class="n">MDIO</span> <span class="o">|</span> <span class="n">MDC</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mdio_read - read MII PHY register</span>
<span class="cm"> *	@net_dev: the net device to read</span>
<span class="cm"> *	@phy_id: the phy address to read</span>
<span class="cm"> *	@location: the phy regiester id to read</span>
<span class="cm"> *</span>
<span class="cm"> *	Read MII registers through MDIO and MDC</span>
<span class="cm"> *	using MDIO management frame structure and protocol(defined by ISO/IEC).</span>
<span class="cm"> *	Please see SiS7014 or ICS spec</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mii_cmd</span> <span class="o">=</span> <span class="n">MIIread</span><span class="o">|</span><span class="p">(</span><span class="n">phy_id</span><span class="o">&lt;&lt;</span><span class="n">MIIpmdShift</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">location</span><span class="o">&lt;&lt;</span><span class="n">MIIregShift</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mdio_reset</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">mdio_idle</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">dataval</span> <span class="o">=</span> <span class="p">(</span><span class="n">mii_cmd</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="n">MDDIR</span> <span class="o">|</span> <span class="n">MDIO</span> <span class="o">:</span> <span class="n">MDDIR</span><span class="p">;</span>

		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">dataval</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">dataval</span> <span class="o">|</span> <span class="n">MDC</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Read the 16 data bits. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">sr32</span><span class="p">(</span><span class="n">mear</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MDIO</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">MDC</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mdio_write - write MII PHY register</span>
<span class="cm"> *	@net_dev: the net device to write</span>
<span class="cm"> *	@phy_id: the phy address to write</span>
<span class="cm"> *	@location: the phy regiester id to write</span>
<span class="cm"> *	@value: the register value to write with</span>
<span class="cm"> *</span>
<span class="cm"> *	Write MII registers with @value through MDIO and MDC</span>
<span class="cm"> *	using MDIO management frame structure and protocol(defined by ISO/IEC)</span>
<span class="cm"> *	please see SiS7014 or ICS spec</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mii_cmd</span> <span class="o">=</span> <span class="n">MIIwrite</span><span class="o">|</span><span class="p">(</span><span class="n">phy_id</span><span class="o">&lt;&lt;</span><span class="n">MIIpmdShift</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">location</span><span class="o">&lt;&lt;</span><span class="n">MIIregShift</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mdio_reset</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">mdio_idle</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

	<span class="cm">/* Shift the command bits out. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">dataval</span> <span class="o">=</span> <span class="p">(</span><span class="n">mii_cmd</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="n">MDDIR</span> <span class="o">|</span> <span class="n">MDIO</span> <span class="o">:</span> <span class="n">MDDIR</span><span class="p">;</span>

		<span class="n">sw8</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">dataval</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
		<span class="n">sw8</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">dataval</span> <span class="o">|</span> <span class="n">MDC</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">mdio_delay</span><span class="p">();</span>

	<span class="cm">/* Shift the value bits out. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">dataval</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="n">MDDIR</span> <span class="o">|</span> <span class="n">MDIO</span> <span class="o">:</span> <span class="n">MDDIR</span><span class="p">;</span>

		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">dataval</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">dataval</span> <span class="o">|</span> <span class="n">MDC</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">mdio_delay</span><span class="p">();</span>

	<span class="cm">/* Clear out extra bits. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sw8</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
		<span class="n">sw8</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="n">MDC</span><span class="p">);</span>
		<span class="n">mdio_delay</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">mear</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	sis900_reset_phy - reset sis900 mii phy.</span>
<span class="cm"> *	@net_dev: the net device to write</span>
<span class="cm"> *	@phy_addr: default phy address</span>
<span class="cm"> *</span>
<span class="cm"> *	Some specific phy can&#39;t work properly without reset.</span>
<span class="cm"> *	This function will be called during initialization and</span>
<span class="cm"> *	link status change from ON to DOWN.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">sis900_reset_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>

	<span class="n">mdio_write</span><span class="p">(</span> <span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_CONTROL</span><span class="p">,</span> <span class="n">MII_CNTL_RESET</span> <span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="cm">/*</span>
<span class="cm"> * Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<span class="cm"> * without having to re-enable interrupts. It&#39;s not called while</span>
<span class="cm"> * the interrupt routine is executing.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">sis900_interrupt</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_open - open sis900 device</span>
<span class="cm"> *	@net_dev: the net device to open</span>
<span class="cm"> *</span>
<span class="cm"> *	Do some initialization and start net interface.</span>
<span class="cm"> *	enable interrupts and set sis900 timer.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sis900_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Soft reset the chip. */</span>
	<span class="n">sis900_reset</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="cm">/* Equalizer workaround Rule */</span>
	<span class="n">sis630_set_eq</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">sis900_interrupt</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			  <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">sis900_init_rxfilter</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">sis900_init_tx_ring</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">sis900_init_rx_ring</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">set_rx_mode</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="cm">/* Workaround for EDB */</span>
	<span class="n">sis900_set_mode</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">,</span> <span class="n">HW_SPEED_10_MBPS</span><span class="p">,</span> <span class="n">FDX_CAPABLE_HALF_SELECTED</span><span class="p">);</span>

	<span class="cm">/* Enable all known interrupts by setting the interrupt mask. */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">imr</span><span class="p">,</span> <span class="n">RxSOVR</span> <span class="o">|</span> <span class="n">RxORN</span> <span class="o">|</span> <span class="n">RxERR</span> <span class="o">|</span> <span class="n">RxOK</span> <span class="o">|</span> <span class="n">TxURN</span> <span class="o">|</span> <span class="n">TxERR</span> <span class="o">|</span> <span class="n">TxIDLE</span><span class="p">);</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">RxENA</span> <span class="o">|</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cr</span><span class="p">));</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="n">IE</span><span class="p">);</span>

	<span class="n">sis900_check_mode</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">);</span>

	<span class="cm">/* Set the timer to switch to check for link beat and perhaps switch</span>
<span class="cm">	   to an alternate media type. */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">sis900_timer</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_init_rxfilter - Initialize the Rx filter</span>
<span class="cm"> *	@net_dev: the net device to initialize for</span>
<span class="cm"> *</span>
<span class="cm"> *	Set receive filter address to our MAC address</span>
<span class="cm"> *	and enable packet filtering.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sis900_init_rxfilter</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rfcrSave</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rfcrSave</span> <span class="o">=</span> <span class="n">sr32</span><span class="p">(</span><span class="n">rfcr</span><span class="p">);</span>

	<span class="cm">/* disable packet filtering before setting filter */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">rfcr</span><span class="p">,</span> <span class="n">rfcrSave</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RFEN</span><span class="p">);</span>

	<span class="cm">/* load MAC addr to filter data register */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span><span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>

		<span class="n">sw32</span><span class="p">(</span><span class="n">rfcr</span><span class="p">,</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">RFADDR_shift</span><span class="p">);</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">rfdr</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Receive Filter Addrss[%d]=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sr32</span><span class="p">(</span><span class="n">rfdr</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* enable packet filtering */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">rfcr</span><span class="p">,</span> <span class="n">rfcrSave</span> <span class="o">|</span> <span class="n">RFEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_init_tx_ring - Initialize the Tx descriptor ring</span>
<span class="cm"> *	@net_dev: the net device to initialize for</span>
<span class="cm"> *</span>
<span class="cm"> *	Initialize the Tx descriptor ring,</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sis900_init_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_TX_DESC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">link</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span> <span class="o">+</span>
			<span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">NUM_TX_DESC</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BufferDesc</span><span class="p">);</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmdsts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bufptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* load Transmit Descriptor Register */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">txdp</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: TX descriptor register loaded with: %8.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sr32</span><span class="p">(</span><span class="n">txdp</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_init_rx_ring - Initialize the Rx descriptor ring</span>
<span class="cm"> *	@net_dev: the net device to initialize for</span>
<span class="cm"> *</span>
<span class="cm"> *	Initialize the Rx descriptor ring,</span>
<span class="cm"> *	and pre-allocate recevie buffers (socket buffer)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sis900_init_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* init RX descriptor */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RX_DESC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">link</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span> <span class="o">+</span>
			<span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">NUM_RX_DESC</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BufferDesc</span><span class="p">);</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmdsts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bufptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate sock buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RX_DESC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">RX_BUF_SIZE</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* not enough memory for skbuff, this makes a &quot;hole&quot;</span>
<span class="cm">			   on the buffer ring, it is not clear how the</span>
<span class="cm">			   hardware will react to this kind of degenerated</span>
<span class="cm">			   buffer */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmdsts</span> <span class="o">=</span> <span class="n">RX_BUF_SIZE</span><span class="p">;</span>
                <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bufptr</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
                        <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">RX_BUF_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">NUM_RX_DESC</span><span class="p">);</span>

	<span class="cm">/* load Receive Descriptor Register */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">rxdp</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: RX descriptor register loaded with: %8.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sr32</span><span class="p">(</span><span class="n">rxdp</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis630_set_eq - set phy equalizer value for 630 LAN</span>
<span class="cm"> *	@net_dev: the net device to set equalizer value</span>
<span class="cm"> *	@revision: 630 LAN revision number</span>
<span class="cm"> *</span>
<span class="cm"> *	630E equalizer workaround rule(Cyrus Huang 08/15)</span>
<span class="cm"> *	PHY register 14h(Test)</span>
<span class="cm"> *	Bit 14: 0 -- Automatically detect (default)</span>
<span class="cm"> *		1 -- Manually set Equalizer filter</span>
<span class="cm"> *	Bit 13: 0 -- (Default)</span>
<span class="cm"> *		1 -- Speed up convergence of equalizer setting</span>
<span class="cm"> *	Bit 9 : 0 -- (Default)</span>
<span class="cm"> *		1 -- Disable Baseline Wander</span>
<span class="cm"> *	Bit 3~7   -- Equalizer filter setting</span>
<span class="cm"> *	Link ON: Set Bit 9, 13 to 1, Bit 14 to 0</span>
<span class="cm"> *	Then calculate equalizer value</span>
<span class="cm"> *	Then set equalizer value, and set Bit 14 to 1, Bit 9 to 0</span>
<span class="cm"> *	Link Off:Set Bit 13 to 1, Bit 14 to 0</span>
<span class="cm"> *	Calculate Equalizer value:</span>
<span class="cm"> *	When Link is ON and Bit 14 is 0, SIS900PHY will auto-detect proper equalizer value.</span>
<span class="cm"> *	When the equalizer is stable, this value is not a fixed value. It will be within</span>
<span class="cm"> *	a small range(eg. 7~9). Then we get a minimum and a maximum value(eg. min=7, max=9)</span>
<span class="cm"> *	0 &lt;= max &lt;= 4  --&gt; set equalizer to max</span>
<span class="cm"> *	5 &lt;= max &lt;= 14 --&gt; set equalizer to max+1 or set equalizer to max+2 if max == min</span>
<span class="cm"> *	max &gt;= 15      --&gt; set equalizer to max+5 or set equalizer to max+6 if max == min</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis630_set_eq</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">revision</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">reg14h</span><span class="p">,</span> <span class="n">eq_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">maxcount</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">revision</span> <span class="o">==</span> <span class="n">SIS630E_900_REV</span> <span class="o">||</span> <span class="n">revision</span> <span class="o">==</span> <span class="n">SIS630EA1_900_REV</span> <span class="o">||</span>
	       <span class="n">revision</span> <span class="o">==</span> <span class="n">SIS630A_900_REV</span> <span class="o">||</span> <span class="n">revision</span> <span class="o">==</span>  <span class="n">SIS630ET_900_REV</span><span class="p">)</span> <span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">net_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reg14h</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_RESV</span><span class="p">);</span>
		<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_RESV</span><span class="p">,</span>
					<span class="p">(</span><span class="mh">0x2200</span> <span class="o">|</span> <span class="n">reg14h</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xBFFF</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxcount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eq_value</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x00F8</span> <span class="o">&amp;</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span>
					<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_RESV</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">max_value</span><span class="o">=</span><span class="n">min_value</span><span class="o">=</span><span class="n">eq_value</span><span class="p">;</span>
			<span class="n">max_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">eq_value</span> <span class="o">&gt;</span> <span class="n">max_value</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">eq_value</span> <span class="o">:</span> <span class="n">max_value</span><span class="p">;</span>
			<span class="n">min_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">eq_value</span> <span class="o">&lt;</span> <span class="n">min_value</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">eq_value</span> <span class="o">:</span> <span class="n">min_value</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* 630E rule to determine the equalizer value */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">revision</span> <span class="o">==</span> <span class="n">SIS630E_900_REV</span> <span class="o">||</span> <span class="n">revision</span> <span class="o">==</span> <span class="n">SIS630EA1_900_REV</span> <span class="o">||</span>
		    <span class="n">revision</span> <span class="o">==</span> <span class="n">SIS630ET_900_REV</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">max_value</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>
				<span class="n">eq_value</span> <span class="o">=</span> <span class="n">max_value</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max_value</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="n">max_value</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">)</span>
				<span class="n">eq_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_value</span> <span class="o">==</span> <span class="n">min_value</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">max_value</span><span class="o">+</span><span class="mi">2</span> <span class="o">:</span> <span class="n">max_value</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max_value</span> <span class="o">&gt;=</span> <span class="mi">15</span><span class="p">)</span>
				<span class="n">eq_value</span><span class="o">=</span><span class="p">(</span><span class="n">max_value</span> <span class="o">==</span> <span class="n">min_value</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">max_value</span><span class="o">+</span><span class="mi">6</span> <span class="o">:</span> <span class="n">max_value</span><span class="o">+</span><span class="mi">5</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* 630B0&amp;B1 rule to determine the equalizer value */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">revision</span> <span class="o">==</span> <span class="n">SIS630A_900_REV</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">host_bridge_rev</span> <span class="o">==</span> <span class="n">SIS630B0</span> <span class="o">||</span>
		     <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">host_bridge_rev</span> <span class="o">==</span> <span class="n">SIS630B1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">max_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">eq_value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">eq_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_value</span> <span class="o">+</span> <span class="n">min_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* write equalizer value and setting */</span>
		<span class="n">reg14h</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_RESV</span><span class="p">);</span>
		<span class="n">reg14h</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg14h</span> <span class="o">&amp;</span> <span class="mh">0xFF07</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">eq_value</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00F8</span><span class="p">);</span>
		<span class="n">reg14h</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg14h</span> <span class="o">|</span> <span class="mh">0x6000</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFDFF</span><span class="p">;</span>
		<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_RESV</span><span class="p">,</span> <span class="n">reg14h</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">reg14h</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_RESV</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">revision</span> <span class="o">==</span> <span class="n">SIS630A_900_REV</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">host_bridge_rev</span> <span class="o">==</span> <span class="n">SIS630B0</span> <span class="o">||</span>
		     <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">host_bridge_rev</span> <span class="o">==</span> <span class="n">SIS630B1</span><span class="p">))</span>
			<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_RESV</span><span class="p">,</span>
						<span class="p">(</span><span class="n">reg14h</span> <span class="o">|</span> <span class="mh">0x2200</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xBFFF</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_RESV</span><span class="p">,</span>
						<span class="p">(</span><span class="n">reg14h</span> <span class="o">|</span> <span class="mh">0x2000</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xBFFF</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_timer - sis900 timer routine</span>
<span class="cm"> *	@data: pointer to sis900 net device</span>
<span class="cm"> *</span>
<span class="cm"> *	On each timer ticks we check two things,</span>
<span class="cm"> *	link status (ON/OFF) and link mode (10/100/Full/Half)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span><span class="n">mii_phy</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">next_tick</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">autong_complete</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">speed</span><span class="p">),</span> <span class="n">duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">sis900_read_mode</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">duplex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">duplex</span><span class="p">){</span>
			<span class="n">sis900_set_mode</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">duplex</span><span class="p">);</span>
			<span class="n">sis630_set_eq</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span><span class="p">);</span>
			<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>

	<span class="cm">/* Link OFF -&gt; ON */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">net_dev</span><span class="p">))</span> <span class="p">{</span>
	<span class="nl">LookForLink:</span>
		<span class="cm">/* Search for new PHY */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sis900_default_phy</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="n">mii_phy</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MII_STAT_LINK</span><span class="p">){</span>
			<span class="n">sis900_check_mode</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">mii_phy</span><span class="p">);</span>
			<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="cm">/* Link ON -&gt; OFF */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MII_STAT_LINK</span><span class="p">)){</span>
                	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">netif_msg_link</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
                		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Media Link Off</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

                	<span class="cm">/* Change mode issue */</span>
                	<span class="k">if</span> <span class="p">((</span><span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_id0</span> <span class="o">==</span> <span class="mh">0x001D</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">((</span><span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_id1</span> <span class="o">&amp;</span> <span class="mh">0xFFF0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x8000</span><span class="p">))</span>
               			<span class="n">sis900_reset_phy</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span>  <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">);</span>

			<span class="n">sis630_set_eq</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span><span class="p">);</span>

                	<span class="k">goto</span> <span class="n">LookForLink</span><span class="p">;</span>
                <span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">next_tick</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_check_mode - check the media mode for sis900</span>
<span class="cm"> *	@net_dev: the net device to be checked</span>
<span class="cm"> *	@mii_phy: the mii phy</span>
<span class="cm"> *</span>
<span class="cm"> *	Older driver gets the media mode from mii status output</span>
<span class="cm"> *	register. Now we set our media capability and auto-negotiate</span>
<span class="cm"> *	to get the upper bound of speed and duplex between two ends.</span>
<span class="cm"> *	If the types of mii phy is HOME, it doesn&#39;t need to auto-negotiate</span>
<span class="cm"> *	and autong_complete should be set to 1.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_check_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span><span class="n">mii_phy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">speed</span><span class="p">,</span> <span class="n">duplex</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_types</span> <span class="o">==</span> <span class="n">LAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="o">~</span><span class="n">EXD</span> <span class="o">&amp;</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cfg</span><span class="p">));</span>
		<span class="n">sis900_set_capability</span><span class="p">(</span><span class="n">net_dev</span> <span class="p">,</span> <span class="n">mii_phy</span><span class="p">);</span>
		<span class="n">sis900_auto_negotiate</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">EXD</span> <span class="o">|</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cfg</span><span class="p">));</span>
		<span class="n">speed</span> <span class="o">=</span> <span class="n">HW_SPEED_HOME</span><span class="p">;</span>
		<span class="n">duplex</span> <span class="o">=</span> <span class="n">FDX_CAPABLE_HALF_SELECTED</span><span class="p">;</span>
		<span class="n">sis900_set_mode</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">duplex</span><span class="p">);</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">autong_complete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_set_mode - Set the media mode of mac register.</span>
<span class="cm"> *	@sp:     the device private data</span>
<span class="cm"> *	@speed : the transmit speed to be determined</span>
<span class="cm"> *	@duplex: the duplex mode to be determined</span>
<span class="cm"> *</span>
<span class="cm"> *	Set the media mode of mac register txcfg/rxcfg according to</span>
<span class="cm"> *	speed and duplex of phy. Bit EDB_MASTER_EN indicates the EDB</span>
<span class="cm"> *	bus is used instead of PCI bus. When this bit is set 1, the</span>
<span class="cm"> *	Max DMA Burst Size for TX/RX DMA should be no larger than 16</span>
<span class="cm"> *	double words.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_set_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">,</span> <span class="kt">int</span> <span class="n">duplex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rx_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sr32</span><span class="p">(</span> <span class="n">cfg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EDB_MASTER_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_flags</span> <span class="o">=</span> <span class="n">TxATP</span> <span class="o">|</span> <span class="p">(</span><span class="n">DMA_BURST_64</span> <span class="o">&lt;&lt;</span> <span class="n">TxMXDMA_shift</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">TX_FILL_THRESH</span> <span class="o">&lt;&lt;</span> <span class="n">TxFILLT_shift</span><span class="p">);</span>
		<span class="n">rx_flags</span> <span class="o">=</span> <span class="n">DMA_BURST_64</span> <span class="o">&lt;&lt;</span> <span class="n">RxMXDMA_shift</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tx_flags</span> <span class="o">=</span> <span class="n">TxATP</span> <span class="o">|</span> <span class="p">(</span><span class="n">DMA_BURST_512</span> <span class="o">&lt;&lt;</span> <span class="n">TxMXDMA_shift</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">TX_FILL_THRESH</span> <span class="o">&lt;&lt;</span> <span class="n">TxFILLT_shift</span><span class="p">);</span>
		<span class="n">rx_flags</span> <span class="o">=</span> <span class="n">DMA_BURST_512</span> <span class="o">&lt;&lt;</span> <span class="n">RxMXDMA_shift</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HW_SPEED_HOME</span> <span class="o">||</span> <span class="n">speed</span> <span class="o">==</span> <span class="n">HW_SPEED_10_MBPS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">RxDRNT_10</span> <span class="o">&lt;&lt;</span> <span class="n">RxDRNT_shift</span><span class="p">);</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TxDRNT_10</span> <span class="o">&lt;&lt;</span> <span class="n">TxDRNT_shift</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rx_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">RxDRNT_100</span> <span class="o">&lt;&lt;</span> <span class="n">RxDRNT_shift</span><span class="p">);</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TxDRNT_100</span> <span class="o">&lt;&lt;</span> <span class="n">TxDRNT_shift</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">FDX_CAPABLE_FULL_SELECTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TxCSI</span> <span class="o">|</span> <span class="n">TxHBI</span><span class="p">);</span>
		<span class="n">rx_flags</span> <span class="o">|=</span> <span class="n">RxATX</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)</span>
	<span class="cm">/* Can accept Jumbo packet */</span>
	<span class="n">rx_flags</span> <span class="o">|=</span> <span class="n">RxAJAB</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">sw32</span><span class="p">(</span><span class="n">txcfg</span><span class="p">,</span> <span class="n">tx_flags</span><span class="p">);</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">rxcfg</span><span class="p">,</span> <span class="n">rx_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_auto_negotiate - Set the Auto-Negotiation Enable/Reset bit.</span>
<span class="cm"> *	@net_dev: the net device to read mode for</span>
<span class="cm"> *	@phy_addr: mii phy address</span>
<span class="cm"> *</span>
<span class="cm"> *	If the adapter is link-on, set the auto-negotiate enable/reset bit.</span>
<span class="cm"> *	autong_complete should be set to 0 when starting auto-negotiation.</span>
<span class="cm"> *	autong_complete should be set to 1 if we didn&#39;t start auto-negotiation.</span>
<span class="cm"> *	sis900_timer will wait for link on again if autong_complete = 0.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_auto_negotiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MII_STAT_LINK</span><span class="p">)){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">netif_msg_link</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Media Link Off</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">autong_complete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* (Re)start AutoNegotiate */</span>
	<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_CONTROL</span><span class="p">,</span>
		   <span class="n">MII_CNTL_AUTO</span> <span class="o">|</span> <span class="n">MII_CNTL_RST_AUTO</span><span class="p">);</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">autong_complete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	sis900_read_mode - read media mode for sis900 internal phy</span>
<span class="cm"> *	@net_dev: the net device to read mode for</span>
<span class="cm"> *	@speed  : the transmit speed to be determined</span>
<span class="cm"> *	@duplex : the duplex mode to be determined</span>
<span class="cm"> *</span>
<span class="cm"> *	The capability of remote end will be put in mii register autorec</span>
<span class="cm"> *	after auto-negotiation. Use AND operation to get the upper bound</span>
<span class="cm"> *	of speed and duplex between two ends.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_read_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">speed</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">duplex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">phy_addr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">autoadv</span><span class="p">,</span> <span class="n">autorec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_STATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MII_STAT_LINK</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* AutoNegotiate completed */</span>
	<span class="n">autoadv</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_ANADV</span><span class="p">);</span>
	<span class="n">autorec</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_ANLPAR</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">autoadv</span> <span class="o">&amp;</span> <span class="n">autorec</span><span class="p">;</span>

	<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">HW_SPEED_10_MBPS</span><span class="p">;</span>
	<span class="o">*</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">FDX_CAPABLE_HALF_SELECTED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MII_NWAY_TX</span> <span class="o">|</span> <span class="n">MII_NWAY_TX_FDX</span><span class="p">))</span>
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">HW_SPEED_100_MBPS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">MII_NWAY_TX_FDX</span> <span class="o">|</span> <span class="n">MII_NWAY_T_FDX</span><span class="p">))</span>
		<span class="o">*</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">FDX_CAPABLE_FULL_SELECTED</span><span class="p">;</span>

	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">autong_complete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Workaround for Realtek RTL8201 PHY issue */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_id0</span> <span class="o">==</span> <span class="mh">0x0000</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_id1</span> <span class="o">&amp;</span> <span class="mh">0xFFF0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x8200</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MII_CNTL_FDX</span><span class="p">)</span>
			<span class="o">*</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">FDX_CAPABLE_FULL_SELECTED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="mh">0x0019</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
			<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">HW_SPEED_100_MBPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">netif_msg_link</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Media Link On %s %s-duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	       				<span class="o">*</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HW_SPEED_100_MBPS</span> <span class="o">?</span>
	       					<span class="s">&quot;100mbps&quot;</span> <span class="o">:</span> <span class="s">&quot;10mbps&quot;</span><span class="p">,</span>
	       				<span class="o">*</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">FDX_CAPABLE_FULL_SELECTED</span> <span class="o">?</span>
	       					<span class="s">&quot;full&quot;</span> <span class="o">:</span> <span class="s">&quot;half&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_tx_timeout - sis900 transmit timeout routine</span>
<span class="cm"> *	@net_dev: the net device to transmit</span>
<span class="cm"> *</span>
<span class="cm"> *	print transmit timeout status</span>
<span class="cm"> *	disable interrupts and do some tasks</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_tx_err</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Transmit timeout, status %8.8x %8.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cr</span><span class="p">),</span> <span class="n">sr32</span><span class="p">(</span><span class="n">isr</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Disable interrupts by clearing the interrupt mask. */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">imr</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>

	<span class="cm">/* use spinlock to prevent interrupt handler accessing buffer ring */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* discard unsent packets */</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_TX_DESC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bufptr</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmdsts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bufptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>

	<span class="cm">/* load Transmit Descriptor Register */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">txdp</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">);</span>

	<span class="cm">/* Enable all known interrupts by setting the interrupt mask. */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">imr</span><span class="p">,</span> <span class="n">RxSOVR</span> <span class="o">|</span> <span class="n">RxORN</span> <span class="o">|</span> <span class="n">RxERR</span> <span class="o">|</span> <span class="n">RxOK</span> <span class="o">|</span> <span class="n">TxURN</span> <span class="o">|</span> <span class="n">TxERR</span> <span class="o">|</span> <span class="n">TxIDLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_start_xmit - sis900 start transmit routine</span>
<span class="cm"> *	@skb: socket buffer pointer to put the data being transmitted</span>
<span class="cm"> *	@net_dev: the net device to transmit with</span>
<span class="cm"> *</span>
<span class="cm"> *	Set the transmit buffer descriptor,</span>
<span class="cm"> *	and write TxENA to enable transmit state machine.</span>
<span class="cm"> *	tell upper layer if the buffer is full</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span>
<span class="nf">sis900_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">index_cur_tx</span><span class="p">,</span> <span class="n">index_dirty_tx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">count_dirty_tx</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t transmit data before the complete of auto-negotiation */</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">autong_complete</span><span class="p">){</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Calculate the next Tx descriptor entry. */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">%</span> <span class="n">NUM_TX_DESC</span><span class="p">;</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* set the transmit buffer descriptor and enable Transmit State Machine */</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">bufptr</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmdsts</span> <span class="o">=</span> <span class="p">(</span><span class="n">OWN</span> <span class="o">|</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">TxENA</span> <span class="o">|</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cr</span><span class="p">));</span>

	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">++</span><span class="p">;</span>
	<span class="n">index_cur_tx</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">;</span>
	<span class="n">index_dirty_tx</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">count_dirty_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index_cur_tx</span> <span class="o">!=</span> <span class="n">index_dirty_tx</span><span class="p">;</span> <span class="n">index_dirty_tx</span><span class="o">++</span><span class="p">)</span>
		<span class="n">count_dirty_tx</span> <span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index_cur_tx</span> <span class="o">==</span> <span class="n">index_dirty_tx</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* dirty_tx is met in the cycle of cur_tx, buffer full */</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count_dirty_tx</span> <span class="o">&lt;</span> <span class="n">NUM_TX_DESC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Typical path, tell upper layer that more transmission is possible */</span>
		<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* buffer full, tell upper layer no more transmission */</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_tx_queued</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Queued Tx packet at %p size %d &quot;</span>
		       <span class="s">&quot;to slot %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_interrupt - sis900 interrupt handler</span>
<span class="cm"> *	@irq: the irq number</span>
<span class="cm"> *	@dev_instance: the client data object</span>
<span class="cm"> *</span>
<span class="cm"> *	The interrupt handler does all of the Rx thread work,</span>
<span class="cm"> *	and cleans up after the Tx thread</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">sis900_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">dev_instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">boguscnt</span> <span class="o">=</span> <span class="n">max_interrupt_work</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sr32</span><span class="p">(</span><span class="n">isr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HIBERR</span><span class="o">|</span><span class="n">TxURN</span><span class="o">|</span><span class="n">TxERR</span><span class="o">|</span><span class="n">TxIDLE</span><span class="o">|</span><span class="n">RxORN</span><span class="o">|</span><span class="n">RxERR</span><span class="o">|</span><span class="n">RxOK</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* nothing intresting happened */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* why dow&#39;t we break after Tx/Rx case ?? keyword: full-duplex */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RxORN</span> <span class="o">|</span> <span class="n">RxERR</span> <span class="o">|</span> <span class="n">RxOK</span><span class="p">))</span>
			<span class="cm">/* Rx interrupt */</span>
			<span class="n">sis900_rx</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TxURN</span> <span class="o">|</span> <span class="n">TxERR</span> <span class="o">|</span> <span class="n">TxIDLE</span><span class="p">))</span>
			<span class="cm">/* Tx interrupt */</span>
			<span class="n">sis900_finish_xmit</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

		<span class="cm">/* something strange happened !!! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">HIBERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">netif_msg_intr</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Abnormal interrupt, &quot;</span>
					<span class="s">&quot;status %#8.8x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">boguscnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">netif_msg_intr</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Too much work at interrupt, &quot;</span>
					<span class="s">&quot;interrupt status = %#8.8x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">netif_msg_intr</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: exiting interrupt, &quot;</span>
		       <span class="s">&quot;interrupt status = 0x%#8.8x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sr32</span><span class="p">(</span><span class="n">isr</span><span class="p">));</span>

	<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_rx - sis900 receive routine</span>
<span class="cm"> *	@net_dev: the net device which receives data</span>
<span class="cm"> *</span>
<span class="cm"> *	Process receive interrupt events,</span>
<span class="cm"> *	put buffer to higher layer and refill buffer pool</span>
<span class="cm"> *	Note: This function is called by interrupt handler,</span>
<span class="cm"> *	don&#39;t do &quot;too much&quot; work here</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sis900_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">%</span> <span class="n">NUM_RX_DESC</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_status</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmdsts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_work_limit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_rx_status</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;sis900_rx, cur_rx:%4.4d, dirty_rx:%4.4d &quot;</span>
		       <span class="s">&quot;status:0x%8.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_rx</span><span class="p">,</span> <span class="n">rx_status</span><span class="p">);</span>
	<span class="n">rx_work_limit</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">+</span> <span class="n">NUM_RX_DESC</span> <span class="o">-</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rx_status</span> <span class="o">&amp;</span> <span class="n">OWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_size</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">rx_work_limit</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">data_size</span> <span class="o">=</span> <span class="n">rx_status</span> <span class="o">&amp;</span> <span class="n">DSIZE</span><span class="p">;</span>
		<span class="n">rx_size</span> <span class="o">=</span> <span class="n">data_size</span> <span class="o">-</span> <span class="n">CRC_SIZE</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)</span>
		<span class="cm">/* ``TOOLONG&#39;&#39; flag means jumbo packet received. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rx_status</span> <span class="o">&amp;</span> <span class="n">TOOLONG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">data_size</span> <span class="o">&lt;=</span> <span class="n">MAX_FRAME_SIZE</span><span class="p">)</span>
			<span class="n">rx_status</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">TOOLONG</span><span class="p">));</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rx_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ABORT</span><span class="o">|</span><span class="n">OVERRUN</span><span class="o">|</span><span class="n">TOOLONG</span><span class="o">|</span><span class="n">RUNT</span><span class="o">|</span><span class="n">RXISERR</span><span class="o">|</span><span class="n">CRCERR</span><span class="o">|</span><span class="n">FAERR</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* corrupted packet received */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_rx_err</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Corrupted packet &quot;</span>
				       <span class="s">&quot;received, buffer status = 0x%8.8x/%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rx_status</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
			<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_status</span> <span class="o">&amp;</span> <span class="n">OVERRUN</span><span class="p">)</span>
				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TOOLONG</span><span class="o">|</span><span class="n">RUNT</span><span class="p">))</span>
				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RXISERR</span> <span class="o">|</span> <span class="n">FAERR</span><span class="p">))</span>
				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_status</span> <span class="o">&amp;</span> <span class="n">CRCERR</span><span class="p">)</span>
				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* reset buffer descriptor state */</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmdsts</span> <span class="o">=</span> <span class="n">RX_BUF_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">rx_skb</span><span class="p">;</span>

			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">bufptr</span><span class="p">,</span> <span class="n">RX_BUF_SIZE</span><span class="p">,</span>
				<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

			<span class="cm">/* refill the Rx buffer, what if there is not enough</span>
<span class="cm">			 * memory for new socket buffer ?? */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">RX_BUF_SIZE</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Not enough memory to refill the buffer</span>
<span class="cm">				 * so we need to recycle the old one so</span>
<span class="cm">				 * as to avoid creating a memory hole</span>
<span class="cm">				 * in the rx ring</span>
<span class="cm">				 */</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">refill_rx_ring</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* This situation should never happen, but due to</span>
<span class="cm">			   some unknown bugs, it is possible that</span>
<span class="cm">			   we are working on NULL sk_buff :-( */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_rx_err</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: NULL pointer &quot;</span>
					      <span class="s">&quot;encountered in Rx ring</span><span class="se">\n</span><span class="s">&quot;</span>
					      <span class="s">&quot;cur_rx:%4.4d, dirty_rx:%4.4d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					      <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">,</span>
					      <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_rx</span><span class="p">);</span>
				<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* give the socket buffer to upper layers */</span>
			<span class="n">rx_skb</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">rx_skb</span><span class="p">,</span> <span class="n">rx_size</span><span class="p">);</span>
			<span class="n">rx_skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">rx_skb</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>
			<span class="n">netif_rx</span><span class="p">(</span><span class="n">rx_skb</span><span class="p">);</span>

			<span class="cm">/* some network statistics */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rx_status</span> <span class="o">&amp;</span> <span class="n">BCAST</span><span class="p">)</span> <span class="o">==</span> <span class="n">MCAST</span><span class="p">)</span>
				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">multicast</span><span class="o">++</span><span class="p">;</span>
			<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">rx_size</span><span class="p">;</span>
			<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_rx</span><span class="o">++</span><span class="p">;</span>
<span class="nl">refill_rx_ring:</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmdsts</span> <span class="o">=</span> <span class="n">RX_BUF_SIZE</span><span class="p">;</span>
                	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">bufptr</span> <span class="o">=</span>
				<span class="n">pci_map_single</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
					<span class="n">RX_BUF_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="o">++</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">%</span> <span class="n">NUM_RX_DESC</span><span class="p">;</span>
		<span class="n">rx_status</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmdsts</span><span class="p">;</span>
	<span class="p">}</span> <span class="c1">// while</span>

	<span class="cm">/* refill the Rx buffer, what if the rate of refilling is slower</span>
<span class="cm">	 * than consuming ?? */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">!=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_rx</span><span class="p">;</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_rx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

		<span class="n">entry</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">%</span> <span class="n">NUM_RX_DESC</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">RX_BUF_SIZE</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* not enough memory for skbuff, this makes a</span>
<span class="cm">				 * &quot;hole&quot; on the buffer ring, it is not clear</span>
<span class="cm">				 * how the hardware will react to this kind</span>
<span class="cm">				 * of degenerated buffer */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_rx_err</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Memory squeeze, &quot;</span>
						<span class="s">&quot;deferring packet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmdsts</span> <span class="o">=</span> <span class="n">RX_BUF_SIZE</span><span class="p">;</span>
                	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">bufptr</span> <span class="o">=</span>
				<span class="n">pci_map_single</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
					<span class="n">RX_BUF_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* re-enable the potentially idle receive state matchine */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span> <span class="p">,</span> <span class="n">RxENA</span> <span class="o">|</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cr</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_finish_xmit - finish up transmission of packets</span>
<span class="cm"> *	@net_dev: the net device to be transmitted on</span>
<span class="cm"> *</span>
<span class="cm"> *	Check for error condition and free socket buffer etc</span>
<span class="cm"> *	schedule for more transmission as needed</span>
<span class="cm"> *	Note: This function is called by interrupt handler,</span>
<span class="cm"> *	don&#39;t do &quot;too much&quot; work here</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_finish_xmit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">!=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">;</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">tx_status</span><span class="p">;</span>

		<span class="n">entry</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">%</span> <span class="n">NUM_TX_DESC</span><span class="p">;</span>
		<span class="n">tx_status</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmdsts</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">OWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The packet is not transmitted yet (owned by hardware) !</span>
<span class="cm">			 * Note: the interrupt is generated only when Tx Machine</span>
<span class="cm">			 * is idle, so this is an almost impossible case */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ABORT</span> <span class="o">|</span> <span class="n">UNDERRUN</span> <span class="o">|</span> <span class="n">OWCOLL</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* packet unsuccessfully transmitted */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_tx_err</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Transmit &quot;</span>
				       <span class="s">&quot;error, Tx status %8.8x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">tx_status</span><span class="p">);</span>
			<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">UNDERRUN</span><span class="p">)</span>
				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">ABORT</span><span class="p">)</span>
				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">NOCARRIER</span><span class="p">)</span>
				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_carrier_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">OWCOLL</span><span class="p">)</span>
				<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* packet successfully transmitted */</span>
			<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">COLCNT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">DSIZE</span><span class="p">;</span>
			<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Free the original skb. */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">bufptr</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
			<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">bufptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmdsts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">&amp;&amp;</span> <span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">net_dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">&lt;</span> <span class="n">NUM_TX_DESC</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The ring is no longer full, clear tx_full and schedule</span>
<span class="cm">		 * more transmission by netif_wake_queue(net_dev) */</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">netif_wake_queue</span> <span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_close - close sis900 device</span>
<span class="cm"> *	@net_dev: the net device to be closed</span>
<span class="cm"> *</span>
<span class="cm"> *	Disable interrupts, stop the Tx and Rx Status Machine</span>
<span class="cm"> *	free Tx and RX socket buffer</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sis900_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="cm">/* Disable interrupts by clearing the interrupt mask. */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">imr</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>

	<span class="cm">/* Stop the chip&#39;s Tx and Rx Status Machine */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">RxDIS</span> <span class="o">|</span> <span class="n">TxDIS</span> <span class="o">|</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cr</span><span class="p">));</span>

	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>

	<span class="cm">/* Free Tx and RX skbuff */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RX_DESC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bufptr</span><span class="p">,</span>
					 <span class="n">RX_BUF_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_TX_DESC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bufptr</span><span class="p">,</span>
					 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Green! Put the chip in low-power mode. */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_get_drvinfo - Return information about driver</span>
<span class="cm"> *	@net_dev: the net device to probe</span>
<span class="cm"> *	@info: container for info returned</span>
<span class="cm"> *</span>
<span class="cm"> *	Process ethtool command such as &quot;ehtool -i&quot; to show information</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">SIS900_MODULE_NAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">SIS900_DRV_VERSION</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">sis900_get_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_set_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">sis900_get_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mii_link_ok</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sis900_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mii_ethtool_gset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii_info</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sis900_set_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rt</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rt</span> <span class="o">=</span> <span class="n">mii_ethtool_sset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii_info</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sis900_nway_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mii_nway_restart</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_set_wol - Set up Wake on Lan registers</span>
<span class="cm"> *	@net_dev: the net device to probe</span>
<span class="cm"> *	@wol: container for info passed to the driver</span>
<span class="cm"> *</span>
<span class="cm"> *	Process ethtool command &quot;wol&quot; to setup wake on lan features.</span>
<span class="cm"> *	SiS900 supports sending WoL events if a correct packet is received,</span>
<span class="cm"> *	but there is no simple way to filter them to only a subset (broadcast,</span>
<span class="cm"> *	multicast, unicast or arp).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sis900_set_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfgpmcsr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pmctrl_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">CFGPMCSR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfgpmcsr</span><span class="p">);</span>
		<span class="n">cfgpmcsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PME_EN</span><span class="p">;</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">CFGPMCSR</span><span class="p">,</span> <span class="n">cfgpmcsr</span><span class="p">);</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">pmctrl</span><span class="p">,</span> <span class="n">pmctrl_bits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_wol</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Wake on LAN disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">WAKE_MAGICSECURE</span> <span class="o">|</span> <span class="n">WAKE_UCAST</span> <span class="o">|</span> <span class="n">WAKE_MCAST</span>
				<span class="o">|</span> <span class="n">WAKE_BCAST</span> <span class="o">|</span> <span class="n">WAKE_ARP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">&amp;</span> <span class="n">WAKE_MAGIC</span><span class="p">)</span>
		<span class="n">pmctrl_bits</span> <span class="o">|=</span> <span class="n">MAGICPKT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">&amp;</span> <span class="n">WAKE_PHY</span><span class="p">)</span>
		<span class="n">pmctrl_bits</span> <span class="o">|=</span> <span class="n">LINKON</span><span class="p">;</span>

	<span class="n">sw32</span><span class="p">(</span><span class="n">pmctrl</span><span class="p">,</span> <span class="n">pmctrl_bits</span><span class="p">);</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">CFGPMCSR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfgpmcsr</span><span class="p">);</span>
	<span class="n">cfgpmcsr</span> <span class="o">|=</span> <span class="n">PME_EN</span><span class="p">;</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">CFGPMCSR</span><span class="p">,</span> <span class="n">cfgpmcsr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_wol</span><span class="p">(</span><span class="n">sis_priv</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Wake on LAN enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_get_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pmctrl_bits</span><span class="p">;</span>

	<span class="n">pmctrl_bits</span> <span class="o">=</span> <span class="n">sr32</span><span class="p">(</span><span class="n">pmctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmctrl_bits</span> <span class="o">&amp;</span> <span class="n">MAGICPKT</span><span class="p">)</span>
		<span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">|=</span> <span class="n">WAKE_MAGIC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmctrl_bits</span> <span class="o">&amp;</span> <span class="n">LINKON</span><span class="p">)</span>
		<span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">|=</span> <span class="n">WAKE_PHY</span><span class="p">;</span>

	<span class="n">wol</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">=</span> <span class="p">(</span><span class="n">WAKE_PHY</span> <span class="o">|</span> <span class="n">WAKE_MAGIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">sis900_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_drvinfo</span> 	<span class="o">=</span> <span class="n">sis900_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span>	<span class="o">=</span> <span class="n">sis900_get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span>	<span class="o">=</span> <span class="n">sis900_set_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span>	<span class="o">=</span> <span class="n">sis900_get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_settings</span>	<span class="o">=</span> <span class="n">sis900_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span>	<span class="o">=</span> <span class="n">sis900_set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nway_reset</span>	<span class="o">=</span> <span class="n">sis900_nway_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_wol</span>	<span class="o">=</span> <span class="n">sis900_get_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_wol</span>	<span class="o">=</span> <span class="n">sis900_set_wol</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	mii_ioctl - process MII i/o control command</span>
<span class="cm"> *	@net_dev: the net device to command for</span>
<span class="cm"> *	@rq: parameter for command</span>
<span class="cm"> *	@cmd: the i/o command</span>
<span class="cm"> *</span>
<span class="cm"> *	Process MII command like read/write MII register</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mii_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mii_ioctl_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:		<span class="cm">/* Get address of MII PHY in use. */</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">;</span>
		<span class="cm">/* Fall Through */</span>

	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:		<span class="cm">/* Read MII PHY register. */</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:		<span class="cm">/* Write MII PHY register. */</span>
		<span class="n">mdio_write</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">val_in</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_set_config - Set media type by net_device.set_config</span>
<span class="cm"> *	@dev: the net device for media type change</span>
<span class="cm"> *	@map: ifmap passed by ifconfig</span>
<span class="cm"> *</span>
<span class="cm"> *	Set media type to 10baseT, 100baseT or 0(for auto) by ifconfig</span>
<span class="cm"> *	we support only port changes. All other runtime configuration</span>
<span class="cm"> *	changes will be ignored</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sis900_set_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifmap</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span><span class="n">mii_phy</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u_char</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we switch on the ifmap-&gt;port field. I couldn&#39;t find anything</span>
<span class="cm">		 * like a definition or standard for the values of that field.</span>
<span class="cm">		 * I think the meaning of those values is device specific. But</span>
<span class="cm">		 * since I would like to change the media type via the ifconfig</span>
<span class="cm">		 * command I use the definition from linux/netdevice.h</span>
<span class="cm">		 * (which seems to be different from the ifport(pcmcia) definition) */</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">){</span>
		<span class="k">case</span> <span class="n">IF_PORT_UNKNOWN</span>: <span class="cm">/* use auto here */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
			<span class="cm">/* we are going to change the media type, so the Link</span>
<span class="cm">			 * will be temporary down and we need to reflect that</span>
<span class="cm">			 * here. When the Link comes up again, it will be</span>
<span class="cm">			 * sensed by the sis_timer procedure, which also does</span>
<span class="cm">			 * all the rest for us */</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

			<span class="cm">/* read current state */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_CONTROL</span><span class="p">);</span>

			<span class="cm">/* enable auto negotiation and reset the negotioation</span>
<span class="cm">			 * (I don&#39;t really know what the auto negatiotiation</span>
<span class="cm">			 * reset really means, but it sounds for me right to</span>
<span class="cm">			 * do one here) */</span>
			<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span>
				   <span class="n">MII_CONTROL</span><span class="p">,</span> <span class="n">status</span> <span class="o">|</span> <span class="n">MII_CNTL_AUTO</span> <span class="o">|</span> <span class="n">MII_CNTL_RST_AUTO</span><span class="p">);</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IF_PORT_10BASET</span>: <span class="cm">/* 10BaseT */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

			<span class="cm">/* we are going to change the media type, so the Link</span>
<span class="cm">			 * will be temporary down and we need to reflect that</span>
<span class="cm">			 * here. When the Link comes up again, it will be</span>
<span class="cm">			 * sensed by the sis_timer procedure, which also does</span>
<span class="cm">			 * all the rest for us */</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

			<span class="cm">/* set Speed to 10Mbps */</span>
			<span class="cm">/* read current state */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_CONTROL</span><span class="p">);</span>

			<span class="cm">/* disable auto negotiation and force 10MBit mode*/</span>
			<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span>
				   <span class="n">MII_CONTROL</span><span class="p">,</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MII_CNTL_SPEED</span> <span class="o">|</span>
					<span class="n">MII_CNTL_AUTO</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IF_PORT_100BASET</span>: <span class="cm">/* 100BaseT */</span>
		<span class="k">case</span> <span class="n">IF_PORT_100BASETX</span>: <span class="cm">/* 100BaseTx */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

			<span class="cm">/* we are going to change the media type, so the Link</span>
<span class="cm">			 * will be temporary down and we need to reflect that</span>
<span class="cm">			 * here. When the Link comes up again, it will be</span>
<span class="cm">			 * sensed by the sis_timer procedure, which also does</span>
<span class="cm">			 * all the rest for us */</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

			<span class="cm">/* set Speed to 100Mbps */</span>
			<span class="cm">/* disable auto negotiation and enable 100MBit Mode */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">MII_CONTROL</span><span class="p">);</span>
			<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mii_phy</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">,</span>
				   <span class="n">MII_CONTROL</span><span class="p">,</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MII_CNTL_SPEED</span><span class="p">)</span> <span class="o">|</span>
				   <span class="n">MII_CNTL_SPEED</span><span class="p">);</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IF_PORT_10BASE2</span>: <span class="cm">/* 10Base2 */</span>
		<span class="k">case</span> <span class="n">IF_PORT_AUI</span>: <span class="cm">/* AUI */</span>
		<span class="k">case</span> <span class="n">IF_PORT_100BASEFX</span>: <span class="cm">/* 100BaseFx */</span>
                	<span class="cm">/* These Modes are not supported (are they?)*/</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_mcast_bitnr - compute hashtable index</span>
<span class="cm"> *	@addr: multicast address</span>
<span class="cm"> *	@revision: revision id of chip</span>
<span class="cm"> *</span>
<span class="cm"> *	SiS 900 uses the most sigificant 7 bits to index a 128 bits multicast</span>
<span class="cm"> *	hash table, which makes this function a little bit different from other drivers</span>
<span class="cm"> *	SiS 900 B0 &amp; 635 M/B uses the most significat 8 bits to index 256 bits</span>
<span class="cm"> *   	multicast hash table.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">sis900_mcast_bitnr</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">revision</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">u32</span> <span class="n">crc</span> <span class="o">=</span> <span class="n">ether_crc</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="cm">/* leave 8 or 7 most siginifant bits */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">SIS635A_900_REV</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">revision</span> <span class="o">==</span> <span class="n">SIS900B_900_REV</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">25</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	set_rx_mode - Set SiS900 receive mode</span>
<span class="cm"> *	@net_dev: the net device to be set</span>
<span class="cm"> *</span>
<span class="cm"> *	Set SiS900 receive mode for promiscuous, multicast, or broadcast mode.</span>
<span class="cm"> *	And set the appropriate multicast filter.</span>
<span class="cm"> *	Multicast hash table changes from 128 to 256 bits for 635M/B &amp; 900B0.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mc_filter</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>	<span class="cm">/* 256/128 bits multicast hash table */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">table_entries</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_mode</span><span class="p">;</span>

	<span class="cm">/* 635 Hash Table entries = 256(2^16) */</span>
	<span class="k">if</span><span class="p">((</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span> <span class="o">&gt;=</span> <span class="n">SIS635A_900_REV</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span> <span class="o">==</span> <span class="n">SIS900B_900_REV</span><span class="p">))</span>
		<span class="n">table_entries</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">table_entries</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Accept any kinds of packets */</span>
		<span class="n">rx_mode</span> <span class="o">=</span> <span class="n">RFPromiscuous</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">mc_filter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">net_dev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">multicast_filter_limit</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* too many multicast addresses or accept all multicast packet */</span>
		<span class="n">rx_mode</span> <span class="o">=</span> <span class="n">RFAAB</span> <span class="o">|</span> <span class="n">RFAAM</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">mc_filter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Accept Broadcast packet, destination address matchs our</span>
<span class="cm">		 * MAC address, use Receive Filter to reject unwanted MCAST</span>
<span class="cm">		 * packets */</span>
		<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
		<span class="n">rx_mode</span> <span class="o">=</span> <span class="n">RFAAB</span><span class="p">;</span>

		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit_nr</span><span class="p">;</span>

			<span class="n">bit_nr</span> <span class="o">=</span> <span class="n">sis900_mcast_bitnr</span><span class="p">(</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
						    <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span><span class="p">);</span>
			<span class="n">mc_filter</span><span class="p">[</span><span class="n">bit_nr</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bit_nr</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* update Multicast Hash Table in Receive Filter */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* why plus 0x04 ??, That makes the correct value for hash table. */</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">rfcr</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="mh">0x00000004</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">RFADDR_shift</span><span class="p">);</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">rfdr</span><span class="p">,</span> <span class="n">mc_filter</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">sw32</span><span class="p">(</span><span class="n">rfcr</span><span class="p">,</span> <span class="n">RFEN</span> <span class="o">|</span> <span class="n">rx_mode</span><span class="p">);</span>

	<span class="cm">/* sis900 is capable of looping back packets at MAC level for</span>
<span class="cm">	 * debugging purpose */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_LOOPBACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">cr_saved</span><span class="p">;</span>
		<span class="cm">/* We must disable Tx/Rx before setting loopback mode */</span>
		<span class="n">cr_saved</span> <span class="o">=</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cr</span><span class="p">);</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">cr_saved</span> <span class="o">|</span> <span class="n">TxDIS</span> <span class="o">|</span> <span class="n">RxDIS</span><span class="p">);</span>
		<span class="cm">/* enable loopback */</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">txcfg</span><span class="p">,</span> <span class="n">sr32</span><span class="p">(</span><span class="n">txcfg</span><span class="p">)</span> <span class="o">|</span> <span class="n">TxMLB</span><span class="p">);</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">rxcfg</span><span class="p">,</span> <span class="n">sr32</span><span class="p">(</span><span class="n">rxcfg</span><span class="p">)</span> <span class="o">|</span> <span class="n">RxATX</span><span class="p">);</span>
		<span class="cm">/* restore cr */</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">cr_saved</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_reset - Reset sis900 MAC</span>
<span class="cm"> *	@net_dev: the net device to reset</span>
<span class="cm"> *</span>
<span class="cm"> *	reset sis900 MAC and wait until finished</span>
<span class="cm"> *	reset through command register</span>
<span class="cm"> *	change backoff algorithm for 900B0 &amp; 635 M/B</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sis900_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">TxRCMP</span> <span class="o">|</span> <span class="n">RxRCMP</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sw32</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">imr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">rfcr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">RxRESET</span> <span class="o">|</span> <span class="n">TxRESET</span> <span class="o">|</span> <span class="n">RESET</span> <span class="o">|</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cr</span><span class="p">));</span>

	<span class="cm">/* Check that the chip has finished the reset. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">^=</span> <span class="n">sr32</span><span class="p">(</span><span class="n">isr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span> <span class="o">&gt;=</span> <span class="n">SIS635A_900_REV</span> <span class="o">||</span>
	    <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">chipset_rev</span> <span class="o">==</span> <span class="n">SIS900B_900_REV</span><span class="p">)</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">PESEL</span> <span class="o">|</span> <span class="n">RND_CNT</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sw32</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">PESEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sis900_remove - Remove sis900 device</span>
<span class="cm"> *	@pci_dev: the pci device to be removed</span>
<span class="cm"> *</span>
<span class="cm"> *	remove and release SiS900 net device</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">sis900_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">first_mii</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mii_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">first_mii</span><span class="p">;</span>

		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">first_mii</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">phy</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">RX_TOTAL_SIZE</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">,</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">TX_TOTAL_SIZE</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">,</span>
		<span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">);</span>
	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sis900_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">net_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="cm">/* Stop the chip&#39;s Tx and Rx Status Machine */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">RxDIS</span> <span class="o">|</span> <span class="n">TxDIS</span> <span class="o">|</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cr</span><span class="p">));</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sis900_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sis900_private</span> <span class="o">*</span><span class="n">sis_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">net_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>

	<span class="n">sis900_init_rxfilter</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">sis900_init_tx_ring</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">sis900_init_rx_ring</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">set_rx_mode</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="cm">/* Workaround for EDB */</span>
	<span class="n">sis900_set_mode</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">HW_SPEED_10_MBPS</span><span class="p">,</span> <span class="n">FDX_CAPABLE_HALF_SELECTED</span><span class="p">);</span>

	<span class="cm">/* Enable all known interrupts by setting the interrupt mask. */</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">imr</span><span class="p">,</span> <span class="n">RxSOVR</span> <span class="o">|</span> <span class="n">RxORN</span> <span class="o">|</span> <span class="n">RxERR</span> <span class="o">|</span> <span class="n">RxOK</span> <span class="o">|</span> <span class="n">TxURN</span> <span class="o">|</span> <span class="n">TxERR</span> <span class="o">|</span> <span class="n">TxIDLE</span><span class="p">);</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">RxENA</span> <span class="o">|</span> <span class="n">sr32</span><span class="p">(</span><span class="n">cr</span><span class="p">));</span>
	<span class="n">sw32</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="n">IE</span><span class="p">);</span>

	<span class="n">sis900_check_mode</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">sis_priv</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">sis900_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">SIS900_MODULE_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">sis900_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">sis900_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">sis900_remove</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">sis900_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">sis900_resume</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sis900_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* when a module, this is printed whether or not devices are found in probe */</span>
<span class="cp">#ifdef MODULE</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis900_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">sis900_cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis900_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">sis900_init_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">sis900_cleanup_module</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
