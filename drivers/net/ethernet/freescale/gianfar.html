<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › freescale › gianfar.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>gianfar.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/net/ethernet/freescale/gianfar.c</span>
<span class="cm"> *</span>
<span class="cm"> * Gianfar Ethernet Driver</span>
<span class="cm"> * This driver is designed for the non-CPM ethernet controllers</span>
<span class="cm"> * on the 85xx and 83xx family of integrated processors</span>
<span class="cm"> * Based on 8260_io/fcc_enet.c</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Andy Fleming</span>
<span class="cm"> * Maintainer: Kumar Gala</span>
<span class="cm"> * Modifier: Sandeep Gopalpet &lt;sandeep.kumar@freescale.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2002-2009, 2011 Freescale Semiconductor, Inc.</span>
<span class="cm"> * Copyright 2007 MontaVista Software, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> * under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  Gianfar:  AKA Lambda Draconis, &quot;Dragon&quot;</span>
<span class="cm"> *  RA 11 31 24.2</span>
<span class="cm"> *  Dec +69 19 52</span>
<span class="cm"> *  V 3.84</span>
<span class="cm"> *  B-V +1.62</span>
<span class="cm"> *</span>
<span class="cm"> *  Theory of operation</span>
<span class="cm"> *</span>
<span class="cm"> *  The driver is initialized through of_device. Configuration information</span>
<span class="cm"> *  is therefore conveyed through an OF-style device tree.</span>
<span class="cm"> *</span>
<span class="cm"> *  The Gianfar Ethernet Controller uses a ring of buffer</span>
<span class="cm"> *  descriptors.  The beginning is indicated by a register</span>
<span class="cm"> *  pointing to the physical address of the start of the ring.</span>
<span class="cm"> *  The end is determined by a &quot;wrap&quot; bit being set in the</span>
<span class="cm"> *  last descriptor of the ring.</span>
<span class="cm"> *</span>
<span class="cm"> *  When a packet is received, the RXF bit in the</span>
<span class="cm"> *  IEVENT register is set, triggering an interrupt when the</span>
<span class="cm"> *  corresponding bit in the IMASK register is also set (if</span>
<span class="cm"> *  interrupt coalescing is active, then the interrupt may not</span>
<span class="cm"> *  happen immediately, but will wait until either a set number</span>
<span class="cm"> *  of frames or amount of time have passed).  In NAPI, the</span>
<span class="cm"> *  interrupt handler will signal there is work to be done, and</span>
<span class="cm"> *  exit. This method will start at the last known empty</span>
<span class="cm"> *  descriptor, and process every subsequent descriptor until there</span>
<span class="cm"> *  are none left with data (NAPI will stop after a set number of</span>
<span class="cm"> *  packets to give time to other tasks, but will eventually</span>
<span class="cm"> *  process all the packets).  The data arrives inside a</span>
<span class="cm"> *  pre-allocated skb, and so after the skb is passed up to the</span>
<span class="cm"> *  stack, a new skb must be allocated, and the address field in</span>
<span class="cm"> *  the buffer descriptor must be updated to indicate this new</span>
<span class="cm"> *  skb.</span>
<span class="cm"> *</span>
<span class="cm"> *  When the kernel requests that a packet be transmitted, the</span>
<span class="cm"> *  driver starts where it left off last time, and points the</span>
<span class="cm"> *  descriptor at the buffer which was passed in.  The driver</span>
<span class="cm"> *  then informs the DMA engine that there are packets ready to</span>
<span class="cm"> *  be transmitted.  Once the controller is finished transmitting</span>
<span class="cm"> *  the packet, an interrupt may be triggered (under the same</span>
<span class="cm"> *  conditions as for reception, but depending on the TXF bit).</span>
<span class="cm"> *  The driver then cleans up the buffer.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>
<span class="cp">#define DEBUG</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/of_mdio.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/udp.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/net_tstamp.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/reg.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/phy.h&gt;</span>
<span class="cp">#include &lt;linux/phy_fixed.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/of_net.h&gt;</span>

<span class="cp">#include &quot;gianfar.h&quot;</span>
<span class="cp">#include &quot;fsl_pq_mdio.h&quot;</span>

<span class="cp">#define TX_TIMEOUT      (1*HZ)</span>

<span class="k">const</span> <span class="kt">char</span> <span class="n">gfar_driver_version</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;1.3&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">gfar_enet_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gfar_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gfar_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gfar_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gfar_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">gfar_new_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gfar_new_rxbdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_rx_q</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rxbd8</span> <span class="o">*</span><span class="n">bdp</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gfar_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gfar_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">gfar_error</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">gfar_transmit</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">gfar_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">adjust_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">init_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">init_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gfar_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gfar_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">free_skb_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gfar_set_multi</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gfar_set_hash_for_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gfar_configure_serdes</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gfar_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gfar_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="kt">int</span> <span class="n">gfar_clean_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_rx_q</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rx_work_limit</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gfar_clean_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_tx_q</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gfar_process_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">amount_pull</span><span class="p">,</span> <span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gfar_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gfar_halt_nodisable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gfar_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gfar_clear_exact_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gfar_set_mac_for_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span>
				  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gfar_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Freescale Semiconductor, Inc&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Gianfar Ethernet Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_init_rxbdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_rx_q</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rxbd8</span> <span class="o">*</span><span class="n">bdp</span><span class="p">,</span>
			    <span class="n">dma_addr_t</span> <span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">lstatus</span><span class="p">;</span>

	<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">bufPtr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">lstatus</span> <span class="o">=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">RXBD_EMPTY</span> <span class="o">|</span> <span class="n">RXBD_INTERRUPT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdp</span> <span class="o">==</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_bd_base</span> <span class="o">+</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">lstatus</span> <span class="o">|=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">RXBD_WRAP</span><span class="p">);</span>

	<span class="n">eieio</span><span class="p">();</span>

	<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">=</span> <span class="n">lstatus</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_init_bds</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar_priv_tx_q</span> <span class="o">*</span><span class="n">tx_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_priv_rx_q</span> <span class="o">*</span><span class="n">rx_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="n">txbdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rxbd8</span> <span class="o">*</span><span class="n">rxbdp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* Initialize some variables in our dev structure */</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">num_txbdfree</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">;</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">;</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">skb_curtx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">skb_dirtytx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Initialize Transmit Descriptor Ring */</span>
		<span class="n">txbdp</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">bufPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">txbdp</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Set the last descriptor in the ring to indicate wrap */</span>
		<span class="n">txbdp</span><span class="o">--</span><span class="p">;</span>
		<span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TXBD_WRAP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_bd_base</span><span class="p">;</span>
		<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">skb_currx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rxbdp</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_bd_base</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">gfar_init_rxbdp</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">rxbdp</span><span class="p">,</span>
						<span class="n">rxbdp</span><span class="o">-&gt;</span><span class="n">bufPtr</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">gfar_new_skb</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t allocate RX buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">err_rxalloc_fail</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

				<span class="n">gfar_new_rxbdp</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">rxbdp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">rxbdp</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_rxalloc_fail:</span>
	<span class="n">free_skb_resources</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_alloc_skb_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_priv_tx_q</span> <span class="o">*</span><span class="n">tx_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_priv_rx_q</span> <span class="o">*</span><span class="n">rx_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">total_tx_ring_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">total_tx_ring_size</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">total_rx_ring_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">total_rx_ring_size</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for the buffer descriptors */</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">txbd8</span><span class="p">)</span> <span class="o">*</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">total_tx_ring_size</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxbd8</span><span class="p">)</span> <span class="o">*</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">total_rx_ring_size</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">ndev</span><span class="p">,</span>
			  <span class="s">&quot;Could not allocate buffer descriptors!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_bd_dma_base</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ndev</span><span class="p">;</span>
		<span class="cm">/* enet DMA only understands physical addresses */</span>
		<span class="n">addr</span>    <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">txbd8</span><span class="p">)</span> <span class="o">*</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span>
		<span class="n">vaddr</span>   <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">txbd8</span><span class="p">)</span> <span class="o">*</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Start the rx descriptor ring where the tx ring leaves off */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_bd_base</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>
		<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_bd_dma_base</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ndev</span><span class="p">;</span>
		<span class="n">addr</span>    <span class="o">+=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rxbd8</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span>
		<span class="n">vaddr</span>   <span class="o">+=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rxbd8</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup the skbuff rings */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">)</span> <span class="o">*</span>
				  <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">ndev</span><span class="p">,</span>
				  <span class="s">&quot;Could not allocate tx_skbuff</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">)</span> <span class="o">*</span>
				  <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">ndev</span><span class="p">,</span>
				  <span class="s">&quot;Could not allocate rx_skbuff</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gfar_init_bds</span><span class="p">(</span><span class="n">ndev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cleanup:</span>
	<span class="n">free_skb_resources</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_init_tx_rx_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">baddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">baddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tbase0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="n">baddr</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">tx_bd_dma_base</span><span class="p">);</span>
		<span class="n">baddr</span>	<span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">baddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rbase0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="n">baddr</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rx_bd_dma_base</span><span class="p">);</span>
		<span class="n">baddr</span>   <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_init_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tctrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">attrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* write the tx/rx base registers */</span>
	<span class="n">gfar_init_tx_rx_base</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* Configure the coalescing support */</span>
	<span class="n">gfar_configure_coalescing</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_filer_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rctrl</span> <span class="o">|=</span> <span class="n">RCTRL_FILREN</span><span class="p">;</span>
		<span class="cm">/* Program the RIR0 reg with the required distribution */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rir0</span><span class="p">,</span> <span class="n">DEFAULT_RIR0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span>
		<span class="n">rctrl</span> <span class="o">|=</span> <span class="n">RCTRL_CHECKSUMMING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">extended_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rctrl</span> <span class="o">|=</span> <span class="n">RCTRL_EXTHASH</span><span class="p">;</span>

		<span class="n">gfar_clear_exact_match</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
		<span class="n">rctrl</span> <span class="o">|=</span> <span class="n">RCTRL_EMEN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RCTRL_PAL_MASK</span><span class="p">;</span>
		<span class="n">rctrl</span> <span class="o">|=</span> <span class="n">RCTRL_PADDING</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Insert receive time stamps into padding alignment bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RCTRL_PAL_MASK</span><span class="p">;</span>
		<span class="n">rctrl</span> <span class="o">|=</span> <span class="n">RCTRL_PADDING</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">padding</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable HW time stamping if requested from user space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwts_rx_en</span><span class="p">)</span>
		<span class="n">rctrl</span> <span class="o">|=</span> <span class="n">RCTRL_PRSDEP_INIT</span> <span class="o">|</span> <span class="n">RCTRL_TS_ENABLE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span>
		<span class="n">rctrl</span> <span class="o">|=</span> <span class="n">RCTRL_VLEX</span> <span class="o">|</span> <span class="n">RCTRL_PRSDEP_INIT</span><span class="p">;</span>

	<span class="cm">/* Init rctrl based on our settings */</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rctrl</span><span class="p">,</span> <span class="n">rctrl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_IP_CSUM</span><span class="p">)</span>
		<span class="n">tctrl</span> <span class="o">|=</span> <span class="n">TCTRL_INIT_CSUM</span><span class="p">;</span>

	<span class="n">tctrl</span> <span class="o">|=</span> <span class="n">TCTRL_TXSCHED_PRIO</span><span class="p">;</span>

	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tctrl</span><span class="p">,</span> <span class="n">tctrl</span><span class="p">);</span>

	<span class="cm">/* Set the extraction length and index */</span>
	<span class="n">attrs</span> <span class="o">=</span> <span class="n">ATTRELI_EL</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_stash_size</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">ATTRELI_EI</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_stash_index</span><span class="p">);</span>

	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">attreli</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>

	<span class="cm">/* Start with defaults, and add stashing or locking</span>
<span class="cm">	 * depending on the approprate variables */</span>
	<span class="n">attrs</span> <span class="o">=</span> <span class="n">ATTR_INIT_SETTINGS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">bd_stash_en</span><span class="p">)</span>
		<span class="n">attrs</span> <span class="o">|=</span> <span class="n">ATTR_BDSTASH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_stash_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">attrs</span> <span class="o">|=</span> <span class="n">ATTR_BUFSTASH</span><span class="p">;</span>

	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>

	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">fifo_tx_thr</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_threshold</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">fifo_tx_starve</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_starve</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">fifo_tx_starve_shutoff</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_starve_off</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">gfar_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rx_dropped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_packets</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="p">;</span>
		<span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span><span class="p">;</span>
		<span class="n">rx_dropped</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span> <span class="o">=</span> <span class="n">rx_packets</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">rx_bytes</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span> <span class="o">=</span> <span class="n">rx_dropped</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span><span class="p">;</span>
		<span class="n">tx_packets</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">tx_bytes</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span> <span class="o">=</span> <span class="n">tx_packets</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">gfar_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> <span class="o">=</span> <span class="n">gfar_enet_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">gfar_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span> <span class="o">=</span> <span class="n">gfar_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span> <span class="o">=</span> <span class="n">gfar_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_features</span> <span class="o">=</span> <span class="n">gfar_set_features</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span> <span class="o">=</span> <span class="n">gfar_set_multi</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span> <span class="o">=</span> <span class="n">gfar_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span> <span class="o">=</span> <span class="n">gfar_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span> <span class="o">=</span> <span class="n">gfar_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> <span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span> <span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span> <span class="o">=</span> <span class="n">gfar_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">lock_rx_qs</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rxlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lock_tx_qs</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">txlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unlock_rx_qs</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rxlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unlock_tx_qs</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">txlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">gfar_is_vlan_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns 1 if incoming frames use an FCB */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">gfar_uses_fcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">gfar_is_vlan_on</span><span class="p">(</span><span class="n">priv</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_TIMER</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_tx_pointers</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_rx_pointers</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmap_group_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAXGROUPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">regs</span><span class="p">)</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_napi</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_napi</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_parse_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">queue_mask</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">regs</span> <span class="o">=</span> <span class="n">of_iomap</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">regs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">interruptTransmit</span> <span class="o">=</span>
			<span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* If we aren&#39;t the FEC we have multiple interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">model</span> <span class="o">&amp;&amp;</span> <span class="n">strcasecmp</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;FEC&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">interruptReceive</span> <span class="o">=</span>
			<span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">interruptError</span> <span class="o">=</span>
			<span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">interruptTransmit</span> <span class="o">==</span> <span class="n">NO_IRQ</span> <span class="o">||</span>
		    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">interruptReceive</span>  <span class="o">==</span> <span class="n">NO_IRQ</span> <span class="o">||</span>
		    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">interruptError</span>    <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">grp_id</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">priv</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">grplock</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MQ_MG_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span>
					<span class="s">&quot;fsl,rx-bit-map&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">rx_bit_map</span> <span class="o">=</span>
			<span class="n">queue_mask</span> <span class="o">?</span>  <span class="o">*</span><span class="n">queue_mask</span> <span class="o">:</span><span class="p">(</span><span class="n">DEFAULT_MAPPING</span> <span class="o">&gt;&gt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">);</span>
		<span class="n">queue_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span>
					<span class="s">&quot;fsl,tx-bit-map&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">tx_bit_map</span> <span class="o">=</span>
			<span class="n">queue_mask</span> <span class="o">?</span> <span class="o">*</span><span class="n">queue_mask</span> <span class="o">:</span> <span class="p">(</span><span class="n">DEFAULT_MAPPING</span> <span class="o">&gt;&gt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">rx_bit_map</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">].</span><span class="n">tx_bit_map</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_of_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">**</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctype</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">stash</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">stash_len</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">stash_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_tx_qs</span><span class="p">,</span> <span class="n">num_rx_qs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">tx_queues</span><span class="p">,</span> <span class="o">*</span><span class="n">rx_queues</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span> <span class="o">||</span> <span class="o">!</span><span class="n">of_device_is_available</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* parse the num of tx and rx queues */</span>
	<span class="n">tx_queues</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;fsl,num_tx_queues&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">num_tx_qs</span> <span class="o">=</span> <span class="n">tx_queues</span> <span class="o">?</span> <span class="o">*</span><span class="n">tx_queues</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_tx_qs</span> <span class="o">&gt;</span> <span class="n">MAX_TX_QS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;num_tx_qs(=%d) greater than MAX_TX_QS(=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">num_tx_qs</span><span class="p">,</span> <span class="n">MAX_TX_QS</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Cannot do alloc_etherdev, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rx_queues</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;fsl,num_rx_queues&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">num_rx_qs</span> <span class="o">=</span> <span class="n">rx_queues</span> <span class="o">?</span> <span class="o">*</span><span class="n">rx_queues</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_rx_qs</span> <span class="o">&gt;</span> <span class="n">MAX_RX_QS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;num_rx_qs(=%d) greater than MAX_RX_QS(=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">num_rx_qs</span><span class="p">,</span> <span class="n">MAX_RX_QS</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Cannot do alloc_etherdev, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">alloc_etherdev_mq</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="p">),</span> <span class="n">num_tx_qs</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="n">num_tx_qs</span><span class="p">;</span>
	<span class="n">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">num_rx_qs</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">num_rx_qs</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="cm">/* Init Rx queue filer rule set linked list*/</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_list</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_list</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue_access</span><span class="p">);</span>

	<span class="n">model</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;model&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAXGROUPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Parse and initialize group specific information */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;fsl,etsec2&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MQ_MG_MODE</span><span class="p">;</span>
		<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">gfar_parse_group</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_grp_init</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">SQ_SG_MODE</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">gfar_parse_group</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_grp_init</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	       <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_tx_q</span><span class="p">),</span>
					    <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">tx_alloc_failed</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">qindex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">txlock</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_rx_q</span><span class="p">),</span>
					    <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">rx_alloc_failed</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">qindex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rxlock</span><span class="p">));</span>
	<span class="p">}</span>


	<span class="n">stash</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;bd-stash&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">|=</span> <span class="n">FSL_GIANFAR_DEV_HAS_BD_STASHING</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">bd_stash_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">stash_len</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;rx-stash-len&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stash_len</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_stash_size</span> <span class="o">=</span> <span class="o">*</span><span class="n">stash_len</span><span class="p">;</span>

	<span class="n">stash_idx</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;rx-stash-idx&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stash_idx</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_stash_index</span> <span class="o">=</span> <span class="o">*</span><span class="n">stash_idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stash_len</span> <span class="o">||</span> <span class="n">stash_idx</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">|=</span> <span class="n">FSL_GIANFAR_DEV_HAS_BUF_STASHING</span><span class="p">;</span>

	<span class="n">mac_addr</span> <span class="o">=</span> <span class="n">of_get_mac_address</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">model</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;TSEC&quot;</span><span class="p">))</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">=</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_GIGABIT</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_COALESCE</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_RMON</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_MULTI_INTR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">model</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;eTSEC&quot;</span><span class="p">))</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">=</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_GIGABIT</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_COALESCE</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_RMON</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_MULTI_INTR</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_PADDING</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_CSUM</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_VLAN</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_MAGIC_PACKET</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_EXTENDED_HASH</span> <span class="o">|</span>
			<span class="n">FSL_GIANFAR_DEV_HAS_TIMER</span><span class="p">;</span>

	<span class="n">ctype</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;phy-connection-type&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* We only care about rgmii-id.  The rest are autodetected */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctype</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="s">&quot;rgmii-id&quot;</span><span class="p">))</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">=</span> <span class="n">PHY_INTERFACE_MODE_RGMII_ID</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">=</span> <span class="n">PHY_INTERFACE_MODE_MII</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;fsl,magic-packet&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">|=</span> <span class="n">FSL_GIANFAR_DEV_HAS_MAGIC_PACKET</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">phy_node</span> <span class="o">=</span> <span class="n">of_parse_phandle</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;phy-handle&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Find the TBI PHY.  If it&#39;s not there, we don&#39;t support SGMII */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tbi_node</span> <span class="o">=</span> <span class="n">of_parse_phandle</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;tbi-handle&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">rx_alloc_failed:</span>
	<span class="n">free_rx_pointers</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
<span class="nl">tx_alloc_failed:</span>
	<span class="n">free_tx_pointers</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
<span class="nl">err_grp_init:</span>
	<span class="n">unmap_group_regs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_hwtstamp_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hwtstamp_config</span> <span class="n">config</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">config</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* reserved for future extensions */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">tx_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_TX_OFF</span>:
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwts_tx_en</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_TX_ON</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_TIMER</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwts_tx_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">rx_filter</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_NONE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwts_rx_en</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stop_gfar</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwts_rx_en</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">startup_gfar</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_TIMER</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwts_rx_en</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stop_gfar</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwts_rx_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">startup_gfar</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">config</span><span class="p">.</span><span class="n">rx_filter</span> <span class="o">=</span> <span class="n">HWTSTAMP_FILTER_ALL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">config</span><span class="p">))</span> <span class="o">?</span>
		<span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Ioctl MII Interface */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCSHWTSTAMP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">gfar_hwtstamp_ioctl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">phy_mii_ioctl</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">reverse_bitmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit_map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_qs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_bit_map</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">max_qs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_qs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bit_map</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
			<span class="n">new_bit_map</span> <span class="o">=</span> <span class="n">new_bit_map</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">new_bit_map</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">cluster_entry_per_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rqfar</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rqfpr</span> <span class="o">=</span> <span class="n">FPR_FILER_MASK</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rqfcr</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="n">rqfar</span><span class="o">--</span><span class="p">;</span>
	<span class="n">rqfcr</span> <span class="o">=</span> <span class="n">RQFCR_CLE</span> <span class="o">|</span> <span class="n">RQFCR_PID_MASK</span> <span class="o">|</span> <span class="n">RQFCR_CMP_EXACT</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfpr</span><span class="p">[</span><span class="n">rqfar</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfpr</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfcr</span><span class="p">[</span><span class="n">rqfar</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfcr</span><span class="p">;</span>
	<span class="n">gfar_write_filer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rqfar</span><span class="p">,</span> <span class="n">rqfcr</span><span class="p">,</span> <span class="n">rqfpr</span><span class="p">);</span>

	<span class="n">rqfar</span><span class="o">--</span><span class="p">;</span>
	<span class="n">rqfcr</span> <span class="o">=</span> <span class="n">RQFCR_CMP_NOMATCH</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfpr</span><span class="p">[</span><span class="n">rqfar</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfpr</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfcr</span><span class="p">[</span><span class="n">rqfar</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfcr</span><span class="p">;</span>
	<span class="n">gfar_write_filer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rqfar</span><span class="p">,</span> <span class="n">rqfcr</span><span class="p">,</span> <span class="n">rqfpr</span><span class="p">);</span>

	<span class="n">rqfar</span><span class="o">--</span><span class="p">;</span>
	<span class="n">rqfcr</span> <span class="o">=</span> <span class="n">RQFCR_CMP_EXACT</span> <span class="o">|</span> <span class="n">RQFCR_PID_PARSE</span> <span class="o">|</span> <span class="n">RQFCR_CLE</span> <span class="o">|</span> <span class="n">RQFCR_AND</span><span class="p">;</span>
	<span class="n">rqfpr</span> <span class="o">=</span> <span class="n">class</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfcr</span><span class="p">[</span><span class="n">rqfar</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfcr</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfpr</span><span class="p">[</span><span class="n">rqfar</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfpr</span><span class="p">;</span>
	<span class="n">gfar_write_filer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rqfar</span><span class="p">,</span> <span class="n">rqfcr</span><span class="p">,</span> <span class="n">rqfpr</span><span class="p">);</span>

	<span class="n">rqfar</span><span class="o">--</span><span class="p">;</span>
	<span class="n">rqfcr</span> <span class="o">=</span> <span class="n">RQFCR_CMP_EXACT</span> <span class="o">|</span> <span class="n">RQFCR_PID_MASK</span> <span class="o">|</span> <span class="n">RQFCR_AND</span><span class="p">;</span>
	<span class="n">rqfpr</span> <span class="o">=</span> <span class="n">class</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfcr</span><span class="p">[</span><span class="n">rqfar</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfcr</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfpr</span><span class="p">[</span><span class="n">rqfar</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfpr</span><span class="p">;</span>
	<span class="n">gfar_write_filer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rqfar</span><span class="p">,</span> <span class="n">rqfcr</span><span class="p">,</span> <span class="n">rqfpr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rqfar</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_init_filer_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rqfar</span> <span class="o">=</span> <span class="n">MAX_FILER_IDX</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rqfcr</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rqfpr</span> <span class="o">=</span> <span class="n">FPR_FILER_MASK</span><span class="p">;</span>

	<span class="cm">/* Default rule */</span>
	<span class="n">rqfcr</span> <span class="o">=</span> <span class="n">RQFCR_CMP_MATCH</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfcr</span><span class="p">[</span><span class="n">rqfar</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfcr</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfpr</span><span class="p">[</span><span class="n">rqfar</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfpr</span><span class="p">;</span>
	<span class="n">gfar_write_filer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rqfar</span><span class="p">,</span> <span class="n">rqfcr</span><span class="p">,</span> <span class="n">rqfpr</span><span class="p">);</span>

	<span class="n">rqfar</span> <span class="o">=</span> <span class="n">cluster_entry_per_class</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rqfar</span><span class="p">,</span> <span class="n">RQFPR_IPV6</span><span class="p">);</span>
	<span class="n">rqfar</span> <span class="o">=</span> <span class="n">cluster_entry_per_class</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rqfar</span><span class="p">,</span> <span class="n">RQFPR_IPV6</span> <span class="o">|</span> <span class="n">RQFPR_UDP</span><span class="p">);</span>
	<span class="n">rqfar</span> <span class="o">=</span> <span class="n">cluster_entry_per_class</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rqfar</span><span class="p">,</span> <span class="n">RQFPR_IPV6</span> <span class="o">|</span> <span class="n">RQFPR_TCP</span><span class="p">);</span>
	<span class="n">rqfar</span> <span class="o">=</span> <span class="n">cluster_entry_per_class</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rqfar</span><span class="p">,</span> <span class="n">RQFPR_IPV4</span><span class="p">);</span>
	<span class="n">rqfar</span> <span class="o">=</span> <span class="n">cluster_entry_per_class</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rqfar</span><span class="p">,</span> <span class="n">RQFPR_IPV4</span> <span class="o">|</span> <span class="n">RQFPR_UDP</span><span class="p">);</span>
	<span class="n">rqfar</span> <span class="o">=</span> <span class="n">cluster_entry_per_class</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rqfar</span><span class="p">,</span> <span class="n">RQFPR_IPV4</span> <span class="o">|</span> <span class="n">RQFPR_TCP</span><span class="p">);</span>

	<span class="cm">/* cur_filer_idx indicated the first non-masked rule */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_filer_idx</span> <span class="o">=</span> <span class="n">rqfar</span><span class="p">;</span>

	<span class="cm">/* Rest are masked rules */</span>
	<span class="n">rqfcr</span> <span class="o">=</span> <span class="n">RQFCR_CMP_NOMATCH</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rqfar</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfcr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfcr</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ftp_rqfpr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rqfpr</span><span class="p">;</span>
		<span class="n">gfar_write_filer</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rqfcr</span><span class="p">,</span> <span class="n">rqfpr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_detect_errata</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pvr</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PVR</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">svr</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_SVR</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="p">(</span><span class="n">svr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff6</span><span class="p">;</span> <span class="cm">/* w/o E suffix */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rev</span> <span class="o">=</span> <span class="n">svr</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="cm">/* MPC8313 Rev 2.0 and higher; All MPC837x */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pvr</span> <span class="o">==</span> <span class="mh">0x80850010</span> <span class="o">&amp;&amp;</span> <span class="n">mod</span> <span class="o">==</span> <span class="mh">0x80b0</span> <span class="o">&amp;&amp;</span> <span class="n">rev</span> <span class="o">&gt;=</span> <span class="mh">0x0020</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">pvr</span> <span class="o">==</span> <span class="mh">0x80861010</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mod</span> <span class="o">&amp;</span> <span class="mh">0xfff9</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80c0</span><span class="p">))</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">errata</span> <span class="o">|=</span> <span class="n">GFAR_ERRATA_74</span><span class="p">;</span>

	<span class="cm">/* MPC8313 and MPC837x all rev */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pvr</span> <span class="o">==</span> <span class="mh">0x80850010</span> <span class="o">&amp;&amp;</span> <span class="n">mod</span> <span class="o">==</span> <span class="mh">0x80b0</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">pvr</span> <span class="o">==</span> <span class="mh">0x80861010</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mod</span> <span class="o">&amp;</span> <span class="mh">0xfff9</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80c0</span><span class="p">))</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">errata</span> <span class="o">|=</span> <span class="n">GFAR_ERRATA_76</span><span class="p">;</span>

	<span class="cm">/* MPC8313 and MPC837x all rev */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pvr</span> <span class="o">==</span> <span class="mh">0x80850010</span> <span class="o">&amp;&amp;</span> <span class="n">mod</span> <span class="o">==</span> <span class="mh">0x80b0</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">pvr</span> <span class="o">==</span> <span class="mh">0x80861010</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mod</span> <span class="o">&amp;</span> <span class="mh">0xfff9</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80c0</span><span class="p">))</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">errata</span> <span class="o">|=</span> <span class="n">GFAR_ERRATA_A002</span><span class="p">;</span>

	<span class="cm">/* MPC8313 Rev &lt; 2.0, MPC8548 rev 2.0 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pvr</span> <span class="o">==</span> <span class="mh">0x80850010</span> <span class="o">&amp;&amp;</span> <span class="n">mod</span> <span class="o">==</span> <span class="mh">0x80b0</span> <span class="o">&amp;&amp;</span> <span class="n">rev</span> <span class="o">&lt;</span> <span class="mh">0x0020</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">pvr</span> <span class="o">==</span> <span class="mh">0x80210020</span> <span class="o">&amp;&amp;</span> <span class="n">mod</span> <span class="o">==</span> <span class="mh">0x8030</span> <span class="o">&amp;&amp;</span> <span class="n">rev</span> <span class="o">==</span> <span class="mh">0x0020</span><span class="p">))</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">errata</span> <span class="o">|=</span> <span class="n">GFAR_ERRATA_12</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">errata</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;enabled errata workarounds, flags: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">priv</span><span class="o">-&gt;</span><span class="n">errata</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set up the ethernet device structure, private data,</span>
<span class="cm"> * and anything else we need before we start */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tempval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">grp_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rstat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tstat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rqueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tqueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">isrg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">baddr</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">gfar_of_init</span><span class="p">(</span><span class="n">ofdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span> <span class="o">=</span> <span class="n">ofdev</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">bflock</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">,</span> <span class="n">gfar_reset_task</span><span class="p">);</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
	<span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>

	<span class="n">gfar_detect_errata</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* Stop the DMA engine now, in case it was running before */</span>
	<span class="cm">/* (The firmware could have used it, and left it running). */</span>
	<span class="n">gfar_halt</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Reset MAC layer */</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg1</span><span class="p">,</span> <span class="n">MACCFG1_SOFT_RESET</span><span class="p">);</span>

	<span class="cm">/* We need to delay at least 3 TX clocks */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="n">tempval</span> <span class="o">=</span> <span class="p">(</span><span class="n">MACCFG1_TX_FLOW</span> <span class="o">|</span> <span class="n">MACCFG1_RX_FLOW</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg1</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>

	<span class="cm">/* Initialize MACCFG2. */</span>
	<span class="n">tempval</span> <span class="o">=</span> <span class="n">MACCFG2_INIT_SETTINGS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gfar_has_errata</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">GFAR_ERRATA_74</span><span class="p">))</span>
		<span class="n">tempval</span> <span class="o">|=</span> <span class="n">MACCFG2_HUGEFRAME</span> <span class="o">|</span> <span class="n">MACCFG2_LENGTHCHECK</span><span class="p">;</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg2</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>

	<span class="cm">/* Initialize ECNTRL */</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ecntrl</span><span class="p">,</span> <span class="n">ECNTRL_INIT_SETTINGS</span><span class="p">);</span>

	<span class="cm">/* Set the dev-&gt;base_addr to the gfar reg region */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">regs</span><span class="p">;</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Fill in the dev structure */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TX_TIMEOUT</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="mi">1500</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gfar_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gfar_ethtool_ops</span><span class="p">;</span>

	<span class="cm">/* Register for napi ...We are registering NAPI for each grp */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">napi</span><span class="p">,</span> <span class="n">gfar_poll</span><span class="p">,</span> <span class="n">GFAR_DEV_WEIGHT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_CSUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">=</span> <span class="n">NETIF_F_IP_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span>
			<span class="n">NETIF_F_RXCSUM</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_IP_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span>
			<span class="n">NETIF_F_RXCSUM</span> <span class="o">|</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_VLAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_VLAN_TX</span> <span class="o">|</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_VLAN_TX</span> <span class="o">|</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_EXTENDED_HASH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">extended_hash</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_width</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr1</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr2</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr3</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr4</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr5</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr6</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr7</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr1</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr2</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr3</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr4</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr5</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr6</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr7</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">extended_hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_width</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr1</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr2</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr3</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr4</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr5</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr6</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr7</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_PADDING</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">padding</span> <span class="o">=</span> <span class="n">DEFAULT_PADDING</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">padding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_IP_CSUM</span> <span class="o">||</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_TIMER</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">needed_headroom</span> <span class="o">=</span> <span class="n">GMAC_FCB_LEN</span><span class="p">;</span>

	<span class="cm">/* Program the isrg regs only if number of grps &gt; 1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">baddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">isrg0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">isrg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_bit_map</span> <span class="o">&lt;&lt;</span> <span class="n">ISRG_SHIFT_RX</span><span class="p">);</span>
			<span class="n">isrg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_bit_map</span> <span class="o">&lt;&lt;</span> <span class="n">ISRG_SHIFT_TX</span><span class="p">);</span>
			<span class="n">gfar_write</span><span class="p">(</span><span class="n">baddr</span><span class="p">,</span> <span class="n">isrg</span><span class="p">);</span>
			<span class="n">baddr</span><span class="o">++</span><span class="p">;</span>
			<span class="n">isrg</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Need to reverse the bit maps as  bit_map&#39;s MSB is q0</span>
<span class="cm">	 * but, for_each_set_bit parses from right to left, which</span>
<span class="cm">	 * basically reverses the queue numbers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_bit_map</span> <span class="o">=</span> <span class="n">reverse_bitmap</span><span class="p">(</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_bit_map</span><span class="p">,</span> <span class="n">MAX_TX_QS</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_bit_map</span> <span class="o">=</span> <span class="n">reverse_bitmap</span><span class="p">(</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_bit_map</span><span class="p">,</span> <span class="n">MAX_RX_QS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate RSTAT, TSTAT, RQUEUE and TQUEUE values,</span>
<span class="cm">	 * also assign queues to groups */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">grp_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">grp_idx</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">grp_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">grp_idx</span><span class="p">].</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
		<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">grp_idx</span><span class="p">].</span><span class="n">rx_bit_map</span><span class="p">,</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">grp_idx</span><span class="p">].</span><span class="n">num_rx_queues</span><span class="o">++</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">grp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">grp_idx</span><span class="p">];</span>
			<span class="n">rstat</span> <span class="o">=</span> <span class="n">rstat</span> <span class="o">|</span> <span class="p">(</span><span class="n">RSTAT_CLEAR_RHALT</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">rqueue</span> <span class="o">=</span> <span class="n">rqueue</span> <span class="o">|</span> <span class="p">((</span><span class="n">RQUEUE_EN0</span> <span class="o">|</span> <span class="n">RQUEUE_EX0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">grp_idx</span><span class="p">].</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
		<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">grp_idx</span><span class="p">].</span><span class="n">tx_bit_map</span><span class="p">,</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">grp_idx</span><span class="p">].</span><span class="n">num_tx_queues</span><span class="o">++</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">grp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">grp_idx</span><span class="p">];</span>
			<span class="n">tstat</span> <span class="o">=</span> <span class="n">tstat</span> <span class="o">|</span> <span class="p">(</span><span class="n">TSTAT_CLEAR_THALT</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">tqueue</span> <span class="o">=</span> <span class="n">tqueue</span> <span class="o">|</span> <span class="p">(</span><span class="n">TQUEUE_EN0</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">grp_idx</span><span class="p">].</span><span class="n">rstat</span> <span class="o">=</span> <span class="n">rstat</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">grp_idx</span><span class="p">].</span><span class="n">tstat</span> <span class="o">=</span> <span class="n">tstat</span><span class="p">;</span>
		<span class="n">rstat</span> <span class="o">=</span> <span class="n">tstat</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rqueue</span><span class="p">,</span> <span class="n">rqueue</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tqueue</span><span class="p">,</span> <span class="n">tqueue</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span> <span class="o">=</span> <span class="n">DEFAULT_RX_BUFFER_SIZE</span><span class="p">;</span>

	<span class="cm">/* Initializing some of the rx/tx queue level parameters */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span> <span class="o">=</span> <span class="n">DEFAULT_TX_RING_SIZE</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_txbdfree</span> <span class="o">=</span> <span class="n">DEFAULT_TX_RING_SIZE</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">txcoalescing</span> <span class="o">=</span> <span class="n">DEFAULT_TX_COALESCE</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">txic</span> <span class="o">=</span> <span class="n">DEFAULT_TXIC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">=</span> <span class="n">DEFAULT_RX_RING_SIZE</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rxcoalescing</span> <span class="o">=</span> <span class="n">DEFAULT_RX_COALESCE</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rxic</span> <span class="o">=</span> <span class="n">DEFAULT_RXIC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* always enable rx filer*/</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_filer_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Enable most messages by default */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="p">(</span><span class="n">NETIF_MSG_IFUP</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Carrier starts down, phylib will bring it up */</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Cannot register net device, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">register_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">device_init_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_MAGIC_PACKET</span><span class="p">);</span>

	<span class="cm">/* fill out IRQ number and name fields */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_MULTI_INTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">int_name_tx</span><span class="p">,</span> <span class="s">&quot;%s%s%c%s&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;_g&quot;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="s">&quot;_tx&quot;</span><span class="p">);</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">int_name_rx</span><span class="p">,</span> <span class="s">&quot;%s%s%c%s&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;_g&quot;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="s">&quot;_rx&quot;</span><span class="p">);</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">int_name_er</span><span class="p">,</span> <span class="s">&quot;%s%s%c%s&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;_g&quot;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="s">&quot;_er&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">int_name_tx</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the filer table */</span>
	<span class="n">gfar_init_filer_table</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* Create all the sysfs files */</span>
	<span class="n">gfar_init_sysfs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Print out the device info */</span>
	<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;mac: %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="cm">/* Even more device info helps when determining which kernel */</span>
	<span class="cm">/* provided which set of benchmarks. */</span>
	<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Running with NAPI enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RX BD ring size for Q[%d]: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">i</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX BD ring size for Q[%d]: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">i</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">register_fail:</span>
	<span class="n">unmap_group_regs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">free_tx_pointers</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">free_rx_pointers</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phy_node</span><span class="p">)</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phy_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tbi_node</span><span class="p">)</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tbi_node</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phy_node</span><span class="p">)</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phy_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tbi_node</span><span class="p">)</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tbi_node</span><span class="p">);</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">unmap_group_regs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tempval</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">magic_packet</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">wol_en</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_MAGIC_PACKET</span><span class="p">);</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">ndev</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">lock_tx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="n">lock_rx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

		<span class="n">gfar_halt_nodisable</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

		<span class="cm">/* Disable Tx, and Rx if wake-on-LAN is disabled. */</span>
		<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg1</span><span class="p">);</span>

		<span class="n">tempval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MACCFG1_TX_EN</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">magic_packet</span><span class="p">)</span>
			<span class="n">tempval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MACCFG1_RX_EN</span><span class="p">;</span>

		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg1</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>

		<span class="n">unlock_rx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="n">unlock_tx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">disable_napi</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">magic_packet</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Enable interrupt on Magic Packet */</span>
			<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">,</span> <span class="n">IMASK_MAG</span><span class="p">);</span>

			<span class="cm">/* Enable Magic Packet mode */</span>
			<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg2</span><span class="p">);</span>
			<span class="n">tempval</span> <span class="o">|=</span> <span class="n">MACCFG2_MPEN</span><span class="p">;</span>
			<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg2</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">phy_stop</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tempval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">magic_packet</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">wol_en</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_MAGIC_PACKET</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">ndev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">magic_packet</span> <span class="o">&amp;&amp;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">)</span>
		<span class="n">phy_start</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">);</span>

	<span class="cm">/* Disable Magic Packet mode, in case something</span>
<span class="cm">	 * else woke us up.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">lock_tx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">lock_rx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg2</span><span class="p">);</span>
	<span class="n">tempval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MACCFG2_MPEN</span><span class="p">;</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg2</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>

	<span class="n">gfar_start</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="n">unlock_rx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">unlock_tx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="n">enable_napi</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">ndev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">gfar_init_bds</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">init_registers</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">gfar_set_mac_address</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">gfar_init_mac</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">gfar_start</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldspeed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldduplex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">)</span>
		<span class="n">phy_start</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">);</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">enable_napi</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">gfar_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">gfar_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">gfar_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze</span> <span class="o">=</span> <span class="n">gfar_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span> <span class="o">=</span> <span class="n">gfar_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore</span> <span class="o">=</span> <span class="n">gfar_restore</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define GFAR_PM_OPS (&amp;gfar_pm_ops)</span>

<span class="cp">#else</span>

<span class="cp">#define GFAR_PM_OPS NULL</span>

<span class="cp">#endif</span>

<span class="cm">/* Reads the controller&#39;s registers to determine what interface</span>
<span class="cm"> * connects it to the PHY.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">phy_interface_t</span> <span class="nf">gfar_get_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ecntrl</span><span class="p">;</span>

	<span class="n">ecntrl</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ecntrl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ecntrl</span> <span class="o">&amp;</span> <span class="n">ECNTRL_SGMII_MODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PHY_INTERFACE_MODE_SGMII</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ecntrl</span> <span class="o">&amp;</span> <span class="n">ECNTRL_TBI_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecntrl</span> <span class="o">&amp;</span> <span class="n">ECNTRL_REDUCED_MODE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">PHY_INTERFACE_MODE_RTBI</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">PHY_INTERFACE_MODE_TBI</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ecntrl</span> <span class="o">&amp;</span> <span class="n">ECNTRL_REDUCED_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecntrl</span> <span class="o">&amp;</span> <span class="n">ECNTRL_REDUCED_MII_MODE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">PHY_INTERFACE_MODE_RMII</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">phy_interface_t</span> <span class="n">interface</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * This isn&#39;t autodetected right now, so it must</span>
<span class="cm">			 * be set by the device tree or platform code.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">interface</span> <span class="o">==</span> <span class="n">PHY_INTERFACE_MODE_RGMII_ID</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">PHY_INTERFACE_MODE_RGMII_ID</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">PHY_INTERFACE_MODE_RGMII</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_GIGABIT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PHY_INTERFACE_MODE_GMII</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">PHY_INTERFACE_MODE_MII</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Initializes driver&#39;s PHY state, and attaches to the PHY.</span>
<span class="cm"> * Returns 0 on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">uint</span> <span class="n">gigabit_support</span> <span class="o">=</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_GIGABIT</span> <span class="o">?</span>
		<span class="n">SUPPORTED_1000baseT_Full</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phy_interface_t</span> <span class="n">interface</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldspeed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldduplex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">interface</span> <span class="o">=</span> <span class="n">gfar_get_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">of_phy_connect</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">phy_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adjust_link</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="n">interface</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">of_phy_connect_fixed_link</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adjust_link</span><span class="p">,</span>
							 <span class="n">interface</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not attach to PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interface</span> <span class="o">==</span> <span class="n">PHY_INTERFACE_MODE_SGMII</span><span class="p">)</span>
		<span class="n">gfar_configure_serdes</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Remove any features not supported by the controller */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">GFAR_SUPPORTED</span> <span class="o">|</span> <span class="n">gigabit_support</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">supported</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize TBI PHY interface for communicating with the</span>
<span class="cm"> * SERDES lynx PHY on the chip.  We communicate with this PHY</span>
<span class="cm"> * through the MDIO bus on each controller, treating it as a</span>
<span class="cm"> * &quot;normal&quot; PHY at the address found in the TBIPA register.  We assume</span>
<span class="cm"> * that the TBIPA register is valid.  Either the MDIO bus code will set</span>
<span class="cm"> * it to a value that doesn&#39;t conflict with other PHYs on the bus, or the</span>
<span class="cm"> * value doesn&#39;t matter, as there are no other PHYs on the bus.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_configure_serdes</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">tbiphy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tbi_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error: SGMII mode requires that the &quot;</span>
				    <span class="s">&quot;device tree specify a tbi-handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tbiphy</span> <span class="o">=</span> <span class="n">of_phy_find_device</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tbi_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbiphy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error: Could not get TBI device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the link is already up, we must already be ok, and don&#39;t need to</span>
<span class="cm">	 * configure and reset the TBI&lt;-&gt;SerDes link.  Maybe U-Boot configured</span>
<span class="cm">	 * everything for us?  Resetting it takes the link down and requires</span>
<span class="cm">	 * several seconds for it to come back.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy_read</span><span class="p">(</span><span class="n">tbiphy</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BMSR_LSTATUS</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Single clk mode, mii mode off(for serdes communication) */</span>
	<span class="n">phy_write</span><span class="p">(</span><span class="n">tbiphy</span><span class="p">,</span> <span class="n">MII_TBICON</span><span class="p">,</span> <span class="n">TBICON_CLK_SELECT</span><span class="p">);</span>

	<span class="n">phy_write</span><span class="p">(</span><span class="n">tbiphy</span><span class="p">,</span> <span class="n">MII_ADVERTISE</span><span class="p">,</span>
			<span class="n">ADVERTISE_1000XFULL</span> <span class="o">|</span> <span class="n">ADVERTISE_1000XPAUSE</span> <span class="o">|</span>
			<span class="n">ADVERTISE_1000XPSE_ASYM</span><span class="p">);</span>

	<span class="n">phy_write</span><span class="p">(</span><span class="n">tbiphy</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">BMCR_ANENABLE</span> <span class="o">|</span>
			<span class="n">BMCR_ANRESTART</span> <span class="o">|</span> <span class="n">BMCR_FULLDPLX</span> <span class="o">|</span> <span class="n">BMCR_SPEED1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
		<span class="cm">/* Clear IEVENT */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ievent</span><span class="p">,</span> <span class="n">IEVENT_INIT_CLEAR</span><span class="p">);</span>

		<span class="cm">/* Initialize IMASK */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">,</span> <span class="n">IMASK_INIT_CLEAR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="cm">/* Init hash registers to zero */</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr7</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr7</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Zero out the rmon mib registers if it has them */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_RMON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset_io</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rmon</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rmon_mib</span><span class="p">));</span>

		<span class="cm">/* Mask off the CAM interrupts */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rmon</span><span class="p">.</span><span class="n">cam1</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rmon</span><span class="p">.</span><span class="n">cam2</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the max receive buffer length */</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mrblr</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span><span class="p">);</span>

	<span class="cm">/* Initialize the Minimum Frame Length Register */</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">minflr</span><span class="p">,</span> <span class="n">MINFLR_INIT_SETTINGS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__gfar_is_rx_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Normaly TSEC should not hang on GRS commands, so we should</span>
<span class="cm">	 * actually wait for IEVENT_GRSC flag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">gfar_has_errata</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">GFAR_ERRATA_A002</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the eTSEC register at offset 0xD1C. If bits 7-14 are</span>
<span class="cm">	 * the same as bits 23-30, the eTSEC Rx is assumed to be idle</span>
<span class="cm">	 * and the Rx can be safely reset.</span>
<span class="cm">	 */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">((</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span> <span class="o">+</span> <span class="mh">0xd1c</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">&amp;=</span> <span class="mh">0x7f807f80</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">res</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Halt the receive and transmit queues */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_halt_nodisable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tempval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
		<span class="cm">/* Mask all interrupts */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">,</span> <span class="n">IMASK_INIT_CLEAR</span><span class="p">);</span>

		<span class="cm">/* Clear all interrupts */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ievent</span><span class="p">,</span> <span class="n">IEVENT_INIT_CLEAR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="cm">/* Stop the DMA, and wait for it to stop */</span>
	<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">dmactrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tempval</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DMACTRL_GRS</span> <span class="o">|</span> <span class="n">DMACTRL_GTS</span><span class="p">))</span>
	    <span class="o">!=</span> <span class="p">(</span><span class="n">DMACTRL_GRS</span> <span class="o">|</span> <span class="n">DMACTRL_GTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">tempval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DMACTRL_GRS</span> <span class="o">|</span> <span class="n">DMACTRL_GTS</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">dmactrl</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">spin_event_timeout</span><span class="p">(((</span><span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ievent</span><span class="p">)</span> <span class="o">&amp;</span>
				 <span class="p">(</span><span class="n">IEVENT_GRSC</span> <span class="o">|</span> <span class="n">IEVENT_GTSC</span><span class="p">))</span> <span class="o">==</span>
				 <span class="p">(</span><span class="n">IEVENT_GRSC</span> <span class="o">|</span> <span class="n">IEVENT_GTSC</span><span class="p">)),</span> <span class="mi">1000000</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ievent</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IEVENT_GRSC</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">__gfar_is_rx_idle</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Halt the receive and transmit queues */</span>
<span class="kt">void</span> <span class="nf">gfar_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tempval</span><span class="p">;</span>

	<span class="n">gfar_halt_nodisable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Disable Rx and Tx */</span>
	<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg1</span><span class="p">);</span>
	<span class="n">tempval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MACCFG1_RX_EN</span> <span class="o">|</span> <span class="n">MACCFG1_TX_EN</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg1</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_grp_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_grp</span> <span class="o">*</span><span class="n">grp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptError</span><span class="p">,</span> <span class="n">grp</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptTransmit</span><span class="p">,</span> <span class="n">grp</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptReceive</span><span class="p">,</span> <span class="n">grp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">stop_gfar</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">phy_stop</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">);</span>


	<span class="cm">/* Lock it down */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">lock_tx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">lock_rx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">gfar_halt</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">unlock_rx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">unlock_tx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Free the IRQs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_MULTI_INTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">free_grp_irqs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">interruptTransmit</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">free_skb_resources</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_skb_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_tx_q</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="n">txbdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">txbdp</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">bufPtr</span><span class="p">,</span>
				<span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
				<span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">txbdp</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">bufPtr</span><span class="p">,</span>
					<span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">txbdp</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_skb_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_rx_q</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rxbd8</span> <span class="o">*</span><span class="n">rxbdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rxbdp</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_bd_base</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">rxbdp</span><span class="o">-&gt;</span><span class="n">bufPtr</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span><span class="p">,</span>
					<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rxbdp</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rxbdp</span><span class="o">-&gt;</span><span class="n">bufPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rxbdp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* If there are any tx skbs or rx skbs still around, free them.</span>
<span class="cm"> * Then free tx_skbuff and rx_skbuff */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_skb_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_priv_tx_q</span> <span class="o">*</span><span class="n">tx_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_priv_rx_q</span> <span class="o">*</span><span class="n">rx_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Go through all the buffer descriptors and free their data buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
		<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">qindex</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">)</span>
			<span class="n">free_skb_tx_queue</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>
		<span class="n">netdev_tx_reset_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">)</span>
			<span class="n">free_skb_rx_queue</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">txbd8</span><span class="p">)</span> <span class="o">*</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">total_tx_ring_size</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxbd8</span><span class="p">)</span> <span class="o">*</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">total_rx_ring_size</span><span class="p">,</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">,</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">tx_bd_dma_base</span><span class="p">);</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_recycle</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gfar_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tempval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Enable Rx and Tx in MACCFG1 */</span>
	<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg1</span><span class="p">);</span>
	<span class="n">tempval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">MACCFG1_RX_EN</span> <span class="o">|</span> <span class="n">MACCFG1_TX_EN</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg1</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>

	<span class="cm">/* Initialize DMACTRL to have WWR and WOP */</span>
	<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">dmactrl</span><span class="p">);</span>
	<span class="n">tempval</span> <span class="o">|=</span> <span class="n">DMACTRL_INIT_SETTINGS</span><span class="p">;</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">dmactrl</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>

	<span class="cm">/* Make sure we aren&#39;t stopped */</span>
	<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">dmactrl</span><span class="p">);</span>
	<span class="n">tempval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DMACTRL_GRS</span> <span class="o">|</span> <span class="n">DMACTRL_GTS</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">dmactrl</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
		<span class="cm">/* Clear THLT/RHLT, so that the DMA starts polling now */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tstat</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tstat</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rstat</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rstat</span><span class="p">);</span>
		<span class="cm">/* Unmask the interrupts we look for */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">,</span> <span class="n">IMASK_DEFAULT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gfar_configure_coalescing</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tx_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">baddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Backward compatible case ---- even if we enable</span>
<span class="cm">	 * multiple queues, there&#39;s only single reg to program</span>
<span class="cm">	 */</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txic</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">txcoalescing</span><span class="p">))</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txic</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">txic</span><span class="p">);</span>

	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxic</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rxcoalescing</span><span class="p">))</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxic</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rxic</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MQ_MG_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">baddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txic0</span><span class="p">;</span>
		<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_mask</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gfar_write</span><span class="p">(</span><span class="n">baddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">txcoalescing</span><span class="p">))</span>
				<span class="n">gfar_write</span><span class="p">(</span><span class="n">baddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">txic</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">baddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxic0</span><span class="p">;</span>
		<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_mask</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gfar_write</span><span class="p">(</span><span class="n">baddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rxcoalescing</span><span class="p">))</span>
				<span class="n">gfar_write</span><span class="p">(</span><span class="n">baddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rxic</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">register_grp_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_grp</span> <span class="o">*</span><span class="n">grp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">grp</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* If the device has multiple interrupts, register for</span>
<span class="cm">	 * them.  Otherwise, only register for the one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_MULTI_INTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Install our interrupt handlers for Error,</span>
<span class="cm">		 * Transmit, and Receive */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptError</span><span class="p">,</span> <span class="n">gfar_error</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">grp</span><span class="o">-&gt;</span><span class="n">int_name_er</span><span class="p">,</span><span class="n">grp</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptError</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">err_irq_fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptTransmit</span><span class="p">,</span> <span class="n">gfar_transmit</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="n">grp</span><span class="o">-&gt;</span><span class="n">int_name_tx</span><span class="p">,</span> <span class="n">grp</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptTransmit</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">tx_irq_fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptReceive</span><span class="p">,</span> <span class="n">gfar_receive</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">grp</span><span class="o">-&gt;</span><span class="n">int_name_rx</span><span class="p">,</span> <span class="n">grp</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptReceive</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">rx_irq_fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptTransmit</span><span class="p">,</span> <span class="n">gfar_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">grp</span><span class="o">-&gt;</span><span class="n">int_name_tx</span><span class="p">,</span> <span class="n">grp</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptTransmit</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_irq_fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">rx_irq_fail:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptTransmit</span><span class="p">,</span> <span class="n">grp</span><span class="p">);</span>
<span class="nl">tx_irq_fail:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">interruptError</span><span class="p">,</span> <span class="n">grp</span><span class="p">);</span>
<span class="nl">err_irq_fail:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/* Bring the controller up and running */</span>
<span class="kt">int</span> <span class="nf">startup_gfar</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">,</span> <span class="n">IMASK_INIT_CLEAR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">regs</span><span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">gfar_alloc_skb_resources</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">gfar_init_mac</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">register_grp_irqs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">free_grp_irqs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
			<span class="k">goto</span> <span class="n">irq_fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Start the controller */</span>
	<span class="n">gfar_start</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="n">phy_start</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">);</span>

	<span class="n">gfar_configure_coalescing</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">irq_fail:</span>
	<span class="n">free_skb_resources</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called when something needs to use the ethernet device */</span>
<span class="cm">/* Returns 0 for success. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_enet_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">enable_napi</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_recycle</span><span class="p">);</span>

	<span class="cm">/* Initialize a bunch of registers */</span>
	<span class="n">init_registers</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">gfar_set_mac_address</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">init_phy</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">disable_napi</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">startup_gfar</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">disable_napi</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netif_tx_start_all_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">device_set_wakeup_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">wol_en</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">txfcb</span> <span class="o">*</span><span class="nf">gfar_add_fcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">txfcb</span> <span class="o">*</span><span class="n">fcb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">txfcb</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GMAC_FCB_LEN</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">fcb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GMAC_FCB_LEN</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fcb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gfar_tx_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">txfcb</span> <span class="o">*</span><span class="n">fcb</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">fcb_length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If we&#39;re here, it&#39;s a IP packet with a TCP or UDP</span>
<span class="cm">	 * payload.  We set it to checksum, using a pseudo-header</span>
<span class="cm">	 * we provide</span>
<span class="cm">	 */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">TXFCB_DEFAULT</span><span class="p">;</span>

	<span class="cm">/* Tell the controller what the protocol is */</span>
	<span class="cm">/* And provide the already calculated phcs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">TXFCB_UDP</span><span class="p">;</span>
		<span class="n">fcb</span><span class="o">-&gt;</span><span class="n">phcs</span> <span class="o">=</span> <span class="n">udp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">fcb</span><span class="o">-&gt;</span><span class="n">phcs</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">;</span>

	<span class="cm">/* l3os is the distance between the start of the</span>
<span class="cm">	 * frame (skb-&gt;data) and the start of the IP hdr.</span>
<span class="cm">	 * l4os is the distance between the start of the</span>
<span class="cm">	 * l3 hdr and the l4 hdr */</span>
	<span class="n">fcb</span><span class="o">-&gt;</span><span class="n">l3os</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">fcb_length</span><span class="p">);</span>
	<span class="n">fcb</span><span class="o">-&gt;</span><span class="n">l4os</span> <span class="o">=</span> <span class="n">skb_network_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">fcb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="kr">inline</span> <span class="nf">gfar_tx_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">txfcb</span> <span class="o">*</span><span class="n">fcb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fcb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TXFCB_VLN</span><span class="p">;</span>
	<span class="n">fcb</span><span class="o">-&gt;</span><span class="n">vlctl</span> <span class="o">=</span> <span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="nf">skip_txbd</span><span class="p">(</span><span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="n">bdp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stride</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="n">new_bd</span> <span class="o">=</span> <span class="n">bdp</span> <span class="o">+</span> <span class="n">stride</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">new_bd</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">ring_size</span><span class="p">))</span> <span class="o">?</span> <span class="p">(</span><span class="n">new_bd</span> <span class="o">-</span> <span class="n">ring_size</span><span class="p">)</span> <span class="o">:</span> <span class="n">new_bd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="nf">next_txbd</span><span class="p">(</span><span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="n">bdp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">ring_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skip_txbd</span><span class="p">(</span><span class="n">bdp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">ring_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is called by the kernel when a frame is ready for transmission. */</span>
<span class="cm">/* It is pointed to by the dev-&gt;hard_start_xmit function pointer */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar_priv_tx_q</span> <span class="o">*</span><span class="n">tx_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">txfcb</span> <span class="o">*</span><span class="n">fcb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="n">txbdp</span><span class="p">,</span> <span class="o">*</span><span class="n">txbdp_start</span><span class="p">,</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">txbdp_tstamp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lstatus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">do_tstamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bufaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_frags</span><span class="p">,</span> <span class="n">nr_txbds</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">fcb_length</span> <span class="o">=</span> <span class="n">GMAC_FCB_LEN</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TOE=1 frames larger than 2500 bytes may see excess delays</span>
<span class="cm">	 * before start of transmission.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">gfar_has_errata</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">GFAR_ERRATA_76</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span> <span class="o">&amp;&amp;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">2500</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">skb_checksum_help</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span><span class="p">;</span>
	<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">rq</span><span class="p">];</span>
	<span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">;</span>
	<span class="n">regs</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>

	<span class="cm">/* check if time stamp should be generated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_HW_TSTAMP</span> <span class="o">&amp;&amp;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwts_tx_en</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">do_tstamp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">fcb_length</span> <span class="o">=</span> <span class="n">GMAC_FCB_LEN</span> <span class="o">+</span> <span class="n">GMAC_TXPAL_LEN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* make space for additional header when fcb is needed */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">unlikely</span><span class="p">(</span><span class="n">do_tstamp</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fcb_length</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_new</span><span class="p">;</span>

		<span class="n">skb_new</span> <span class="o">=</span> <span class="n">skb_realloc_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fcb_length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_new</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Steal sock reference for processing TX time stamps */</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">skb_new</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">skb_new</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_new</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* total number of fragments in the SKB */</span>
	<span class="n">nr_frags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>

	<span class="cm">/* calculate the required number of TxBDs for this skb */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">do_tstamp</span><span class="p">))</span>
		<span class="n">nr_txbds</span> <span class="o">=</span> <span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">nr_txbds</span> <span class="o">=</span> <span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* check if there is space to queue this packet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_txbds</span> <span class="o">&gt;</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">num_txbdfree</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no space, stop the queue */</span>
		<span class="n">netif_tx_stop_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update transmit stats */</span>
	<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>

	<span class="n">txbdp</span> <span class="o">=</span> <span class="n">txbdp_start</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">;</span>
	<span class="n">lstatus</span> <span class="o">=</span> <span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">lstatus</span><span class="p">;</span>

	<span class="cm">/* Time stamp insertion requires one additional TxBD */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">do_tstamp</span><span class="p">))</span>
		<span class="n">txbdp_tstamp</span> <span class="o">=</span> <span class="n">txbdp</span> <span class="o">=</span> <span class="n">next_txbd</span><span class="p">(</span><span class="n">txbdp</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span>
				<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_frags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">do_tstamp</span><span class="p">))</span>
			<span class="n">txbdp_tstamp</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">|=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_LAST</span> <span class="o">|</span>
					<span class="n">TXBD_INTERRUPT</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lstatus</span> <span class="o">|=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_LAST</span> <span class="o">|</span> <span class="n">TXBD_INTERRUPT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Place the fragment addresses and lengths into the TxBDs */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Point at the next BD, wrapping as needed */</span>
			<span class="n">txbdp</span> <span class="o">=</span> <span class="n">next_txbd</span><span class="p">(</span><span class="n">txbdp</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">);</span>

			<span class="n">length</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>

			<span class="n">lstatus</span> <span class="o">=</span> <span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">|</span> <span class="n">length</span> <span class="o">|</span>
				<span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_READY</span><span class="p">);</span>

			<span class="cm">/* Handle the last BD specially */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nr_frags</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">lstatus</span> <span class="o">|=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_LAST</span> <span class="o">|</span> <span class="n">TXBD_INTERRUPT</span><span class="p">);</span>

			<span class="n">bufaddr</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						   <span class="mi">0</span><span class="p">,</span>
						   <span class="n">length</span><span class="p">,</span>
						   <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

			<span class="cm">/* set the TxBD length and buffer pointer */</span>
			<span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">bufPtr</span> <span class="o">=</span> <span class="n">bufaddr</span><span class="p">;</span>
			<span class="n">txbdp</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">=</span> <span class="n">lstatus</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lstatus</span> <span class="o">=</span> <span class="n">txbdp_start</span><span class="o">-&gt;</span><span class="n">lstatus</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Add TxPAL between FCB and frame if required */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">do_tstamp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GMAC_TXPAL_LEN</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GMAC_TXPAL_LEN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set up checksumming */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CHECKSUM_PARTIAL</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fcb</span> <span class="o">=</span> <span class="n">gfar_add_fcb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="cm">/* as specified by errata */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">gfar_has_errata</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">GFAR_ERRATA_12</span><span class="p">)</span>
			     <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fcb</span> <span class="o">%</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x18</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GMAC_FCB_LEN</span><span class="p">);</span>
			<span class="n">skb_checksum_help</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lstatus</span> <span class="o">|=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_TOE</span><span class="p">);</span>
			<span class="n">gfar_tx_checksum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fcb</span><span class="p">,</span> <span class="n">fcb_length</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">fcb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fcb</span> <span class="o">=</span> <span class="n">gfar_add_fcb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">lstatus</span> <span class="o">|=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_TOE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">gfar_tx_vlan</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fcb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Setup tx hardware time stamping if requested */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">do_tstamp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">SKBTX_IN_PROGRESS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">fcb</span> <span class="o">=</span> <span class="n">gfar_add_fcb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">fcb</span><span class="o">-&gt;</span><span class="n">ptp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lstatus</span> <span class="o">|=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_TOE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">txbdp_start</span><span class="o">-&gt;</span><span class="n">bufPtr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			<span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If time stamping is requested one additional TxBD must be set up. The</span>
<span class="cm">	 * first TxBD points to the FCB and must have a data length of</span>
<span class="cm">	 * GMAC_FCB_LEN. The second TxBD points to the actual frame data with</span>
<span class="cm">	 * the full frame length.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">do_tstamp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">txbdp_tstamp</span><span class="o">-&gt;</span><span class="n">bufPtr</span> <span class="o">=</span> <span class="n">txbdp_start</span><span class="o">-&gt;</span><span class="n">bufPtr</span> <span class="o">+</span> <span class="n">fcb_length</span><span class="p">;</span>
		<span class="n">txbdp_tstamp</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">|=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_READY</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">fcb_length</span><span class="p">);</span>
		<span class="n">lstatus</span> <span class="o">|=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_CRC</span> <span class="o">|</span> <span class="n">TXBD_READY</span><span class="p">)</span> <span class="o">|</span> <span class="n">GMAC_FCB_LEN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lstatus</span> <span class="o">|=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_CRC</span> <span class="o">|</span> <span class="n">TXBD_READY</span><span class="p">)</span> <span class="o">|</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netdev_tx_sent_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can work in parallel with gfar_clean_tx_ring(), except</span>
<span class="cm">	 * when modifying num_txbdfree. Note that we didn&#39;t grab the lock</span>
<span class="cm">	 * when we were reading the num_txbdfree and checking for available</span>
<span class="cm">	 * space, that&#39;s because outside of this function it can only grow,</span>
<span class="cm">	 * and once we&#39;ve got needed space, it cannot suddenly disappear.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The lock also protects us from gfar_error(), which can modify</span>
<span class="cm">	 * regs-&gt;tstat and thus retrigger the transfers, which is why we</span>
<span class="cm">	 * also must grab the lock before setting ready bit for the first</span>
<span class="cm">	 * to be transmitted BD.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The powerpc-specific eieio() is used, as wmb() has too strong</span>
<span class="cm">	 * semantics (it requires synchronization between cacheable and</span>
<span class="cm">	 * uncacheable mappings, which eieio doesn&#39;t provide and which we</span>
<span class="cm">	 * don&#39;t need), thus requiring a more expensive sync instruction.  At</span>
<span class="cm">	 * some point, the set of architecture-independent barrier functions</span>
<span class="cm">	 * should be expanded to include weaker barriers.</span>
<span class="cm">	 */</span>
	<span class="n">eieio</span><span class="p">();</span>

	<span class="n">txbdp_start</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">=</span> <span class="n">lstatus</span><span class="p">;</span>

	<span class="n">eieio</span><span class="p">();</span> <span class="cm">/* force lstatus write before tx_skbuff */</span>

	<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">skb_curtx</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* Update the current skb pointer to the next entry we will use</span>
<span class="cm">	 * (wrapping if necessary) */</span>
	<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">skb_curtx</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">skb_curtx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">TX_RING_MOD_MASK</span><span class="p">(</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">);</span>

	<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="n">next_txbd</span><span class="p">(</span><span class="n">txbdp</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">);</span>

	<span class="cm">/* reduce TxBD free count */</span>
	<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">num_txbdfree</span> <span class="o">-=</span> <span class="p">(</span><span class="n">nr_txbds</span><span class="p">);</span>

	<span class="cm">/* If the next BD still needs to be cleaned up, then the bds</span>
<span class="cm">	   are full.  We need to tell the kernel to stop sending us stuff. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">num_txbdfree</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_tx_stop_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Tell the DMA to go go go */</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tstat</span><span class="p">,</span> <span class="n">TSTAT_CLEAR_THALT</span> <span class="o">&gt;&gt;</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">qindex</span><span class="p">);</span>

	<span class="cm">/* Unlock priv */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Stops the kernel queue, and halts the controller */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">disable_napi</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
	<span class="n">stop_gfar</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Disconnect from the PHY */</span>
	<span class="n">phy_disconnect</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">netif_tx_stop_all_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Changes the mac address if the controller is not running. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfar_set_mac_for_addr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check if rx parser should be activated */</span>
<span class="kt">void</span> <span class="nf">gfar_check_rx_parser_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tempval</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>

	<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rctrl</span><span class="p">);</span>
	<span class="cm">/* If parse is no longer required, then disable parser */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tempval</span> <span class="o">&amp;</span> <span class="n">RCTRL_REQ_PARSER</span><span class="p">)</span>
		<span class="n">tempval</span> <span class="o">|=</span> <span class="n">RCTRL_PRSDEP_INIT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tempval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RCTRL_PRSDEP_INIT</span><span class="p">;</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rctrl</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Enables and disables VLAN insertion/extraction */</span>
<span class="kt">void</span> <span class="nf">gfar_vlan_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tempval</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">lock_rx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable VLAN tag insertion */</span>
		<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tctrl</span><span class="p">);</span>
		<span class="n">tempval</span> <span class="o">|=</span> <span class="n">TCTRL_VLINS</span><span class="p">;</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tctrl</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Disable VLAN tag insertion */</span>
		<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tctrl</span><span class="p">);</span>
		<span class="n">tempval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCTRL_VLINS</span><span class="p">;</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tctrl</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable VLAN tag extraction */</span>
		<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rctrl</span><span class="p">);</span>
		<span class="n">tempval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">RCTRL_VLEX</span> <span class="o">|</span> <span class="n">RCTRL_PRSDEP_INIT</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rctrl</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Disable VLAN tag extraction */</span>
		<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rctrl</span><span class="p">);</span>
		<span class="n">tempval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RCTRL_VLEX</span><span class="p">;</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rctrl</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>

		<span class="n">gfar_check_rx_parser_mode</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">gfar_change_mtu</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>

	<span class="n">unlock_rx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tempsize</span><span class="p">,</span> <span class="n">tempval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oldsize</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frame_size</span> <span class="o">=</span> <span class="n">new_mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gfar_is_vlan_on</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span>
		<span class="n">frame_size</span> <span class="o">+=</span> <span class="n">VLAN_HLEN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">frame_size</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">frame_size</span> <span class="o">&gt;</span> <span class="n">JUMBO_FRAME_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid MTU setting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gfar_uses_fcb</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span>
		<span class="n">frame_size</span> <span class="o">+=</span> <span class="n">GMAC_FCB_LEN</span><span class="p">;</span>

	<span class="n">frame_size</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">;</span>

	<span class="n">tempsize</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">frame_size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">INCREMENTAL_BUFFER_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
	    <span class="n">INCREMENTAL_BUFFER_SIZE</span><span class="p">;</span>

	<span class="cm">/* Only stop and start the controller if it isn&#39;t already</span>
<span class="cm">	 * stopped, and we changed something */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">oldsize</span> <span class="o">!=</span> <span class="n">tempsize</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">))</span>
		<span class="n">stop_gfar</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span> <span class="o">=</span> <span class="n">tempsize</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mrblr</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span><span class="p">);</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maxfrm</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span><span class="p">);</span>

	<span class="cm">/* If the mtu is larger than the max size for standard</span>
<span class="cm">	 * ethernet frames (ie, a jumbo frame), then set maccfg2</span>
<span class="cm">	 * to allow huge frames, and to check the length */</span>
	<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span> <span class="o">&gt;</span> <span class="n">DEFAULT_RX_BUFFER_SIZE</span> <span class="o">||</span>
			<span class="n">gfar_has_errata</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">GFAR_ERRATA_74</span><span class="p">))</span>
		<span class="n">tempval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">MACCFG2_HUGEFRAME</span> <span class="o">|</span> <span class="n">MACCFG2_LENGTHCHECK</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tempval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MACCFG2_HUGEFRAME</span> <span class="o">|</span> <span class="n">MACCFG2_LENGTHCHECK</span><span class="p">);</span>

	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg2</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">oldsize</span> <span class="o">!=</span> <span class="n">tempsize</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">))</span>
		<span class="n">startup_gfar</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* gfar_reset_task gets scheduled when a packet has not been</span>
<span class="cm"> * transmitted after a set amount of time.</span>
<span class="cm"> * For now, assume that clearing out all the structures, and</span>
<span class="cm"> * starting over will fix the problem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gfar_private</span><span class="p">,</span>
			<span class="n">reset_task</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_tx_stop_all_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">stop_gfar</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">startup_gfar</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">netif_tx_start_all_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netif_tx_schedule_all</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_align_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We need the data buffer to be aligned properly.  We will reserve</span>
<span class="cm">	 * as many bytes as needed to align the data properly</span>
<span class="cm">	 */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">RXBUF_ALIGNMENT</span> <span class="o">-</span>
		<span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RXBUF_ALIGNMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/* Interrupt Handler for Transmit complete */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_clean_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_tx_q</span> <span class="o">*</span><span class="n">tx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar_priv_rx_q</span> <span class="o">*</span><span class="n">rx_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="n">bdp</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="n">lbdp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">txbd8</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skb_dirtytx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_ring_size</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr_txbds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">howmany</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tqi</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">qindex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lstatus</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">buflen</span><span class="p">;</span>

	<span class="n">rx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">tqi</span><span class="p">];</span>
	<span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tqi</span><span class="p">);</span>
	<span class="n">bdp</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">;</span>
	<span class="n">skb_dirtytx</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">skb_dirtytx</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">skb_dirtytx</span><span class="p">]))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">frags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * When time stamping, one additional TxBD must be freed.</span>
<span class="cm">		 * Also, we need to dma_unmap_single() the TxPAL.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_IN_PROGRESS</span><span class="p">))</span>
			<span class="n">nr_txbds</span> <span class="o">=</span> <span class="n">frags</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">nr_txbds</span> <span class="o">=</span> <span class="n">frags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">lbdp</span> <span class="o">=</span> <span class="n">skip_txbd</span><span class="p">(</span><span class="n">bdp</span><span class="p">,</span> <span class="n">nr_txbds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tx_ring_size</span><span class="p">);</span>

		<span class="n">lstatus</span> <span class="o">=</span> <span class="n">lbdp</span><span class="o">-&gt;</span><span class="n">lstatus</span><span class="p">;</span>

		<span class="cm">/* Only clean completed frames */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lstatus</span> <span class="o">&amp;</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_READY</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">lstatus</span> <span class="o">&amp;</span> <span class="n">BD_LENGTH_MASK</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_IN_PROGRESS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">next_txbd</span><span class="p">(</span><span class="n">bdp</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tx_ring_size</span><span class="p">);</span>
			<span class="n">buflen</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span> <span class="n">GMAC_FCB_LEN</span> <span class="o">+</span> <span class="n">GMAC_TXPAL_LEN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">buflen</span> <span class="o">=</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>

		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">bufPtr</span><span class="p">,</span>
				<span class="n">buflen</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_IN_PROGRESS</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="n">shhwtstamps</span><span class="p">;</span>
			<span class="n">u64</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x7</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shhwtstamps</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shhwtstamps</span><span class="p">));</span>
			<span class="n">shhwtstamps</span><span class="p">.</span><span class="n">hwtstamp</span> <span class="o">=</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="o">*</span><span class="n">ns</span><span class="p">);</span>
			<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GMAC_FCB_LEN</span> <span class="o">+</span> <span class="n">GMAC_TXPAL_LEN</span><span class="p">);</span>
			<span class="n">skb_tstamp_tx</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shhwtstamps</span><span class="p">);</span>
			<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">&amp;=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_WRAP</span><span class="p">);</span>
			<span class="n">bdp</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">&amp;=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_WRAP</span><span class="p">);</span>
		<span class="n">bdp</span> <span class="o">=</span> <span class="n">next_txbd</span><span class="p">(</span><span class="n">bdp</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tx_ring_size</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">bufPtr</span><span class="p">,</span>
					<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
					<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">lstatus</span> <span class="o">&amp;=</span> <span class="n">BD_LFLAG</span><span class="p">(</span><span class="n">TXBD_WRAP</span><span class="p">);</span>
			<span class="n">bdp</span> <span class="o">=</span> <span class="n">next_txbd</span><span class="p">(</span><span class="n">bdp</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tx_ring_size</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">bytes_sent</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there&#39;s room in the queue (limit it to rx_buffer_size)</span>
<span class="cm">		 * we add this skb back into the pool, if it&#39;s the right size</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_recycle</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">&amp;&amp;</span>
				<span class="n">skb_recycle_check</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span> <span class="o">+</span>
					<span class="n">RXBUF_ALIGNMENT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">gfar_align_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_recycle</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">skb_dirtytx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">skb_dirtytx</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb_dirtytx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">TX_RING_MOD_MASK</span><span class="p">(</span><span class="n">tx_ring_size</span><span class="p">);</span>

		<span class="n">howmany</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">num_txbdfree</span> <span class="o">+=</span> <span class="n">nr_txbds</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">txlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If we freed a buffer, we can restart transmission, if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_tx_queue_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">num_txbdfree</span><span class="p">)</span>
		<span class="n">netif_wake_subqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tqi</span><span class="p">);</span>

	<span class="cm">/* Update dirty indicators */</span>
	<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">skb_dirtytx</span> <span class="o">=</span> <span class="n">skb_dirtytx</span><span class="p">;</span>
	<span class="n">tx_queue</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">bdp</span><span class="p">;</span>

	<span class="n">netdev_tx_completed_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">,</span> <span class="n">howmany</span><span class="p">,</span> <span class="n">bytes_sent</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">howmany</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_schedule_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_grp</span> <span class="o">*</span><span class="n">gfargrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">grplock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">,</span> <span class="n">IMASK_RTX_DISABLED</span><span class="p">);</span>
		<span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear IEVENT, so interrupts aren&#39;t called again</span>
<span class="cm">		 * because of the packets that have already arrived.</span>
<span class="cm">		 */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ievent</span><span class="p">,</span> <span class="n">IEVENT_RTX_MASK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">grplock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/* Interrupt Handler for Transmit complete */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">gfar_transmit</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">grp_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfar_schedule_cleanup</span><span class="p">((</span><span class="k">struct</span> <span class="n">gfar_priv_grp</span> <span class="o">*</span><span class="p">)</span><span class="n">grp_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_new_rxbdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_rx_q</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rxbd8</span> <span class="o">*</span><span class="n">bdp</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dma_addr_t</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			     <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="n">gfar_init_rxbdp</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">bdp</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="nf">gfar_alloc_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span> <span class="o">+</span> <span class="n">RXBUF_ALIGNMENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">gfar_align_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="nf">gfar_new_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_recycle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">gfar_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">count_errors</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">status</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_extra_stats</span> <span class="o">*</span><span class="n">estats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">extra_stats</span><span class="p">;</span>

	<span class="cm">/* If the packet was truncated, none of the other errors</span>
<span class="cm">	 * matter */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXBD_TRUNCATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>

		<span class="n">estats</span><span class="o">-&gt;</span><span class="n">rx_trunc</span><span class="o">++</span><span class="p">;</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Count the errors, if there were any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RXBD_LARGE</span> <span class="o">|</span> <span class="n">RXBD_SHORT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXBD_LARGE</span><span class="p">)</span>
			<span class="n">estats</span><span class="o">-&gt;</span><span class="n">rx_large</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">estats</span><span class="o">-&gt;</span><span class="n">rx_short</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXBD_NONOCTET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">estats</span><span class="o">-&gt;</span><span class="n">rx_nonoctet</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXBD_CRCERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">estats</span><span class="o">-&gt;</span><span class="n">rx_crcerr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXBD_OVERRUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">estats</span><span class="o">-&gt;</span><span class="n">rx_overrun</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">gfar_receive</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">grp_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfar_schedule_cleanup</span><span class="p">((</span><span class="k">struct</span> <span class="n">gfar_priv_grp</span> <span class="o">*</span><span class="p">)</span><span class="n">grp_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gfar_rx_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rxfcb</span> <span class="o">*</span><span class="n">fcb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If valid headers were found, and valid sums</span>
<span class="cm">	 * were verified, then we tell the kernel that no</span>
<span class="cm">	 * checksumming is necessary.  Otherwise, it is */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fcb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RXFCB_CSUM_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">RXFCB_CIP</span> <span class="o">|</span> <span class="n">RXFCB_CTU</span><span class="p">))</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* gfar_process_frame() -- handle one incoming packet if skb</span>
<span class="cm"> * isn&#39;t NULL.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_process_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">amount_pull</span><span class="p">,</span> <span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rxfcb</span> <span class="o">*</span><span class="n">fcb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">gro_result_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* fcb is at the beginning if exists */</span>
	<span class="n">fcb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rxfcb</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Remove the FCB from the skb */</span>
	<span class="cm">/* Remove the padded bytes, if there are any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">amount_pull</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_record_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fcb</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">amount_pull</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Get receive timestamp from the skb */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwts_rx_en</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="o">*</span><span class="n">shhwtstamps</span> <span class="o">=</span> <span class="n">skb_hwtstamps</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">u64</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">shhwtstamps</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">shhwtstamps</span><span class="p">));</span>
		<span class="n">shhwtstamps</span><span class="o">-&gt;</span><span class="n">hwtstamp</span> <span class="o">=</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="o">*</span><span class="n">ns</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">)</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span>
		<span class="n">gfar_rx_checksum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fcb</span><span class="p">);</span>

	<span class="cm">/* Tell the skb what kind of packet this is */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * There&#39;s need to check for NETIF_F_HW_VLAN_RX here.</span>
<span class="cm">	 * Even if vlan rx accel is disabled, on some chips</span>
<span class="cm">	 * RXFCB_VLN is pseudo randomly set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span> <span class="o">&amp;&amp;</span>
	    <span class="n">fcb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RXFCB_VLN</span><span class="p">)</span>
		<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fcb</span><span class="o">-&gt;</span><span class="n">vlctl</span><span class="p">);</span>

	<span class="cm">/* Send the packet up the stack */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">napi_gro_receive</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">GRO_DROP</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">extra_stats</span><span class="p">.</span><span class="n">kernel_dropped</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* gfar_clean_rx_ring() -- Processes each frame in the rx ring</span>
<span class="cm"> *   until the budget/quota has been reached. Returns the number</span>
<span class="cm"> *   of frames handled</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gfar_clean_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfar_priv_rx_q</span> <span class="o">*</span><span class="n">rx_queue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rx_work_limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rxbd8</span> <span class="o">*</span><span class="n">bdp</span><span class="p">,</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pkt_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">amount_pull</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">howmany</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Get the first full descriptor */</span>
	<span class="n">bdp</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">;</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_bd_base</span><span class="p">;</span>

	<span class="n">amount_pull</span> <span class="o">=</span> <span class="p">(</span><span class="n">gfar_uses_fcb</span><span class="p">(</span><span class="n">priv</span><span class="p">)</span> <span class="o">?</span> <span class="n">GMAC_FCB_LEN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXBD_EMPTY</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">--</span><span class="n">rx_work_limit</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newskb</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span>

		<span class="cm">/* Add another skb for the future */</span>
		<span class="n">newskb</span> <span class="o">=</span> <span class="n">gfar_new_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">skb_currx</span><span class="p">];</span>

		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">bufPtr</span><span class="p">,</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXBD_ERR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span><span class="p">))</span>
			<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">RXBD_LARGE</span><span class="p">;</span>

		<span class="cm">/* We drop the frame if we failed to allocate a new buffer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">newskb</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXBD_LAST</span><span class="p">)</span> <span class="o">||</span>
				 <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXBD_ERR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">count_errors</span><span class="p">(</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">newskb</span><span class="p">))</span>
				<span class="n">newskb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
				<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_recycle</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Increment the number of packets */</span>
			<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">howmany</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pkt_len</span> <span class="o">=</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>
				<span class="cm">/* Remove the FCS from the packet length */</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>
				<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">pkt_len</span><span class="p">;</span>
				<span class="n">skb_record_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">qindex</span><span class="p">);</span>
				<span class="n">gfar_process_frame</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">amount_pull</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">netif_warn</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Missing skb!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">extra_stats</span><span class="p">.</span><span class="n">rx_skbmissing</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span>

		<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">skb_currx</span><span class="p">]</span> <span class="o">=</span> <span class="n">newskb</span><span class="p">;</span>

		<span class="cm">/* Setup the new bdp */</span>
		<span class="n">gfar_new_rxbdp</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">bdp</span><span class="p">,</span> <span class="n">newskb</span><span class="p">);</span>

		<span class="cm">/* Update to the next pointer */</span>
		<span class="n">bdp</span> <span class="o">=</span> <span class="n">next_bd</span><span class="p">(</span><span class="n">bdp</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">);</span>

		<span class="cm">/* update to point at the next skb */</span>
		<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">skb_currx</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">skb_currx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
		    <span class="n">RX_RING_MOD_MASK</span><span class="p">(</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Update the current rxbd pointer to be the next one */</span>
	<span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">=</span> <span class="n">bdp</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">howmany</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gfar_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_priv_grp</span> <span class="o">*</span><span class="n">gfargrp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">gfar_priv_grp</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_priv_tx_q</span> <span class="o">*</span><span class="n">tx_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_priv_rx_q</span> <span class="o">*</span><span class="n">rx_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_cleaned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">budget_per_queue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rx_cleaned_per_queue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_cleaned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">left_over_budget</span> <span class="o">=</span> <span class="n">budget</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">serviced_queues</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_queues</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">num_queues</span> <span class="o">=</span> <span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span>
	<span class="n">budget_per_queue</span> <span class="o">=</span> <span class="n">budget</span><span class="o">/</span><span class="n">num_queues</span><span class="p">;</span>

	<span class="cm">/* Clear IEVENT, so interrupts aren&#39;t called again</span>
<span class="cm">	 * because of the packets that have already arrived */</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ievent</span><span class="p">,</span> <span class="n">IEVENT_RTX_MASK</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">num_queues</span> <span class="o">&amp;&amp;</span> <span class="n">left_over_budget</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">budget_per_queue</span> <span class="o">=</span> <span class="n">left_over_budget</span><span class="o">/</span><span class="n">num_queues</span><span class="p">;</span>
		<span class="n">left_over_budget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">rx_bit_map</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serviced_queues</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">rx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">tx_queue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">rx_queue</span><span class="o">-&gt;</span><span class="n">qindex</span><span class="p">];</span>

			<span class="n">tx_cleaned</span> <span class="o">+=</span> <span class="n">gfar_clean_tx_ring</span><span class="p">(</span><span class="n">tx_queue</span><span class="p">);</span>
			<span class="n">rx_cleaned_per_queue</span> <span class="o">=</span> <span class="n">gfar_clean_rx_ring</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span>
							<span class="n">budget_per_queue</span><span class="p">);</span>
			<span class="n">rx_cleaned</span> <span class="o">+=</span> <span class="n">rx_cleaned_per_queue</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">rx_cleaned_per_queue</span> <span class="o">&lt;</span> <span class="n">budget_per_queue</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">left_over_budget</span> <span class="o">=</span> <span class="n">left_over_budget</span> <span class="o">+</span>
					<span class="p">(</span><span class="n">budget_per_queue</span> <span class="o">-</span> <span class="n">rx_cleaned_per_queue</span><span class="p">);</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serviced_queues</span><span class="p">);</span>
				<span class="n">num_queues</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_cleaned</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">budget</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rx_cleaned</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>

		<span class="cm">/* Clear the halt bit in RSTAT */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rstat</span><span class="p">,</span> <span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">rstat</span><span class="p">);</span>

		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">,</span> <span class="n">IMASK_DEFAULT</span><span class="p">);</span>

		<span class="cm">/* If we are coalescing interrupts, update the timer */</span>
		<span class="cm">/* Otherwise, clear it */</span>
		<span class="n">gfar_configure_coalescing</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
				<span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">rx_bit_map</span><span class="p">,</span> <span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">tx_bit_map</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rx_cleaned</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="cm">/*</span>
<span class="cm"> * Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<span class="cm"> * without having to re-enable interrupts. It&#39;s not called while</span>
<span class="cm"> * the interrupt routine is executing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If the device has multiple interrupts, run tx/rx */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_MULTI_INTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">disable_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">interruptTransmit</span><span class="p">);</span>
			<span class="n">disable_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">interruptReceive</span><span class="p">);</span>
			<span class="n">disable_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">interruptError</span><span class="p">);</span>
			<span class="n">gfar_interrupt</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">interruptTransmit</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">enable_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">interruptError</span><span class="p">);</span>
			<span class="n">enable_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">interruptReceive</span><span class="p">);</span>
			<span class="n">enable_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">interruptTransmit</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_grps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">disable_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">interruptTransmit</span><span class="p">);</span>
			<span class="n">gfar_interrupt</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">interruptTransmit</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">enable_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">interruptTransmit</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* The interrupt handler for devices with one interrupt */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">gfar_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">grp_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_priv_grp</span> <span class="o">*</span><span class="n">gfargrp</span> <span class="o">=</span> <span class="n">grp_id</span><span class="p">;</span>

	<span class="cm">/* Save ievent for future reference */</span>
	<span class="n">u32</span> <span class="n">events</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ievent</span><span class="p">);</span>

	<span class="cm">/* Check for reception */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_RX_MASK</span><span class="p">)</span>
		<span class="n">gfar_receive</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">grp_id</span><span class="p">);</span>

	<span class="cm">/* Check for transmit completion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_TX_MASK</span><span class="p">)</span>
		<span class="n">gfar_transmit</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">grp_id</span><span class="p">);</span>

	<span class="cm">/* Check for errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_ERR_MASK</span><span class="p">)</span>
		<span class="n">gfar_error</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">grp_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called every time the controller might need to be made</span>
<span class="cm"> * aware of new link state.  The PHY code conveys this</span>
<span class="cm"> * information through variables in the phydev structure, and this</span>
<span class="cm"> * function converts those variables into the appropriate</span>
<span class="cm"> * register values, and can bring down the device if needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">adjust_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">lock_tx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg2</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">ecntrl</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ecntrl</span><span class="p">);</span>

		<span class="cm">/* Now we make sure that we can be in full duplex mode.</span>
<span class="cm">		 * If not, we operate in half-duplex mode. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">!=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldduplex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">))</span>
				<span class="n">tempval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MACCFG2_FULL_DUPLEX</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">tempval</span> <span class="o">|=</span> <span class="n">MACCFG2_FULL_DUPLEX</span><span class="p">;</span>

			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldduplex</span> <span class="o">=</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldspeed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">1000</span>:
				<span class="n">tempval</span> <span class="o">=</span>
				    <span class="p">((</span><span class="n">tempval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MACCFG2_IF</span><span class="p">))</span> <span class="o">|</span> <span class="n">MACCFG2_GMII</span><span class="p">);</span>

				<span class="n">ecntrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ECNTRL_R100</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">100</span>:
			<span class="k">case</span> <span class="mi">10</span>:
				<span class="n">tempval</span> <span class="o">=</span>
				    <span class="p">((</span><span class="n">tempval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MACCFG2_IF</span><span class="p">))</span> <span class="o">|</span> <span class="n">MACCFG2_MII</span><span class="p">);</span>

				<span class="cm">/* Reduced mode distinguishes</span>
<span class="cm">				 * between 10 and 100 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_100</span><span class="p">)</span>
					<span class="n">ecntrl</span> <span class="o">|=</span> <span class="n">ECNTRL_R100</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">ecntrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ECNTRL_R100</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">netif_warn</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
					   <span class="s">&quot;Ack!  Speed (%d) is not 10/100/1000!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldspeed</span> <span class="o">=</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">maccfg2</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ecntrl</span><span class="p">,</span> <span class="n">ecntrl</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldlink</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldlink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldlink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldspeed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">oldduplex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">&amp;&amp;</span> <span class="n">netif_msg_link</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span>
		<span class="n">phy_print_status</span><span class="p">(</span><span class="n">phydev</span><span class="p">);</span>
	<span class="n">unlock_tx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Update the hash table based on the current list of multicast</span>
<span class="cm"> * addresses we subscribe to.  Also, change the promiscuity of</span>
<span class="cm"> * the device based on the flags (this function is called</span>
<span class="cm"> * whenever dev-&gt;flags is changed */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_set_multi</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tempval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set RCTRL to PROM */</span>
		<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rctrl</span><span class="p">);</span>
		<span class="n">tempval</span> <span class="o">|=</span> <span class="n">RCTRL_PROM</span><span class="p">;</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rctrl</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Set RCTRL to not PROM */</span>
		<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rctrl</span><span class="p">);</span>
		<span class="n">tempval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RCTRL_PROM</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rctrl</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set the hash to rx all multicast frames */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr0</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr1</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr2</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr3</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr4</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr5</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr6</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr7</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr0</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr1</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr2</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr3</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr4</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr5</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr6</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr7</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">em_num</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

		<span class="cm">/* zero out the hash */</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr1</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr2</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr3</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr4</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr5</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr6</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">igaddr7</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr1</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr2</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr3</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr4</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr5</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr6</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gaddr7</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>

		<span class="cm">/* If we have extended hash tables, we need to</span>
<span class="cm">		 * clear the exact match registers to prepare for</span>
<span class="cm">		 * setting them */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">extended_hash</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">em_num</span> <span class="o">=</span> <span class="n">GFAR_EM_NUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">gfar_clear_exact_match</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">em_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netdev_mc_empty</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/* Parse the list, and set the appropriate bits */</span>
		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">em_num</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">gfar_set_mac_for_addr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
				<span class="n">idx</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">gfar_set_hash_for_addr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Clears each of the exact match registers to zero, so they</span>
<span class="cm"> * don&#39;t interfere with normal reception */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_clear_exact_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">zero_arr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

	<span class="k">for</span><span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">GFAR_EM_NUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="n">idx</span><span class="o">++</span><span class="p">)</span>
		<span class="n">gfar_set_mac_for_addr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">zero_arr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set the appropriate hash bit for the given addr */</span>
<span class="cm">/* The algorithm works like so:</span>
<span class="cm"> * 1) Take the Destination Address (ie the multicast address), and</span>
<span class="cm"> * do a CRC on it (little endian), and reverse the bits of the</span>
<span class="cm"> * result.</span>
<span class="cm"> * 2) Use the 8 most significant bits as a hash into a 256-entry</span>
<span class="cm"> * table.  The table is controlled through 8 32-bit registers:</span>
<span class="cm"> * gaddr0-7.  gaddr0&#39;s MSB is entry 0, and gaddr7&#39;s LSB is</span>
<span class="cm"> * gaddr7.  This means that the 3 most significant bits in the</span>
<span class="cm"> * hash index which gaddr register to use, and the 5 other bits</span>
<span class="cm"> * indicate which bit (assuming an IBM numbering scheme, which</span>
<span class="cm"> * for PowerPC (tm) is usually the case) in the register holds</span>
<span class="cm"> * the entry. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_set_hash_for_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tempval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ether_crc</span><span class="p">(</span><span class="n">ETH_ALEN</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_width</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">whichbit</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">width</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">whichreg</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">width</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">31</span><span class="o">-</span><span class="n">whichbit</span><span class="p">));</span>

	<span class="n">tempval</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="n">whichreg</span><span class="p">]);</span>
	<span class="n">tempval</span> <span class="o">|=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hash_regs</span><span class="p">[</span><span class="n">whichreg</span><span class="p">],</span> <span class="n">tempval</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* There are multiple MAC Address register pairs on some controllers</span>
<span class="cm"> * This function sets the numth pair to a given address</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfar_set_mac_for_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span>
				  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">gfargrp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tmpbuf</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">tempval</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">macptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">macstnaddr1</span><span class="p">;</span>

	<span class="n">macptr</span> <span class="o">+=</span> <span class="n">num</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Now copy it into the mac registers backwards, cuz */</span>
	<span class="cm">/* little endian is silly */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">ETH_ALEN</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tmpbuf</span><span class="p">[</span><span class="n">ETH_ALEN</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="n">gfar_write</span><span class="p">(</span><span class="n">macptr</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">tmpbuf</span><span class="p">)));</span>

	<span class="n">tempval</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">tmpbuf</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>

	<span class="n">gfar_write</span><span class="p">(</span><span class="n">macptr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tempval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* GFAR error interrupt handler */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">gfar_error</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">grp_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfar_priv_grp</span> <span class="o">*</span><span class="n">gfargrp</span> <span class="o">=</span> <span class="n">grp_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gfar_private</span> <span class="o">*</span><span class="n">priv</span><span class="o">=</span> <span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

	<span class="cm">/* Save ievent for future reference */</span>
	<span class="n">u32</span> <span class="n">events</span> <span class="o">=</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ievent</span><span class="p">);</span>

	<span class="cm">/* Clear IEVENT */</span>
	<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ievent</span><span class="p">,</span> <span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_ERR_MASK</span><span class="p">);</span>

	<span class="cm">/* Magic Packet is not an error. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">device_flags</span> <span class="o">&amp;</span> <span class="n">FSL_GIANFAR_DEV_HAS_MAGIC_PACKET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_MAG</span><span class="p">))</span>
		<span class="n">events</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IEVENT_MAG</span><span class="p">;</span>

	<span class="cm">/* Hmm... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_rx_err</span><span class="p">(</span><span class="n">priv</span><span class="p">)</span> <span class="o">||</span> <span class="n">netif_msg_tx_err</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span>
		<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error interrupt (ievent=0x%08x imask=0x%08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">events</span><span class="p">,</span> <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">));</span>

	<span class="cm">/* Update the error counters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_TXE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_LC</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_CRL</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_XFUN</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				  <span class="s">&quot;TX FIFO underrun, packet dropped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">extra_stats</span><span class="p">.</span><span class="n">tx_underrun</span><span class="o">++</span><span class="p">;</span>

			<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">lock_tx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

			<span class="cm">/* Reactivate the Tx Queues */</span>
			<span class="n">gfar_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tstat</span><span class="p">,</span> <span class="n">gfargrp</span><span class="o">-&gt;</span><span class="n">tstat</span><span class="p">);</span>

			<span class="n">unlock_tx_qs</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Transmit Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_BSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">extra_stats</span><span class="p">.</span><span class="n">rx_bsy</span><span class="o">++</span><span class="p">;</span>

		<span class="n">gfar_receive</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">grp_id</span><span class="p">);</span>

		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;busy error (rstat: %x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">gfar_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rstat</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_BABR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">extra_stats</span><span class="p">.</span><span class="n">rx_babr</span><span class="o">++</span><span class="p">;</span>

		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;babbling RX error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_EBERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">extra_stats</span><span class="p">.</span><span class="n">eberr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bus error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_RXC</span><span class="p">)</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">rx_status</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;control frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">IEVENT_BABT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">extra_stats</span><span class="p">.</span><span class="n">tx_babt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;babbling TX error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">gfar_match</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;network&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;gianfar&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;fsl,etsec2&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">gfar_match</span><span class="p">);</span>

<span class="cm">/* Structure for a device driver */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">gfar_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;fsl-gianfar&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="n">GFAR_PM_OPS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">gfar_match</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">gfar_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">gfar_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">gfar_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
