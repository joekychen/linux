<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › tile › tilepro.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>tilepro.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2011 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;      </span><span class="cm">/* printk() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/slab.h&gt;        </span><span class="cm">/* kmalloc() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/errno.h&gt;       </span><span class="cm">/* error codes */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/types.h&gt;       </span><span class="cm">/* size_t */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;   </span><span class="cm">/* struct device, and other headers */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/etherdevice.h&gt; </span><span class="cm">/* eth_type_trans */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;asm/checksum.h&gt;</span>
<span class="cp">#include &lt;asm/homecache.h&gt;</span>

<span class="cp">#include &lt;hv/drv_xgbe_intf.h&gt;</span>
<span class="cp">#include &lt;hv/drv_xgbe_impl.h&gt;</span>
<span class="cp">#include &lt;hv/hypervisor.h&gt;</span>
<span class="cp">#include &lt;hv/netio_intf.h&gt;</span>

<span class="cm">/* For TSO */</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * First, &quot;tile_net_init_module()&quot; initializes all four &quot;devices&quot; which</span>
<span class="cm"> * can be used by linux.</span>
<span class="cm"> *</span>
<span class="cm"> * Then, &quot;ifconfig DEVICE up&quot; calls &quot;tile_net_open()&quot;, which analyzes</span>
<span class="cm"> * the network cpus, then uses &quot;tile_net_open_aux()&quot; to initialize</span>
<span class="cm"> * LIPP/LEPP, and then uses &quot;tile_net_open_inner()&quot; to register all</span>
<span class="cm"> * the tiles, provide buffers to LIPP, allow ingress to start, and</span>
<span class="cm"> * turn on hypervisor interrupt handling (and NAPI) on all tiles.</span>
<span class="cm"> *</span>
<span class="cm"> * If registration fails due to the link being down, then &quot;retry_work&quot;</span>
<span class="cm"> * is used to keep calling &quot;tile_net_open_inner()&quot; until it succeeds.</span>
<span class="cm"> *</span>
<span class="cm"> * If &quot;ifconfig DEVICE down&quot; is called, it uses &quot;tile_net_stop()&quot; to</span>
<span class="cm"> * stop egress, drain the LIPP buffers, unregister all the tiles, stop</span>
<span class="cm"> * LIPP/LEPP, and wipe the LEPP queue.</span>
<span class="cm"> *</span>
<span class="cm"> * We start out with the ingress interrupt enabled on each CPU.  When</span>
<span class="cm"> * this interrupt fires, we disable it, and call &quot;napi_schedule()&quot;.</span>
<span class="cm"> * This will cause &quot;tile_net_poll()&quot; to be called, which will pull</span>
<span class="cm"> * packets from the netio queue, filtering them out, or passing them</span>
<span class="cm"> * to &quot;netif_receive_skb()&quot;.  If our budget is exhausted, we will</span>
<span class="cm"> * return, knowing we will be called again later.  Otherwise, we</span>
<span class="cm"> * reenable the ingress interrupt, and call &quot;napi_complete()&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * HACK: Since disabling the ingress interrupt is not reliable, we</span>
<span class="cm"> * ignore the interrupt if the global &quot;active&quot; flag is false.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: The use of &quot;native_driver&quot; ensures that EPP exists, and that</span>
<span class="cm"> * we are using &quot;LIPP&quot; and &quot;LEPP&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Failing to free completions for an arbitrarily long time</span>
<span class="cm"> * (which is defined to be illegal) does in fact cause bizarre</span>
<span class="cm"> * problems.  The &quot;egress_timer&quot; helps prevent this from happening.</span>
<span class="cm"> */</span>


<span class="cm">/* HACK: Allow use of &quot;jumbo&quot; packets. */</span>
<span class="cm">/* This should be 1500 if &quot;jumbo&quot; is not set in LIPP. */</span>
<span class="cm">/* This should be at most 10226 (10240 - 14) if &quot;jumbo&quot; is set in LIPP. */</span>
<span class="cm">/* ISSUE: This has not been thoroughly tested (except at 1500). */</span>
<span class="cp">#define TILE_NET_MTU 1500</span>

<span class="cm">/* HACK: Define to support GSO. */</span>
<span class="cm">/* ISSUE: This may actually hurt performance of the TCP blaster. */</span>
<span class="cm">/* #define TILE_NET_GSO */</span>

<span class="cm">/* Define this to collapse &quot;duplicate&quot; acks. */</span>
<span class="cm">/* #define IGNORE_DUP_ACKS */</span>

<span class="cm">/* HACK: Define this to verify incoming packets. */</span>
<span class="cm">/* #define TILE_NET_VERIFY_INGRESS */</span>

<span class="cm">/* Use 3000 to enable the Linux Traffic Control (QoS) layer, else 0. */</span>
<span class="cp">#define TILE_NET_TX_QUEUE_LEN 0</span>

<span class="cm">/* Define to dump packets (prints out the whole packet on tx and rx). */</span>
<span class="cm">/* #define TILE_NET_DUMP_PACKETS */</span>

<span class="cm">/* Define to enable debug spew (all PDEBUG&#39;s are enabled). */</span>
<span class="cm">/* #define TILE_NET_DEBUG */</span>


<span class="cm">/* Define to activate paranoia checks. */</span>
<span class="cm">/* #define TILE_NET_PARANOIA */</span>

<span class="cm">/* Default transmit lockup timeout period, in jiffies. */</span>
<span class="cp">#define TILE_NET_TIMEOUT (5 * HZ)</span>

<span class="cm">/* Default retry interval for bringing up the NetIO interface, in jiffies. */</span>
<span class="cp">#define TILE_NET_RETRY_INTERVAL (5 * HZ)</span>

<span class="cm">/* Number of ports (xgbe0, xgbe1, gbe0, gbe1). */</span>
<span class="cp">#define TILE_NET_DEVS 4</span>



<span class="cm">/* Paranoia. */</span>
<span class="cp">#if NET_IP_ALIGN != LIPP_PACKET_PADDING</span>
<span class="cp">#error &quot;NET_IP_ALIGN must match LIPP_PACKET_PADDING.&quot;</span>
<span class="cp">#endif</span>


<span class="cm">/* Debug print. */</span>
<span class="cp">#ifdef TILE_NET_DEBUG</span>
<span class="cp">#define PDEBUG(fmt, args...) net_printk(fmt, ## args)</span>
<span class="cp">#else</span>
<span class="cp">#define PDEBUG(fmt, args...)</span>
<span class="cp">#endif</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Tilera&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Queue of incoming packets for a specific cpu and device.</span>
<span class="cm"> *</span>
<span class="cm"> * Includes a pointer to the &quot;system&quot; data, and the actual &quot;user&quot; data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tile_netio_queue</span> <span class="p">{</span>
	<span class="n">netio_queue_impl_t</span> <span class="o">*</span><span class="n">__system_part</span><span class="p">;</span>
	<span class="n">netio_queue_user_impl_t</span> <span class="n">__user_part</span><span class="p">;</span>

<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Statistics counters for a specific cpu and device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tile_net_stats_t</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">rx_packets</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_packets</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_bytes</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Info for a specific cpu and device.</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: There is a &quot;dev&quot; pointer in &quot;napi&quot; as well.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="p">{</span>
	<span class="cm">/* The NAPI struct. */</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>
	<span class="cm">/* Packet queue. */</span>
	<span class="k">struct</span> <span class="n">tile_netio_queue</span> <span class="n">queue</span><span class="p">;</span>
	<span class="cm">/* Statistics. */</span>
	<span class="k">struct</span> <span class="n">tile_net_stats_t</span> <span class="n">stats</span><span class="p">;</span>
	<span class="cm">/* True iff NAPI is enabled. */</span>
	<span class="n">bool</span> <span class="n">napi_enabled</span><span class="p">;</span>
	<span class="cm">/* True if this tile has successfully registered with the IPP. */</span>
	<span class="n">bool</span> <span class="n">registered</span><span class="p">;</span>
	<span class="cm">/* True if the link was down last time we tried to register. */</span>
	<span class="n">bool</span> <span class="n">link_down</span><span class="p">;</span>
	<span class="cm">/* True if &quot;egress_timer&quot; is scheduled. */</span>
	<span class="n">bool</span> <span class="n">egress_timer_scheduled</span><span class="p">;</span>
	<span class="cm">/* Number of small sk_buffs which must still be provided. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_needed_small_buffers</span><span class="p">;</span>
	<span class="cm">/* Number of large sk_buffs which must still be provided. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_needed_large_buffers</span><span class="p">;</span>
	<span class="cm">/* A timer for handling egress completions. */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">egress_timer</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Info for a specific device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="p">{</span>
	<span class="cm">/* Our network device. */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="cm">/* Pages making up the egress queue. */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">eq_pages</span><span class="p">;</span>
	<span class="cm">/* Address of the actual egress queue. */</span>
	<span class="n">lepp_queue_t</span> <span class="o">*</span><span class="n">eq</span><span class="p">;</span>
	<span class="cm">/* Protects &quot;eq&quot;. */</span>
	<span class="n">spinlock_t</span> <span class="n">eq_lock</span><span class="p">;</span>
	<span class="cm">/* The hypervisor handle for this interface. */</span>
	<span class="kt">int</span> <span class="n">hv_devhdl</span><span class="p">;</span>
	<span class="cm">/* The intr bit mask that IDs this device. */</span>
	<span class="n">u32</span> <span class="n">intr_id</span><span class="p">;</span>
	<span class="cm">/* True iff &quot;tile_net_open_aux()&quot; has succeeded. */</span>
	<span class="n">bool</span> <span class="n">partly_opened</span><span class="p">;</span>
	<span class="cm">/* True iff the device is &quot;active&quot;. */</span>
	<span class="n">bool</span> <span class="n">active</span><span class="p">;</span>
	<span class="cm">/* Effective network cpus. */</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">network_cpus_map</span><span class="p">;</span>
	<span class="cm">/* Number of network cpus. */</span>
	<span class="kt">int</span> <span class="n">network_cpus_count</span><span class="p">;</span>
	<span class="cm">/* Credits per network cpu. */</span>
	<span class="kt">int</span> <span class="n">network_cpus_credits</span><span class="p">;</span>
	<span class="cm">/* Network stats. */</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="n">stats</span><span class="p">;</span>
	<span class="cm">/* For NetIO bringup retries. */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">retry_work</span><span class="p">;</span>
	<span class="cm">/* Quick access to per cpu data. */</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Log2 of the number of small pages needed for the egress queue. */</span>
<span class="cp">#define EQ_ORDER  get_order(sizeof(lepp_queue_t))</span>
<span class="cm">/* Size of the egress queue&#39;s pages. */</span>
<span class="cp">#define EQ_SIZE   (1 &lt;&lt; (PAGE_SHIFT + EQ_ORDER))</span>

<span class="cm">/*</span>
<span class="cm"> * The actual devices (xgbe0, xgbe1, gbe0, gbe1).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">tile_net_devs</span><span class="p">[</span><span class="n">TILE_NET_DEVS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;tile_net_cpu&quot; structures for each device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span><span class="p">,</span> <span class="n">hv_xgbe0</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span><span class="p">,</span> <span class="n">hv_xgbe1</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span><span class="p">,</span> <span class="n">hv_gbe0</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span><span class="p">,</span> <span class="n">hv_gbe1</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * True if &quot;network_cpus&quot; was specified.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">network_cpus_used</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The actual cpus in &quot;network_cpus&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="n">network_cpus_map</span><span class="p">;</span>



<span class="cp">#ifdef TILE_NET_DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * printk with extra stuff.</span>
<span class="cm"> *</span>
<span class="cm"> * We print the CPU we&#39;re running in brackets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">net_printk</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;tile_net[%2.2d]: &quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">vscnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">255</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cp">#ifdef TILE_NET_DUMP_PACKETS</span>
<span class="cm">/*</span>
<span class="cm"> * Dump a packet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_packet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;dump_packet(data %p, length 0x%lx s %s count 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="o">++</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;[%02d] %8.8lx:&quot;</span><span class="p">,</span> <span class="n">my_cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot; %2.2x&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xf</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">strcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * Provide support for the __netio_fastio1() swint</span>
<span class="cm"> * (see &lt;hv/drv_xgbe_intf.h&gt; for how it is used).</span>
<span class="cm"> *</span>
<span class="cm"> * The fastio swint2 call may clobber all the caller-saved registers.</span>
<span class="cm"> * It rarely clobbers memory, but we allow for the possibility in</span>
<span class="cm"> * the signature just to be on the safe side.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, gcc doesn&#39;t seem to allow an input operand to be</span>
<span class="cm"> * clobbered, so we fake it with dummy outputs.</span>
<span class="cm"> *</span>
<span class="cm"> * This function can&#39;t be static because of the way it is declared</span>
<span class="cm"> * in the netio header.</span>
<span class="cm"> */</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__netio_fastio1</span><span class="p">(</span><span class="n">u32</span> <span class="n">fastio_index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">arg0</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">result</span><span class="p">,</span> <span class="n">clobber_r1</span><span class="p">,</span> <span class="n">clobber_r10</span><span class="p">;</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;swint2&quot;</span>
		     <span class="o">:</span> <span class="s">&quot;=R00&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">),</span>
		       <span class="s">&quot;=R01&quot;</span> <span class="p">(</span><span class="n">clobber_r1</span><span class="p">),</span> <span class="s">&quot;=R10&quot;</span> <span class="p">(</span><span class="n">clobber_r10</span><span class="p">)</span>
		     <span class="o">:</span> <span class="s">&quot;R10&quot;</span> <span class="p">(</span><span class="n">fastio_index</span><span class="p">),</span> <span class="s">&quot;R01&quot;</span> <span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
		     <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;r2&quot;</span><span class="p">,</span> <span class="s">&quot;r3&quot;</span><span class="p">,</span> <span class="s">&quot;r4&quot;</span><span class="p">,</span>
		       <span class="s">&quot;r5&quot;</span><span class="p">,</span> <span class="s">&quot;r6&quot;</span><span class="p">,</span> <span class="s">&quot;r7&quot;</span><span class="p">,</span> <span class="s">&quot;r8&quot;</span><span class="p">,</span> <span class="s">&quot;r9&quot;</span><span class="p">,</span>
		       <span class="s">&quot;r11&quot;</span><span class="p">,</span> <span class="s">&quot;r12&quot;</span><span class="p">,</span> <span class="s">&quot;r13&quot;</span><span class="p">,</span> <span class="s">&quot;r14&quot;</span><span class="p">,</span>
		       <span class="s">&quot;r15&quot;</span><span class="p">,</span> <span class="s">&quot;r16&quot;</span><span class="p">,</span> <span class="s">&quot;r17&quot;</span><span class="p">,</span> <span class="s">&quot;r18&quot;</span><span class="p">,</span> <span class="s">&quot;r19&quot;</span><span class="p">,</span>
		       <span class="s">&quot;r20&quot;</span><span class="p">,</span> <span class="s">&quot;r21&quot;</span><span class="p">,</span> <span class="s">&quot;r22&quot;</span><span class="p">,</span> <span class="s">&quot;r23&quot;</span><span class="p">,</span> <span class="s">&quot;r24&quot;</span><span class="p">,</span>
		       <span class="s">&quot;r25&quot;</span><span class="p">,</span> <span class="s">&quot;r26&quot;</span><span class="p">,</span> <span class="s">&quot;r27&quot;</span><span class="p">,</span> <span class="s">&quot;r28&quot;</span><span class="p">,</span> <span class="s">&quot;r29&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_return_credit</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_netio_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="n">netio_queue_user_impl_t</span> <span class="o">*</span><span class="n">qup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">;</span>

	<span class="cm">/* Return four credits after every fourth packet. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">qup</span><span class="o">-&gt;</span><span class="n">__receive_credit_remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">qup</span><span class="o">-&gt;</span><span class="n">__receive_credit_interval</span><span class="p">;</span>
		<span class="n">qup</span><span class="o">-&gt;</span><span class="n">__receive_credit_remaining</span> <span class="o">=</span> <span class="n">interval</span><span class="p">;</span>
		<span class="n">__netio_fastio_return_credits</span><span class="p">(</span><span class="n">qup</span><span class="o">-&gt;</span><span class="n">__fastio_index</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * Provide a linux buffer to LIPP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_provide_linux_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="n">bool</span> <span class="n">small</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_netio_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>

	<span class="cm">/* Convert &quot;va&quot; and &quot;small&quot; to &quot;linux_buffer_t&quot;. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">__pa</span><span class="p">(</span><span class="n">va</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">small</span><span class="p">;</span>

	<span class="n">__netio_fastio_free_buffer</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">.</span><span class="n">__fastio_index</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Provide a linux buffer for LIPP.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the ACTUAL allocation for each buffer is a &quot;struct sk_buff&quot;,</span>
<span class="cm"> * plus a chunk of memory that includes not only the requested bytes, but</span>
<span class="cm"> * also NET_SKB_PAD bytes of initial padding, and a &quot;struct skb_shared_info&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that &quot;struct skb_shared_info&quot; is 88 bytes with 64K pages and</span>
<span class="cm"> * 268 bytes with 4K pages (since the frags[] array needs 18 entries).</span>
<span class="cm"> *</span>
<span class="cm"> * Without jumbo packets, the maximum packet size will be 1536 bytes,</span>
<span class="cm"> * and we use 2 bytes (NET_IP_ALIGN) of padding.  ISSUE: If we told</span>
<span class="cm"> * the hardware to clip at 1518 bytes instead of 1536 bytes, then we</span>
<span class="cm"> * could save an entire cache line, but in practice, we don&#39;t need it.</span>
<span class="cm"> *</span>
<span class="cm"> * Since CPAs are 38 bits, and we can only encode the high 31 bits in</span>
<span class="cm"> * a &quot;linux_buffer_t&quot;, the low 7 bits must be zero, and thus, we must</span>
<span class="cm"> * align the actual &quot;va&quot; mod 128.</span>
<span class="cm"> *</span>
<span class="cm"> * We assume that the underlying &quot;head&quot; will be aligned mod 64.  Note</span>
<span class="cm"> * that in practice, we have seen &quot;head&quot; NOT aligned mod 128 even when</span>
<span class="cm"> * using 2048 byte allocations, which is surprising.</span>
<span class="cm"> *</span>
<span class="cm"> * If &quot;head&quot; WAS always aligned mod 128, we could change LIPP to</span>
<span class="cm"> * assume that the low SIX bits are zero, and the 7th bit is one, that</span>
<span class="cm"> * is, align the actual &quot;va&quot; mod 128 plus 64, which would be &quot;free&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * For now, the actual &quot;head&quot; pointer points at NET_SKB_PAD bytes of</span>
<span class="cm"> * padding, plus 28 or 92 bytes of extra padding, plus the sk_buff</span>
<span class="cm"> * pointer, plus the NET_IP_ALIGN padding, plus 126 or 1536 bytes for</span>
<span class="cm"> * the actual packet, plus 62 bytes of empty padding, plus some</span>
<span class="cm"> * padding and the &quot;struct skb_shared_info&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * With 64K pages, a large buffer thus needs 32+92+4+2+1536+62+88</span>
<span class="cm"> * bytes, or 1816 bytes, which fits comfortably into 2048 bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * With 64K pages, a small buffer thus needs 32+92+4+2+126+88</span>
<span class="cm"> * bytes, or 344 bytes, which means we are wasting 64+ bytes, and</span>
<span class="cm"> * could presumably increase the size of small buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * With 4K pages, a large buffer thus needs 32+92+4+2+1536+62+268</span>
<span class="cm"> * bytes, or 1996 bytes, which fits comfortably into 2048 bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * With 4K pages, a small buffer thus needs 32+92+4+2+126+268</span>
<span class="cm"> * bytes, or 524 bytes, which is annoyingly wasteful.</span>
<span class="cm"> *</span>
<span class="cm"> * Maybe we should increase LIPP_SMALL_PACKET_SIZE to 192?</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: Maybe we should increase &quot;NET_SKB_PAD&quot; to 64?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tile_net_provide_needed_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
					   <span class="n">bool</span> <span class="n">small</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if TILE_NET_MTU &lt;= 1536</span>
	<span class="cm">/* Without &quot;jumbo&quot;, 2 + 1536 should be sufficient. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">large_size</span> <span class="o">=</span> <span class="n">NET_IP_ALIGN</span> <span class="o">+</span> <span class="mi">1536</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="cm">/* ISSUE: This has not been tested. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">large_size</span> <span class="o">=</span> <span class="n">NET_IP_ALIGN</span> <span class="o">+</span> <span class="n">TILE_NET_MTU</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Avoid &quot;false sharing&quot; with last cache line. */</span>
	<span class="cm">/* ISSUE: This is already done by &quot;netdev_alloc_skb()&quot;. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span>
		 <span class="p">(((</span><span class="n">small</span> <span class="o">?</span> <span class="n">LIPP_SMALL_PACKET_SIZE</span> <span class="o">:</span> <span class="n">large_size</span><span class="p">)</span> <span class="o">+</span>
		   <span class="n">CHIP_L2_LINE_SIZE</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">CHIP_L2_LINE_SIZE</span><span class="p">());</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">padding</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">-</span> <span class="n">NET_SKB_PAD</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">align</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">skb_ptr</span><span class="p">;</span>

	<span class="cm">/* Request 96 extra bytes for alignment purposes. */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="n">padding</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Skip 32 or 96 bytes to align &quot;data&quot; mod 128. */</span>
	<span class="n">align</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">128</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">align</span> <span class="o">&gt;</span> <span class="n">padding</span><span class="p">);</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>

	<span class="cm">/* This address is given to IPP. */</span>
	<span class="n">va</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Buffers must not span a huge page. */</span>
	<span class="n">BUG_ON</span><span class="p">(((((</span><span class="kt">long</span><span class="p">)</span><span class="n">va</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HPAGE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef TILE_NET_PARANOIA</span>
<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hash_default</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">HV_PTE</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">virt_to_pte</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">va</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hv_pte_get_mode</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HV_PTE_MODE_CACHE_HASH_L3</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Non-HFH ingress buffer! VA=%p Mode=%d PTE=%llx&quot;</span><span class="p">,</span>
			      <span class="n">va</span><span class="p">,</span> <span class="n">hv_pte_get_mode</span><span class="p">(</span><span class="n">pte</span><span class="p">),</span> <span class="n">hv_pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

	<span class="cm">/* Invalidate the packet buffer. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash_default</span><span class="p">)</span>
		<span class="n">__inv_buffer</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Skip two bytes to satisfy LIPP assumptions. */</span>
	<span class="cm">/* Note that this aligns IP on a 16 byte boundary. */</span>
	<span class="cm">/* ISSUE: Do this when the packet arrives? */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>

	<span class="cm">/* Save a back-pointer to &#39;skb&#39;. */</span>
	<span class="n">skb_ptr</span> <span class="o">=</span> <span class="n">va</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">skb_ptr</span><span class="p">);</span>
	<span class="o">*</span><span class="n">skb_ptr</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* Make sure &quot;skb_ptr&quot; has been flushed. */</span>
	<span class="n">__insn_mf</span><span class="p">();</span>

	<span class="cm">/* Provide the new buffer. */</span>
	<span class="n">tile_net_provide_linux_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">small</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Provide linux buffers for LIPP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_provide_needed_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_small_buffers</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tile_net_provide_needed_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">oops</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_small_buffers</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_large_buffers</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tile_net_provide_needed_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">oops</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_large_buffers</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">oops:</span>

	<span class="cm">/* Add a description to the page allocation failure dump. */</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Could not provide a linux buffer to LIPP.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Grab some LEPP completions, and store them in &quot;comps&quot;, of size</span>
<span class="cm"> * &quot;comps_size&quot;, and return the number of completions which were</span>
<span class="cm"> * stored, so the caller can free them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tile_net_lepp_grab_comps</span><span class="p">(</span><span class="n">lepp_queue_t</span> <span class="o">*</span><span class="n">eq</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">comps</span><span class="p">[],</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comps_size</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comp_head</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comp_busy</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_busy</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">comp_head</span> <span class="o">!=</span> <span class="n">comp_busy</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">comps_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">comps</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">comps</span><span class="p">[</span><span class="n">comp_head</span><span class="p">];</span>
		<span class="n">LEPP_QINC</span><span class="p">(</span><span class="n">comp_head</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">min_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_head</span> <span class="o">=</span> <span class="n">comp_head</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Free some comps, and return true iff there are still some pending.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tile_net_lepp_free_comps</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">all</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">lepp_queue_t</span> <span class="o">*</span><span class="n">eq</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">olds</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wanted</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">pending</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">all</span><span class="p">)</span>
		<span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_busy</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_tail</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">tile_net_lepp_grab_comps</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">olds</span><span class="p">,</span> <span class="n">wanted</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">pending</span> <span class="o">=</span> <span class="p">(</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_head</span> <span class="o">!=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_tail</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">olds</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">pending</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Make sure the egress timer is scheduled.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we use &quot;schedule if not scheduled&quot; logic instead of the more</span>
<span class="cm"> * obvious &quot;reschedule&quot; logic, because &quot;reschedule&quot; is fairly expensive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_schedule_egress_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer_scheduled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mod_timer_pinned</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer_scheduled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * The &quot;function&quot; for &quot;info-&gt;egress_timer&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * This timer will reschedule itself as long as there are any pending</span>
<span class="cm"> * completions expected (on behalf of any tile).</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: Realistically, will the timer ever stop scheduling itself?</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: This timer is almost never actually needed, so just use a global</span>
<span class="cm"> * timer that can run on any tile.</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: Maybe instead track number of expected completions, and free</span>
<span class="cm"> * only that many, resetting to zero if &quot;pending&quot; is ever false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_handle_egress_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* The timer is no longer scheduled. */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer_scheduled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Free comps, and reschedule timer if more are pending. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tile_net_lepp_free_comps</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
		<span class="n">tile_net_schedule_egress_timer</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#ifdef IGNORE_DUP_ACKS</span>

<span class="cm">/*</span>
<span class="cm"> * Help detect &quot;duplicate&quot; ACKs.  These are sequential packets (for a</span>
<span class="cm"> * given flow) which are exactly 66 bytes long, sharing everything but</span>
<span class="cm"> * ID=2@0x12, Hsum=2@0x18, Ack=4@0x2a, WinSize=2@0x30, Csum=2@0x32,</span>
<span class="cm"> * Tstamps=10@0x38.  The ID&#39;s are +1, the Hsum&#39;s are -1, the Ack&#39;s are</span>
<span class="cm"> * +N, and the Tstamps are usually identical.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Apparently truly duplicate acks (with identical &quot;ack&quot; values),</span>
<span class="cm"> * should not be collapsed, as they are used for some kind of flow control.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_dup_ack</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ignorable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Identification. */</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x12</span><span class="p">);</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x13</span><span class="p">);</span>

	<span class="cm">/* Header checksum. */</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x18</span><span class="p">);</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x19</span><span class="p">);</span>

	<span class="cm">/* ACK. */</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x2a</span><span class="p">);</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x2b</span><span class="p">);</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x2c</span><span class="p">);</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x2d</span><span class="p">);</span>

	<span class="cm">/* WinSize. */</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x30</span><span class="p">);</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x31</span><span class="p">);</span>

	<span class="cm">/* Checksum. */</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x32</span><span class="p">);</span>
	<span class="n">ignorable</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mh">0x33</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">ignorable</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ignorable</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>

<span class="cp">#ifdef TILE_NET_DEBUG</span>
		<span class="cm">/* HACK: Mention non-timestamp diffs. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x38</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mh">0x2f</span> <span class="o">&amp;&amp;</span>
		    <span class="n">net_ratelimit</span><span class="p">())</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Diff at 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef TILE_NET_NO_SUPPRESS_DUP_ACKS</span>
	<span class="cm">/* HACK: Do not suppress truly duplicate ACKs. */</span>
	<span class="cm">/* ISSUE: Is this actually necessary or helpful? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mh">0x2a</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="mh">0x2a</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
	    <span class="n">s1</span><span class="p">[</span><span class="mh">0x2b</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="mh">0x2b</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
	    <span class="n">s1</span><span class="p">[</span><span class="mh">0x2c</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="mh">0x2c</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
	    <span class="n">s1</span><span class="p">[</span><span class="mh">0x2d</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="mh">0x2d</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>



<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_discard_aux</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_netio_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="n">netio_queue_impl_t</span> <span class="o">*</span><span class="n">qsp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">__system_part</span><span class="p">;</span>
	<span class="n">netio_queue_user_impl_t</span> <span class="o">*</span><span class="n">qup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">index2_aux</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">index2</span> <span class="o">=</span>
		<span class="p">((</span><span class="n">index2_aux</span> <span class="o">==</span>
		  <span class="n">qsp</span><span class="o">-&gt;</span><span class="n">__packet_receive_queue</span><span class="p">.</span><span class="n">__last_packet_plus_one</span><span class="p">)</span> <span class="o">?</span>
		 <span class="mi">0</span> <span class="o">:</span> <span class="n">index2_aux</span><span class="p">);</span>

	<span class="n">netio_pkt_t</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="p">(</span><span class="n">netio_pkt_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">qsp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>

	<span class="cm">/* Extract the &quot;linux_buffer_t&quot;. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__packet</span><span class="p">.</span><span class="n">word</span><span class="p">;</span>

	<span class="cm">/* Convert &quot;linux_buffer_t&quot; to &quot;va&quot;. */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span> <span class="o">=</span> <span class="n">__va</span><span class="p">((</span><span class="n">phys_addr_t</span><span class="p">)(</span><span class="n">buffer</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>

	<span class="cm">/* Acquire the associated &quot;skb&quot;. */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">skb_ptr</span> <span class="o">=</span> <span class="n">va</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">skb_ptr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="o">*</span><span class="n">skb_ptr</span><span class="p">;</span>

	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Consume this packet. */</span>
	<span class="n">qup</span><span class="o">-&gt;</span><span class="n">__packet_receive_read</span> <span class="o">=</span> <span class="n">index2</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Like &quot;tile_net_poll()&quot;, but just discard packets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_discard_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">my_cpu</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tile_netio_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="n">netio_queue_impl_t</span> <span class="o">*</span><span class="n">qsp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">__system_part</span><span class="p">;</span>
	<span class="n">netio_queue_user_impl_t</span> <span class="o">*</span><span class="n">qup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">qup</span><span class="o">-&gt;</span><span class="n">__packet_receive_read</span> <span class="o">!=</span>
	       <span class="n">qsp</span><span class="o">-&gt;</span><span class="n">__packet_receive_queue</span><span class="p">.</span><span class="n">__packet_write</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">qup</span><span class="o">-&gt;</span><span class="n">__packet_receive_read</span><span class="p">;</span>
		<span class="n">tile_net_discard_aux</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Handle the next packet.  Return true if &quot;processed&quot;, false if &quot;filtered&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tile_net_poll_aux</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tile_netio_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="n">netio_queue_impl_t</span> <span class="o">*</span><span class="n">qsp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">__system_part</span><span class="p">;</span>
	<span class="n">netio_queue_user_impl_t</span> <span class="o">*</span><span class="n">qup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_stats_t</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">filter</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">index2_aux</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">index2</span> <span class="o">=</span>
		<span class="p">((</span><span class="n">index2_aux</span> <span class="o">==</span>
		  <span class="n">qsp</span><span class="o">-&gt;</span><span class="n">__packet_receive_queue</span><span class="p">.</span><span class="n">__last_packet_plus_one</span><span class="p">)</span> <span class="o">?</span>
		 <span class="mi">0</span> <span class="o">:</span> <span class="n">index2_aux</span><span class="p">);</span>

	<span class="n">netio_pkt_t</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="p">(</span><span class="n">netio_pkt_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">qsp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>

	<span class="n">netio_pkt_metadata_t</span> <span class="o">*</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

	<span class="cm">/* Extract the packet size.  FIXME: Shouldn&#39;t the second line */</span>
	<span class="cm">/* get subtracted?  Mostly moot, since it should be &quot;zero&quot;. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">NETIO_PKT_CUSTOM_LENGTH</span><span class="p">(</span><span class="n">pkt</span><span class="p">)</span> <span class="o">+</span>
		 <span class="n">NET_IP_ALIGN</span> <span class="o">-</span> <span class="n">NETIO_PACKET_PADDING</span><span class="p">);</span>

	<span class="cm">/* Extract the &quot;linux_buffer_t&quot;. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__packet</span><span class="p">.</span><span class="n">word</span><span class="p">;</span>

	<span class="cm">/* Extract &quot;small&quot; (vs &quot;large&quot;). */</span>
	<span class="n">bool</span> <span class="n">small</span> <span class="o">=</span> <span class="p">((</span><span class="n">buffer</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Convert &quot;linux_buffer_t&quot; to &quot;va&quot;. */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span> <span class="o">=</span> <span class="n">__va</span><span class="p">((</span><span class="n">phys_addr_t</span><span class="p">)(</span><span class="n">buffer</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>

	<span class="cm">/* Extract the packet data pointer. */</span>
	<span class="cm">/* Compare to &quot;NETIO_PKT_CUSTOM_DATA(pkt)&quot;. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">va</span> <span class="o">+</span> <span class="n">NET_IP_ALIGN</span><span class="p">;</span>

	<span class="cm">/* Invalidate the packet buffer. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash_default</span><span class="p">)</span>
		<span class="n">__inv_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* ISSUE: Is this needed? */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_rx</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

<span class="cp">#ifdef TILE_NET_DUMP_PACKETS</span>
	<span class="n">dump_packet</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;rx&quot;</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* TILE_NET_DUMP_PACKETS */</span><span class="cp"></span>

<span class="cp">#ifdef TILE_NET_VERIFY_INGRESS</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NETIO_PKT_L4_CSUM_CORRECT_M</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">NETIO_PKT_L4_CSUM_CALCULATED_M</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">pkt</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Bug 6624: Includes UDP packets with a &quot;zero&quot; checksum. */</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Bad L4 checksum on %d byte packet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NETIO_PKT_L3_CSUM_CORRECT_M</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">NETIO_PKT_L3_CSUM_CALCULATED_M</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">pkt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dump_packet</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;rx&quot;</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Bad L3 checksum.&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">NETIO_PKT_STATUS_M</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">pkt</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NETIO_PKT_STATUS_OVERSIZE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dump_packet</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;rx&quot;</span><span class="p">);</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unexpected OVERSIZE.&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETIO_PKT_STATUS_BAD</span>:
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Unexpected BAD %ld byte packet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">filter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ISSUE: Filter TCP packets with &quot;bad&quot; checksums? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Filter packets received before we&#39;re up. */</span>
		<span class="n">filter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">NETIO_PKT_STATUS_M</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">==</span> <span class="n">NETIO_PKT_STATUS_BAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Filter &quot;truncated&quot; packets. */</span>
		<span class="n">filter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* FIXME: Implement HW multicast filter. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_multicast_ether_addr</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Filter packets not for our address. */</span>
			<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mine</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">;</span>
			<span class="n">filter</span> <span class="o">=</span> <span class="o">!</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">mine</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* ISSUE: Update &quot;drop&quot; statistics? */</span>

		<span class="n">tile_net_provide_linux_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">small</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/* Acquire the associated &quot;skb&quot;. */</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">skb_ptr</span> <span class="o">=</span> <span class="n">va</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">skb_ptr</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="o">*</span><span class="n">skb_ptr</span><span class="p">;</span>

		<span class="cm">/* Paranoia. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">buf</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Corrupt linux buffer from LIPP! &quot;</span>
			      <span class="s">&quot;VA=%p, skb=%p, skb-&gt;data=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">va</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

		<span class="cm">/* Encode the actual packet length. */</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="cm">/* NOTE: This call also sets &quot;skb-&gt;dev = dev&quot;. */</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* Avoid recomputing &quot;good&quot; TCP/UDP checksums. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NETIO_PKT_L4_CSUM_CORRECT_M</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">pkt</span><span class="p">))</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>

		<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ISSUE: It would be nice to defer this until the packet has */</span>
	<span class="cm">/* actually been processed. */</span>
	<span class="n">tile_net_return_credit</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Consume this packet. */</span>
	<span class="n">qup</span><span class="o">-&gt;</span><span class="n">__packet_receive_read</span> <span class="o">=</span> <span class="n">index2</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">filter</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Handle some packets for the given device on the current CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * If &quot;tile_net_stop()&quot; is called on some other tile while this</span>
<span class="cm"> * function is running, we will return, hopefully before that</span>
<span class="cm"> * other tile asks us to call &quot;napi_disable()&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;rotting packet&quot; race condition occurs if a packet arrives</span>
<span class="cm"> * during the extremely narrow window between the queue appearing to</span>
<span class="cm"> * be empty, and the ingress interrupt being re-enabled.  This happens</span>
<span class="cm"> * a LOT under heavy network load.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">my_cpu</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tile_netio_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="n">netio_queue_impl_t</span> <span class="o">*</span><span class="n">qsp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">__system_part</span><span class="p">;</span>
	<span class="n">netio_queue_user_impl_t</span> <span class="o">*</span><span class="n">qup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">work</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">qup</span><span class="o">-&gt;</span><span class="n">__packet_receive_read</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">qsp</span><span class="o">-&gt;</span><span class="n">__packet_receive_queue</span><span class="p">.</span><span class="n">__packet_write</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tile_net_poll_aux</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">work</span> <span class="o">&gt;=</span> <span class="n">budget</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">napi_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Re-enable the ingress interrupt. */</span>
	<span class="n">enable_percpu_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* HACK: Avoid the &quot;rotting packet&quot; problem (see above). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qup</span><span class="o">-&gt;</span><span class="n">__packet_receive_read</span> <span class="o">!=</span>
	    <span class="n">qsp</span><span class="o">-&gt;</span><span class="n">__packet_receive_queue</span><span class="p">.</span><span class="n">__packet_write</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ISSUE: Sometimes this returns zero, presumably */</span>
		<span class="cm">/* because an interrupt was handled for this tile. */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">napi_reschedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">done:</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="n">tile_net_provide_needed_buffers</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">work</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Handle an ingress interrupt for the given device on the current cpu.</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: Sometimes this gets called after &quot;disable_percpu_irq()&quot; has</span>
<span class="cm"> * been called!  This is probably due to &quot;pending hypervisor downcalls&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: Is there any race condition between the &quot;napi_schedule()&quot; here</span>
<span class="cm"> * and the &quot;napi_complete()&quot; call above?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">tile_net_handle_ingress_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">my_cpu</span><span class="p">];</span>

	<span class="cm">/* Disable the ingress interrupt. */</span>
	<span class="n">disable_percpu_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span><span class="p">);</span>

	<span class="cm">/* Ignore unwanted interrupts. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="cm">/* ISSUE: Sometimes &quot;info-&gt;napi_enabled&quot; is false here. */</span>

	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * One time initialization per interface.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_open_aux</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">epp_lotar</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find out where EPP memory should be homed.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">hv_dev_pread</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">epp_lotar</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">epp_lotar</span><span class="p">),</span>
			   <span class="n">NETIO_EPP_SHM_OFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;could not read epp_shm_queue lotar.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Home the page on the EPP.</span>
<span class="cm">	 */</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">epp_home</span> <span class="o">=</span> <span class="n">hv_lotar_to_cpu</span><span class="p">(</span><span class="n">epp_lotar</span><span class="p">);</span>
		<span class="n">homecache_change_page_home</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_pages</span><span class="p">,</span> <span class="n">EQ_ORDER</span><span class="p">,</span> <span class="n">epp_home</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register the EPP shared memory queue.</span>
<span class="cm">	 */</span>
	<span class="p">{</span>
		<span class="n">netio_ipp_address_t</span> <span class="n">ea</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq</span><span class="p">),</span>
			<span class="p">.</span><span class="n">pte</span> <span class="o">=</span> <span class="n">hv_pte</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">EQ_SIZE</span><span class="p">,</span>
		<span class="p">};</span>
		<span class="n">ea</span><span class="p">.</span><span class="n">pte</span> <span class="o">=</span> <span class="n">hv_pte_set_lotar</span><span class="p">(</span><span class="n">ea</span><span class="p">.</span><span class="n">pte</span><span class="p">,</span> <span class="n">epp_lotar</span><span class="p">);</span>
		<span class="n">ea</span><span class="p">.</span><span class="n">pte</span> <span class="o">=</span> <span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">ea</span><span class="p">.</span><span class="n">pte</span><span class="p">,</span> <span class="n">HV_PTE_MODE_CACHE_TILE_L3</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">hv_dev_pwrite</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ea</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="n">ea</span><span class="p">),</span>
				    <span class="n">NETIO_EPP_SHM_OFF</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start LIPP/LEPP.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hv_dev_pwrite</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="n">dummy</span><span class="p">),</span> <span class="n">NETIO_IPP_START_SHIM_OFF</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to start LIPP/LEPP.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Register with hypervisor on the current CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * Strangely, this function does important things even if it &quot;fails&quot;,</span>
<span class="cm"> * which is especially common if the link is not up yet.  Hopefully</span>
<span class="cm"> * these things are all &quot;harmless&quot; if done twice!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_register</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dev_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tile_netio_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>

	<span class="cm">/* Only network cpus can receive packets. */</span>
	<span class="kt">int</span> <span class="n">queue_id</span> <span class="o">=</span>
		<span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">my_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">network_cpus_map</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">255</span><span class="p">;</span>

	<span class="n">netio_input_config_t</span> <span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">num_receive_packets</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">network_cpus_credits</span><span class="p">,</span>
		<span class="p">.</span><span class="n">queue_id</span> <span class="o">=</span> <span class="n">queue_id</span>
	<span class="p">};</span>

	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netio_queue_impl_t</span> <span class="o">*</span><span class="n">queuep</span><span class="p">;</span>

	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;tile_net_register(queue_id %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">queue_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;xgbe0&quot;</span><span class="p">))</span>
		<span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hv_xgbe0</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;xgbe1&quot;</span><span class="p">))</span>
		<span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hv_xgbe1</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;gbe0&quot;</span><span class="p">))</span>
		<span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hv_gbe0</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;gbe1&quot;</span><span class="p">))</span>
		<span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hv_gbe1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="cm">/* Initialize the egress timer. */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">tile_net_handle_egress_timer</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">my_cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register ourselves with LIPP.  This does a lot of stuff,</span>
<span class="cm">	 * including invoking the LIPP registration code.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">hv_dev_pwrite</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">config</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="n">netio_input_config_t</span><span class="p">),</span>
			    <span class="n">NETIO_IPP_INPUT_REGISTER_OFF</span><span class="p">);</span>
	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;hv_dev_pwrite(NETIO_IPP_INPUT_REGISTER_OFF) returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">NETIO_LINK_DOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;hv_dev_pwrite &quot;</span>
			       <span class="s">&quot;NETIO_IPP_INPUT_REGISTER_OFF failure %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">link_down</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NETIO_LINK_DOWN</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the pointer to our queue&#39;s system part.</span>
<span class="cm">	 */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">hv_dev_pread</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">queuep</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">netio_queue_impl_t</span> <span class="o">*</span><span class="p">),</span>
			   <span class="n">NETIO_IPP_INPUT_REGISTER_OFF</span><span class="p">);</span>
	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;hv_dev_pread(NETIO_IPP_INPUT_REGISTER_OFF) returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ret</span><span class="p">);</span>
	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;queuep %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">queuep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ISSUE: Shouldn&#39;t this be a fatal error? */</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;hv_dev_pread NETIO_IPP_INPUT_REGISTER_OFF failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">__system_part</span> <span class="o">=</span> <span class="n">queuep</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">netio_queue_user_impl_t</span><span class="p">));</span>

	<span class="cm">/* This is traditionally &quot;config.num_receive_packets / 2&quot;. */</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">.</span><span class="n">__receive_credit_interval</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">.</span><span class="n">__receive_credit_remaining</span> <span class="o">=</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">.</span><span class="n">__receive_credit_interval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get a fastio index from the hypervisor.</span>
<span class="cm">	 * ISSUE: Shouldn&#39;t this check the result?</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">hv_dev_pread</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">.</span><span class="n">__fastio_index</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">.</span><span class="n">__fastio_index</span><span class="p">),</span>
			   <span class="n">NETIO_IPP_GET_FASTIO_OFF</span><span class="p">);</span>
	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;hv_dev_pread(NETIO_IPP_GET_FASTIO_OFF) returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* Now we are registered. */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Deregister with hypervisor on the current CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * This simply discards all our credits, so no more packets will be</span>
<span class="cm"> * delivered to this tile.  There may still be packets in our queue.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, disable the ingress interrupt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_deregister</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dev_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">my_cpu</span><span class="p">];</span>

	<span class="cm">/* Disable the ingress interrupt. */</span>
	<span class="n">disable_percpu_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span><span class="p">);</span>

	<span class="cm">/* Do nothing else if not registered. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">tile_netio_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
		<span class="n">netio_queue_user_impl_t</span> <span class="o">*</span><span class="n">qup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">__user_part</span><span class="p">;</span>

		<span class="cm">/* Discard all our credits. */</span>
		<span class="n">__netio_fastio_return_credits</span><span class="p">(</span><span class="n">qup</span><span class="o">-&gt;</span><span class="n">__fastio_index</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Unregister with hypervisor on the current CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, disable the ingress interrupt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_unregister</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dev_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">my_cpu</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dummy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Disable the ingress interrupt. */</span>
	<span class="n">disable_percpu_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span><span class="p">);</span>

	<span class="cm">/* Do nothing else if not registered. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Unregister ourselves with LIPP/LEPP. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">hv_dev_pwrite</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="n">dummy</span><span class="p">),</span> <span class="n">NETIO_IPP_INPUT_UNREGISTER_OFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed to unregister with LIPP/LEPP!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Discard all packets still in our NetIO queue. */</span>
	<span class="n">tile_net_discard_packets</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Reset state. */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_small_buffers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_large_buffers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Cancel egress timer. */</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer_scheduled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Helper function for &quot;tile_net_stop()&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Also used to handle registration failure in &quot;tile_net_open_inner()&quot;,</span>
<span class="cm"> * when the various extra steps in &quot;tile_net_stop()&quot; are not necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_stop_aux</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">dummy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unregister all tiles, so LIPP will stop delivering packets.</span>
<span class="cm">	 * Also, delete all the &quot;napi&quot; objects (sequentially, to protect</span>
<span class="cm">	 * &quot;dev-&gt;napi_list&quot;).</span>
<span class="cm">	 */</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">tile_net_unregister</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_napi_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Stop LIPP/LEPP. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hv_dev_pwrite</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="n">dummy</span><span class="p">),</span> <span class="n">NETIO_IPP_STOP_SHIM_OFF</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed to stop LIPP/LEPP!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">partly_opened</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Disable NAPI for the given device on the current cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_stop_disable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dev_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">my_cpu</span><span class="p">];</span>

	<span class="cm">/* Disable NAPI if needed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">napi_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">napi_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Enable NAPI and the ingress interrupt for the given device</span>
<span class="cm"> * on the current cpu.</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: Only do this for &quot;network cpus&quot;?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_open_enable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dev_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">my_cpu</span><span class="p">];</span>

	<span class="cm">/* Enable NAPI. */</span>
	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">napi_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Enable the ingress interrupt. */</span>
	<span class="n">enable_percpu_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * tile_net_open_inner does most of the work of bringing up the interface.</span>
<span class="cm"> * It&#39;s called from tile_net_open(), and also from tile_net_retry_open().</span>
<span class="cm"> * The return value is 0 if the interface was brought up, &lt; 0 if</span>
<span class="cm"> * tile_net_open() should return the return value as an error, and &gt; 0 if</span>
<span class="cm"> * tile_net_open() should return success and schedule a work item to</span>
<span class="cm"> * periodically retry the bringup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_open_inner</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_netio_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dummy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First try to register just on the local CPU, and handle any</span>
<span class="cm">	 * semi-expected &quot;link down&quot; failure specially.  Note that we</span>
<span class="cm">	 * do NOT call &quot;tile_net_stop_aux()&quot;, unlike below.</span>
<span class="cm">	 */</span>
	<span class="n">tile_net_register</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">my_cpu</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">link_down</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now register everywhere else.  If any registration fails,</span>
<span class="cm">	 * even for &quot;link down&quot; (which might not be possible), we</span>
<span class="cm">	 * clean up using &quot;tile_net_stop_aux()&quot;.  Also, add all the</span>
<span class="cm">	 * &quot;napi&quot; objects (sequentially, to protect &quot;dev-&gt;napi_list&quot;).</span>
<span class="cm">	 * ISSUE: Only use &quot;netif_napi_add()&quot; for &quot;network cpus&quot;?</span>
<span class="cm">	 */</span>
	<span class="n">smp_call_function</span><span class="p">(</span><span class="n">tile_net_register</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span>
			<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">tile_net_poll</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tile_net_stop_aux</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Acquire the irq allocated by the hypervisor.  Every</span>
<span class="cm">		 * queue gets the same irq.  The &quot;__intr_id&quot; field is</span>
<span class="cm">		 * &quot;1 &lt;&lt; irq&quot;, so we use &quot;__ffs()&quot; to extract &quot;irq&quot;.</span>
<span class="cm">		 */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">__system_part</span><span class="o">-&gt;</span><span class="n">__intr_id</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Register the ingress interrupt handler for this</span>
<span class="cm">		 * device, permanently.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We used to call &quot;free_irq()&quot; in &quot;tile_net_stop()&quot;,</span>
<span class="cm">		 * and then re-register the handler here every time,</span>
<span class="cm">		 * but that caused DNP errors in &quot;handle_IRQ_event()&quot;</span>
<span class="cm">		 * because &quot;desc-&gt;action&quot; was NULL.  See bug 9143.</span>
<span class="cm">		 */</span>
		<span class="n">tile_irq_activate</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">TILE_IRQ_PERCPU</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">tile_net_handle_ingress_interrupt</span><span class="p">,</span>
				   <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="p">{</span>
		<span class="cm">/* Allocate initial buffers. */</span>

		<span class="kt">int</span> <span class="n">max_buffers</span> <span class="o">=</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">network_cpus_count</span> <span class="o">*</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">network_cpus_credits</span><span class="p">;</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_small_buffers</span> <span class="o">=</span>
			<span class="n">min</span><span class="p">(</span><span class="n">LIPP_SMALL_BUFFERS</span><span class="p">,</span> <span class="n">max_buffers</span><span class="p">);</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_large_buffers</span> <span class="o">=</span>
			<span class="n">min</span><span class="p">(</span><span class="n">LIPP_LARGE_BUFFERS</span><span class="p">,</span> <span class="n">max_buffers</span><span class="p">);</span>

		<span class="n">tile_net_provide_needed_buffers</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_small_buffers</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_large_buffers</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Insufficient memory for buffer stack!&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We are about to be active. */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Make sure &quot;active&quot; is visible to all tiles. */</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="cm">/* On each tile, enable NAPI and the ingress interrupt. */</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">tile_net_open_enable</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Start LIPP/LEPP and activate &quot;ingress&quot; at the shim. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hv_dev_pwrite</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="n">dummy</span><span class="p">),</span> <span class="n">NETIO_IPP_INPUT_INIT_OFF</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed to activate the LIPP Shim!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Start our transmit queue. */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Called periodically to retry bringing up the NetIO interface,</span>
<span class="cm"> * if it doesn&#39;t come up cleanly during tile_net_open().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_open_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dw</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="k">struct</span> <span class="n">delayed_work</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">dw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tile_net_priv</span><span class="p">,</span> <span class="n">retry_work</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to bring the NetIO interface up.  If it fails, reschedule</span>
<span class="cm">	 * ourselves to try again later; otherwise, tell Linux we now have</span>
<span class="cm">	 * a working link.  ISSUE: What if the return value is negative?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tile_net_open_inner</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">retry_work</span><span class="p">,</span>
				      <span class="n">TILE_NET_RETRY_INTERVAL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Called when a network interface is made active.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative value on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * The open entry point is called when a network interface is made</span>
<span class="cm"> * active by the system (IFF_UP).  At this point all resources needed</span>
<span class="cm"> * for transmit and receive operations are allocated, the interrupt</span>
<span class="cm"> * handler is registered with the OS (if needed), the watchdog timer</span>
<span class="cm"> * is started, and the stack is notified that the interface is ready.</span>
<span class="cm"> *</span>
<span class="cm"> * If the actual link is not available yet, then we tell Linux that</span>
<span class="cm"> * we have no carrier, and we keep checking until the link comes up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We rely on priv-&gt;partly_opened to tell us if this is the</span>
<span class="cm">	 * first time this interface is being brought up. If it is</span>
<span class="cm">	 * set, the IPP was already initialized and should not be</span>
<span class="cm">	 * initialized again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">partly_opened</span><span class="p">)</span> <span class="p">{</span>

		<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">credits</span><span class="p">;</span>

		<span class="cm">/* Initialize LIPP/LEPP, and start the Shim. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tile_net_open_aux</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;tile_net_open_aux failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Analyze the network cpus. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">network_cpus_used</span><span class="p">)</span>
			<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">network_cpus_map</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">network_cpus_map</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">network_cpus_map</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>


		<span class="n">count</span> <span class="o">=</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">network_cpus_map</span><span class="p">);</span>

		<span class="cm">/* Limit credits to available buffers, and apply min. */</span>
		<span class="n">credits</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="p">(</span><span class="n">LIPP_LARGE_BUFFERS</span> <span class="o">/</span> <span class="n">count</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Apply &quot;GBE&quot; max limit. */</span>
		<span class="cm">/* ISSUE: Use higher limit for XGBE? */</span>
		<span class="n">credits</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">NETIO_MAX_RECEIVE_PKTS</span><span class="p">,</span> <span class="n">credits</span><span class="p">);</span>

		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">network_cpus_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">network_cpus_credits</span> <span class="o">=</span> <span class="n">credits</span><span class="p">;</span>

<span class="cp">#ifdef TILE_NET_DEBUG</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Using %d network cpus, with %d credits each</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">priv</span><span class="o">-&gt;</span><span class="n">network_cpus_count</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">network_cpus_credits</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">partly_opened</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* FIXME: Is this possible? */</span>
		<span class="cm">/* printk(&quot;Already partly opened.\n&quot;); */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attempt to bring up the link.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">tile_net_open_inner</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We were unable to bring up the NetIO interface, but we want to</span>
<span class="cm">	 * try again in a little bit.  Tell Linux that we have no carrier</span>
<span class="cm">	 * so it doesn&#39;t try to use the interface before the link comes up</span>
<span class="cm">	 * and then remember to try again later.</span>
<span class="cm">	 */</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">retry_work</span><span class="p">,</span> <span class="n">TILE_NET_RETRY_INTERVAL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_drain_lipp_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Drain all the LIPP buffers. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">;</span>

		<span class="cm">/* NOTE: This should never fail. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hv_dev_pread</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">NETIO_IPP_DRAIN_OFF</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Stop when done. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">{</span>
			<span class="cm">/* Convert &quot;linux_buffer_t&quot; to &quot;va&quot;. */</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">va</span> <span class="o">=</span> <span class="n">__va</span><span class="p">((</span><span class="n">phys_addr_t</span><span class="p">)(</span><span class="n">buffer</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>

			<span class="cm">/* Acquire the associated &quot;skb&quot;. */</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">skb_ptr</span> <span class="o">=</span> <span class="n">va</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">skb_ptr</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="o">*</span><span class="n">skb_ptr</span><span class="p">;</span>

			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Disables a network interface.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0, this is not allowed to fail.</span>
<span class="cm"> *</span>
<span class="cm"> * The close entry point is called when an interface is de-activated</span>
<span class="cm"> * by the OS.  The hardware is still under the drivers control, but</span>
<span class="cm"> * needs to be disabled.  A global MAC reset is issued to stop the</span>
<span class="cm"> * hardware, and all transmit and receive resources are freed.</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: How closely does &quot;netif_running(dev)&quot; mirror &quot;priv-&gt;active&quot;?</span>
<span class="cm"> *</span>
<span class="cm"> * Before we are called by &quot;__dev_close()&quot;, &quot;netif_running()&quot; will</span>
<span class="cm"> * have been cleared, so no NEW calls to &quot;tile_net_poll()&quot; will be</span>
<span class="cm"> * made by &quot;netpoll_poll_dev()&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Often, this can cause some tiles to still have packets in their</span>
<span class="cm"> * queues, so we must call &quot;tile_net_discard_packets()&quot; later.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that some other tile may still be INSIDE &quot;tile_net_poll()&quot;,</span>
<span class="cm"> * and in fact, many will be, if there is heavy network load.</span>
<span class="cm"> *</span>
<span class="cm"> * Calling &quot;on_each_cpu(tile_net_stop_disable, (void *)dev, 1)&quot; when</span>
<span class="cm"> * any tile is still &quot;napi_schedule()&quot;&#39;d will induce a horrible crash</span>
<span class="cm"> * when &quot;msleep()&quot; is called.  This includes tiles which are inside</span>
<span class="cm"> * &quot;tile_net_poll()&quot; which have not yet called &quot;napi_complete()&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * So, we must first try to wait long enough for other tiles to finish</span>
<span class="cm"> * with any current &quot;tile_net_poll()&quot; call, and, hopefully, to clear</span>
<span class="cm"> * the &quot;scheduled&quot; flag.  ISSUE: It is unclear what happens to tiles</span>
<span class="cm"> * which have called &quot;napi_schedule()&quot; but which had not yet tried to</span>
<span class="cm"> * call &quot;tile_net_poll()&quot;, or which exhausted their budget inside</span>
<span class="cm"> * &quot;tile_net_poll()&quot; just before this function was called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;tile_net_stop()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Start discarding packets. */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Make sure &quot;active&quot; is visible to all tiles. */</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * On each tile, make sure no NEW packets get delivered, and</span>
<span class="cm">	 * disable the ingress interrupt.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that the ingress interrupt can fire AFTER this,</span>
<span class="cm">	 * presumably due to packets which were recently delivered,</span>
<span class="cm">	 * but it will have no effect.</span>
<span class="cm">	 */</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">tile_net_deregister</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Optimistically drain LIPP buffers. */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">tile_net_drain_lipp_buffers</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* ISSUE: Only needed if not yet fully open. */</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">retry_work</span><span class="p">);</span>

	<span class="cm">/* Can&#39;t transmit any more. */</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Disable NAPI on each tile. */</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">tile_net_stop_disable</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Drain any remaining LIPP buffers.  NOTE: This &quot;printk()&quot;</span>
<span class="cm">	 * has never been observed, but in theory it could happen.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tile_net_drain_lipp_buffers</span><span class="p">(</span><span class="n">priv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Had to drain some extra LIPP buffers!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Stop LIPP/LEPP. */</span>
	<span class="n">tile_net_stop_aux</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * ISSUE: It appears that, in practice anyway, by the time we</span>
<span class="cm">	 * get here, there are no pending completions, but just in case,</span>
<span class="cm">	 * we free (all of) them anyway.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tile_net_lepp_free_comps</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
		<span class="cm">/* loop */</span><span class="p">;</span>

	<span class="cm">/* Wipe the EPP queue, and wait till the stores hit the EPP. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lepp_queue_t</span><span class="p">));</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Prepare the &quot;frags&quot; info for the resulting LEPP command.</span>
<span class="cm"> *</span>
<span class="cm"> * If needed, flush the memory used by the frags.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tile_net_tx_frags</span><span class="p">(</span><span class="n">lepp_frag_t</span> <span class="o">*</span><span class="n">frags</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">b_data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">phys_addr_t</span> <span class="n">cpa</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash_default</span><span class="p">)</span>
			<span class="n">finv_buffer_remote</span><span class="p">(</span><span class="n">b_data</span><span class="p">,</span> <span class="n">b_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">cpa</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">b_data</span><span class="p">);</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">cpa_lo</span> <span class="o">=</span> <span class="n">cpa</span><span class="p">;</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">cpa_hi</span> <span class="o">=</span> <span class="n">cpa</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">b_len</span><span class="p">;</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">hash_for_home</span> <span class="o">=</span> <span class="n">hash_default</span><span class="p">;</span>
		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>

		<span class="cm">/* FIXME: Compute &quot;hash_for_home&quot; properly. */</span>
		<span class="cm">/* ISSUE: The hypervisor checks CHIP_HAS_REV1_DMA_PACKETS(). */</span>
		<span class="kt">int</span> <span class="n">hash_for_home</span> <span class="o">=</span> <span class="n">hash_default</span><span class="p">;</span>

		<span class="cm">/* FIXME: Hmmm. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash_default</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">va</span> <span class="o">=</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">pfn</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">f</span><span class="p">)));</span>
			<span class="n">finv_buffer_remote</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">cpa</span> <span class="o">=</span> <span class="p">((</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">;</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">cpa_lo</span> <span class="o">=</span> <span class="n">cpa</span><span class="p">;</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">cpa_hi</span> <span class="o">=</span> <span class="n">cpa</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">hash_for_home</span> <span class="o">=</span> <span class="n">hash_for_home</span><span class="p">;</span>
		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This function takes &quot;skb&quot;, consisting of a header template and a</span>
<span class="cm"> * payload, and hands it to LEPP, to emit as one or more segments,</span>
<span class="cm"> * each consisting of a possibly modified header, plus a piece of the</span>
<span class="cm"> * payload, via a process known as &quot;tcp segmentation offload&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Usually, &quot;data&quot; will contain the header template, of size &quot;sh_len&quot;,</span>
<span class="cm"> * and &quot;sh-&gt;frags&quot; will contain &quot;skb-&gt;data_len&quot; bytes of payload, and</span>
<span class="cm"> * there will be &quot;sh-&gt;gso_segs&quot; segments.</span>
<span class="cm"> *</span>
<span class="cm"> * Sometimes, if &quot;sendfile()&quot; requires copying, we will be called with</span>
<span class="cm"> * &quot;data&quot; containing the header and payload, with &quot;frags&quot; being empty.</span>
<span class="cm"> *</span>
<span class="cm"> * Sometimes, for example when using NFS over TCP, a single segment can</span>
<span class="cm"> * span 3 fragments, which must be handled carefully in LEPP.</span>
<span class="cm"> *</span>
<span class="cm"> * See &quot;emulate_large_send_offload()&quot; for some reference code, which</span>
<span class="cm"> * does not handle checksumming.</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: How do we make sure that high memory DMA does not migrate?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_tx_tso</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">my_cpu</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tile_net_stats_t</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* The ip header follows the ethernet header. */</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ih</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ih_len</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Note that &quot;nh == ih&quot;, by definition. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nh</span> <span class="o">=</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eh_len</span> <span class="o">=</span> <span class="n">nh</span> <span class="o">-</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* The tcp header follows the ip header. */</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">nh</span> <span class="o">+</span> <span class="n">ih_len</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">th_len</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* The total number of header bytes. */</span>
	<span class="cm">/* NOTE: This may be less than skb_headlen(skb). */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sh_len</span> <span class="o">=</span> <span class="n">eh_len</span> <span class="o">+</span> <span class="n">ih_len</span> <span class="o">+</span> <span class="n">th_len</span><span class="p">;</span>

	<span class="cm">/* The number of payload bytes at &quot;skb-&gt;data + sh_len&quot;. */</span>
	<span class="cm">/* This is non-zero for sendfile() without HIGHDMA. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b_len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">sh_len</span><span class="p">;</span>

	<span class="cm">/* The total number of payload bytes. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d_len</span> <span class="o">=</span> <span class="n">b_len</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>

	<span class="cm">/* The maximum payload size. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p_len</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>

	<span class="cm">/* The total number of segments. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_segs</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">gso_segs</span><span class="p">;</span>

	<span class="cm">/* The temporary copy of the command. */</span>
	<span class="n">u32</span> <span class="n">cmd_body</span><span class="p">[(</span><span class="n">LEPP_MAX_CMD_SIZE</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">];</span>
	<span class="n">lepp_tso_cmd_t</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">lepp_tso_cmd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd_body</span><span class="p">;</span>

	<span class="cm">/* Analyze the &quot;frags&quot;. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_frags</span> <span class="o">=</span>
		<span class="n">tile_net_tx_frags</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">sh_len</span><span class="p">,</span> <span class="n">b_len</span><span class="p">);</span>

	<span class="cm">/* The size of the command, including frags and header. */</span>
	<span class="kt">size_t</span> <span class="n">cmd_size</span> <span class="o">=</span> <span class="n">LEPP_TSO_CMD_SIZE</span><span class="p">(</span><span class="n">num_frags</span><span class="p">,</span> <span class="n">sh_len</span><span class="p">);</span>

	<span class="cm">/* The command header. */</span>
	<span class="n">lepp_tso_cmd_t</span> <span class="n">cmd_init</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">tso</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
		<span class="p">.</span><span class="n">header_size</span> <span class="o">=</span> <span class="n">sh_len</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ip_offset</span> <span class="o">=</span> <span class="n">eh_len</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tcp_offset</span> <span class="o">=</span> <span class="n">eh_len</span> <span class="o">+</span> <span class="n">ih_len</span><span class="p">,</span>
		<span class="p">.</span><span class="n">payload_size</span> <span class="o">=</span> <span class="n">p_len</span><span class="p">,</span>
		<span class="p">.</span><span class="n">num_frags</span> <span class="o">=</span> <span class="n">num_frags</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="n">lepp_queue_t</span> <span class="o">*</span><span class="n">eq</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">olds</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wanted</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nolds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_head</span><span class="p">,</span> <span class="n">cmd_tail</span><span class="p">,</span> <span class="n">cmd_next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comp_tail</span><span class="p">;</span>


	<span class="cm">/* Paranoia. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_frags</span> <span class="o">&gt;</span> <span class="n">LEPP_MAX_FRAGS</span><span class="p">);</span>
	<span class="cm">/*--BUG_ON(num_segs != (d_len + (p_len - 1)) / p_len); */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_segs</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>


	<span class="cm">/* Finish preparing the command. */</span>

	<span class="cm">/* Copy the command header. */</span>
	<span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd_init</span><span class="p">;</span>

	<span class="cm">/* Copy the &quot;header&quot;. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">num_frags</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">sh_len</span><span class="p">);</span>


	<span class="cm">/* Prefetch and wait, to minimize time spent holding the spinlock. */</span>
	<span class="n">prefetch_L1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_tail</span><span class="p">);</span>
	<span class="n">prefetch_L1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">cmd_tail</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>


	<span class="cm">/* Enqueue the command. */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/* Handle completions if needed to make room. */</span>
	<span class="cm">/* NOTE: Return NETDEV_TX_BUSY if there is still no room. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lepp_num_free_comp_slots</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nolds</span> <span class="o">=</span> <span class="n">tile_net_lepp_grab_comps</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">olds</span><span class="p">,</span> <span class="n">wanted</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nolds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">busy:</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cmd_head</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">cmd_head</span><span class="p">;</span>
	<span class="n">cmd_tail</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">cmd_tail</span><span class="p">;</span>

	<span class="cm">/* Prepare to advance, detecting full queue. */</span>
	<span class="cm">/* NOTE: Return NETDEV_TX_BUSY if the queue is full. */</span>
	<span class="n">cmd_next</span> <span class="o">=</span> <span class="n">cmd_tail</span> <span class="o">+</span> <span class="n">cmd_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_tail</span> <span class="o">&lt;</span> <span class="n">cmd_head</span> <span class="o">&amp;&amp;</span> <span class="n">cmd_next</span> <span class="o">&gt;=</span> <span class="n">cmd_head</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">busy</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_next</span> <span class="o">&gt;</span> <span class="n">LEPP_CMD_LIMIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_next</span> <span class="o">==</span> <span class="n">cmd_head</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">busy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy the command. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">cmds</span><span class="p">[</span><span class="n">cmd_tail</span><span class="p">],</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cmd_size</span><span class="p">);</span>

	<span class="cm">/* Advance. */</span>
	<span class="n">cmd_tail</span> <span class="o">=</span> <span class="n">cmd_next</span><span class="p">;</span>

	<span class="cm">/* Record &quot;skb&quot; for eventual freeing. */</span>
	<span class="n">comp_tail</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_tail</span><span class="p">;</span>
	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">comps</span><span class="p">[</span><span class="n">comp_tail</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">LEPP_QINC</span><span class="p">(</span><span class="n">comp_tail</span><span class="p">);</span>
	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_tail</span> <span class="o">=</span> <span class="n">comp_tail</span><span class="p">;</span>

	<span class="cm">/* Flush before allowing LEPP to handle the command. */</span>
	<span class="cm">/* ISSUE: Is this the optimal location for the flush? */</span>
	<span class="n">__insn_mf</span><span class="p">();</span>

	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">cmd_tail</span> <span class="o">=</span> <span class="n">cmd_tail</span><span class="p">;</span>

	<span class="cm">/* NOTE: Using &quot;4&quot; here is more efficient than &quot;0&quot; or &quot;2&quot;, */</span>
	<span class="cm">/* and, strangely, more efficient than pre-checking the number */</span>
	<span class="cm">/* of available completions, and comparing it to 4. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nolds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nolds</span> <span class="o">=</span> <span class="n">tile_net_lepp_grab_comps</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">olds</span><span class="p">,</span> <span class="n">wanted</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/* Handle completions. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nolds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">olds</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* Update stats. */</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span> <span class="o">+=</span> <span class="n">num_segs</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="p">(</span><span class="n">num_segs</span> <span class="o">*</span> <span class="n">sh_len</span><span class="p">)</span> <span class="o">+</span> <span class="n">d_len</span><span class="p">;</span>

	<span class="cm">/* Make sure the egress timer is scheduled. */</span>
	<span class="n">tile_net_schedule_egress_timer</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Transmit a packet (called by the kernel via &quot;hard_start_xmit&quot; hook).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tile_net_cpu</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">my_cpu</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tile_net_stats_t</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">csum_start</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">lepp_frag_t</span> <span class="n">frags</span><span class="p">[</span><span class="n">LEPP_MAX_FRAGS</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_frags</span><span class="p">;</span>

	<span class="n">lepp_queue_t</span> <span class="o">*</span><span class="n">eq</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">olds</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wanted</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nolds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lepp_cmd_t</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_head</span><span class="p">,</span> <span class="n">cmd_tail</span><span class="p">,</span> <span class="n">cmd_next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comp_tail</span><span class="p">;</span>

	<span class="n">lepp_cmd_t</span> <span class="n">cmds</span><span class="p">[</span><span class="n">LEPP_MAX_FRAGS</span><span class="p">];</span>


	<span class="cm">/*</span>
<span class="cm">	 * This is paranoia, since we think that if the link doesn&#39;t come</span>
<span class="cm">	 * up, telling Linux we have no carrier will keep it from trying</span>
<span class="cm">	 * to transmit.  If it does, though, we can&#39;t execute this routine,</span>
<span class="cm">	 * since data structures we depend on aren&#39;t set up yet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>


	<span class="cm">/* Save the timestamp. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>


<span class="cp">#ifdef TILE_NET_PARANOIA</span>
<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hash_default</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">HV_PTE</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">virt_to_pte</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hv_pte_get_mode</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HV_PTE_MODE_CACHE_HASH_L3</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Non-HFH egress buffer! VA=%p Mode=%d PTE=%llx&quot;</span><span class="p">,</span>
			      <span class="n">data</span><span class="p">,</span> <span class="n">hv_pte_get_mode</span><span class="p">(</span><span class="n">pte</span><span class="p">),</span> <span class="n">hv_pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>


<span class="cp">#ifdef TILE_NET_DUMP_PACKETS</span>
	<span class="cm">/* ISSUE: Does not dump the &quot;frags&quot;. */</span>
	<span class="n">dump_packet</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="s">&quot;tx&quot;</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* TILE_NET_DUMP_PACKETS */</span><span class="cp"></span>


	<span class="k">if</span> <span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">tile_net_tx_tso</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>


	<span class="cm">/* Prepare the commands. */</span>

	<span class="n">num_frags</span> <span class="o">=</span> <span class="n">tile_net_tx_frags</span><span class="p">(</span><span class="n">frags</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">bool</span> <span class="n">final</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">num_frags</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">lepp_cmd_t</span> <span class="n">cmd</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">cpa_lo</span> <span class="o">=</span> <span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cpa_lo</span><span class="p">,</span>
			<span class="p">.</span><span class="n">cpa_hi</span> <span class="o">=</span> <span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cpa_hi</span><span class="p">,</span>
			<span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">,</span>
			<span class="p">.</span><span class="n">hash_for_home</span> <span class="o">=</span> <span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hash_for_home</span><span class="p">,</span>
			<span class="p">.</span><span class="n">send_completion</span> <span class="o">=</span> <span class="n">final</span><span class="p">,</span>
			<span class="p">.</span><span class="n">end_of_packet</span> <span class="o">=</span> <span class="n">final</span>
		<span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="p">.</span><span class="n">compute_checksum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">cmd</span><span class="p">.</span><span class="n">checksum_data</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">start_byte</span> <span class="o">=</span> <span class="n">csum_start</span><span class="p">;</span>
			<span class="n">cmd</span><span class="p">.</span><span class="n">checksum_data</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">csum_start</span><span class="p">;</span>
			<span class="n">cmd</span><span class="p">.</span><span class="n">checksum_data</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">destination_byte</span> <span class="o">=</span>
				<span class="n">csum_start</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cmds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Prefetch and wait, to minimize time spent holding the spinlock. */</span>
	<span class="n">prefetch_L1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_tail</span><span class="p">);</span>
	<span class="n">prefetch_L1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">cmd_tail</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>


	<span class="cm">/* Enqueue the commands. */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/* Handle completions if needed to make room. */</span>
	<span class="cm">/* NOTE: Return NETDEV_TX_BUSY if there is still no room. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lepp_num_free_comp_slots</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nolds</span> <span class="o">=</span> <span class="n">tile_net_lepp_grab_comps</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">olds</span><span class="p">,</span> <span class="n">wanted</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nolds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">busy:</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cmd_head</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">cmd_head</span><span class="p">;</span>
	<span class="n">cmd_tail</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">cmd_tail</span><span class="p">;</span>

	<span class="cm">/* Copy the commands, or fail. */</span>
	<span class="cm">/* NOTE: Return NETDEV_TX_BUSY if the queue is full. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Prepare to advance, detecting full queue. */</span>
		<span class="n">cmd_next</span> <span class="o">=</span> <span class="n">cmd_tail</span> <span class="o">+</span> <span class="n">cmd_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_tail</span> <span class="o">&lt;</span> <span class="n">cmd_head</span> <span class="o">&amp;&amp;</span> <span class="n">cmd_next</span> <span class="o">&gt;=</span> <span class="n">cmd_head</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">busy</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_next</span> <span class="o">&gt;</span> <span class="n">LEPP_CMD_LIMIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd_next</span> <span class="o">==</span> <span class="n">cmd_head</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">busy</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Copy the command. */</span>
		<span class="o">*</span><span class="p">(</span><span class="n">lepp_cmd_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">cmds</span><span class="p">[</span><span class="n">cmd_tail</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* Advance. */</span>
		<span class="n">cmd_tail</span> <span class="o">=</span> <span class="n">cmd_next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Record &quot;skb&quot; for eventual freeing. */</span>
	<span class="n">comp_tail</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_tail</span><span class="p">;</span>
	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">comps</span><span class="p">[</span><span class="n">comp_tail</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">LEPP_QINC</span><span class="p">(</span><span class="n">comp_tail</span><span class="p">);</span>
	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">comp_tail</span> <span class="o">=</span> <span class="n">comp_tail</span><span class="p">;</span>

	<span class="cm">/* Flush before allowing LEPP to handle the command. */</span>
	<span class="cm">/* ISSUE: Is this the optimal location for the flush? */</span>
	<span class="n">__insn_mf</span><span class="p">();</span>

	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">cmd_tail</span> <span class="o">=</span> <span class="n">cmd_tail</span><span class="p">;</span>

	<span class="cm">/* NOTE: Using &quot;4&quot; here is more efficient than &quot;0&quot; or &quot;2&quot;, */</span>
	<span class="cm">/* and, strangely, more efficient than pre-checking the number */</span>
	<span class="cm">/* of available completions, and comparing it to 4. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nolds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nolds</span> <span class="o">=</span> <span class="n">tile_net_lepp_grab_comps</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">olds</span><span class="p">,</span> <span class="n">wanted</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/* Handle completions. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nolds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">olds</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* HACK: Track &quot;expanded&quot; size for short packets (e.g. 42 &lt; 60). */</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="p">((</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">ETH_ZLEN</span><span class="p">)</span> <span class="o">?</span> <span class="n">len</span> <span class="o">:</span> <span class="n">ETH_ZLEN</span><span class="p">);</span>

	<span class="cm">/* Make sure the egress timer is scheduled. */</span>
	<span class="n">tile_net_schedule_egress_timer</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Deal with a transmit timeout.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;tile_net_tx_timeout()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;Transmit timeout at %ld, latency %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">,</span>
	       <span class="n">jiffies</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span><span class="p">);</span>

	<span class="cm">/* XXX: ISSUE: This doesn&#39;t seem useful for us. */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Ioctl commands.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Get System Network Statistics.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the address of the device statistics structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">tile_net_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">rx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">rx_packets</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="p">;</span>
			<span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span><span class="p">;</span>
			<span class="n">tx_packets</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="p">;</span>
			<span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span> <span class="o">=</span> <span class="n">rx_packets</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">rx_bytes</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span> <span class="o">=</span> <span class="n">tx_packets</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">tx_bytes</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Change the &quot;mtu&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;change_mtu&quot; method is usually not needed.</span>
<span class="cm"> * If you need it, it must be like this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;tile_net_change_mtu()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Check ranges. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="mi">68</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="mi">1500</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Accept the value. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Change the Ethernet Address of the NIC.</span>
<span class="cm"> *</span>
<span class="cm"> * The hypervisor driver does not support changing MAC address.  However,</span>
<span class="cm"> * the IPP does not do anything with the MAC address, so the address which</span>
<span class="cm"> * gets used on outgoing packets, and which is accepted on incoming packets,</span>
<span class="cm"> * is completely up to the NetIO program or kernel driver which is actually</span>
<span class="cm"> * handling them.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="cm">/* ISSUE: Note that &quot;dev_addr&quot; is now a pointer. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_assign_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NET_ADDR_RANDOM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Obtain the MAC address from the hypervisor.</span>
<span class="cm"> * This must be done before opening the device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_get_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="kt">char</span> <span class="n">hv_dev_name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">__netio_getset_offset_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">NETIO_IPP_PARAM_OFF</span> <span class="p">};</span>

	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* For example, &quot;xgbe0&quot;. */</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">hv_dev_name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">hv_dev_name</span><span class="p">);</span>

	<span class="cm">/* For example, &quot;xgbe/0&quot;. */</span>
	<span class="n">hv_dev_name</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="n">hv_dev_name</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">hv_dev_name</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
	<span class="n">len</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* For example, &quot;xgbe/0/native_hash&quot;. */</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">hv_dev_name</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">hash_default</span> <span class="o">?</span> <span class="s">&quot;/native_hash&quot;</span> <span class="o">:</span> <span class="s">&quot;/native&quot;</span><span class="p">);</span>

	<span class="cm">/* Get the hypervisor handle for this device. */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span> <span class="o">=</span> <span class="n">hv_dev_open</span><span class="p">((</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="n">hv_dev_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;hv_dev_open(%s) returned %d %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">hv_dev_name</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span> <span class="o">==</span> <span class="n">HV_ENODEV</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Ignoring unconfigured device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">hv_dev_name</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;hv_dev_open(%s) returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">hv_dev_name</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the hardware address from the hypervisor.</span>
<span class="cm">	 * ISSUE: Note that &quot;dev_addr&quot; is now a pointer.</span>
<span class="cm">	 */</span>
	<span class="n">offset</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">NETIO_PARAM</span><span class="p">;</span>
	<span class="n">offset</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">NETIO_PARAM_MAC</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">hv_dev_pread</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hv_devhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">,</span>
			   <span class="n">offset</span><span class="p">.</span><span class="n">word</span><span class="p">);</span>
	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;hv_dev_pread(NETIO_PARAM_MAC) returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;hv_dev_pread(NETIO_PARAM_MAC) %s failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Since the device is configured by the hypervisor but we</span>
<span class="cm">		 * can&#39;t get its MAC address, we are most likely running</span>
<span class="cm">		 * the simulator, so let&#39;s generate a random MAC address.</span>
<span class="cm">		 */</span>
		<span class="n">eth_hw_addr_random</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="cm">/*</span>
<span class="cm"> * Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<span class="cm"> * without having to re-enable interrupts. It&#39;s not called while</span>
<span class="cm"> * the interrupt routine is executing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">disable_percpu_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span><span class="p">);</span>
	<span class="n">tile_net_handle_ingress_interrupt</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">enable_percpu_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">intr_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">tile_net_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> <span class="o">=</span> <span class="n">tile_net_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span> <span class="o">=</span> <span class="n">tile_net_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">tile_net_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span> <span class="o">=</span> <span class="n">tile_net_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span> <span class="o">=</span> <span class="n">tile_net_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span> <span class="o">=</span> <span class="n">tile_net_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span> <span class="o">=</span> <span class="n">tile_net_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> <span class="o">=</span> <span class="n">tile_net_set_mac_address</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span> <span class="o">=</span> <span class="n">tile_net_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * The setup function.</span>
<span class="cm"> *</span>
<span class="cm"> * This uses ether_setup() to assign various fields in dev, including</span>
<span class="cm"> * setting IFF_BROADCAST and IFF_MULTICAST, then sets some extra fields.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PDEBUG</span><span class="p">(</span><span class="s">&quot;tile_net_setup()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ether_setup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tile_net_ops</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TILE_NET_TIMEOUT</span><span class="p">;</span>

	<span class="cm">/* We want lockless xmit. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_LLTX</span><span class="p">;</span>

	<span class="cm">/* We support hardware tx checksums. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_CSUM</span><span class="p">;</span>

	<span class="cm">/* We support scatter/gather. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_SG</span><span class="p">;</span>

	<span class="cm">/* We support TSO. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO</span><span class="p">;</span>

<span class="cp">#ifdef TILE_NET_GSO</span>
	<span class="cm">/* We support GSO. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_GSO</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hash_default</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>

	<span class="cm">/* ISSUE: We should support NETIF_F_UFO. */</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span> <span class="o">=</span> <span class="n">TILE_NET_TX_QUEUE_LEN</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">TILE_NET_MTU</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Allocate the device structure, register the device, and obtain the</span>
<span class="cm"> * MAC address from the hypervisor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">tile_net_dev_init</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate the device structure.  This allocates &quot;priv&quot;, calls</span>
<span class="cm">	 * tile_net_setup(), and saves &quot;name&quot;.  Normally, &quot;name&quot; is a</span>
<span class="cm">	 * template, instantiated by register_netdev(), but not for us.</span>
<span class="cm">	 */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_netdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span> <span class="n">tile_net_setup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;alloc_netdev(%s) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Initialize &quot;priv&quot;. */</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="p">));</span>

	<span class="cm">/* Save &quot;dev&quot; for &quot;tile_net_open_retry()&quot;. */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">retry_work</span><span class="p">,</span> <span class="n">tile_net_open_retry</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_lock</span><span class="p">);</span>

	<span class="cm">/* Allocate &quot;eq&quot;. */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_pages</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="n">EQ_ORDER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_pages</span><span class="p">);</span>

	<span class="cm">/* Register the network device. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;register_netdev %s failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">__free_pages</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_pages</span><span class="p">,</span> <span class="n">EQ_ORDER</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the MAC address. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">tile_net_get_mac</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">__free_pages</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_pages</span><span class="p">,</span> <span class="n">EQ_ORDER</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Module cleanup.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: If compiled as a module, this module cannot be &quot;unloaded&quot;,</span>
<span class="cm"> * because the &quot;ingress interrupt handler&quot; is registered permanently.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TILE_NET_DEVS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tile_net_devs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">tile_net_devs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">finv_buffer_remote</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq</span><span class="p">,</span> <span class="n">EQ_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">__free_pages</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">eq_pages</span><span class="p">,</span> <span class="n">EQ_ORDER</span><span class="p">);</span>
			<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Module initialization.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tilera Network Driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">tile_net_devs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile_net_dev_init</span><span class="p">(</span><span class="s">&quot;xgbe0&quot;</span><span class="p">);</span>
	<span class="n">tile_net_devs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile_net_dev_init</span><span class="p">(</span><span class="s">&quot;xgbe1&quot;</span><span class="p">);</span>
	<span class="n">tile_net_devs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile_net_dev_init</span><span class="p">(</span><span class="s">&quot;gbe0&quot;</span><span class="p">);</span>
	<span class="n">tile_net_devs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile_net_dev_init</span><span class="p">(</span><span class="s">&quot;gbe1&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">module_init</span><span class="p">(</span><span class="n">tile_net_init_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">tile_net_cleanup</span><span class="p">);</span>


<span class="cp">#ifndef MODULE</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;network_cpus&quot; boot argument specifies the cpus that are dedicated</span>
<span class="cm"> * to handle ingress packets.</span>
<span class="cm"> *</span>
<span class="cm"> * The parameter should be in the form &quot;network_cpus=m-n[,x-y]&quot;, where</span>
<span class="cm"> * m, n, x, y are integer numbers that represent the cpus that can be</span>
<span class="cm"> * neither a dedicated cpu nor a dataplane cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">network_cpus_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">cpulist_parse_crop</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">network_cpus_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;network_cpus=%s: malformed cpu list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">str</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/* Remove dedicated cpus. */</span>
		<span class="n">cpumask_and</span><span class="p">(</span><span class="o">&amp;</span><span class="n">network_cpus_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">network_cpus_map</span><span class="p">,</span>
			    <span class="n">cpu_possible_mask</span><span class="p">);</span>


		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">network_cpus_map</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Ignoring network_cpus=&#39;%s&#39;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">str</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
			<span class="n">cpulist_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">network_cpus_map</span><span class="p">);</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Linux network CPUs: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="n">network_cpus_used</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;network_cpus=&quot;</span><span class="p">,</span> <span class="n">network_cpus_setup</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
