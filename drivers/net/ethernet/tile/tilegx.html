<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › tile › tilegx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>tilegx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;      </span><span class="cm">/* printk() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/slab.h&gt;        </span><span class="cm">/* kmalloc() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/errno.h&gt;       </span><span class="cm">/* error codes */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/types.h&gt;       </span><span class="cm">/* size_t */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;   </span><span class="cm">/* struct device, and other headers */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/etherdevice.h&gt; </span><span class="cm">/* eth_type_trans */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/ktime.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>

<span class="cp">#include &lt;asm/checksum.h&gt;</span>
<span class="cp">#include &lt;asm/homecache.h&gt;</span>
<span class="cp">#include &lt;gxio/mpipe.h&gt;</span>
<span class="cp">#include &lt;arch/sim.h&gt;</span>

<span class="cm">/* Default transmit lockup timeout period, in jiffies. */</span>
<span class="cp">#define TILE_NET_TIMEOUT (5 * HZ)</span>

<span class="cm">/* The maximum number of distinct channels (idesc.channel is 5 bits). */</span>
<span class="cp">#define TILE_NET_CHANNELS 32</span>

<span class="cm">/* Maximum number of idescs to handle per &quot;poll&quot;. */</span>
<span class="cp">#define TILE_NET_BATCH 128</span>

<span class="cm">/* Maximum number of packets to handle per &quot;poll&quot;. */</span>
<span class="cp">#define TILE_NET_WEIGHT 64</span>

<span class="cm">/* Number of entries in each iqueue. */</span>
<span class="cp">#define IQUEUE_ENTRIES 512</span>

<span class="cm">/* Number of entries in each equeue. */</span>
<span class="cp">#define EQUEUE_ENTRIES 2048</span>

<span class="cm">/* Total header bytes per equeue slot.  Must be big enough for 2 bytes</span>
<span class="cm"> * of NET_IP_ALIGN alignment, plus 14 bytes (?) of L2 header, plus up to</span>
<span class="cm"> * 60 bytes of actual TCP header.  We round up to align to cache lines.</span>
<span class="cm"> */</span>
<span class="cp">#define HEADER_BYTES 128</span>

<span class="cm">/* Maximum completions per cpu per device (must be a power of two).</span>
<span class="cm"> * ISSUE: What is the right number here?  If this is too small, then</span>
<span class="cm"> * egress might block waiting for free space in a completions array.</span>
<span class="cm"> * ISSUE: At the least, allocate these only for initialized echannels.</span>
<span class="cm"> */</span>
<span class="cp">#define TILE_NET_MAX_COMPS 64</span>

<span class="cp">#define MAX_FRAGS (MAX_SKB_FRAGS + 1)</span>

<span class="cm">/* Size of completions data to allocate.</span>
<span class="cm"> * ISSUE: Probably more than needed since we don&#39;t use all the channels.</span>
<span class="cm"> */</span>
<span class="cp">#define COMPS_SIZE (TILE_NET_CHANNELS * sizeof(struct tile_net_comps))</span>

<span class="cm">/* Size of NotifRing data to allocate. */</span>
<span class="cp">#define NOTIF_RING_SIZE (IQUEUE_ENTRIES * sizeof(gxio_mpipe_idesc_t))</span>

<span class="cm">/* Timeout to wake the per-device TX timer after we stop the queue.</span>
<span class="cm"> * We don&#39;t want the timeout too short (adds overhead, and might end</span>
<span class="cm"> * up causing stop/wake/stop/wake cycles) or too long (affects performance).</span>
<span class="cm"> * For the 10 Gb NIC, 30 usec means roughly 30+ 1500-byte packets.</span>
<span class="cm"> */</span>
<span class="cp">#define TX_TIMER_DELAY_USEC 30</span>

<span class="cm">/* Timeout to wake the per-cpu egress timer to free completions. */</span>
<span class="cp">#define EGRESS_TIMER_DELAY_USEC 1000</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Tilera Corporation&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/* A &quot;packet fragment&quot; (a chunk of memory). */</span>
<span class="k">struct</span> <span class="n">frag</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* A single completion. */</span>
<span class="k">struct</span> <span class="n">tile_net_comp</span> <span class="p">{</span>
	<span class="cm">/* The &quot;complete_count&quot; when the completion will be complete. */</span>
	<span class="n">s64</span> <span class="n">when</span><span class="p">;</span>
	<span class="cm">/* The buffer to be freed when the completion is complete. */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The completions for a given cpu and echannel. */</span>
<span class="k">struct</span> <span class="n">tile_net_comps</span> <span class="p">{</span>
	<span class="cm">/* The completions. */</span>
	<span class="k">struct</span> <span class="n">tile_net_comp</span> <span class="n">comp_queue</span><span class="p">[</span><span class="n">TILE_NET_MAX_COMPS</span><span class="p">];</span>
	<span class="cm">/* The number of completions used. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">comp_next</span><span class="p">;</span>
	<span class="cm">/* The number of completions freed. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">comp_last</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The transmit wake timer for a given cpu and echannel. */</span>
<span class="k">struct</span> <span class="n">tile_net_tx_wake</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Info for a specific cpu. */</span>
<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="p">{</span>
	<span class="cm">/* The NAPI struct. */</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>
	<span class="cm">/* Packet queue. */</span>
	<span class="n">gxio_mpipe_iqueue_t</span> <span class="n">iqueue</span><span class="p">;</span>
	<span class="cm">/* Our cpu. */</span>
	<span class="kt">int</span> <span class="n">my_cpu</span><span class="p">;</span>
	<span class="cm">/* True if iqueue is valid. */</span>
	<span class="n">bool</span> <span class="n">has_iqueue</span><span class="p">;</span>
	<span class="cm">/* NAPI flags. */</span>
	<span class="n">bool</span> <span class="n">napi_added</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">napi_enabled</span><span class="p">;</span>
	<span class="cm">/* Number of small sk_buffs which must still be provided. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_needed_small_buffers</span><span class="p">;</span>
	<span class="cm">/* Number of large sk_buffs which must still be provided. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_needed_large_buffers</span><span class="p">;</span>
	<span class="cm">/* A timer for handling egress completions. */</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="n">egress_timer</span><span class="p">;</span>
	<span class="cm">/* True if &quot;egress_timer&quot; is scheduled. */</span>
	<span class="n">bool</span> <span class="n">egress_timer_scheduled</span><span class="p">;</span>
	<span class="cm">/* Comps for each egress channel. */</span>
	<span class="k">struct</span> <span class="n">tile_net_comps</span> <span class="o">*</span><span class="n">comps_for_echannel</span><span class="p">[</span><span class="n">TILE_NET_CHANNELS</span><span class="p">];</span>
	<span class="cm">/* Transmit wake timer for each egress channel. */</span>
	<span class="k">struct</span> <span class="n">tile_net_tx_wake</span> <span class="n">tx_wake</span><span class="p">[</span><span class="n">TILE_NET_CHANNELS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Info for egress on a particular egress channel. */</span>
<span class="k">struct</span> <span class="n">tile_net_egress</span> <span class="p">{</span>
	<span class="cm">/* The &quot;equeue&quot;. */</span>
	<span class="n">gxio_mpipe_equeue_t</span> <span class="o">*</span><span class="n">equeue</span><span class="p">;</span>
	<span class="cm">/* The headers for TSO. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">headers</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Info for a specific device. */</span>
<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="p">{</span>
	<span class="cm">/* Our network device. */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="cm">/* The primary link. */</span>
	<span class="n">gxio_mpipe_link_t</span> <span class="n">link</span><span class="p">;</span>
	<span class="cm">/* The primary channel, if open, else -1. */</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="cm">/* The &quot;loopify&quot; egress link, if needed. */</span>
	<span class="n">gxio_mpipe_link_t</span> <span class="n">loopify_link</span><span class="p">;</span>
	<span class="cm">/* The &quot;loopify&quot; egress channel, if open, else -1. */</span>
	<span class="kt">int</span> <span class="n">loopify_channel</span><span class="p">;</span>
	<span class="cm">/* The egress channel (channel or loopify_channel). */</span>
	<span class="kt">int</span> <span class="n">echannel</span><span class="p">;</span>
	<span class="cm">/* Total stats. */</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Egress info, indexed by &quot;priv-&gt;echannel&quot; (lazily created as needed). */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tile_net_egress</span> <span class="n">egress_for_echannel</span><span class="p">[</span><span class="n">TILE_NET_CHANNELS</span><span class="p">];</span>

<span class="cm">/* Devices currently associated with each channel.</span>
<span class="cm"> * NOTE: The array entry can become NULL after ifconfig down, but</span>
<span class="cm"> * we do not free the underlying net_device structures, so it is</span>
<span class="cm"> * safe to use a pointer after reading it from this array.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">tile_net_devs_for_channel</span><span class="p">[</span><span class="n">TILE_NET_CHANNELS</span><span class="p">];</span>

<span class="cm">/* A mutex for &quot;tile_net_devs_for_channel&quot;. */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">tile_net_devs_for_channel_mutex</span><span class="p">);</span>

<span class="cm">/* The per-cpu info. */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_info</span><span class="p">,</span> <span class="n">per_cpu_info</span><span class="p">);</span>

<span class="cm">/* The &quot;context&quot; for all devices. */</span>
<span class="k">static</span> <span class="n">gxio_mpipe_context_t</span> <span class="n">context</span><span class="p">;</span>

<span class="cm">/* Buffer sizes and mpipe enum codes for buffer stacks.</span>
<span class="cm"> * See arch/tile/include/gxio/mpipe.h for the set of possible values.</span>
<span class="cm"> */</span>
<span class="cp">#define BUFFER_SIZE_SMALL_ENUM GXIO_MPIPE_BUFFER_SIZE_128</span>
<span class="cp">#define BUFFER_SIZE_SMALL 128</span>
<span class="cp">#define BUFFER_SIZE_LARGE_ENUM GXIO_MPIPE_BUFFER_SIZE_1664</span>
<span class="cp">#define BUFFER_SIZE_LARGE 1664</span>

<span class="cm">/* The small/large &quot;buffer stacks&quot;. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">small_buffer_stack</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">large_buffer_stack</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="cm">/* Amount of memory allocated for each buffer stack. */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="n">buffer_stack_size</span><span class="p">;</span>

<span class="cm">/* The actual memory allocated for the buffer stacks. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">small_buffer_stack_va</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">large_buffer_stack_va</span><span class="p">;</span>

<span class="cm">/* The buckets. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">first_bucket</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/* The ingress irq. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ingress_irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="cm">/* Text value of tile_net.cpus if passed as a module parameter. */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">network_cpus_string</span><span class="p">;</span>

<span class="cm">/* The actual cpus in &quot;network_cpus&quot;. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="n">network_cpus_map</span><span class="p">;</span>

<span class="cm">/* If &quot;loopify=LINK&quot; was specified, this is &quot;LINK&quot;. */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">loopify_link_name</span><span class="p">;</span>

<span class="cm">/* If &quot;tile_net.custom&quot; was specified, this is non-NULL. */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">custom_str</span><span class="p">;</span>

<span class="cm">/* The &quot;tile_net.cpus&quot; argument specifies the cpus that are dedicated</span>
<span class="cm"> * to handle ingress packets.</span>
<span class="cm"> *</span>
<span class="cm"> * The parameter should be in the form &quot;tile_net.cpus=m-n[,x-y]&quot;, where</span>
<span class="cm"> * m, n, x, y are integer numbers that represent the cpus that can be</span>
<span class="cm"> * neither a dedicated cpu nor a dataplane cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">network_cpus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">network_cpus_string</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cpulist_parse_crop</span><span class="p">(</span><span class="n">network_cpus_string</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">network_cpus_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;tile_net.cpus=%s: malformed cpu list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">network_cpus_string</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remove dedicated cpus. */</span>
	<span class="n">cpumask_and</span><span class="p">(</span><span class="o">&amp;</span><span class="n">network_cpus_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">network_cpus_map</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">network_cpus_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Ignoring empty tile_net.cpus=&#39;%s&#39;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">network_cpus_string</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cpulist_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">network_cpus_map</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Linux network CPUs: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="n">network_cpus_string</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="s">&quot;cpulist of cores that handle network interrupts&quot;</span><span class="p">);</span>

<span class="cm">/* The &quot;tile_net.loopify=LINK&quot; argument causes the named device to</span>
<span class="cm"> * actually use &quot;loop0&quot; for ingress, and &quot;loop1&quot; for egress.  This</span>
<span class="cm"> * allows an app to sit between the actual link and linux, passing</span>
<span class="cm"> * (some) packets along to linux, and forwarding (some) packets sent</span>
<span class="cm"> * out by linux.</span>
<span class="cm"> */</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">loopify</span><span class="p">,</span> <span class="n">loopify_link_name</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">loopify</span><span class="p">,</span> <span class="s">&quot;name the device to use loop0/1 for ingress/egress&quot;</span><span class="p">);</span>

<span class="cm">/* The &quot;tile_net.custom&quot; argument causes us to ignore the &quot;conventional&quot;</span>
<span class="cm"> * classifier metadata, in particular, the &quot;l2_offset&quot;.</span>
<span class="cm"> */</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">custom</span><span class="p">,</span> <span class="n">custom_str</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">custom</span><span class="p">,</span> <span class="s">&quot;indicates a (heavily) customized classifier&quot;</span><span class="p">);</span>

<span class="cm">/* Atomically update a statistics field.</span>
<span class="cm"> * Note that on TILE-Gx, this operation is fire-and-forget on the</span>
<span class="cm"> * issuing core (single-cycle dispatch) and takes only a few cycles</span>
<span class="cm"> * longer than a regular store when the request reaches the home cache.</span>
<span class="cm"> * No expensive bus management overhead is required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_stats_add</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">atomic_long_t</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
	<span class="n">atomic_long_add</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">atomic_long_t</span> <span class="o">*</span><span class="p">)</span><span class="n">field</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Allocate and push a buffer. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tile_net_provide_buffer</span><span class="p">(</span><span class="n">bool</span> <span class="n">small</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">small</span> <span class="o">?</span> <span class="n">small_buffer_stack</span> <span class="o">:</span> <span class="n">large_buffer_stack</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer_alignment</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="p">)</span> <span class="o">+</span> <span class="n">buffer_alignment</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">small</span> <span class="o">?</span> <span class="n">BUFFER_SIZE_SMALL</span> <span class="o">:</span> <span class="n">BUFFER_SIZE_LARGE</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Make room for a back-pointer to &#39;skb&#39; and guarantee alignment. */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="p">));</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">buffer_alignment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* Save a back-pointer to &#39;skb&#39;. */</span>
	<span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="p">))</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* Make sure &quot;skb&quot; and the back-pointer have been flushed. */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">gxio_mpipe_push_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">va_to_tile_io_addr</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert a raw mpipe buffer to its matching skb pointer. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">mpipe_buf_to_skb</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Acquire the associated &quot;skb&quot;. */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">skb_ptr</span> <span class="o">=</span> <span class="n">va</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">skb_ptr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="o">*</span><span class="n">skb_ptr</span><span class="p">;</span>

	<span class="cm">/* Paranoia. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">va</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Panic here since there&#39;s a reasonable chance</span>
<span class="cm">		 * that corrupt buffers means generic memory</span>
<span class="cm">		 * corruption, with unpredictable system effects.</span>
<span class="cm">		 */</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Corrupt linux buffer! va=%p, skb=%p, skb-&gt;data=%p&quot;</span><span class="p">,</span>
		      <span class="n">va</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_pop_all_buffers</span><span class="p">(</span><span class="kt">int</span> <span class="n">stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">tile_io_addr_t</span> <span class="n">addr</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">tile_io_addr_t</span><span class="p">)</span><span class="n">gxio_mpipe_pop_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">stack</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">mpipe_buf_to_skb</span><span class="p">(</span><span class="n">tile_io_addr_to_va</span><span class="p">(</span><span class="n">addr</span><span class="p">)));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Provide linux buffers to mPIPE. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_provide_needed_buffers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_small_buffers</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tile_net_provide_buffer</span><span class="p">(</span><span class="nb">true</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">oops</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_small_buffers</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_large_buffers</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tile_net_provide_buffer</span><span class="p">(</span><span class="nb">false</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">oops</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_large_buffers</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">oops:</span>
	<span class="cm">/* Add a description to the page allocation failure dump. */</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Tile %d still needs some buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">my_cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">filter_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Filter packets received before we&#39;re up. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Filter out packets that aren&#39;t for us. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">is_multicast_ether_addr</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">compare_ether_addr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_receive_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="n">gxio_mpipe_idesc_t</span> <span class="o">*</span><span class="n">idesc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Encode the actual packet length. */</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Acknowledge &quot;good&quot; hardware checksums. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idesc</span><span class="o">-&gt;</span><span class="n">cs</span> <span class="o">&amp;&amp;</span> <span class="n">idesc</span><span class="o">-&gt;</span><span class="n">csum_seed_val</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>

	<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Update stats. */</span>
	<span class="n">tile_net_stats_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="p">);</span>
	<span class="n">tile_net_stats_add</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span><span class="p">);</span>

	<span class="cm">/* Need a new buffer. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idesc</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">BUFFER_SIZE_SMALL_ENUM</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_small_buffers</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_needed_large_buffers</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle a packet.  Return true if &quot;processed&quot;, false if &quot;filtered&quot;. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tile_net_handle_packet</span><span class="p">(</span><span class="n">gxio_mpipe_idesc_t</span> <span class="o">*</span><span class="n">idesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">tile_net_devs_for_channel</span><span class="p">[</span><span class="n">idesc</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">l2_offset</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">filter</span><span class="p">;</span>

	<span class="cm">/* Drop packets for which no buffer was available.</span>
<span class="cm">	 * NOTE: This happens under heavy load.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idesc</span><span class="o">-&gt;</span><span class="n">be</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">tile_net_stats_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="p">);</span>
		<span class="n">gxio_mpipe_iqueue_consume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">iqueue</span><span class="p">,</span> <span class="n">idesc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Dropping packet (insufficient buffers).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the &quot;l2_offset&quot;, if allowed. */</span>
	<span class="n">l2_offset</span> <span class="o">=</span> <span class="n">custom_str</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">gxio_mpipe_idesc_get_l2_offset</span><span class="p">(</span><span class="n">idesc</span><span class="p">);</span>

	<span class="cm">/* Get the raw buffer VA (includes &quot;headroom&quot;). */</span>
	<span class="n">va</span> <span class="o">=</span> <span class="n">tile_io_addr_to_va</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">idesc</span><span class="o">-&gt;</span><span class="n">va</span><span class="p">);</span>

	<span class="cm">/* Get the actual packet start/length. */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">va</span> <span class="o">+</span> <span class="n">l2_offset</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">idesc</span><span class="o">-&gt;</span><span class="n">l2_size</span> <span class="o">-</span> <span class="n">l2_offset</span><span class="p">;</span>

	<span class="cm">/* Point &quot;va&quot; at the raw buffer. */</span>
	<span class="n">va</span> <span class="o">-=</span> <span class="n">NET_IP_ALIGN</span><span class="p">;</span>

	<span class="n">filter</span> <span class="o">=</span> <span class="n">filter_packet</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gxio_mpipe_iqueue_drop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">iqueue</span><span class="p">,</span> <span class="n">idesc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">mpipe_buf_to_skb</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>

		<span class="cm">/* Skip headroom, and any custom header. */</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span> <span class="o">+</span> <span class="n">l2_offset</span><span class="p">);</span>

		<span class="n">tile_net_receive_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">idesc</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">gxio_mpipe_iqueue_consume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">iqueue</span><span class="p">,</span> <span class="n">idesc</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">filter</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle some packets for the current CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * This function handles up to TILE_NET_BATCH idescs per call.</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: Since we do not provide new buffers until this function is</span>
<span class="cm"> * complete, we must initially provide enough buffers for each network</span>
<span class="cm"> * cpu to fill its iqueue and also its batched idescs.</span>
<span class="cm"> *</span>
<span class="cm"> * ISSUE: The &quot;rotting packet&quot; race condition occurs if a packet</span>
<span class="cm"> * arrives after the queue appears to be empty, and before the</span>
<span class="cm"> * hypervisor interrupt is re-enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">work</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">gxio_mpipe_idesc_t</span> <span class="o">*</span><span class="n">idesc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* Process packets. */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">gxio_mpipe_iqueue_try_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">iqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idesc</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">TILE_NET_BATCH</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tile_net_handle_packet</span><span class="p">(</span><span class="n">idesc</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">work</span> <span class="o">&gt;=</span> <span class="n">budget</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* There are no packets left. */</span>
	<span class="n">napi_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="cm">/* Re-enable hypervisor interrupts. */</span>
	<span class="n">gxio_mpipe_enable_notif_ring_interrupt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">iqueue</span><span class="p">.</span><span class="n">ring</span><span class="p">);</span>

	<span class="cm">/* HACK: Avoid the &quot;rotting packet&quot; problem. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gxio_mpipe_iqueue_try_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">iqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idesc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="cm">/* ISSUE: Handle completions? */</span>

<span class="nl">done:</span>
	<span class="n">tile_net_provide_needed_buffers</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">work</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle an ingress interrupt on the current cpu. */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">tile_net_handle_ingress_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>
	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free some completions.  This must be called with interrupts blocked. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_free_comps</span><span class="p">(</span><span class="n">gxio_mpipe_equeue_t</span> <span class="o">*</span><span class="n">equeue</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tile_net_comps</span> <span class="o">*</span><span class="n">comps</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">limit</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force_update</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_last</span> <span class="o">&lt;</span> <span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cid</span> <span class="o">=</span> <span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_last</span> <span class="o">%</span> <span class="n">TILE_NET_MAX_COMPS</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">tile_net_comp</span> <span class="o">*</span><span class="n">comp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_queue</span><span class="p">[</span><span class="n">cid</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gxio_mpipe_equeue_is_complete</span><span class="p">(</span><span class="n">equeue</span><span class="p">,</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">when</span><span class="p">,</span>
						   <span class="n">force_update</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_last</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">n</span> <span class="o">==</span> <span class="n">limit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add a completion.  This must be called with interrupts blocked.</span>
<span class="cm"> * tile_net_equeue_try_reserve() will have ensured a free completion entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_comp</span><span class="p">(</span><span class="n">gxio_mpipe_equeue_t</span> <span class="o">*</span><span class="n">equeue</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">tile_net_comps</span> <span class="o">*</span><span class="n">comps</span><span class="p">,</span>
		     <span class="kt">uint64_t</span> <span class="n">when</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cid</span> <span class="o">=</span> <span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_next</span> <span class="o">%</span> <span class="n">TILE_NET_MAX_COMPS</span><span class="p">;</span>
	<span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_queue</span><span class="p">[</span><span class="n">cid</span><span class="p">].</span><span class="n">when</span> <span class="o">=</span> <span class="n">when</span><span class="p">;</span>
	<span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_queue</span><span class="p">[</span><span class="n">cid</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_next</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_schedule_tx_wake_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_wake</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span><span class="p">].</span><span class="n">timer</span><span class="p">,</span>
		      <span class="n">ktime_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">TX_TIMER_DELAY_USEC</span> <span class="o">*</span> <span class="mi">1000UL</span><span class="p">),</span>
		      <span class="n">HRTIMER_MODE_REL_PINNED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">tile_net_handle_tx_wake_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_tx_wake</span> <span class="o">*</span><span class="n">tx_wake</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tile_net_tx_wake</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>
	<span class="n">netif_wake_subqueue</span><span class="p">(</span><span class="n">tx_wake</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Make sure the egress timer is scheduled. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_schedule_egress_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer_scheduled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer</span><span class="p">,</span>
			      <span class="n">ktime_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EGRESS_TIMER_DELAY_USEC</span> <span class="o">*</span> <span class="mi">1000UL</span><span class="p">),</span>
			      <span class="n">HRTIMER_MODE_REL_PINNED</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer_scheduled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* The &quot;function&quot; for &quot;info-&gt;egress_timer&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * This timer will reschedule itself as long as there are any pending</span>
<span class="cm"> * completions expected for this tile.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">tile_net_handle_egress_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/* The timer is no longer scheduled. */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer_scheduled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Free all possible comps for this tile. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TILE_NET_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tile_net_egress</span> <span class="o">*</span><span class="n">egress</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">egress_for_echannel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">tile_net_comps</span> <span class="o">*</span><span class="n">comps</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">comps_for_echannel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_last</span> <span class="o">&gt;=</span> <span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_next</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">tile_net_free_comps</span><span class="p">(</span><span class="n">egress</span><span class="o">-&gt;</span><span class="n">equeue</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">pending</span> <span class="o">=</span> <span class="n">pending</span> <span class="o">||</span> <span class="p">(</span><span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_last</span> <span class="o">&lt;</span> <span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_next</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Reschedule timer if needed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pending</span><span class="p">)</span>
		<span class="n">tile_net_schedule_egress_timer</span><span class="p">();</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">irqflags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper function for &quot;tile_net_update()&quot;.</span>
<span class="cm"> * &quot;dev&quot; (i.e. arg) is the device being brought up or down,</span>
<span class="cm"> * or NULL if all devices are now down.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_update_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">has_iqueue</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi_added</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span>
				       <span class="n">tile_net_poll</span><span class="p">,</span> <span class="n">TILE_NET_WEIGHT</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">napi_added</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">napi_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">enable_percpu_irq</span><span class="p">(</span><span class="n">ingress_irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">disable_percpu_irq</span><span class="p">(</span><span class="n">ingress_irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">napi_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIXME: Drain the iqueue. */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Helper function for tile_net_open() and tile_net_stop().</span>
<span class="cm"> * Always called under tile_net_devs_for_channel_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">gxio_mpipe_rules_t</span> <span class="n">rules</span><span class="p">;</span>  <span class="cm">/* too big to fit on the stack */</span>
	<span class="n">bool</span> <span class="n">saw_channel</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">gxio_mpipe_rules_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">channel</span> <span class="o">&lt;</span> <span class="n">TILE_NET_CHANNELS</span><span class="p">;</span> <span class="n">channel</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tile_net_devs_for_channel</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">saw_channel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">saw_channel</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">gxio_mpipe_rules_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rules</span><span class="p">,</span> <span class="n">first_bucket</span><span class="p">,</span>
					       <span class="n">num_buckets</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">gxio_mpipe_rules_set_headroom</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rules</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">gxio_mpipe_rules_add_channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rules</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* NOTE: This can fail if there is no classifier.</span>
<span class="cm">	 * ISSUE: Can anything else cause it to fail?</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_rules_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rules</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gxio_mpipe_rules_commit failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update all cpus, sequentially (to protect &quot;netif_napi_add()&quot;). */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tile_net_update_cpu</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">saw_channel</span> <span class="o">?</span> <span class="n">dev</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* HACK: Allow packets to flow in the simulator. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">saw_channel</span><span class="p">)</span>
		<span class="n">sim_enable_mpipe_links</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate and initialize mpipe buffer stacks, and register them in</span>
<span class="cm"> * the mPIPE TLBs, for both small and large packet sizes.</span>
<span class="cm"> * This routine supports tile_net_init_mpipe(), below.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_buffer_stacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_buffers</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">hash_pte</span> <span class="o">=</span> <span class="n">pte_set_home</span><span class="p">((</span><span class="n">pte_t</span><span class="p">)</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">},</span> <span class="n">PAGE_HOME_HASH</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Compute stack bytes; we round up to 64KB and then use</span>
<span class="cm">	 * alloc_pages() so we get the required 64KB alignment as well.</span>
<span class="cm">	 */</span>
	<span class="n">buffer_stack_size</span> <span class="o">=</span>
		<span class="n">ALIGN</span><span class="p">(</span><span class="n">gxio_mpipe_calc_buffer_stack_bytes</span><span class="p">(</span><span class="n">num_buffers</span><span class="p">),</span>
		      <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>

	<span class="cm">/* Allocate two buffer stack indices. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_alloc_buffer_stacks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gxio_mpipe_alloc_buffer_stacks failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">small_buffer_stack</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">large_buffer_stack</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Allocate the small memory stack. */</span>
	<span class="n">small_buffer_stack_va</span> <span class="o">=</span>
		<span class="n">alloc_pages_exact</span><span class="p">(</span><span class="n">buffer_stack_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">small_buffer_stack_va</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;Could not alloc %zd bytes for buffer stacks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">buffer_stack_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_init_buffer_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">small_buffer_stack</span><span class="p">,</span>
					  <span class="n">BUFFER_SIZE_SMALL_ENUM</span><span class="p">,</span>
					  <span class="n">small_buffer_stack_va</span><span class="p">,</span>
					  <span class="n">buffer_stack_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gxio_mpipe_init_buffer_stack: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_register_client_memory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">small_buffer_stack</span><span class="p">,</span>
					       <span class="n">hash_pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;gxio_mpipe_register_buffer_memory failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate the large buffer stack. */</span>
	<span class="n">large_buffer_stack_va</span> <span class="o">=</span>
		<span class="n">alloc_pages_exact</span><span class="p">(</span><span class="n">buffer_stack_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">large_buffer_stack_va</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;Could not alloc %zd bytes for buffer stacks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">buffer_stack_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_init_buffer_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">large_buffer_stack</span><span class="p">,</span>
					  <span class="n">BUFFER_SIZE_LARGE_ENUM</span><span class="p">,</span>
					  <span class="n">large_buffer_stack_va</span><span class="p">,</span>
					  <span class="n">buffer_stack_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gxio_mpipe_init_buffer_stack failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_register_client_memory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">large_buffer_stack</span><span class="p">,</span>
					       <span class="n">hash_pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;gxio_mpipe_register_buffer_memory failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate per-cpu resources (memory for completions and idescs).</span>
<span class="cm"> * This routine supports tile_net_init_mpipe(), below.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_percpu_mpipe_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="cm">/* Allocate the &quot;comps&quot;. */</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">COMPS_SIZE</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">homecache_alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to alloc %zd bytes comps memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">COMPS_SIZE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">COMPS_SIZE</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TILE_NET_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">comps_for_echannel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_net_comps</span><span class="p">);</span>

	<span class="cm">/* If this is a network cpu, create an iqueue. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_isset</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">network_cpus_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">NOTIF_RING_SIZE</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">homecache_alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				   <span class="s">&quot;Failed to alloc %zd bytes iqueue memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">NOTIF_RING_SIZE</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_iqueue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">iqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">ring</span><span class="o">++</span><span class="p">,</span>
					    <span class="n">addr</span><span class="p">,</span> <span class="n">NOTIF_RING_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				   <span class="s">&quot;gxio_mpipe_iqueue_init failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">has_iqueue</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ring</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize NotifGroup and buckets.</span>
<span class="cm"> * This routine supports tile_net_init_mpipe(), below.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_notif_group_and_buckets</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">network_cpus_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Allocate one NotifGroup. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_alloc_notif_groups</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gxio_mpipe_alloc_notif_groups failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">group</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Initialize global num_buckets value. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">network_cpus_count</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">network_cpus_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">num_buckets</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* Allocate some buckets, and set global first_bucket value. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_alloc_buckets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">num_buckets</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gxio_mpipe_alloc_buckets failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">first_bucket</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Init group and buckets. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_init_notif_group_and_buckets</span><span class="p">(</span>
		<span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">network_cpus_count</span><span class="p">,</span>
		<span class="n">first_bucket</span><span class="p">,</span> <span class="n">num_buckets</span><span class="p">,</span>
		<span class="n">GXIO_MPIPE_BUCKET_STICKY_FLOW_LOCALITY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span>
			<span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;gxio_mpipe_init_notif_group_and_buckets failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create an irq and register it, then activate the irq and request</span>
<span class="cm"> * interrupts on all cores.  Note that &quot;ingress_irq&quot; being initialized</span>
<span class="cm"> * is how we know not to call tile_net_init_mpipe() again.</span>
<span class="cm"> * This routine supports tile_net_init_mpipe(), below.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_setup_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">create_irq</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;create_irq failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ingress_irq</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">tile_irq_activate</span><span class="p">(</span><span class="n">ingress_irq</span><span class="p">,</span> <span class="n">TILE_IRQ_PERCPU</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">ingress_irq</span><span class="p">,</span> <span class="n">tile_net_handle_ingress_irq</span><span class="p">,</span>
			 <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request_irq failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">destroy_irq</span><span class="p">(</span><span class="n">ingress_irq</span><span class="p">);</span>
		<span class="n">ingress_irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">has_iqueue</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gxio_mpipe_request_notif_ring_interrupt</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">cpu_x</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">cpu_y</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span>
				<span class="mi">1</span><span class="p">,</span> <span class="n">ingress_irq</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">iqueue</span><span class="p">.</span><span class="n">ring</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Undo any state set up partially by a failed call to tile_net_init_mpipe. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_init_mpipe_fail</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* Do cleanups that require the mpipe context first. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">small_buffer_stack</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tile_net_pop_all_buffers</span><span class="p">(</span><span class="n">small_buffer_stack</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">large_buffer_stack</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tile_net_pop_all_buffers</span><span class="p">(</span><span class="n">large_buffer_stack</span><span class="p">);</span>

	<span class="cm">/* Destroy mpipe context so the hardware no longer owns any memory. */</span>
	<span class="n">gxio_mpipe_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">comps_for_echannel</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			   <span class="n">get_order</span><span class="p">(</span><span class="n">COMPS_SIZE</span><span class="p">));</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">comps_for_echannel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">iqueue</span><span class="p">.</span><span class="n">idescs</span><span class="p">),</span>
			   <span class="n">get_order</span><span class="p">(</span><span class="n">NOTIF_RING_SIZE</span><span class="p">));</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">iqueue</span><span class="p">.</span><span class="n">idescs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">small_buffer_stack_va</span><span class="p">)</span>
		<span class="n">free_pages_exact</span><span class="p">(</span><span class="n">small_buffer_stack_va</span><span class="p">,</span> <span class="n">buffer_stack_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">large_buffer_stack_va</span><span class="p">)</span>
		<span class="n">free_pages_exact</span><span class="p">(</span><span class="n">large_buffer_stack_va</span><span class="p">,</span> <span class="n">buffer_stack_size</span><span class="p">);</span>

	<span class="n">small_buffer_stack_va</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">large_buffer_stack_va</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">large_buffer_stack</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">small_buffer_stack</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">first_bucket</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The first time any tilegx network device is opened, we initialize</span>
<span class="cm"> * the global mpipe state.  If this step fails, we fail to open the</span>
<span class="cm"> * device, but if it succeeds, we never need to do it again, and since</span>
<span class="cm"> * tile_net can&#39;t be unloaded, we never undo it.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that some resources in this path (buffer stack indices,</span>
<span class="cm"> * bindings from init_buffer_stack, etc.) are hypervisor resources</span>
<span class="cm"> * that are freed implicitly by gxio_mpipe_destroy().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_init_mpipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_buffers</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_ring</span><span class="p">,</span> <span class="n">ring</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">network_cpus_count</span> <span class="o">=</span> <span class="n">cpus_weight</span><span class="p">(</span><span class="n">network_cpus_map</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash_default</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Networking requires hash_default!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gxio_mpipe_init failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up the buffer stacks. */</span>
	<span class="n">num_buffers</span> <span class="o">=</span>
		<span class="n">network_cpus_count</span> <span class="o">*</span> <span class="p">(</span><span class="n">IQUEUE_ENTRIES</span> <span class="o">+</span> <span class="n">TILE_NET_BATCH</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">init_buffer_stacks</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">num_buffers</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* Provide initial buffers. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_buffers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tile_net_provide_buffer</span><span class="p">(</span><span class="nb">true</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot allocate initial sk_bufs!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_buffers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tile_net_provide_buffer</span><span class="p">(</span><span class="nb">false</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot allocate initial sk_bufs!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate one NotifRing for each network cpu. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_alloc_notif_rings</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">network_cpus_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gxio_mpipe_alloc_notif_rings failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Init NotifRings per-cpu. */</span>
	<span class="n">first_ring</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">ring</span> <span class="o">=</span> <span class="n">first_ring</span><span class="p">;</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">alloc_percpu_mpipe_resources</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">ring</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize NotifGroup and buckets. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">init_notif_group_and_buckets</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">first_ring</span><span class="p">,</span> <span class="n">network_cpus_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* Create and enable interrupts. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">tile_net_setup_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">tile_net_init_mpipe_fail</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create persistent egress info for a given egress channel.</span>
<span class="cm"> * Note that this may be shared between, say, &quot;gbe0&quot; and &quot;xgbe0&quot;.</span>
<span class="cm"> * ISSUE: Defer header allocation until TSO is actually needed?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_init_egress</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">echannel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">headers_page</span><span class="p">,</span> <span class="o">*</span><span class="n">edescs_page</span><span class="p">,</span> <span class="o">*</span><span class="n">equeue_page</span><span class="p">;</span>
	<span class="n">gxio_mpipe_edesc_t</span> <span class="o">*</span><span class="n">edescs</span><span class="p">;</span>
	<span class="n">gxio_mpipe_equeue_t</span> <span class="o">*</span><span class="n">equeue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">headers</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">headers_order</span><span class="p">,</span> <span class="n">edescs_order</span><span class="p">,</span> <span class="n">equeue_order</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">edescs_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">edma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Only initialize once. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">egress_for_echannel</span><span class="p">[</span><span class="n">echannel</span><span class="p">].</span><span class="n">equeue</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for the &quot;headers&quot;. */</span>
	<span class="n">headers_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">EQUEUE_ENTRIES</span> <span class="o">*</span> <span class="n">HEADER_BYTES</span><span class="p">);</span>
	<span class="n">headers_page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">headers_order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">headers_page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			    <span class="s">&quot;Could not alloc %zd bytes for TSO headers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">headers_order</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">headers</span> <span class="o">=</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">headers_page</span><span class="p">));</span>

	<span class="cm">/* Allocate memory for the &quot;edescs&quot;. */</span>
	<span class="n">edescs_size</span> <span class="o">=</span> <span class="n">EQUEUE_ENTRIES</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">edescs</span><span class="p">);</span>
	<span class="n">edescs_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">edescs_size</span><span class="p">);</span>
	<span class="n">edescs_page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">edescs_order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edescs_page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			    <span class="s">&quot;Could not alloc %zd bytes for eDMA ring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">edescs_size</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_headers</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">edescs</span> <span class="o">=</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">edescs_page</span><span class="p">));</span>

	<span class="cm">/* Allocate memory for the &quot;equeue&quot;. */</span>
	<span class="n">equeue_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">equeue</span><span class="p">));</span>
	<span class="n">equeue_page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">equeue_order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">equeue_page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			    <span class="s">&quot;Could not alloc %zd bytes for equeue info.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">equeue_order</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_edescs</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">equeue</span> <span class="o">=</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">equeue_page</span><span class="p">));</span>

	<span class="cm">/* Allocate an edma ring.  Note that in practice this can&#39;t</span>
<span class="cm">	 * fail, which is good, because we will leak an edma ring if so.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_alloc_edma_rings</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gxio_mpipe_alloc_edma_rings failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_equeue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">edma</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Initialize the equeue. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_equeue_init</span><span class="p">(</span><span class="n">equeue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">edma</span><span class="p">,</span> <span class="n">echannel</span><span class="p">,</span>
				    <span class="n">edescs</span><span class="p">,</span> <span class="n">edescs_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gxio_mpipe_equeue_init failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_equeue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Done. */</span>
	<span class="n">egress_for_echannel</span><span class="p">[</span><span class="n">echannel</span><span class="p">].</span><span class="n">equeue</span> <span class="o">=</span> <span class="n">equeue</span><span class="p">;</span>
	<span class="n">egress_for_echannel</span><span class="p">[</span><span class="n">echannel</span><span class="p">].</span><span class="n">headers</span> <span class="o">=</span> <span class="n">headers</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_equeue:</span>
	<span class="n">__free_pages</span><span class="p">(</span><span class="n">equeue_page</span><span class="p">,</span> <span class="n">equeue_order</span><span class="p">);</span>

<span class="nl">fail_edescs:</span>
	<span class="n">__free_pages</span><span class="p">(</span><span class="n">edescs_page</span><span class="p">,</span> <span class="n">edescs_order</span><span class="p">);</span>

<span class="nl">fail_headers:</span>
	<span class="n">__free_pages</span><span class="p">(</span><span class="n">headers_page</span><span class="p">,</span> <span class="n">headers_order</span><span class="p">);</span>

<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return channel number for a newly-opened link. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_link_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">gxio_mpipe_link_t</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">link_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_link_open</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">link_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to open &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">link_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">gxio_mpipe_link_channel</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rc</span> <span class="o">&gt;=</span> <span class="n">TILE_NET_CHANNELS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gxio_mpipe_link_channel bad value: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">gxio_mpipe_link_close</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Help the kernel activate the given network interface. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tile_net_devs_for_channel_mutex</span><span class="p">);</span>

	<span class="cm">/* Do one-time initialization the first time any device is opened. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ingress_irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">tile_net_init_mpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Determine if this is the &quot;loopify&quot; device. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">loopify_link_name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">loopify_link_name</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">tile_net_link_open</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="s">&quot;loop0&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">tile_net_link_open</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">loopify_link</span><span class="p">,</span> <span class="s">&quot;loop1&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">loopify_channel</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">tile_net_link_open</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize egress info (if needed).  Once ever, per echannel. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">tile_net_init_egress</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">tile_net_devs_for_channel</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">tile_net_update</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tile_net_devs_for_channel_mutex</span><span class="p">);</span>

	<span class="cm">/* Initialize the transmit wake timer for this device for each cpu. */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">tile_net_tx_wake</span> <span class="o">*</span><span class="n">tx_wake</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_wake</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span><span class="p">];</span>

		<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_wake</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span>
			     <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
		<span class="n">tx_wake</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">tile_net_handle_tx_wake_timer</span><span class="p">;</span>
		<span class="n">tx_wake</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">netif_start_subqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">loopify_channel</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gxio_mpipe_link_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">loopify_link</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to close loopify link!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">loopify_channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gxio_mpipe_link_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to close link!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">tile_net_devs_for_channel</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tile_net_devs_for_channel_mutex</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t return raw gxio error codes to generic Linux. */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">512</span><span class="p">)</span> <span class="o">?</span> <span class="n">rc</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Help the kernel deactivate the given network interface. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">tile_net_tx_wake</span> <span class="o">*</span><span class="n">tx_wake</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_wake</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span><span class="p">];</span>

		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_wake</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">netif_stop_subqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tile_net_devs_for_channel_mutex</span><span class="p">);</span>
	<span class="n">tile_net_devs_for_channel</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">tile_net_update</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">loopify_channel</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gxio_mpipe_link_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">loopify_link</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to close loopify link!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">loopify_channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gxio_mpipe_link_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to close link!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tile_net_devs_for_channel_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Determine the VA for a fragment. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">tile_net_frag_buf</span><span class="p">(</span><span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">pfn</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Acquire a completion entry and an egress slot, or if we can&#39;t,</span>
<span class="cm"> * stop the queue and schedule the tx_wake timer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s64</span> <span class="nf">tile_net_equeue_try_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">tile_net_comps</span> <span class="o">*</span><span class="n">comps</span><span class="p">,</span>
				       <span class="n">gxio_mpipe_equeue_t</span> <span class="o">*</span><span class="n">equeue</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">num_edescs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Try to acquire a completion entry. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_next</span> <span class="o">-</span> <span class="n">comps</span><span class="o">-&gt;</span><span class="n">comp_last</span> <span class="o">&lt;</span> <span class="n">TILE_NET_MAX_COMPS</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span>
	    <span class="n">tile_net_free_comps</span><span class="p">(</span><span class="n">equeue</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Try to acquire an egress slot. */</span>
		<span class="n">s64</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">gxio_mpipe_equeue_try_reserve</span><span class="p">(</span><span class="n">equeue</span><span class="p">,</span> <span class="n">num_edescs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">slot</span><span class="p">;</span>

		<span class="cm">/* Freeing some completions gives the equeue time to drain. */</span>
		<span class="n">tile_net_free_comps</span><span class="p">(</span><span class="n">equeue</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">TILE_NET_MAX_COMPS</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

		<span class="n">slot</span> <span class="o">=</span> <span class="n">gxio_mpipe_equeue_try_reserve</span><span class="p">(</span><span class="n">equeue</span><span class="p">,</span> <span class="n">num_edescs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">slot</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Still nothing; give up and stop the queue for a short while. */</span>
	<span class="n">netif_stop_subqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">tile_net_schedule_tx_wake_timer</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Determine how many edesc&#39;s are needed for TSO.</span>
<span class="cm"> *</span>
<span class="cm"> * Sometimes, if &quot;sendfile()&quot; requires copying, we will be called with</span>
<span class="cm"> * &quot;data&quot; containing the header and payload, with &quot;frags&quot; being empty.</span>
<span class="cm"> * Sometimes, for example when using NFS over TCP, a single segment can</span>
<span class="cm"> * span 3 fragments.  This requires special care.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tso_count_edescs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p_len</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">f_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>    <span class="cm">/* id of the current fragment */</span>
	<span class="kt">long</span> <span class="n">f_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* size of the current fragment */</span>
	<span class="kt">long</span> <span class="n">f_used</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* bytes used from the current fragment */</span>
	<span class="kt">long</span> <span class="n">n</span><span class="p">;</span>            <span class="cm">/* size of the current piece of payload */</span>
	<span class="kt">int</span> <span class="n">num_edescs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">segment</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">segment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">segment</span> <span class="o">&lt;</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">gso_segs</span><span class="p">;</span> <span class="n">segment</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* One edesc for header and for each piece of the payload. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">num_edescs</span><span class="o">++</span><span class="p">;</span> <span class="n">p_used</span> <span class="o">&lt;</span> <span class="n">p_len</span><span class="p">;</span> <span class="n">num_edescs</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Advance as needed. */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">f_used</span> <span class="o">&gt;=</span> <span class="n">f_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">f_id</span><span class="o">++</span><span class="p">;</span>
				<span class="n">f_size</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f_id</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
				<span class="n">f_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Use bytes from the current fragment. */</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">p_len</span> <span class="o">-</span> <span class="n">p_used</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">f_size</span> <span class="o">-</span> <span class="n">f_used</span><span class="p">)</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">f_size</span> <span class="o">-</span> <span class="n">f_used</span><span class="p">;</span>
			<span class="n">f_used</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">p_used</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* The last segment may be less than gso_size. */</span>
		<span class="n">data_len</span> <span class="o">-=</span> <span class="n">p_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">&lt;</span> <span class="n">p_len</span><span class="p">)</span>
			<span class="n">p_len</span> <span class="o">=</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">num_edescs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Prepare modified copies of the skbuff headers.</span>
<span class="cm"> * FIXME: add support for IPv6.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tso_headers_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">headers</span><span class="p">,</span>
				<span class="n">s64</span> <span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ih_off</span><span class="p">,</span> <span class="n">th_off</span><span class="p">,</span> <span class="n">sh_len</span><span class="p">,</span> <span class="n">p_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">isum_seed</span><span class="p">,</span> <span class="n">tsum_seed</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">f_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>    <span class="cm">/* id of the current fragment */</span>
	<span class="kt">long</span> <span class="n">f_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* size of the current fragment */</span>
	<span class="kt">long</span> <span class="n">f_used</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* bytes used from the current fragment */</span>
	<span class="kt">long</span> <span class="n">n</span><span class="p">;</span>            <span class="cm">/* size of the current piece of payload */</span>
	<span class="kt">int</span> <span class="n">segment</span><span class="p">;</span>

	<span class="cm">/* Locate original headers and compute various lengths. */</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ih_off</span> <span class="o">=</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">th_off</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">sh_len</span> <span class="o">=</span> <span class="n">th_off</span> <span class="o">+</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">p_len</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>

	<span class="cm">/* Set up seed values for IP and TCP csum and initialize id and seq. */</span>
	<span class="n">isum_seed</span> <span class="o">=</span> <span class="p">((</span><span class="mh">0xFFFF</span> <span class="o">-</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">)</span> <span class="o">+</span>
		     <span class="p">(</span><span class="mh">0xFFFF</span> <span class="o">-</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">tot_len</span><span class="p">)</span> <span class="o">+</span>
		     <span class="p">(</span><span class="mh">0xFFFF</span> <span class="o">-</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">));</span>
	<span class="n">tsum_seed</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">+</span> <span class="p">(</span><span class="mh">0xFFFF</span> <span class="o">^</span> <span class="n">htons</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>
	<span class="n">id</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>

	<span class="cm">/* Prepare all the headers. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">segment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">segment</span> <span class="o">&lt;</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">gso_segs</span><span class="p">;</span> <span class="n">segment</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Copy to the header memory for this segment. */</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">headers</span> <span class="o">+</span> <span class="p">(</span><span class="n">slot</span> <span class="o">%</span> <span class="n">EQUEUE_ENTRIES</span><span class="p">)</span> <span class="o">*</span> <span class="n">HEADER_BYTES</span> <span class="o">+</span>
			<span class="n">NET_IP_ALIGN</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sh_len</span><span class="p">);</span>

		<span class="cm">/* Update copied ip header. */</span>
		<span class="n">ih</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">ih_off</span><span class="p">);</span>
		<span class="n">ih</span><span class="o">-&gt;</span><span class="n">tot_len</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">sh_len</span> <span class="o">+</span> <span class="n">p_len</span> <span class="o">-</span> <span class="n">ih_off</span><span class="p">);</span>
		<span class="n">ih</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
		<span class="n">ih</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="n">csum_long</span><span class="p">(</span><span class="n">isum_seed</span> <span class="o">+</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">tot_len</span> <span class="o">+</span>
				      <span class="n">ih</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0xffff</span><span class="p">;</span>

		<span class="cm">/* Update copied tcp header. */</span>
		<span class="n">th</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">th_off</span><span class="p">);</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="n">csum_long</span><span class="p">(</span><span class="n">tsum_seed</span> <span class="o">+</span> <span class="n">htons</span><span class="p">(</span><span class="n">sh_len</span> <span class="o">+</span> <span class="n">p_len</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">segment</span> <span class="o">!=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">th</span><span class="o">-&gt;</span><span class="n">fin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">th</span><span class="o">-&gt;</span><span class="n">psh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Skip past the header. */</span>
		<span class="n">slot</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Skip past the payload. */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">p_used</span> <span class="o">&lt;</span> <span class="n">p_len</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Advance as needed. */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">f_used</span> <span class="o">&gt;=</span> <span class="n">f_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">f_id</span><span class="o">++</span><span class="p">;</span>
				<span class="n">f_size</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f_id</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
				<span class="n">f_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Use bytes from the current fragment. */</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">p_len</span> <span class="o">-</span> <span class="n">p_used</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">f_size</span> <span class="o">-</span> <span class="n">f_used</span><span class="p">)</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">f_size</span> <span class="o">-</span> <span class="n">f_used</span><span class="p">;</span>
			<span class="n">f_used</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">p_used</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

			<span class="n">slot</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">id</span><span class="o">++</span><span class="p">;</span>
		<span class="n">seq</span> <span class="o">+=</span> <span class="n">p_len</span><span class="p">;</span>

		<span class="cm">/* The last segment may be less than gso_size. */</span>
		<span class="n">data_len</span> <span class="o">-=</span> <span class="n">p_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">&lt;</span> <span class="n">p_len</span><span class="p">)</span>
			<span class="n">p_len</span> <span class="o">=</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Flush the headers so they are ready for hardware DMA. */</span>
	<span class="n">wmb</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Pass all the data to mpipe for egress. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tso_egress</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">gxio_mpipe_equeue_t</span> <span class="o">*</span><span class="n">equeue</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">headers</span><span class="p">,</span> <span class="n">s64</span> <span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p_len</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="n">gxio_mpipe_edesc_t</span> <span class="n">edesc_head</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">};</span>
	<span class="n">gxio_mpipe_edesc_t</span> <span class="n">edesc_body</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">};</span>
	<span class="kt">long</span> <span class="n">f_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>    <span class="cm">/* id of the current fragment */</span>
	<span class="kt">long</span> <span class="n">f_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* size of the current fragment */</span>
	<span class="kt">long</span> <span class="n">f_used</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* bytes used from the current fragment */</span>
	<span class="kt">long</span> <span class="n">n</span><span class="p">;</span>            <span class="cm">/* size of the current piece of payload */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">csum_start</span><span class="p">,</span> <span class="n">sh_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">segment</span><span class="p">;</span>

	<span class="cm">/* Prepare to egress the headers: set up header edesc. */</span>
	<span class="n">csum_start</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">sh_len</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">edesc_head</span><span class="p">.</span><span class="n">csum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">edesc_head</span><span class="p">.</span><span class="n">csum_start</span> <span class="o">=</span> <span class="n">csum_start</span><span class="p">;</span>
	<span class="n">edesc_head</span><span class="p">.</span><span class="n">csum_dest</span> <span class="o">=</span> <span class="n">csum_start</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>
	<span class="n">edesc_head</span><span class="p">.</span><span class="n">xfer_size</span> <span class="o">=</span> <span class="n">sh_len</span><span class="p">;</span>

	<span class="cm">/* This is only used to specify the TLB. */</span>
	<span class="n">edesc_head</span><span class="p">.</span><span class="n">stack_idx</span> <span class="o">=</span> <span class="n">large_buffer_stack</span><span class="p">;</span>
	<span class="n">edesc_body</span><span class="p">.</span><span class="n">stack_idx</span> <span class="o">=</span> <span class="n">large_buffer_stack</span><span class="p">;</span>

	<span class="cm">/* Egress all the edescs. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">segment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">segment</span> <span class="o">&lt;</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">gso_segs</span><span class="p">;</span> <span class="n">segment</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Egress the header. */</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">headers</span> <span class="o">+</span> <span class="p">(</span><span class="n">slot</span> <span class="o">%</span> <span class="n">EQUEUE_ENTRIES</span><span class="p">)</span> <span class="o">*</span> <span class="n">HEADER_BYTES</span> <span class="o">+</span>
			<span class="n">NET_IP_ALIGN</span><span class="p">;</span>
		<span class="n">edesc_head</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="n">va_to_tile_io_addr</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">gxio_mpipe_equeue_put_at</span><span class="p">(</span><span class="n">equeue</span><span class="p">,</span> <span class="n">edesc_head</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">slot</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Egress the payload. */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">p_used</span> <span class="o">&lt;</span> <span class="n">p_len</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Advance as needed. */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">f_used</span> <span class="o">&gt;=</span> <span class="n">f_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">f_id</span><span class="o">++</span><span class="p">;</span>
				<span class="n">f_size</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f_id</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
				<span class="n">f_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">va</span> <span class="o">=</span> <span class="n">tile_net_frag_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f_id</span><span class="p">])</span> <span class="o">+</span> <span class="n">f_used</span><span class="p">;</span>

			<span class="cm">/* Use bytes from the current fragment. */</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">p_len</span> <span class="o">-</span> <span class="n">p_used</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">f_size</span> <span class="o">-</span> <span class="n">f_used</span><span class="p">)</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">f_size</span> <span class="o">-</span> <span class="n">f_used</span><span class="p">;</span>
			<span class="n">f_used</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">p_used</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

			<span class="cm">/* Egress a piece of the payload. */</span>
			<span class="n">edesc_body</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="n">va_to_tile_io_addr</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
			<span class="n">edesc_body</span><span class="p">.</span><span class="n">xfer_size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">edesc_body</span><span class="p">.</span><span class="n">bound</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">p_used</span> <span class="o">&lt;</span> <span class="n">p_len</span><span class="p">);</span>
			<span class="n">gxio_mpipe_equeue_put_at</span><span class="p">(</span><span class="n">equeue</span><span class="p">,</span> <span class="n">edesc_body</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
			<span class="n">slot</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">sh_len</span> <span class="o">+</span> <span class="n">p_len</span><span class="p">;</span>

		<span class="cm">/* The last segment may be less than gso_size. */</span>
		<span class="n">data_len</span> <span class="o">-=</span> <span class="n">p_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">&lt;</span> <span class="n">p_len</span><span class="p">)</span>
			<span class="n">p_len</span> <span class="o">=</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update stats. */</span>
	<span class="n">tile_net_stats_add</span><span class="p">(</span><span class="n">tx_packets</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="p">);</span>
	<span class="n">tile_net_stats_add</span><span class="p">(</span><span class="n">tx_bytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Do &quot;TSO&quot; handling for egress.</span>
<span class="cm"> *</span>
<span class="cm"> * Normally drivers set NETIF_F_TSO only to support hardware TSO;</span>
<span class="cm"> * otherwise the stack uses scatter-gather to implement GSO in software.</span>
<span class="cm"> * On our testing, enabling GSO support (via NETIF_F_SG) drops network</span>
<span class="cm"> * performance down to around 7.5 Gbps on the 10G interfaces, although</span>
<span class="cm"> * also dropping cpu utilization way down, to under 8%.  But</span>
<span class="cm"> * implementing &quot;TSO&quot; in the driver brings performance back up to line</span>
<span class="cm"> * rate, while dropping cpu usage even further, to less than 4%.  In</span>
<span class="cm"> * practice, profiling of GSO shows that skb_segment() is what causes</span>
<span class="cm"> * the performance overheads; we benefit in the driver from using</span>
<span class="cm"> * preallocated memory to duplicate the TCP/IP headers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_tx_tso</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_egress</span> <span class="o">*</span><span class="n">egress</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">egress_for_echannel</span><span class="p">[</span><span class="n">channel</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tile_net_comps</span> <span class="o">*</span><span class="n">comps</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">comps_for_echannel</span><span class="p">[</span><span class="n">channel</span><span class="p">];</span>
	<span class="n">gxio_mpipe_equeue_t</span> <span class="o">*</span><span class="n">equeue</span> <span class="o">=</span> <span class="n">egress</span><span class="o">-&gt;</span><span class="n">equeue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_edescs</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">slot</span><span class="p">;</span>

	<span class="cm">/* Determine how many mpipe edesc&#39;s are needed. */</span>
	<span class="n">num_edescs</span> <span class="o">=</span> <span class="n">tso_count_edescs</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/* Try to acquire a completion entry and an egress slot. */</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">tile_net_equeue_try_reserve</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">equeue</span><span class="p">,</span> <span class="n">num_edescs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">irqflags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up copies of header data properly. */</span>
	<span class="n">tso_headers_prepare</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">egress</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

	<span class="cm">/* Actually pass the data to the network hardware. */</span>
	<span class="n">tso_egress</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">equeue</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">egress</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

	<span class="cm">/* Add a completion record. */</span>
	<span class="n">add_comp</span><span class="p">(</span><span class="n">equeue</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="n">num_edescs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/* Make sure the egress timer is scheduled. */</span>
	<span class="n">tile_net_schedule_egress_timer</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Analyze the body and frags for a transmit request. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tile_net_tx_frags</span><span class="p">(</span><span class="k">struct</span> <span class="n">frag</span> <span class="o">*</span><span class="n">frags</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">b_data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">buf</span> <span class="o">=</span> <span class="n">b_data</span><span class="p">;</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">b_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">buf</span> <span class="o">=</span> <span class="n">tile_net_frag_buf</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="n">frags</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Help the kernel transmit a packet. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tile_net_egress</span> <span class="o">*</span><span class="n">egress</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">egress_for_echannel</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span><span class="p">];</span>
	<span class="n">gxio_mpipe_equeue_t</span> <span class="o">*</span><span class="n">equeue</span> <span class="o">=</span> <span class="n">egress</span><span class="o">-&gt;</span><span class="n">equeue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_comps</span> <span class="o">*</span><span class="n">comps</span> <span class="o">=</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">comps_for_echannel</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_edescs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">frag</span> <span class="n">frags</span><span class="p">[</span><span class="n">MAX_FRAGS</span><span class="p">];</span>
	<span class="n">gxio_mpipe_edesc_t</span> <span class="n">edescs</span><span class="p">[</span><span class="n">MAX_FRAGS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="n">gxio_mpipe_edesc_t</span> <span class="n">edesc</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">slot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">tile_net_tx_tso</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">num_edescs</span> <span class="o">=</span> <span class="n">tile_net_tx_frags</span><span class="p">(</span><span class="n">frags</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="cm">/* This is only used to specify the TLB. */</span>
	<span class="n">edesc</span><span class="p">.</span><span class="n">stack_idx</span> <span class="o">=</span> <span class="n">large_buffer_stack</span><span class="p">;</span>

	<span class="cm">/* Prepare the edescs. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_edescs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edesc</span><span class="p">.</span><span class="n">xfer_size</span> <span class="o">=</span> <span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
		<span class="n">edesc</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="n">va_to_tile_io_addr</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">edescs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">edesc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark the final edesc. */</span>
	<span class="n">edescs</span><span class="p">[</span><span class="n">num_edescs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">bound</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Add checksum info to the initial edesc, if needed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">csum_start</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">edescs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">csum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">edescs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">csum_start</span> <span class="o">=</span> <span class="n">csum_start</span><span class="p">;</span>
		<span class="n">edescs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">csum_dest</span> <span class="o">=</span> <span class="n">csum_start</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/* Try to acquire a completion entry and an egress slot. */</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">tile_net_equeue_try_reserve</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">equeue</span><span class="p">,</span> <span class="n">num_edescs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">irqflags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_edescs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">gxio_mpipe_equeue_put_at</span><span class="p">(</span><span class="n">equeue</span><span class="p">,</span> <span class="n">edescs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">slot</span><span class="o">++</span><span class="p">);</span>

	<span class="cm">/* Add a completion record. */</span>
	<span class="n">add_comp</span><span class="p">(</span><span class="n">equeue</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* NOTE: Use ETH_ZLEN for short packets (e.g. 42 &lt; 60). */</span>
	<span class="n">tile_net_stats_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="p">);</span>
	<span class="n">tile_net_stats_add</span><span class="p">(</span><span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ETH_ZLEN</span><span class="p">),</span>
			   <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/* Make sure the egress timer is scheduled. */</span>
	<span class="n">tile_net_schedule_egress_timer</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return subqueue id on this core (one per core). */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">tile_net_select_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smp_processor_id</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Deal with a transmit timeout. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">netif_wake_subqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Ioctl commands. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get system network statistics for device. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">tile_net_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Change the MTU. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="mi">68</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="mi">1500</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Change the Ethernet address of the NIC.</span>
<span class="cm"> *</span>
<span class="cm"> * The hypervisor driver does not support changing MAC address.  However,</span>
<span class="cm"> * the hardware does not do anything with the MAC address, so the address</span>
<span class="cm"> * which gets used on outgoing packets, and which is accepted on incoming</span>
<span class="cm"> * packets, is completely up to us.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_net_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="cm">/* Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<span class="cm"> * without having to re-enable interrupts. It&#39;s not called while</span>
<span class="cm"> * the interrupt routine is executing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_percpu_irq</span><span class="p">(</span><span class="n">ingress_irq</span><span class="p">);</span>
	<span class="n">tile_net_handle_ingress_irq</span><span class="p">(</span><span class="n">ingress_irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">enable_percpu_irq</span><span class="p">(</span><span class="n">ingress_irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">tile_net_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> <span class="o">=</span> <span class="n">tile_net_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span> <span class="o">=</span> <span class="n">tile_net_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">tile_net_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_select_queue</span> <span class="o">=</span> <span class="n">tile_net_select_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span> <span class="o">=</span> <span class="n">tile_net_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span> <span class="o">=</span> <span class="n">tile_net_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span> <span class="o">=</span> <span class="n">tile_net_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span> <span class="o">=</span> <span class="n">tile_net_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> <span class="o">=</span> <span class="n">tile_net_set_mac_address</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span> <span class="o">=</span> <span class="n">tile_net_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* The setup function.</span>
<span class="cm"> *</span>
<span class="cm"> * This uses ether_setup() to assign various fields in dev, including</span>
<span class="cm"> * setting IFF_BROADCAST and IFF_MULTICAST, then sets some extra fields.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ether_setup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tile_net_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TILE_NET_TIMEOUT</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_LLTX</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_CSUM</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_SG</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="mi">1500</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate the device structure, register the device, and obtain the</span>
<span class="cm"> * MAC address from the hypervisor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_dev_init</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">mac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nz_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_net_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>

	<span class="cm">/* HACK: Ignore &quot;loop&quot; links. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;loop&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Allocate the device structure.  Normally, &quot;name&quot; is a</span>
<span class="cm">	 * template, instantiated by register_netdev(), but not for us.</span>
<span class="cm">	 */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_netdev_mqs</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span> <span class="n">tile_net_setup</span><span class="p">,</span>
			       <span class="n">NR_CPUS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;alloc_netdev_mqs(%s) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize &quot;priv&quot;. */</span>
	<span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="p">));</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">loopify_channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">echannel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Get the MAC address and set it in the device struct; this must</span>
<span class="cm">	 * be done before the device is opened.  If the MAC is all zeroes,</span>
<span class="cm">	 * we use a random address, since we&#39;re probably on the simulator.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">nz_addr</span> <span class="o">|=</span> <span class="n">mac</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nz_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">mac</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">random_ether_addr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Register the network device. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;register_netdev failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Per-cpu module initialization. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tile_net_init_module_percpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tile_net_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">per_cpu_info</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">has_iqueue</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">my_cpu</span> <span class="o">=</span> <span class="n">my_cpu</span><span class="p">;</span>

	<span class="cm">/* Initialize the egress timer. */</span>
	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">egress_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">tile_net_handle_egress_timer</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Module initialization. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">tile_net_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">GXIO_MPIPE_LINK_NAME_LEN</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mac</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tilera Network Driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tile_net_devs_for_channel_mutex</span><span class="p">);</span>

	<span class="cm">/* Initialize each CPU. */</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">tile_net_init_module_percpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Find out what devices we have, and initialize them. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">gxio_mpipe_link_enumerate_mac</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">mac</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tile_net_dev_init</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mac</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">network_cpus_init</span><span class="p">())</span>
		<span class="n">network_cpus_map</span> <span class="o">=</span> <span class="o">*</span><span class="n">cpu_online_mask</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">tile_net_init_module</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
