<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › neterion › vxge › vxge-traffic.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>vxge-traffic.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * This software may be used and distributed according to the terms of</span>
<span class="cm"> * the GNU General Public License (GPL), incorporated herein by reference.</span>
<span class="cm"> * Drivers based on or derived from this code fall under the GPL and must</span>
<span class="cm"> * retain the authorship, copyright and license notice.  This file is not</span>
<span class="cm"> * a complete program and may only be used when the entire operating</span>
<span class="cm"> * system is licensed under the GPL.</span>
<span class="cm"> * See the file COPYING in this distribution for more information.</span>
<span class="cm"> *</span>
<span class="cm"> * vxge-traffic.h: Driver for Exar Corp&#39;s X3100 Series 10GbE PCIe I/O</span>
<span class="cm"> *                 Virtualized Server Adapter.</span>
<span class="cm"> * Copyright(c) 2002-2010 Exar Corp.</span>
<span class="cm"> ******************************************************************************/</span>
<span class="cp">#ifndef VXGE_TRAFFIC_H</span>
<span class="cp">#define VXGE_TRAFFIC_H</span>

<span class="cp">#include &quot;vxge-reg.h&quot;</span>
<span class="cp">#include &quot;vxge-version.h&quot;</span>

<span class="cp">#define VXGE_HW_DTR_MAX_T_CODE		16</span>
<span class="cp">#define VXGE_HW_ALL_FOXES		0xFFFFFFFFFFFFFFFFULL</span>
<span class="cp">#define VXGE_HW_INTR_MASK_ALL		0xFFFFFFFFFFFFFFFFULL</span>
<span class="cp">#define	VXGE_HW_MAX_VIRTUAL_PATHS	17</span>

<span class="cp">#define VXGE_HW_MAC_MAX_MAC_PORT_ID	2</span>

<span class="cp">#define VXGE_HW_DEFAULT_32		0xffffffff</span>
<span class="cm">/* frames sizes */</span>
<span class="cp">#define VXGE_HW_HEADER_802_2_SIZE	3</span>
<span class="cp">#define VXGE_HW_HEADER_SNAP_SIZE	5</span>
<span class="cp">#define VXGE_HW_HEADER_VLAN_SIZE	4</span>
<span class="cp">#define VXGE_HW_MAC_HEADER_MAX_SIZE \</span>
<span class="cp">			(ETH_HLEN + \</span>
<span class="cp">			VXGE_HW_HEADER_802_2_SIZE + \</span>
<span class="cp">			VXGE_HW_HEADER_VLAN_SIZE + \</span>
<span class="cp">			VXGE_HW_HEADER_SNAP_SIZE)</span>

<span class="cm">/* 32bit alignments */</span>
<span class="cp">#define VXGE_HW_HEADER_ETHERNET_II_802_3_ALIGN		2</span>
<span class="cp">#define VXGE_HW_HEADER_802_2_SNAP_ALIGN			2</span>
<span class="cp">#define VXGE_HW_HEADER_802_2_ALIGN			3</span>
<span class="cp">#define VXGE_HW_HEADER_SNAP_ALIGN			1</span>

<span class="cp">#define VXGE_HW_L3_CKSUM_OK				0xFFFF</span>
<span class="cp">#define VXGE_HW_L4_CKSUM_OK				0xFFFF</span>

<span class="cm">/* Forward declarations */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vxge_hw_vp_config</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">__vxge_hw_virtualpath</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">__vxge_hw_channel</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">__vxge_hw_ring</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vxge_hw_ring_attr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vxge_hw_mempool</span><span class="p">;</span>

<span class="cp">#ifndef TRUE</span>
<span class="cp">#define TRUE 1</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef FALSE</span>
<span class="cp">#define FALSE 0</span>
<span class="cp">#endif</span>

<span class="cm">/*VXGE_HW_STATUS_H*/</span>

<span class="cp">#define VXGE_HW_EVENT_BASE			0</span>
<span class="cp">#define VXGE_LL_EVENT_BASE			100</span>

<span class="cm">/**</span>
<span class="cm"> * enum vxge_hw_event- Enumerates slow-path HW events.</span>
<span class="cm"> * @VXGE_HW_EVENT_UNKNOWN: Unknown (and invalid) event.</span>
<span class="cm"> * @VXGE_HW_EVENT_SERR: Serious vpath hardware error event.</span>
<span class="cm"> * @VXGE_HW_EVENT_ECCERR: vpath ECC error event.</span>
<span class="cm"> * @VXGE_HW_EVENT_VPATH_ERR: Error local to the respective vpath</span>
<span class="cm"> * @VXGE_HW_EVENT_FIFO_ERR: FIFO Doorbell fifo error.</span>
<span class="cm"> * @VXGE_HW_EVENT_SRPCIM_SERR: srpcim hardware error event.</span>
<span class="cm"> * @VXGE_HW_EVENT_MRPCIM_SERR: mrpcim hardware error event.</span>
<span class="cm"> * @VXGE_HW_EVENT_MRPCIM_ECCERR: mrpcim ecc error event.</span>
<span class="cm"> * @VXGE_HW_EVENT_RESET_START: Privileged entity is starting device reset</span>
<span class="cm"> * @VXGE_HW_EVENT_RESET_COMPLETE: Device reset has been completed</span>
<span class="cm"> * @VXGE_HW_EVENT_SLOT_FREEZE: Slot-freeze event. Driver tries to distinguish</span>
<span class="cm"> * slot-freeze from the rest critical events (e.g. ECC) when it is</span>
<span class="cm"> * impossible to PIO read &quot;through&quot; the bus, i.e. when getting all-foxes.</span>
<span class="cm"> *</span>
<span class="cm"> * enum vxge_hw_event enumerates slow-path HW eventis.</span>
<span class="cm"> *</span>
<span class="cm"> * See also: struct vxge_hw_uld_cbs{}, vxge_uld_link_up_f{},</span>
<span class="cm"> * vxge_uld_link_down_f{}.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_hw_event</span> <span class="p">{</span>
	<span class="n">VXGE_HW_EVENT_UNKNOWN</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* HW events */</span>
	<span class="n">VXGE_HW_EVENT_RESET_START</span>	<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_RESET_COMPLETE</span>	<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_LINK_DOWN</span>		<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_LINK_UP</span>		<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_ALARM_CLEARED</span>	<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_ECCERR</span>		<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_MRPCIM_ECCERR</span>	<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_FIFO_ERR</span>		<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_VPATH_ERR</span>		<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_CRITICAL_ERR</span>	<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_SERR</span>		<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_SRPCIM_SERR</span>	<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_MRPCIM_SERR</span>	<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">VXGE_HW_EVENT_SLOT_FREEZE</span>	<span class="o">=</span> <span class="n">VXGE_HW_EVENT_BASE</span> <span class="o">+</span> <span class="mi">14</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define VXGE_HW_SET_LEVEL(a, b) (((a) &gt; (b)) ? (a) : (b))</span>

<span class="cm">/*</span>
<span class="cm"> * struct vxge_hw_mempool_dma - Represents DMA objects passed to the</span>
<span class="cm">	caller.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_mempool_dma</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span>			<span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">acc_handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * vxge_hw_mempool_item_f  - Mempool item alloc/free callback</span>
<span class="cm"> * @mempoolh: Memory pool handle.</span>
<span class="cm"> * @memblock: Address of memory block</span>
<span class="cm"> * @memblock_index: Index of memory block</span>
<span class="cm"> * @item: Item that gets allocated or freed.</span>
<span class="cm"> * @index: Item&#39;s index in the memory pool.</span>
<span class="cm"> * @is_last: True, if this item is the last one in the pool; false - otherwise.</span>
<span class="cm"> * userdata: Per-pool user context.</span>
<span class="cm"> *</span>
<span class="cm"> * Memory pool allocation/deallocation callback.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * struct vxge_hw_mempool - Memory pool.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_mempool</span> <span class="p">{</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">item_func_alloc</span><span class="p">)(</span>
	<span class="k">struct</span> <span class="n">vxge_hw_mempool</span> <span class="o">*</span><span class="n">mempoolh</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">memblock_index</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vxge_hw_mempool_dma</span>	<span class="o">*</span><span class="n">dma_object</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">index</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">is_last</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="o">*</span><span class="n">userdata</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">**</span><span class="n">memblocks_arr</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">**</span><span class="n">memblocks_priv_arr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_mempool_dma</span>	<span class="o">*</span><span class="n">memblocks_dma_arr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">memblock_size</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">memblocks_max</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">memblocks_allocated</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">item_size</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">items_max</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">items_initial</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">items_current</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">items_per_memblock</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">**</span><span class="n">items_arr</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">items_priv_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define	VXGE_HW_MAX_INTR_PER_VP				4</span>
<span class="cp">#define	VXGE_HW_VPATH_INTR_TX				0</span>
<span class="cp">#define	VXGE_HW_VPATH_INTR_RX				1</span>
<span class="cp">#define	VXGE_HW_VPATH_INTR_EINTA			2</span>
<span class="cp">#define	VXGE_HW_VPATH_INTR_BMAP				3</span>

<span class="cp">#define VXGE_HW_BLOCK_SIZE				4096</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_tim_intr_config - Titan Tim interrupt configuration.</span>
<span class="cm"> * @intr_enable: Set to 1, if interrupt is enabled.</span>
<span class="cm"> * @btimer_val: Boundary Timer Initialization value in units of 272 ns.</span>
<span class="cm"> * @timer_ac_en: Timer Automatic Cancel. 1 : Automatic Canceling Enable: when</span>
<span class="cm"> *             asserted, other interrupt-generating entities will cancel the</span>
<span class="cm"> *             scheduled timer interrupt.</span>
<span class="cm"> * @timer_ci_en: Timer Continuous Interrupt. 1 : Continuous Interrupting Enable:</span>
<span class="cm"> *             When asserted, an interrupt will be generated every time the</span>
<span class="cm"> *             boundary timer expires, even if no traffic has been transmitted</span>
<span class="cm"> *             on this interrupt.</span>
<span class="cm"> * @timer_ri_en: Timer Consecutive (Re-) Interrupt 1 : Consecutive</span>
<span class="cm"> *             (Re-) Interrupt Enable: When asserted, an interrupt will be</span>
<span class="cm"> *             generated the next time the timer expires, even if no traffic has</span>
<span class="cm"> *             been transmitted on this interrupt. (This will only happen once</span>
<span class="cm"> *             each time that this value is written to the TIM.) This bit is</span>
<span class="cm"> *             cleared by H/W at the end of the current-timer-interval when</span>
<span class="cm"> *             the interrupt is triggered.</span>
<span class="cm"> * @rtimer_val: Restriction Timer Initialization value in units of 272 ns.</span>
<span class="cm"> * @util_sel: Utilization Selector. Selects which of the workload approximations</span>
<span class="cm"> *             to use (e.g. legacy Tx utilization, Tx/Rx utilization, host</span>
<span class="cm"> *             specified utilization etc.), selects one of</span>
<span class="cm"> *             the 17 host configured values.</span>
<span class="cm"> *             0-Virtual Path 0</span>
<span class="cm"> *             1-Virtual Path 1</span>
<span class="cm"> *             ...</span>
<span class="cm"> *             16-Virtual Path 17</span>
<span class="cm"> *             17-Legacy Tx network utilization, provided by TPA</span>
<span class="cm"> *             18-Legacy Rx network utilization, provided by FAU</span>
<span class="cm"> *             19-Average of legacy Rx and Tx utilization calculated from link</span>
<span class="cm"> *                utilization values.</span>
<span class="cm"> *             20-31-Invalid configurations</span>
<span class="cm"> *             32-Host utilization for Virtual Path 0</span>
<span class="cm"> *             33-Host utilization for Virtual Path 1</span>
<span class="cm"> *             ...</span>
<span class="cm"> *             48-Host utilization for Virtual Path 17</span>
<span class="cm"> *             49-Legacy Tx network utilization, provided by TPA</span>
<span class="cm"> *             50-Legacy Rx network utilization, provided by FAU</span>
<span class="cm"> *             51-Average of legacy Rx and Tx utilization calculated from</span>
<span class="cm"> *                link utilization values.</span>
<span class="cm"> *             52-63-Invalid configurations</span>
<span class="cm"> * @ltimer_val: Latency Timer Initialization Value in units of 272 ns.</span>
<span class="cm"> * @txd_cnt_en: TxD Return Event Count Enable. This configuration bit when set</span>
<span class="cm"> *             to 1 enables counting of TxD0 returns (signalled by PCC&#39;s),</span>
<span class="cm"> *             towards utilization event count values.</span>
<span class="cm"> * @urange_a: Defines the upper limit (in percent) for this utilization range</span>
<span class="cm"> *             to be active. This range is considered active</span>
<span class="cm"> *             if 0 = UTIL = URNG_A</span>
<span class="cm"> *             and the UEC_A field (below) is non-zero.</span>
<span class="cm"> * @uec_a: Utilization Event Count A. If this range is active, the adapter will</span>
<span class="cm"> *             wait until UEC_A events have occurred on the interrupt before</span>
<span class="cm"> *             generating an interrupt.</span>
<span class="cm"> * @urange_b: Link utilization range B.</span>
<span class="cm"> * @uec_b: Utilization Event Count B.</span>
<span class="cm"> * @urange_c: Link utilization range C.</span>
<span class="cm"> * @uec_c: Utilization Event Count C.</span>
<span class="cm"> * @urange_d: Link utilization range D.</span>
<span class="cm"> * @uec_d: Utilization Event Count D.</span>
<span class="cm"> * Traffic Interrupt Controller Module interrupt configuration.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_tim_intr_config</span> <span class="p">{</span>

	<span class="n">u32</span>				<span class="n">intr_enable</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_TIM_INTR_ENABLE				1</span>
<span class="cp">#define VXGE_HW_TIM_INTR_DISABLE				0</span>
<span class="cp">#define VXGE_HW_TIM_INTR_DEFAULT				0</span>

	<span class="n">u32</span>				<span class="n">btimer_val</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_TIM_BTIMER_VAL				0</span>
<span class="cp">#define VXGE_HW_MAX_TIM_BTIMER_VAL				67108864</span>
<span class="cp">#define VXGE_HW_USE_FLASH_DEFAULT				(~0)</span>

	<span class="n">u32</span>				<span class="n">timer_ac_en</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_TIM_TIMER_AC_ENABLE				1</span>
<span class="cp">#define VXGE_HW_TIM_TIMER_AC_DISABLE				0</span>

	<span class="n">u32</span>				<span class="n">timer_ci_en</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_TIM_TIMER_CI_ENABLE				1</span>
<span class="cp">#define VXGE_HW_TIM_TIMER_CI_DISABLE				0</span>

	<span class="n">u32</span>				<span class="n">timer_ri_en</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_TIM_TIMER_RI_ENABLE				1</span>
<span class="cp">#define VXGE_HW_TIM_TIMER_RI_DISABLE				0</span>

	<span class="n">u32</span>				<span class="n">rtimer_val</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_TIM_RTIMER_VAL				0</span>
<span class="cp">#define VXGE_HW_MAX_TIM_RTIMER_VAL				67108864</span>

	<span class="n">u32</span>				<span class="n">util_sel</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_TIM_UTIL_SEL_LEGACY_TX_NET_UTIL		17</span>
<span class="cp">#define VXGE_HW_TIM_UTIL_SEL_LEGACY_RX_NET_UTIL		18</span>
<span class="cp">#define VXGE_HW_TIM_UTIL_SEL_LEGACY_TX_RX_AVE_NET_UTIL		19</span>
<span class="cp">#define VXGE_HW_TIM_UTIL_SEL_PER_VPATH				63</span>

	<span class="n">u32</span>				<span class="n">ltimer_val</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_TIM_LTIMER_VAL				0</span>
<span class="cp">#define VXGE_HW_MAX_TIM_LTIMER_VAL				67108864</span>

	<span class="cm">/* Line utilization interrupts */</span>
	<span class="n">u32</span>				<span class="n">urange_a</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_TIM_URANGE_A				0</span>
<span class="cp">#define VXGE_HW_MAX_TIM_URANGE_A				100</span>

	<span class="n">u32</span>				<span class="n">uec_a</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_TIM_UEC_A					0</span>
<span class="cp">#define VXGE_HW_MAX_TIM_UEC_A					65535</span>

	<span class="n">u32</span>				<span class="n">urange_b</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_TIM_URANGE_B				0</span>
<span class="cp">#define VXGE_HW_MAX_TIM_URANGE_B				100</span>

	<span class="n">u32</span>				<span class="n">uec_b</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_TIM_UEC_B					0</span>
<span class="cp">#define VXGE_HW_MAX_TIM_UEC_B					65535</span>

	<span class="n">u32</span>				<span class="n">urange_c</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_TIM_URANGE_C				0</span>
<span class="cp">#define VXGE_HW_MAX_TIM_URANGE_C				100</span>

	<span class="n">u32</span>				<span class="n">uec_c</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_TIM_UEC_C					0</span>
<span class="cp">#define VXGE_HW_MAX_TIM_UEC_C					65535</span>

	<span class="n">u32</span>				<span class="n">uec_d</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_TIM_UEC_D					0</span>
<span class="cp">#define VXGE_HW_MAX_TIM_UEC_D					65535</span>
<span class="p">};</span>

<span class="cp">#define	VXGE_HW_STATS_OP_READ					0</span>
<span class="cp">#define	VXGE_HW_STATS_OP_CLEAR_STAT				1</span>
<span class="cp">#define	VXGE_HW_STATS_OP_CLEAR_ALL_VPATH_STATS			2</span>
<span class="cp">#define	VXGE_HW_STATS_OP_CLEAR_ALL_STATS_OF_LOC			2</span>
<span class="cp">#define	VXGE_HW_STATS_OP_CLEAR_ALL_STATS			3</span>

<span class="cp">#define	VXGE_HW_STATS_LOC_AGGR					17</span>
<span class="cp">#define VXGE_HW_STATS_AGGRn_OFFSET				0x00720</span>

<span class="cp">#define VXGE_HW_STATS_VPATH_TX_OFFSET				0x0</span>
<span class="cp">#define VXGE_HW_STATS_VPATH_RX_OFFSET				0x00090</span>

<span class="cp">#define	VXGE_HW_STATS_VPATH_PROG_EVENT_VNUM0_OFFSET	   (0x001d0 &gt;&gt; 3)</span>
<span class="cp">#define	VXGE_HW_STATS_GET_VPATH_PROG_EVENT_VNUM0(bits) \</span>
<span class="cp">						vxge_bVALn(bits, 0, 32)</span>

<span class="cp">#define	VXGE_HW_STATS_GET_VPATH_PROG_EVENT_VNUM1(bits) \</span>
<span class="cp">						vxge_bVALn(bits, 32, 32)</span>

<span class="cp">#define	VXGE_HW_STATS_VPATH_PROG_EVENT_VNUM2_OFFSET	   (0x001d8 &gt;&gt; 3)</span>
<span class="cp">#define	VXGE_HW_STATS_GET_VPATH_PROG_EVENT_VNUM2(bits) \</span>
<span class="cp">						vxge_bVALn(bits, 0, 32)</span>

<span class="cp">#define	VXGE_HW_STATS_GET_VPATH_PROG_EVENT_VNUM3(bits) \</span>
<span class="cp">						vxge_bVALn(bits, 32, 32)</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_xmac_aggr_stats - Per-Aggregator XMAC Statistics</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_frms: Count of data frames transmitted on this Aggregator on all</span>
<span class="cm"> *             its Aggregation ports. Does not include LACPDUs or Marker PDUs.</span>
<span class="cm"> *             However, does include frames discarded by the Distribution</span>
<span class="cm"> *             function.</span>
<span class="cm"> * @tx_data_octets: Count of data and padding octets of frames transmitted</span>
<span class="cm"> *             on this Aggregator on all its Aggregation ports. Does not include</span>
<span class="cm"> *             octets of LACPDUs or Marker PDUs. However, does include octets of</span>
<span class="cm"> *             frames discarded by the Distribution function.</span>
<span class="cm"> * @tx_mcast_frms: Count of data frames transmitted (to a group destination</span>
<span class="cm"> *             address other than the broadcast address) on this Aggregator on</span>
<span class="cm"> *             all its Aggregation ports. Does not include LACPDUs or Marker</span>
<span class="cm"> *             PDUs. However, does include frames discarded by the Distribution</span>
<span class="cm"> *             function.</span>
<span class="cm"> * @tx_bcast_frms: Count of broadcast data frames transmitted on this Aggregator</span>
<span class="cm"> *             on all its Aggregation ports. Does not include LACPDUs or Marker</span>
<span class="cm"> *             PDUs. However, does include frames discarded by the Distribution</span>
<span class="cm"> *             function.</span>
<span class="cm"> * @tx_discarded_frms: Count of data frames to be transmitted on this Aggregator</span>
<span class="cm"> *             that are discarded by the Distribution function. This occurs when</span>
<span class="cm"> *             conversation are allocated to different ports and have to be</span>
<span class="cm"> *             flushed on old ports</span>
<span class="cm"> * @tx_errored_frms: Count of data frames transmitted on this Aggregator that</span>
<span class="cm"> *             experience transmission errors on its Aggregation ports.</span>
<span class="cm"> * @rx_frms: Count of data frames received on this Aggregator on all its</span>
<span class="cm"> *             Aggregation ports. Does not include LACPDUs or Marker PDUs.</span>
<span class="cm"> *             Also, does not include frames discarded by the Collection</span>
<span class="cm"> *             function.</span>
<span class="cm"> * @rx_data_octets: Count of data and padding octets of frames received on this</span>
<span class="cm"> *             Aggregator on all its Aggregation ports. Does not include octets</span>
<span class="cm"> *             of LACPDUs or Marker PDUs. Also, does not include</span>
<span class="cm"> *             octets of frames</span>
<span class="cm"> *             discarded by the Collection function.</span>
<span class="cm"> * @rx_mcast_frms: Count of data frames received (from a group destination</span>
<span class="cm"> *             address other than the broadcast address) on this Aggregator on</span>
<span class="cm"> *             all its Aggregation ports. Does not include LACPDUs or Marker</span>
<span class="cm"> *             PDUs. Also, does not include frames discarded by the Collection</span>
<span class="cm"> *             function.</span>
<span class="cm"> * @rx_bcast_frms: Count of broadcast data frames received on this Aggregator on</span>
<span class="cm"> *             all its Aggregation ports. Does not include LACPDUs or Marker</span>
<span class="cm"> *             PDUs. Also, does not include frames discarded by the Collection</span>
<span class="cm"> *             function.</span>
<span class="cm"> * @rx_discarded_frms: Count of data frames received on this Aggregator that are</span>
<span class="cm"> *             discarded by the Collection function because the Collection</span>
<span class="cm"> *             function was disabled on the port which the frames are received.</span>
<span class="cm"> * @rx_errored_frms: Count of data frames received on this Aggregator that are</span>
<span class="cm"> *             discarded by its Aggregation ports, or are discarded by the</span>
<span class="cm"> *             Collection function of the Aggregator, or that are discarded by</span>
<span class="cm"> *             the Aggregator due to detection of an illegal Slow Protocols PDU.</span>
<span class="cm"> * @rx_unknown_slow_proto_frms: Count of data frames received on this Aggregator</span>
<span class="cm"> *             that are discarded by its Aggregation ports due to detection of</span>
<span class="cm"> *             an unknown Slow Protocols PDU.</span>
<span class="cm"> *</span>
<span class="cm"> * Per aggregator XMAC RX statistics.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_xmac_aggr_stats</span> <span class="p">{</span>
<span class="cm">/*0x000*/</span>		<span class="n">u64</span>	<span class="n">tx_frms</span><span class="p">;</span>
<span class="cm">/*0x008*/</span>		<span class="n">u64</span>	<span class="n">tx_data_octets</span><span class="p">;</span>
<span class="cm">/*0x010*/</span>		<span class="n">u64</span>	<span class="n">tx_mcast_frms</span><span class="p">;</span>
<span class="cm">/*0x018*/</span>		<span class="n">u64</span>	<span class="n">tx_bcast_frms</span><span class="p">;</span>
<span class="cm">/*0x020*/</span>		<span class="n">u64</span>	<span class="n">tx_discarded_frms</span><span class="p">;</span>
<span class="cm">/*0x028*/</span>		<span class="n">u64</span>	<span class="n">tx_errored_frms</span><span class="p">;</span>
<span class="cm">/*0x030*/</span>		<span class="n">u64</span>	<span class="n">rx_frms</span><span class="p">;</span>
<span class="cm">/*0x038*/</span>		<span class="n">u64</span>	<span class="n">rx_data_octets</span><span class="p">;</span>
<span class="cm">/*0x040*/</span>		<span class="n">u64</span>	<span class="n">rx_mcast_frms</span><span class="p">;</span>
<span class="cm">/*0x048*/</span>		<span class="n">u64</span>	<span class="n">rx_bcast_frms</span><span class="p">;</span>
<span class="cm">/*0x050*/</span>		<span class="n">u64</span>	<span class="n">rx_discarded_frms</span><span class="p">;</span>
<span class="cm">/*0x058*/</span>		<span class="n">u64</span>	<span class="n">rx_errored_frms</span><span class="p">;</span>
<span class="cm">/*0x060*/</span>		<span class="n">u64</span>	<span class="n">rx_unknown_slow_proto_frms</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_xmac_port_stats - XMAC Port Statistics</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_ttl_frms: Count of successfully transmitted MAC frames</span>
<span class="cm"> * @tx_ttl_octets: Count of total octets of transmitted frames, not including</span>
<span class="cm"> *            framing characters (i.e. less framing bits). To determine the</span>
<span class="cm"> *            total octets of transmitted frames, including framing characters,</span>
<span class="cm"> *            multiply PORTn_TX_TTL_FRMS by 8 and add it to this stat (unless</span>
<span class="cm"> *            otherwise configured, this stat only counts frames that have</span>
<span class="cm"> *            8 bytes of preamble for each frame). This stat can be configured</span>
<span class="cm"> *            (see XMAC_STATS_GLOBAL_CFG.TTL_FRMS_HANDLING) to count everything</span>
<span class="cm"> *            including the preamble octets.</span>
<span class="cm"> * @tx_data_octets: Count of data and padding octets of successfully transmitted</span>
<span class="cm"> *            frames.</span>
<span class="cm"> * @tx_mcast_frms: Count of successfully transmitted frames to a group address</span>
<span class="cm"> *            other than the broadcast address.</span>
<span class="cm"> * @tx_bcast_frms: Count of successfully transmitted frames to the broadcast</span>
<span class="cm"> *            group address.</span>
<span class="cm"> * @tx_ucast_frms: Count of transmitted frames containing a unicast address.</span>
<span class="cm"> *            Includes discarded frames that are not sent to the network.</span>
<span class="cm"> * @tx_tagged_frms: Count of transmitted frames containing a VLAN tag.</span>
<span class="cm"> * @tx_vld_ip: Count of transmitted IP datagrams that are passed to the network.</span>
<span class="cm"> * @tx_vld_ip_octets: Count of total octets of transmitted IP datagrams that</span>
<span class="cm"> *            are passed to the network.</span>
<span class="cm"> * @tx_icmp: Count of transmitted ICMP messages. Includes messages not sent</span>
<span class="cm"> *            due to problems within ICMP.</span>
<span class="cm"> * @tx_tcp: Count of transmitted TCP segments. Does not include segments</span>
<span class="cm"> *            containing retransmitted octets.</span>
<span class="cm"> * @tx_rst_tcp: Count of transmitted TCP segments containing the RST flag.</span>
<span class="cm"> * @tx_udp: Count of transmitted UDP datagrams.</span>
<span class="cm"> * @tx_parse_error: Increments when the TPA is unable to parse a packet. This</span>
<span class="cm"> *            generally occurs when a packet is corrupt somehow, including</span>
<span class="cm"> *            packets that have IP version mismatches, invalid Layer 2 control</span>
<span class="cm"> *            fields, etc. L3/L4 checksums are not offloaded, but the packet</span>
<span class="cm"> *            is still be transmitted.</span>
<span class="cm"> * @tx_unknown_protocol: Increments when the TPA encounters an unknown</span>
<span class="cm"> *            protocol, such as a new IPv6 extension header, or an unsupported</span>
<span class="cm"> *            Routing Type. The packet still has a checksum calculated but it</span>
<span class="cm"> *            may be incorrect.</span>
<span class="cm"> * @tx_pause_ctrl_frms: Count of MAC PAUSE control frames that are transmitted.</span>
<span class="cm"> *            Since, the only control frames supported by this device are</span>
<span class="cm"> *            PAUSE frames, this register is a count of all transmitted MAC</span>
<span class="cm"> *            control frames.</span>
<span class="cm"> * @tx_marker_pdu_frms: Count of Marker PDUs transmitted</span>
<span class="cm"> * on this Aggregation port.</span>
<span class="cm"> * @tx_lacpdu_frms: Count of LACPDUs transmitted on this Aggregation port.</span>
<span class="cm"> * @tx_drop_ip: Count of transmitted IP datagrams that could not be passed to</span>
<span class="cm"> *            the network. Increments because of:</span>
<span class="cm"> *            1) An internal processing error</span>
<span class="cm"> *            (such as an uncorrectable ECC error). 2) A frame parsing error</span>
<span class="cm"> *            during IP checksum calculation.</span>
<span class="cm"> * @tx_marker_resp_pdu_frms: Count of Marker Response PDUs transmitted on this</span>
<span class="cm"> *            Aggregation port.</span>
<span class="cm"> * @tx_xgmii_char2_match: Maintains a count of the number of transmitted XGMII</span>
<span class="cm"> *            characters that match a pattern that is programmable through</span>
<span class="cm"> *            register XMAC_STATS_TX_XGMII_CHAR_PORTn. By default, the pattern</span>
<span class="cm"> *            is set to /T/ (i.e. the terminate character), thus the statistic</span>
<span class="cm"> *            tracks the number of transmitted Terminate characters.</span>
<span class="cm"> * @tx_xgmii_char1_match: Maintains a count of the number of transmitted XGMII</span>
<span class="cm"> *            characters that match a pattern that is programmable through</span>
<span class="cm"> *            register XMAC_STATS_TX_XGMII_CHAR_PORTn. By default, the pattern</span>
<span class="cm"> *            is set to /S/ (i.e. the start character),</span>
<span class="cm"> *            thus the statistic tracks</span>
<span class="cm"> *            the number of transmitted Start characters.</span>
<span class="cm"> * @tx_xgmii_column2_match: Maintains a count of the number of transmitted XGMII</span>
<span class="cm"> *            columns that match a pattern that is programmable through register</span>
<span class="cm"> *            XMAC_STATS_TX_XGMII_COLUMN2_PORTn. By default, the pattern is set</span>
<span class="cm"> *            to 4 x /E/ (i.e. a column containing all error characters), thus</span>
<span class="cm"> *            the statistic tracks the number of Error columns transmitted at</span>
<span class="cm"> *            any time. If XMAC_STATS_TX_XGMII_BEHAV_COLUMN2_PORTn.NEAR_COL1 is</span>
<span class="cm"> *            set to 1, then this stat increments when COLUMN2 is found within</span>
<span class="cm"> *            &#39;n&#39; clocks after COLUMN1. Here, &#39;n&#39; is defined by</span>
<span class="cm"> *            XMAC_STATS_TX_XGMII_BEHAV_COLUMN2_PORTn.NUM_COL (if &#39;n&#39; is set</span>
<span class="cm"> *            to 0, then it means to search anywhere for COLUMN2).</span>
<span class="cm"> * @tx_xgmii_column1_match: Maintains a count of the number of transmitted XGMII</span>
<span class="cm"> *            columns that match a pattern that is programmable through register</span>
<span class="cm"> *            XMAC_STATS_TX_XGMII_COLUMN1_PORTn. By default, the pattern is set</span>
<span class="cm"> *            to 4 x /I/ (i.e. a column containing all idle characters),</span>
<span class="cm"> *            thus the statistic tracks the number of transmitted Idle columns.</span>
<span class="cm"> * @tx_any_err_frms: Count of transmitted frames containing any error that</span>
<span class="cm"> *            prevents them from being passed to the network. Increments if</span>
<span class="cm"> *            there is an ECC while reading the frame out of the transmit</span>
<span class="cm"> *            buffer. Also increments if the transmit protocol assist (TPA)</span>
<span class="cm"> *            block determines that the frame should not be sent.</span>
<span class="cm"> * @tx_drop_frms: Count of frames that could not be sent for no other reason</span>
<span class="cm"> *            than internal MAC processing. Increments once whenever the</span>
<span class="cm"> *            transmit buffer is flushed (due to an ECC error on a memory</span>
<span class="cm"> *            descriptor).</span>
<span class="cm"> * @rx_ttl_frms: Count of total received MAC frames, including frames received</span>
<span class="cm"> *            with frame-too-long, FCS, or length errors. This stat can be</span>
<span class="cm"> *            configured (see XMAC_STATS_GLOBAL_CFG.TTL_FRMS_HANDLING) to count</span>
<span class="cm"> *            everything, even &quot;frames&quot; as small one byte of preamble.</span>
<span class="cm"> * @rx_vld_frms: Count of successfully received MAC frames. Does not include</span>
<span class="cm"> *            frames received with frame-too-long, FCS, or length errors.</span>
<span class="cm"> * @rx_offload_frms: Count of offloaded received frames that are passed to</span>
<span class="cm"> *            the host.</span>
<span class="cm"> * @rx_ttl_octets: Count of total octets of received frames, not including</span>
<span class="cm"> *            framing characters (i.e. less framing bits). To determine the</span>
<span class="cm"> *            total octets of received frames, including framing characters,</span>
<span class="cm"> *            multiply PORTn_RX_TTL_FRMS by 8 and add it to this stat (unless</span>
<span class="cm"> *            otherwise configured, this stat only counts frames that have 8</span>
<span class="cm"> *            bytes of preamble for each frame). This stat can be configured</span>
<span class="cm"> *            (see XMAC_STATS_GLOBAL_CFG.TTL_FRMS_HANDLING) to count everything,</span>
<span class="cm"> *            even the preamble octets of &quot;frames&quot; as small one byte of preamble</span>
<span class="cm"> * @rx_data_octets: Count of data and padding octets of successfully received</span>
<span class="cm"> *            frames. Does not include frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_offload_octets: Count of total octets, not including framing</span>
<span class="cm"> *            characters, of offloaded received frames that are passed</span>
<span class="cm"> *            to the host.</span>
<span class="cm"> * @rx_vld_mcast_frms: Count of successfully received MAC frames containing a</span>
<span class="cm"> *	      nonbroadcast group address. Does not include frames received</span>
<span class="cm"> *            with frame-too-long, FCS, or length errors.</span>
<span class="cm"> * @rx_vld_bcast_frms: Count of successfully received MAC frames containing</span>
<span class="cm"> *            the broadcast group address. Does not include frames received</span>
<span class="cm"> *            with frame-too-long, FCS, or length errors.</span>
<span class="cm"> * @rx_accepted_ucast_frms: Count of successfully received frames containing</span>
<span class="cm"> *            a unicast address. Only includes frames that are passed to</span>
<span class="cm"> *            the system.</span>
<span class="cm"> * @rx_accepted_nucast_frms: Count of successfully received frames containing</span>
<span class="cm"> *            a non-unicast (broadcast or multicast) address. Only includes</span>
<span class="cm"> *            frames that are passed to the system. Could include, for instance,</span>
<span class="cm"> *            non-unicast frames that contain FCS errors if the MAC_ERROR_CFG</span>
<span class="cm"> *            register is set to pass FCS-errored frames to the host.</span>
<span class="cm"> * @rx_tagged_frms: Count of received frames containing a VLAN tag.</span>
<span class="cm"> * @rx_long_frms: Count of received frames that are longer than RX_MAX_PYLD_LEN</span>
<span class="cm"> *            + 18 bytes (+ 22 bytes if VLAN-tagged).</span>
<span class="cm"> * @rx_usized_frms: Count of received frames of length (including FCS, but not</span>
<span class="cm"> *            framing bits) less than 64 octets, that are otherwise well-formed.</span>
<span class="cm"> *            In other words, counts runts.</span>
<span class="cm"> * @rx_osized_frms: Count of received frames of length (including FCS, but not</span>
<span class="cm"> *            framing bits) more than 1518 octets, that are otherwise</span>
<span class="cm"> *            well-formed. Note: If register XMAC_STATS_GLOBAL_CFG.VLAN_HANDLING</span>
<span class="cm"> *            is set to 1, then &quot;more than 1518 octets&quot; becomes &quot;more than 1518</span>
<span class="cm"> *            (1522 if VLAN-tagged) octets&quot;.</span>
<span class="cm"> * @rx_frag_frms: Count of received frames of length (including FCS, but not</span>
<span class="cm"> *            framing bits) less than 64 octets that had bad FCS. In other</span>
<span class="cm"> *            words, counts fragments.</span>
<span class="cm"> * @rx_jabber_frms: Count of received frames of length (including FCS, but not</span>
<span class="cm"> *            framing bits) more than 1518 octets that had bad FCS. In other</span>
<span class="cm"> *            words, counts jabbers. Note: If register</span>
<span class="cm"> *            XMAC_STATS_GLOBAL_CFG.VLAN_HANDLING is set to 1, then &quot;more than</span>
<span class="cm"> *            1518 octets&quot; becomes &quot;more than 1518 (1522 if VLAN-tagged)</span>
<span class="cm"> *            octets&quot;.</span>
<span class="cm"> * @rx_ttl_64_frms: Count of total received MAC frames with length (including</span>
<span class="cm"> *            FCS, but not framing bits) of exactly 64 octets. Includes frames</span>
<span class="cm"> *            received with frame-too-long, FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_65_127_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 65 and 127</span>
<span class="cm"> *            octets inclusive. Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_128_255_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 128 and 255</span>
<span class="cm"> *            octets inclusive. Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_256_511_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 256 and 511</span>
<span class="cm"> *            octets inclusive. Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_512_1023_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 512 and 1023</span>
<span class="cm"> *            octets inclusive. Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_1024_1518_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 1024 and 1518</span>
<span class="cm"> *            octets inclusive. Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_1519_4095_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 1519 and 4095</span>
<span class="cm"> *            octets inclusive. Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_4096_8191_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 4096 and 8191</span>
<span class="cm"> *            octets inclusive. Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_8192_max_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 8192 and</span>
<span class="cm"> *            RX_MAX_PYLD_LEN+18 octets inclusive. Includes frames received</span>
<span class="cm"> *            with frame-too-long, FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_gt_max_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) exceeding</span>
<span class="cm"> *            RX_MAX_PYLD_LEN+18 (+22 bytes if VLAN-tagged) octets inclusive.</span>
<span class="cm"> *            Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ip: Count of received IP datagrams. Includes errored IP datagrams.</span>
<span class="cm"> * @rx_accepted_ip: Count of received IP datagrams that</span>
<span class="cm"> * 		are passed to the system.</span>
<span class="cm"> * @rx_ip_octets: Count of number of octets in received IP datagrams. Includes</span>
<span class="cm"> *            errored IP datagrams.</span>
<span class="cm"> * @rx_err_ip: 	Count of received IP datagrams containing errors. For example,</span>
<span class="cm"> *            bad IP checksum.</span>
<span class="cm"> * @rx_icmp: Count of received ICMP messages. Includes errored ICMP messages.</span>
<span class="cm"> * @rx_tcp: Count of received TCP segments. Includes errored TCP segments.</span>
<span class="cm"> *            Note: This stat contains a count of all received TCP segments,</span>
<span class="cm"> *            regardless of whether or not they pertain to an established</span>
<span class="cm"> *            connection.</span>
<span class="cm"> * @rx_udp: Count of received UDP datagrams.</span>
<span class="cm"> * @rx_err_tcp: Count of received TCP segments containing errors. For example,</span>
<span class="cm"> *            bad TCP checksum.</span>
<span class="cm"> * @rx_pause_count: Count of number of pause quanta that the MAC has been in</span>
<span class="cm"> *            the paused state. Recall, one pause quantum equates to 512</span>
<span class="cm"> *            bit times.</span>
<span class="cm"> * @rx_pause_ctrl_frms: Count of received MAC PAUSE control frames.</span>
<span class="cm"> * @rx_unsup_ctrl_frms: Count of received MAC control frames that do not</span>
<span class="cm"> *            contain the PAUSE opcode. The sum of RX_PAUSE_CTRL_FRMS and</span>
<span class="cm"> *            this register is a count of all received MAC control frames.</span>
<span class="cm"> *            Note: This stat may be configured to count all layer 2 errors</span>
<span class="cm"> *            (i.e. length errors and FCS errors).</span>
<span class="cm"> * @rx_fcs_err_frms: Count of received MAC frames that do not pass FCS. Does</span>
<span class="cm"> *            not include frames received with frame-too-long or</span>
<span class="cm"> *            frame-too-short error.</span>
<span class="cm"> * @rx_in_rng_len_err_frms: Count of received frames with a length/type field</span>
<span class="cm"> *            value between 46 (42 for VLAN-tagged frames) and 1500 (also 1500</span>
<span class="cm"> *            for VLAN-tagged frames), inclusive, that does not match the</span>
<span class="cm"> *            number of data octets (including pad) received. Also contains</span>
<span class="cm"> *            a count of received frames with a length/type field less than</span>
<span class="cm"> *            46 (42 for VLAN-tagged frames) and the number of data octets</span>
<span class="cm"> *            (including pad) received is greater than 46 (42 for VLAN-tagged</span>
<span class="cm"> *            frames).</span>
<span class="cm"> * @rx_out_rng_len_err_frms:  Count of received frames with length/type field</span>
<span class="cm"> *            between 1501 and 1535 decimal, inclusive.</span>
<span class="cm"> * @rx_drop_frms: Count of received frames that could not be passed to the host.</span>
<span class="cm"> *            See PORTn_RX_L2_MGMT_DISCARD, PORTn_RX_RPA_DISCARD,</span>
<span class="cm"> *            PORTn_RX_TRASH_DISCARD, PORTn_RX_RTS_DISCARD, PORTn_RX_RED_DISCARD</span>
<span class="cm"> *            for a list of reasons. Because the RMAC drops one frame at a time,</span>
<span class="cm"> *            this stat also indicates the number of drop events.</span>
<span class="cm"> * @rx_discarded_frms: Count of received frames containing</span>
<span class="cm"> * 		any error that prevents</span>
<span class="cm"> *            them from being passed to the system. See PORTn_RX_FCS_DISCARD,</span>
<span class="cm"> *            PORTn_RX_LEN_DISCARD, and PORTn_RX_SWITCH_DISCARD for a list of</span>
<span class="cm"> *            reasons.</span>
<span class="cm"> * @rx_drop_ip: Count of received IP datagrams that could not be passed to the</span>
<span class="cm"> *            host. See PORTn_RX_DROP_FRMS for a list of reasons.</span>
<span class="cm"> * @rx_drop_udp: Count of received UDP datagrams that are not delivered to the</span>
<span class="cm"> *            host. See PORTn_RX_DROP_FRMS for a list of reasons.</span>
<span class="cm"> * @rx_marker_pdu_frms: Count of valid Marker PDUs received on this Aggregation</span>
<span class="cm"> *            port.</span>
<span class="cm"> * @rx_lacpdu_frms: Count of valid LACPDUs received on this Aggregation port.</span>
<span class="cm"> * @rx_unknown_pdu_frms: Count of received frames (on this Aggregation port)</span>
<span class="cm"> *            that carry the Slow Protocols EtherType, but contain an unknown</span>
<span class="cm"> *            PDU. Or frames that contain the Slow Protocols group MAC address,</span>
<span class="cm"> *            but do not carry the Slow Protocols EtherType.</span>
<span class="cm"> * @rx_marker_resp_pdu_frms: Count of valid Marker Response PDUs received on</span>
<span class="cm"> *            this Aggregation port.</span>
<span class="cm"> * @rx_fcs_discard: Count of received frames that are discarded because the</span>
<span class="cm"> *            FCS check failed.</span>
<span class="cm"> * @rx_illegal_pdu_frms: Count of received frames (on this Aggregation port)</span>
<span class="cm"> *            that carry the Slow Protocols EtherType, but contain a badly</span>
<span class="cm"> *            formed PDU. Or frames that carry the Slow Protocols EtherType,</span>
<span class="cm"> *            but contain an illegal value of Protocol Subtype.</span>
<span class="cm"> * @rx_switch_discard: Count of received frames that are discarded by the</span>
<span class="cm"> *            internal switch because they did not have an entry in the</span>
<span class="cm"> *            Filtering Database. This includes frames that had an invalid</span>
<span class="cm"> *            destination MAC address or VLAN ID. It also includes frames are</span>
<span class="cm"> *            discarded because they did not satisfy the length requirements</span>
<span class="cm"> *            of the target VPATH.</span>
<span class="cm"> * @rx_len_discard: Count of received frames that are discarded because of an</span>
<span class="cm"> *            invalid frame length (includes fragments, oversized frames and</span>
<span class="cm"> *            mismatch between frame length and length/type field). This stat</span>
<span class="cm"> *            can be configured</span>
<span class="cm"> *            (see XMAC_STATS_GLOBAL_CFG.LEN_DISCARD_HANDLING).</span>
<span class="cm"> * @rx_rpa_discard: Count of received frames that were discarded because the</span>
<span class="cm"> *            receive protocol assist (RPA) discovered and error in the frame</span>
<span class="cm"> *            or was unable to parse the frame.</span>
<span class="cm"> * @rx_l2_mgmt_discard: Count of Layer 2 management frames (eg. pause frames,</span>
<span class="cm"> *            Link Aggregation Control Protocol (LACP) frames, etc.) that are</span>
<span class="cm"> *            discarded.</span>
<span class="cm"> * @rx_rts_discard: Count of received frames that are discarded by the receive</span>
<span class="cm"> *            traffic steering (RTS) logic. Includes those frame discarded</span>
<span class="cm"> *            because the SSC response contradicted the switch table, because</span>
<span class="cm"> *            the SSC timed out, or because the target queue could not fit the</span>
<span class="cm"> *            frame.</span>
<span class="cm"> * @rx_trash_discard: Count of received frames that are discarded because</span>
<span class="cm"> *            receive traffic steering (RTS) steered the frame to the trash</span>
<span class="cm"> *            queue.</span>
<span class="cm"> * @rx_buff_full_discard: Count of received frames that are discarded because</span>
<span class="cm"> *            internal buffers are full. Includes frames discarded because the</span>
<span class="cm"> *            RTS logic is waiting for an SSC lookup that has no timeout bound.</span>
<span class="cm"> *            Also, includes frames that are dropped because the MAC2FAU buffer</span>
<span class="cm"> *            is nearly full -- this can happen if the external receive buffer</span>
<span class="cm"> *            is full and the receive path is backing up.</span>
<span class="cm"> * @rx_red_discard: Count of received frames that are discarded because of RED</span>
<span class="cm"> *            (Random Early Discard).</span>
<span class="cm"> * @rx_xgmii_ctrl_err_cnt: Maintains a count of unexpected or misplaced control</span>
<span class="cm"> *            characters occurring between times of normal data transmission</span>
<span class="cm"> *            (i.e. not included in RX_XGMII_DATA_ERR_CNT). This counter is</span>
<span class="cm"> *            incremented when either -</span>
<span class="cm"> *            1) The Reconciliation Sublayer (RS) is expecting one control</span>
<span class="cm"> *               character and gets another (i.e. is expecting a Start</span>
<span class="cm"> *               character, but gets another control character).</span>
<span class="cm"> *            2) Start control character is not in lane 0</span>
<span class="cm"> *            Only increments the count by one for each XGMII column.</span>
<span class="cm"> * @rx_xgmii_data_err_cnt: Maintains a count of unexpected control characters</span>
<span class="cm"> *            during normal data transmission. If the Reconciliation Sublayer</span>
<span class="cm"> *            (RS) receives a control character, other than a terminate control</span>
<span class="cm"> *            character, during receipt of data octets then this register is</span>
<span class="cm"> *            incremented. Also increments if the start frame delimiter is not</span>
<span class="cm"> *            found in the correct location. Only increments the count by one</span>
<span class="cm"> *            for each XGMII column.</span>
<span class="cm"> * @rx_xgmii_char1_match: Maintains a count of the number of XGMII characters</span>
<span class="cm"> *            that match a pattern that is programmable through register</span>
<span class="cm"> *            XMAC_STATS_RX_XGMII_CHAR_PORTn. By default, the pattern is set</span>
<span class="cm"> *            to /E/ (i.e. the error character), thus the statistic tracks the</span>
<span class="cm"> *            number of Error characters received at any time.</span>
<span class="cm"> * @rx_xgmii_err_sym: Count of the number of symbol errors in the received</span>
<span class="cm"> *            XGMII data (i.e. PHY indicates &quot;Receive Error&quot; on the XGMII).</span>
<span class="cm"> *            Only includes symbol errors that are observed between the XGMII</span>
<span class="cm"> *            Start Frame Delimiter and End Frame Delimiter, inclusive. And</span>
<span class="cm"> *            only increments the count by one for each frame.</span>
<span class="cm"> * @rx_xgmii_column1_match: Maintains a count of the number of XGMII columns</span>
<span class="cm"> *            that match a pattern that is programmable through register</span>
<span class="cm"> *            XMAC_STATS_RX_XGMII_COLUMN1_PORTn. By default, the pattern is set</span>
<span class="cm"> *            to 4 x /E/ (i.e. a column containing all error characters), thus</span>
<span class="cm"> *            the statistic tracks the number of Error columns received at any</span>
<span class="cm"> *            time.</span>
<span class="cm"> * @rx_xgmii_char2_match: Maintains a count of the number of XGMII characters</span>
<span class="cm"> *            that match a pattern that is programmable through register</span>
<span class="cm"> *            XMAC_STATS_RX_XGMII_CHAR_PORTn. By default, the pattern is set</span>
<span class="cm"> *            to /E/ (i.e. the error character), thus the statistic tracks the</span>
<span class="cm"> *            number of Error characters received at any time.</span>
<span class="cm"> * @rx_local_fault: Maintains a count of the number of times that link</span>
<span class="cm"> *            transitioned from &quot;up&quot; to &quot;down&quot; due to a local fault.</span>
<span class="cm"> * @rx_xgmii_column2_match: Maintains a count of the number of XGMII columns</span>
<span class="cm"> *            that match a pattern that is programmable through register</span>
<span class="cm"> *            XMAC_STATS_RX_XGMII_COLUMN2_PORTn. By default, the pattern is set</span>
<span class="cm"> *            to 4 x /E/ (i.e. a column containing all error characters), thus</span>
<span class="cm"> *            the statistic tracks the number of Error columns received at any</span>
<span class="cm"> *            time. If XMAC_STATS_RX_XGMII_BEHAV_COLUMN2_PORTn.NEAR_COL1 is set</span>
<span class="cm"> *            to 1, then this stat increments when COLUMN2 is found within &#39;n&#39;</span>
<span class="cm"> *            clocks after COLUMN1. Here, &#39;n&#39; is defined by</span>
<span class="cm"> *            XMAC_STATS_RX_XGMII_BEHAV_COLUMN2_PORTn.NUM_COL (if &#39;n&#39; is set to</span>
<span class="cm"> *            0, then it means to search anywhere for COLUMN2).</span>
<span class="cm"> * @rx_jettison: Count of received frames that are jettisoned because internal</span>
<span class="cm"> *            buffers are full.</span>
<span class="cm"> * @rx_remote_fault: Maintains a count of the number of times that link</span>
<span class="cm"> *            transitioned from &quot;up&quot; to &quot;down&quot; due to a remote fault.</span>
<span class="cm"> *</span>
<span class="cm"> * XMAC Port Statistics.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_xmac_port_stats</span> <span class="p">{</span>
<span class="cm">/*0x000*/</span>		<span class="n">u64</span>	<span class="n">tx_ttl_frms</span><span class="p">;</span>
<span class="cm">/*0x008*/</span>		<span class="n">u64</span>	<span class="n">tx_ttl_octets</span><span class="p">;</span>
<span class="cm">/*0x010*/</span>		<span class="n">u64</span>	<span class="n">tx_data_octets</span><span class="p">;</span>
<span class="cm">/*0x018*/</span>		<span class="n">u64</span>	<span class="n">tx_mcast_frms</span><span class="p">;</span>
<span class="cm">/*0x020*/</span>		<span class="n">u64</span>	<span class="n">tx_bcast_frms</span><span class="p">;</span>
<span class="cm">/*0x028*/</span>		<span class="n">u64</span>	<span class="n">tx_ucast_frms</span><span class="p">;</span>
<span class="cm">/*0x030*/</span>		<span class="n">u64</span>	<span class="n">tx_tagged_frms</span><span class="p">;</span>
<span class="cm">/*0x038*/</span>		<span class="n">u64</span>	<span class="n">tx_vld_ip</span><span class="p">;</span>
<span class="cm">/*0x040*/</span>		<span class="n">u64</span>	<span class="n">tx_vld_ip_octets</span><span class="p">;</span>
<span class="cm">/*0x048*/</span>		<span class="n">u64</span>	<span class="n">tx_icmp</span><span class="p">;</span>
<span class="cm">/*0x050*/</span>		<span class="n">u64</span>	<span class="n">tx_tcp</span><span class="p">;</span>
<span class="cm">/*0x058*/</span>		<span class="n">u64</span>	<span class="n">tx_rst_tcp</span><span class="p">;</span>
<span class="cm">/*0x060*/</span>		<span class="n">u64</span>	<span class="n">tx_udp</span><span class="p">;</span>
<span class="cm">/*0x068*/</span>		<span class="n">u32</span>	<span class="n">tx_parse_error</span><span class="p">;</span>
<span class="cm">/*0x06c*/</span>		<span class="n">u32</span>	<span class="n">tx_unknown_protocol</span><span class="p">;</span>
<span class="cm">/*0x070*/</span>		<span class="n">u64</span>	<span class="n">tx_pause_ctrl_frms</span><span class="p">;</span>
<span class="cm">/*0x078*/</span>		<span class="n">u32</span>	<span class="n">tx_marker_pdu_frms</span><span class="p">;</span>
<span class="cm">/*0x07c*/</span>		<span class="n">u32</span>	<span class="n">tx_lacpdu_frms</span><span class="p">;</span>
<span class="cm">/*0x080*/</span>		<span class="n">u32</span>	<span class="n">tx_drop_ip</span><span class="p">;</span>
<span class="cm">/*0x084*/</span>		<span class="n">u32</span>	<span class="n">tx_marker_resp_pdu_frms</span><span class="p">;</span>
<span class="cm">/*0x088*/</span>		<span class="n">u32</span>	<span class="n">tx_xgmii_char2_match</span><span class="p">;</span>
<span class="cm">/*0x08c*/</span>		<span class="n">u32</span>	<span class="n">tx_xgmii_char1_match</span><span class="p">;</span>
<span class="cm">/*0x090*/</span>		<span class="n">u32</span>	<span class="n">tx_xgmii_column2_match</span><span class="p">;</span>
<span class="cm">/*0x094*/</span>		<span class="n">u32</span>	<span class="n">tx_xgmii_column1_match</span><span class="p">;</span>
<span class="cm">/*0x098*/</span>		<span class="n">u32</span>	<span class="n">unused1</span><span class="p">;</span>
<span class="cm">/*0x09c*/</span>		<span class="n">u16</span>	<span class="n">tx_any_err_frms</span><span class="p">;</span>
<span class="cm">/*0x09e*/</span>		<span class="n">u16</span>	<span class="n">tx_drop_frms</span><span class="p">;</span>
<span class="cm">/*0x0a0*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_frms</span><span class="p">;</span>
<span class="cm">/*0x0a8*/</span>		<span class="n">u64</span>	<span class="n">rx_vld_frms</span><span class="p">;</span>
<span class="cm">/*0x0b0*/</span>		<span class="n">u64</span>	<span class="n">rx_offload_frms</span><span class="p">;</span>
<span class="cm">/*0x0b8*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_octets</span><span class="p">;</span>
<span class="cm">/*0x0c0*/</span>		<span class="n">u64</span>	<span class="n">rx_data_octets</span><span class="p">;</span>
<span class="cm">/*0x0c8*/</span>		<span class="n">u64</span>	<span class="n">rx_offload_octets</span><span class="p">;</span>
<span class="cm">/*0x0d0*/</span>		<span class="n">u64</span>	<span class="n">rx_vld_mcast_frms</span><span class="p">;</span>
<span class="cm">/*0x0d8*/</span>		<span class="n">u64</span>	<span class="n">rx_vld_bcast_frms</span><span class="p">;</span>
<span class="cm">/*0x0e0*/</span>		<span class="n">u64</span>	<span class="n">rx_accepted_ucast_frms</span><span class="p">;</span>
<span class="cm">/*0x0e8*/</span>		<span class="n">u64</span>	<span class="n">rx_accepted_nucast_frms</span><span class="p">;</span>
<span class="cm">/*0x0f0*/</span>		<span class="n">u64</span>	<span class="n">rx_tagged_frms</span><span class="p">;</span>
<span class="cm">/*0x0f8*/</span>		<span class="n">u64</span>	<span class="n">rx_long_frms</span><span class="p">;</span>
<span class="cm">/*0x100*/</span>		<span class="n">u64</span>	<span class="n">rx_usized_frms</span><span class="p">;</span>
<span class="cm">/*0x108*/</span>		<span class="n">u64</span>	<span class="n">rx_osized_frms</span><span class="p">;</span>
<span class="cm">/*0x110*/</span>		<span class="n">u64</span>	<span class="n">rx_frag_frms</span><span class="p">;</span>
<span class="cm">/*0x118*/</span>		<span class="n">u64</span>	<span class="n">rx_jabber_frms</span><span class="p">;</span>
<span class="cm">/*0x120*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_64_frms</span><span class="p">;</span>
<span class="cm">/*0x128*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_65_127_frms</span><span class="p">;</span>
<span class="cm">/*0x130*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_128_255_frms</span><span class="p">;</span>
<span class="cm">/*0x138*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_256_511_frms</span><span class="p">;</span>
<span class="cm">/*0x140*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_512_1023_frms</span><span class="p">;</span>
<span class="cm">/*0x148*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_1024_1518_frms</span><span class="p">;</span>
<span class="cm">/*0x150*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_1519_4095_frms</span><span class="p">;</span>
<span class="cm">/*0x158*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_4096_8191_frms</span><span class="p">;</span>
<span class="cm">/*0x160*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_8192_max_frms</span><span class="p">;</span>
<span class="cm">/*0x168*/</span>		<span class="n">u64</span>	<span class="n">rx_ttl_gt_max_frms</span><span class="p">;</span>
<span class="cm">/*0x170*/</span>		<span class="n">u64</span>	<span class="n">rx_ip</span><span class="p">;</span>
<span class="cm">/*0x178*/</span>		<span class="n">u64</span>	<span class="n">rx_accepted_ip</span><span class="p">;</span>
<span class="cm">/*0x180*/</span>		<span class="n">u64</span>	<span class="n">rx_ip_octets</span><span class="p">;</span>
<span class="cm">/*0x188*/</span>		<span class="n">u64</span>	<span class="n">rx_err_ip</span><span class="p">;</span>
<span class="cm">/*0x190*/</span>		<span class="n">u64</span>	<span class="n">rx_icmp</span><span class="p">;</span>
<span class="cm">/*0x198*/</span>		<span class="n">u64</span>	<span class="n">rx_tcp</span><span class="p">;</span>
<span class="cm">/*0x1a0*/</span>		<span class="n">u64</span>	<span class="n">rx_udp</span><span class="p">;</span>
<span class="cm">/*0x1a8*/</span>		<span class="n">u64</span>	<span class="n">rx_err_tcp</span><span class="p">;</span>
<span class="cm">/*0x1b0*/</span>		<span class="n">u64</span>	<span class="n">rx_pause_count</span><span class="p">;</span>
<span class="cm">/*0x1b8*/</span>		<span class="n">u64</span>	<span class="n">rx_pause_ctrl_frms</span><span class="p">;</span>
<span class="cm">/*0x1c0*/</span>		<span class="n">u64</span>	<span class="n">rx_unsup_ctrl_frms</span><span class="p">;</span>
<span class="cm">/*0x1c8*/</span>		<span class="n">u64</span>	<span class="n">rx_fcs_err_frms</span><span class="p">;</span>
<span class="cm">/*0x1d0*/</span>		<span class="n">u64</span>	<span class="n">rx_in_rng_len_err_frms</span><span class="p">;</span>
<span class="cm">/*0x1d8*/</span>		<span class="n">u64</span>	<span class="n">rx_out_rng_len_err_frms</span><span class="p">;</span>
<span class="cm">/*0x1e0*/</span>		<span class="n">u64</span>	<span class="n">rx_drop_frms</span><span class="p">;</span>
<span class="cm">/*0x1e8*/</span>		<span class="n">u64</span>	<span class="n">rx_discarded_frms</span><span class="p">;</span>
<span class="cm">/*0x1f0*/</span>		<span class="n">u64</span>	<span class="n">rx_drop_ip</span><span class="p">;</span>
<span class="cm">/*0x1f8*/</span>		<span class="n">u64</span>	<span class="n">rx_drop_udp</span><span class="p">;</span>
<span class="cm">/*0x200*/</span>		<span class="n">u32</span>	<span class="n">rx_marker_pdu_frms</span><span class="p">;</span>
<span class="cm">/*0x204*/</span>		<span class="n">u32</span>	<span class="n">rx_lacpdu_frms</span><span class="p">;</span>
<span class="cm">/*0x208*/</span>		<span class="n">u32</span>	<span class="n">rx_unknown_pdu_frms</span><span class="p">;</span>
<span class="cm">/*0x20c*/</span>		<span class="n">u32</span>	<span class="n">rx_marker_resp_pdu_frms</span><span class="p">;</span>
<span class="cm">/*0x210*/</span>		<span class="n">u32</span>	<span class="n">rx_fcs_discard</span><span class="p">;</span>
<span class="cm">/*0x214*/</span>		<span class="n">u32</span>	<span class="n">rx_illegal_pdu_frms</span><span class="p">;</span>
<span class="cm">/*0x218*/</span>		<span class="n">u32</span>	<span class="n">rx_switch_discard</span><span class="p">;</span>
<span class="cm">/*0x21c*/</span>		<span class="n">u32</span>	<span class="n">rx_len_discard</span><span class="p">;</span>
<span class="cm">/*0x220*/</span>		<span class="n">u32</span>	<span class="n">rx_rpa_discard</span><span class="p">;</span>
<span class="cm">/*0x224*/</span>		<span class="n">u32</span>	<span class="n">rx_l2_mgmt_discard</span><span class="p">;</span>
<span class="cm">/*0x228*/</span>		<span class="n">u32</span>	<span class="n">rx_rts_discard</span><span class="p">;</span>
<span class="cm">/*0x22c*/</span>		<span class="n">u32</span>	<span class="n">rx_trash_discard</span><span class="p">;</span>
<span class="cm">/*0x230*/</span>		<span class="n">u32</span>	<span class="n">rx_buff_full_discard</span><span class="p">;</span>
<span class="cm">/*0x234*/</span>		<span class="n">u32</span>	<span class="n">rx_red_discard</span><span class="p">;</span>
<span class="cm">/*0x238*/</span>		<span class="n">u32</span>	<span class="n">rx_xgmii_ctrl_err_cnt</span><span class="p">;</span>
<span class="cm">/*0x23c*/</span>		<span class="n">u32</span>	<span class="n">rx_xgmii_data_err_cnt</span><span class="p">;</span>
<span class="cm">/*0x240*/</span>		<span class="n">u32</span>	<span class="n">rx_xgmii_char1_match</span><span class="p">;</span>
<span class="cm">/*0x244*/</span>		<span class="n">u32</span>	<span class="n">rx_xgmii_err_sym</span><span class="p">;</span>
<span class="cm">/*0x248*/</span>		<span class="n">u32</span>	<span class="n">rx_xgmii_column1_match</span><span class="p">;</span>
<span class="cm">/*0x24c*/</span>		<span class="n">u32</span>	<span class="n">rx_xgmii_char2_match</span><span class="p">;</span>
<span class="cm">/*0x250*/</span>		<span class="n">u32</span>	<span class="n">rx_local_fault</span><span class="p">;</span>
<span class="cm">/*0x254*/</span>		<span class="n">u32</span>	<span class="n">rx_xgmii_column2_match</span><span class="p">;</span>
<span class="cm">/*0x258*/</span>		<span class="n">u32</span>	<span class="n">rx_jettison</span><span class="p">;</span>
<span class="cm">/*0x25c*/</span>		<span class="n">u32</span>	<span class="n">rx_remote_fault</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_xmac_vpath_tx_stats - XMAC Vpath Tx Statistics</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_ttl_eth_frms: Count of successfully transmitted MAC frames.</span>
<span class="cm"> * @tx_ttl_eth_octets: Count of total octets of transmitted frames,</span>
<span class="cm"> *             not including framing characters (i.e. less framing bits).</span>
<span class="cm"> *             To determine the total octets of transmitted frames, including</span>
<span class="cm"> *             framing characters, multiply TX_TTL_ETH_FRMS by 8 and add it to</span>
<span class="cm"> *             this stat (the device always prepends 8 bytes of preamble for</span>
<span class="cm"> *             each frame)</span>
<span class="cm"> * @tx_data_octets: Count of data and padding octets of successfully transmitted</span>
<span class="cm"> *             frames.</span>
<span class="cm"> * @tx_mcast_frms: Count of successfully transmitted frames to a group address</span>
<span class="cm"> *             other than the broadcast address.</span>
<span class="cm"> * @tx_bcast_frms: Count of successfully transmitted frames to the broadcast</span>
<span class="cm"> *             group address.</span>
<span class="cm"> * @tx_ucast_frms: Count of transmitted frames containing a unicast address.</span>
<span class="cm"> *             Includes discarded frames that are not sent to the network.</span>
<span class="cm"> * @tx_tagged_frms: Count of transmitted frames containing a VLAN tag.</span>
<span class="cm"> * @tx_vld_ip: Count of transmitted IP datagrams that are passed to the network.</span>
<span class="cm"> * @tx_vld_ip_octets: Count of total octets of transmitted IP datagrams that</span>
<span class="cm"> *            are passed to the network.</span>
<span class="cm"> * @tx_icmp: Count of transmitted ICMP messages. Includes messages not sent due</span>
<span class="cm"> *            to problems within ICMP.</span>
<span class="cm"> * @tx_tcp: Count of transmitted TCP segments. Does not include segments</span>
<span class="cm"> *            containing retransmitted octets.</span>
<span class="cm"> * @tx_rst_tcp: Count of transmitted TCP segments containing the RST flag.</span>
<span class="cm"> * @tx_udp: Count of transmitted UDP datagrams.</span>
<span class="cm"> * @tx_unknown_protocol: Increments when the TPA encounters an unknown protocol,</span>
<span class="cm"> *            such as a new IPv6 extension header, or an unsupported Routing</span>
<span class="cm"> *            Type. The packet still has a checksum calculated but it may be</span>
<span class="cm"> *            incorrect.</span>
<span class="cm"> * @tx_lost_ip: Count of transmitted IP datagrams that could not be passed</span>
<span class="cm"> *            to the network. Increments because of: 1) An internal processing</span>
<span class="cm"> *            error (such as an uncorrectable ECC error). 2) A frame parsing</span>
<span class="cm"> *            error during IP checksum calculation.</span>
<span class="cm"> * @tx_parse_error: Increments when the TPA is unable to parse a packet. This</span>
<span class="cm"> *            generally occurs when a packet is corrupt somehow, including</span>
<span class="cm"> *            packets that have IP version mismatches, invalid Layer 2 control</span>
<span class="cm"> *            fields, etc. L3/L4 checksums are not offloaded, but the packet</span>
<span class="cm"> *            is still be transmitted.</span>
<span class="cm"> * @tx_tcp_offload: For frames belonging to offloaded sessions only, a count</span>
<span class="cm"> *            of transmitted TCP segments. Does not include segments containing</span>
<span class="cm"> *            retransmitted octets.</span>
<span class="cm"> * @tx_retx_tcp_offload: For frames belonging to offloaded sessions only, the</span>
<span class="cm"> *            total number of segments retransmitted. Retransmitted segments</span>
<span class="cm"> *            that are sourced by the host are counted by the host.</span>
<span class="cm"> * @tx_lost_ip_offload: For frames belonging to offloaded sessions only, a count</span>
<span class="cm"> *            of transmitted IP datagrams that could not be passed to the</span>
<span class="cm"> *            network.</span>
<span class="cm"> *</span>
<span class="cm"> * XMAC Vpath TX Statistics.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_xmac_vpath_tx_stats</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">tx_ttl_eth_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_ttl_eth_octets</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_data_octets</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_mcast_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_bcast_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_ucast_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_tagged_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_vld_ip</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_vld_ip_octets</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_icmp</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_tcp</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_rst_tcp</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_udp</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">tx_unknown_protocol</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">tx_lost_ip</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">unused1</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">tx_parse_error</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_tcp_offload</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_retx_tcp_offload</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tx_lost_ip_offload</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_xmac_vpath_rx_stats - XMAC Vpath RX Statistics</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_ttl_eth_frms: Count of successfully received MAC frames.</span>
<span class="cm"> * @rx_vld_frms: Count of successfully received MAC frames. Does not include</span>
<span class="cm"> *            frames received with frame-too-long, FCS, or length errors.</span>
<span class="cm"> * @rx_offload_frms: Count of offloaded received frames that are passed to</span>
<span class="cm"> *            the host.</span>
<span class="cm"> * @rx_ttl_eth_octets: Count of total octets of received frames, not including</span>
<span class="cm"> *            framing characters (i.e. less framing bits). Only counts octets</span>
<span class="cm"> *            of frames that are at least 14 bytes (18 bytes for VLAN-tagged)</span>
<span class="cm"> *            before FCS. To determine the total octets of received frames,</span>
<span class="cm"> *            including framing characters, multiply RX_TTL_ETH_FRMS by 8 and</span>
<span class="cm"> *            add it to this stat (the stat RX_TTL_ETH_FRMS only counts frames</span>
<span class="cm"> *            that have the required 8 bytes of preamble).</span>
<span class="cm"> * @rx_data_octets: Count of data and padding octets of successfully received</span>
<span class="cm"> *            frames. Does not include frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_offload_octets: Count of total octets, not including framing characters,</span>
<span class="cm"> *            of offloaded received frames that are passed to the host.</span>
<span class="cm"> * @rx_vld_mcast_frms: Count of successfully received MAC frames containing a</span>
<span class="cm"> *            nonbroadcast group address. Does not include frames received with</span>
<span class="cm"> *            frame-too-long, FCS, or length errors.</span>
<span class="cm"> * @rx_vld_bcast_frms: Count of successfully received MAC frames containing the</span>
<span class="cm"> *            broadcast group address. Does not include frames received with</span>
<span class="cm"> *            frame-too-long, FCS, or length errors.</span>
<span class="cm"> * @rx_accepted_ucast_frms: Count of successfully received frames containing</span>
<span class="cm"> *            a unicast address. Only includes frames that are passed to the</span>
<span class="cm"> *            system.</span>
<span class="cm"> * @rx_accepted_nucast_frms: Count of successfully received frames containing</span>
<span class="cm"> *            a non-unicast (broadcast or multicast) address. Only includes</span>
<span class="cm"> *            frames that are passed to the system. Could include, for instance,</span>
<span class="cm"> *            non-unicast frames that contain FCS errors if the MAC_ERROR_CFG</span>
<span class="cm"> *            register is set to pass FCS-errored frames to the host.</span>
<span class="cm"> * @rx_tagged_frms: Count of received frames containing a VLAN tag.</span>
<span class="cm"> * @rx_long_frms: Count of received frames that are longer than RX_MAX_PYLD_LEN</span>
<span class="cm"> *            + 18 bytes (+ 22 bytes if VLAN-tagged).</span>
<span class="cm"> * @rx_usized_frms: Count of received frames of length (including FCS, but not</span>
<span class="cm"> *            framing bits) less than 64 octets, that are otherwise well-formed.</span>
<span class="cm"> *            In other words, counts runts.</span>
<span class="cm"> * @rx_osized_frms: Count of received frames of length (including FCS, but not</span>
<span class="cm"> *            framing bits) more than 1518 octets, that are otherwise</span>
<span class="cm"> *            well-formed.</span>
<span class="cm"> * @rx_frag_frms: Count of received frames of length (including FCS, but not</span>
<span class="cm"> *            framing bits) less than 64 octets that had bad FCS.</span>
<span class="cm"> *            In other words, counts fragments.</span>
<span class="cm"> * @rx_jabber_frms: Count of received frames of length (including FCS, but not</span>
<span class="cm"> *            framing bits) more than 1518 octets that had bad FCS. In other</span>
<span class="cm"> *            words, counts jabbers.</span>
<span class="cm"> * @rx_ttl_64_frms: Count of total received MAC frames with length (including</span>
<span class="cm"> *            FCS, but not framing bits) of exactly 64 octets. Includes frames</span>
<span class="cm"> *            received with frame-too-long, FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_65_127_frms: Count of total received MAC frames</span>
<span class="cm"> * 		with length (including</span>
<span class="cm"> *            FCS, but not framing bits) of between 65 and 127 octets inclusive.</span>
<span class="cm"> *            Includes frames received with frame-too-long, FCS,</span>
<span class="cm"> *            or length errors.</span>
<span class="cm"> * @rx_ttl_128_255_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits)</span>
<span class="cm"> *            of between 128 and 255 octets</span>
<span class="cm"> *            inclusive. Includes frames received with frame-too-long, FCS,</span>
<span class="cm"> *            or length errors.</span>
<span class="cm"> * @rx_ttl_256_511_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits)</span>
<span class="cm"> *            of between 256 and 511 octets</span>
<span class="cm"> *            inclusive. Includes frames received with frame-too-long, FCS, or</span>
<span class="cm"> *            length errors.</span>
<span class="cm"> * @rx_ttl_512_1023_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 512 and 1023</span>
<span class="cm"> *            octets inclusive. Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_1024_1518_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 1024 and 1518</span>
<span class="cm"> *            octets inclusive. Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_1519_4095_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 1519 and 4095</span>
<span class="cm"> *            octets inclusive. Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_4096_8191_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 4096 and 8191</span>
<span class="cm"> *            octets inclusive. Includes frames received with frame-too-long,</span>
<span class="cm"> *            FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_8192_max_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) of between 8192 and</span>
<span class="cm"> *            RX_MAX_PYLD_LEN+18 octets inclusive. Includes frames received</span>
<span class="cm"> *            with frame-too-long, FCS, or length errors.</span>
<span class="cm"> * @rx_ttl_gt_max_frms: Count of total received MAC frames with length</span>
<span class="cm"> *            (including FCS, but not framing bits) exceeding RX_MAX_PYLD_LEN+18</span>
<span class="cm"> *            (+22 bytes if VLAN-tagged) octets inclusive. Includes frames</span>
<span class="cm"> *            received with frame-too-long, FCS, or length errors.</span>
<span class="cm"> * @rx_ip: Count of received IP datagrams. Includes errored IP datagrams.</span>
<span class="cm"> * @rx_accepted_ip: Count of received IP datagrams that</span>
<span class="cm"> * 		are passed to the system.</span>
<span class="cm"> * @rx_ip_octets: Count of number of octets in received IP datagrams.</span>
<span class="cm"> *            Includes errored IP datagrams.</span>
<span class="cm"> * @rx_err_ip: Count of received IP datagrams containing errors. For example,</span>
<span class="cm"> *            bad IP checksum.</span>
<span class="cm"> * @rx_icmp: Count of received ICMP messages. Includes errored ICMP messages.</span>
<span class="cm"> * @rx_tcp: Count of received TCP segments. Includes errored TCP segments.</span>
<span class="cm"> *             Note: This stat contains a count of all received TCP segments,</span>
<span class="cm"> *             regardless of whether or not they pertain to an established</span>
<span class="cm"> *             connection.</span>
<span class="cm"> * @rx_udp: Count of received UDP datagrams.</span>
<span class="cm"> * @rx_err_tcp: Count of received TCP segments containing errors. For example,</span>
<span class="cm"> *             bad TCP checksum.</span>
<span class="cm"> * @rx_lost_frms: Count of received frames that could not be passed to the host.</span>
<span class="cm"> *             See RX_QUEUE_FULL_DISCARD and RX_RED_DISCARD</span>
<span class="cm"> *             for a list of reasons.</span>
<span class="cm"> * @rx_lost_ip: Count of received IP datagrams that could not be passed to</span>
<span class="cm"> *             the host. See RX_LOST_FRMS for a list of reasons.</span>
<span class="cm"> * @rx_lost_ip_offload: For frames belonging to offloaded sessions only, a count</span>
<span class="cm"> *             of received IP datagrams that could not be passed to the host.</span>
<span class="cm"> *             See RX_LOST_FRMS for a list of reasons.</span>
<span class="cm"> * @rx_various_discard: Count of received frames that are discarded because</span>
<span class="cm"> *             the target receive queue is full.</span>
<span class="cm"> * @rx_sleep_discard: Count of received frames that are discarded because the</span>
<span class="cm"> *            target VPATH is asleep (a Wake-on-LAN magic packet can be used</span>
<span class="cm"> *            to awaken the VPATH).</span>
<span class="cm"> * @rx_red_discard: Count of received frames that are discarded because of RED</span>
<span class="cm"> *            (Random Early Discard).</span>
<span class="cm"> * @rx_queue_full_discard: Count of received frames that are discarded because</span>
<span class="cm"> *             the target receive queue is full.</span>
<span class="cm"> * @rx_mpa_ok_frms: Count of received frames that pass the MPA checks.</span>
<span class="cm"> *</span>
<span class="cm"> * XMAC Vpath RX Statistics.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_xmac_vpath_rx_stats</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_eth_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_vld_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_offload_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_eth_octets</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_data_octets</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_offload_octets</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_vld_mcast_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_vld_bcast_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_accepted_ucast_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_accepted_nucast_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_tagged_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_long_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_usized_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_osized_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_frag_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_jabber_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_64_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_65_127_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_128_255_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_256_511_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_512_1023_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_1024_1518_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_1519_4095_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_4096_8191_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_8192_max_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ttl_gt_max_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ip</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_accepted_ip</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_ip_octets</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_err_ip</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_icmp</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_tcp</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_udp</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_err_tcp</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_lost_frms</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_lost_ip</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_lost_ip_offload</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">rx_various_discard</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">rx_sleep_discard</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">rx_red_discard</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">rx_queue_full_discard</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rx_mpa_ok_frms</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_xmac_stats - XMAC Statistics</span>
<span class="cm"> *</span>
<span class="cm"> * @aggr_stats: Statistics on aggregate port(port 0, port 1)</span>
<span class="cm"> * @port_stats: Staticstics on ports(wire 0, wire 1, lag)</span>
<span class="cm"> * @vpath_tx_stats: Per vpath XMAC TX stats</span>
<span class="cm"> * @vpath_rx_stats: Per vpath XMAC RX stats</span>
<span class="cm"> *</span>
<span class="cm"> * XMAC Statistics.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_xmac_stats</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vxge_hw_xmac_aggr_stats</span>
				<span class="n">aggr_stats</span><span class="p">[</span><span class="n">VXGE_HW_MAC_MAX_MAC_PORT_ID</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">vxge_hw_xmac_port_stats</span>
				<span class="n">port_stats</span><span class="p">[</span><span class="n">VXGE_HW_MAC_MAX_MAC_PORT_ID</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">vxge_hw_xmac_vpath_tx_stats</span>
				<span class="n">vpath_tx_stats</span><span class="p">[</span><span class="n">VXGE_HW_MAX_VIRTUAL_PATHS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">vxge_hw_xmac_vpath_rx_stats</span>
				<span class="n">vpath_rx_stats</span><span class="p">[</span><span class="n">VXGE_HW_MAX_VIRTUAL_PATHS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_vpath_stats_hw_info - Titan vpath hardware statistics.</span>
<span class="cm"> * @ini_num_mwr_sent: The number of PCI memory writes initiated by the PIC block</span>
<span class="cm"> *             for the given VPATH</span>
<span class="cm"> * @ini_num_mrd_sent: The number of PCI memory reads initiated by the PIC block</span>
<span class="cm"> * @ini_num_cpl_rcvd: The number of PCI read completions received by the</span>
<span class="cm"> *             PIC block</span>
<span class="cm"> * @ini_num_mwr_byte_sent: The number of PCI memory write bytes sent by the PIC</span>
<span class="cm"> *             block to the host</span>
<span class="cm"> * @ini_num_cpl_byte_rcvd: The number of PCI read completion bytes received by</span>
<span class="cm"> *             the PIC block</span>
<span class="cm"> * @wrcrdtarb_xoff: TBD</span>
<span class="cm"> * @rdcrdtarb_xoff: TBD</span>
<span class="cm"> * @vpath_genstats_count0: TBD</span>
<span class="cm"> * @vpath_genstats_count1: TBD</span>
<span class="cm"> * @vpath_genstats_count2: TBD</span>
<span class="cm"> * @vpath_genstats_count3: TBD</span>
<span class="cm"> * @vpath_genstats_count4: TBD</span>
<span class="cm"> * @vpath_gennstats_count5: TBD</span>
<span class="cm"> * @tx_stats: Transmit stats</span>
<span class="cm"> * @rx_stats: Receive stats</span>
<span class="cm"> * @prog_event_vnum1: Programmable statistic. Increments when internal logic</span>
<span class="cm"> *             detects a certain event. See register</span>
<span class="cm"> *             XMAC_STATS_CFG.EVENT_VNUM1_CFG for more information.</span>
<span class="cm"> * @prog_event_vnum0: Programmable statistic. Increments when internal logic</span>
<span class="cm"> *             detects a certain event. See register</span>
<span class="cm"> *             XMAC_STATS_CFG.EVENT_VNUM0_CFG for more information.</span>
<span class="cm"> * @prog_event_vnum3: Programmable statistic. Increments when internal logic</span>
<span class="cm"> *             detects a certain event. See register</span>
<span class="cm"> *             XMAC_STATS_CFG.EVENT_VNUM3_CFG for more information.</span>
<span class="cm"> * @prog_event_vnum2: Programmable statistic. Increments when internal logic</span>
<span class="cm"> *             detects a certain event. See register</span>
<span class="cm"> *             XMAC_STATS_CFG.EVENT_VNUM2_CFG for more information.</span>
<span class="cm"> * @rx_multi_cast_frame_discard: TBD</span>
<span class="cm"> * @rx_frm_transferred: TBD</span>
<span class="cm"> * @rxd_returned: TBD</span>
<span class="cm"> * @rx_mpa_len_fail_frms: Count of received frames</span>
<span class="cm"> * 		that fail the MPA length check</span>
<span class="cm"> * @rx_mpa_mrk_fail_frms: Count of received frames</span>
<span class="cm"> * 		that fail the MPA marker check</span>
<span class="cm"> * @rx_mpa_crc_fail_frms: Count of received frames that fail the MPA CRC check</span>
<span class="cm"> * @rx_permitted_frms: Count of frames that pass through the FAU and on to the</span>
<span class="cm"> *             frame buffer (and subsequently to the host).</span>
<span class="cm"> * @rx_vp_reset_discarded_frms: Count of receive frames that are discarded</span>
<span class="cm"> *             because the VPATH is in reset</span>
<span class="cm"> * @rx_wol_frms: Count of received &quot;magic packet&quot; frames. Stat increments</span>
<span class="cm"> *             whenever the received frame matches the VPATH&#39;s Wake-on-LAN</span>
<span class="cm"> *             signature(s) CRC.</span>
<span class="cm"> * @tx_vp_reset_discarded_frms: Count of transmit frames that are discarded</span>
<span class="cm"> *             because the VPATH is in reset. Includes frames that are discarded</span>
<span class="cm"> *             because the current VPIN does not match that VPIN of the frame</span>
<span class="cm"> *</span>
<span class="cm"> * Titan vpath hardware statistics.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_hw_info</span> <span class="p">{</span>
<span class="cm">/*0x000*/</span>	<span class="n">u32</span> <span class="n">ini_num_mwr_sent</span><span class="p">;</span>
<span class="cm">/*0x004*/</span>	<span class="n">u32</span> <span class="n">unused1</span><span class="p">;</span>
<span class="cm">/*0x008*/</span>	<span class="n">u32</span> <span class="n">ini_num_mrd_sent</span><span class="p">;</span>
<span class="cm">/*0x00c*/</span>	<span class="n">u32</span> <span class="n">unused2</span><span class="p">;</span>
<span class="cm">/*0x010*/</span>	<span class="n">u32</span> <span class="n">ini_num_cpl_rcvd</span><span class="p">;</span>
<span class="cm">/*0x014*/</span>	<span class="n">u32</span> <span class="n">unused3</span><span class="p">;</span>
<span class="cm">/*0x018*/</span>	<span class="n">u64</span> <span class="n">ini_num_mwr_byte_sent</span><span class="p">;</span>
<span class="cm">/*0x020*/</span>	<span class="n">u64</span> <span class="n">ini_num_cpl_byte_rcvd</span><span class="p">;</span>
<span class="cm">/*0x028*/</span>	<span class="n">u32</span> <span class="n">wrcrdtarb_xoff</span><span class="p">;</span>
<span class="cm">/*0x02c*/</span>	<span class="n">u32</span> <span class="n">unused4</span><span class="p">;</span>
<span class="cm">/*0x030*/</span>	<span class="n">u32</span> <span class="n">rdcrdtarb_xoff</span><span class="p">;</span>
<span class="cm">/*0x034*/</span>	<span class="n">u32</span> <span class="n">unused5</span><span class="p">;</span>
<span class="cm">/*0x038*/</span>	<span class="n">u32</span> <span class="n">vpath_genstats_count0</span><span class="p">;</span>
<span class="cm">/*0x03c*/</span>	<span class="n">u32</span> <span class="n">vpath_genstats_count1</span><span class="p">;</span>
<span class="cm">/*0x040*/</span>	<span class="n">u32</span> <span class="n">vpath_genstats_count2</span><span class="p">;</span>
<span class="cm">/*0x044*/</span>	<span class="n">u32</span> <span class="n">vpath_genstats_count3</span><span class="p">;</span>
<span class="cm">/*0x048*/</span>	<span class="n">u32</span> <span class="n">vpath_genstats_count4</span><span class="p">;</span>
<span class="cm">/*0x04c*/</span>	<span class="n">u32</span> <span class="n">unused6</span><span class="p">;</span>
<span class="cm">/*0x050*/</span>	<span class="n">u32</span> <span class="n">vpath_genstats_count5</span><span class="p">;</span>
<span class="cm">/*0x054*/</span>	<span class="n">u32</span> <span class="n">unused7</span><span class="p">;</span>
<span class="cm">/*0x058*/</span>	<span class="k">struct</span> <span class="n">vxge_hw_xmac_vpath_tx_stats</span> <span class="n">tx_stats</span><span class="p">;</span>
<span class="cm">/*0x0e8*/</span>	<span class="k">struct</span> <span class="n">vxge_hw_xmac_vpath_rx_stats</span> <span class="n">rx_stats</span><span class="p">;</span>
<span class="cm">/*0x220*/</span>	<span class="n">u64</span> <span class="n">unused9</span><span class="p">;</span>
<span class="cm">/*0x228*/</span>	<span class="n">u32</span> <span class="n">prog_event_vnum1</span><span class="p">;</span>
<span class="cm">/*0x22c*/</span>	<span class="n">u32</span> <span class="n">prog_event_vnum0</span><span class="p">;</span>
<span class="cm">/*0x230*/</span>	<span class="n">u32</span> <span class="n">prog_event_vnum3</span><span class="p">;</span>
<span class="cm">/*0x234*/</span>	<span class="n">u32</span> <span class="n">prog_event_vnum2</span><span class="p">;</span>
<span class="cm">/*0x238*/</span>	<span class="n">u16</span> <span class="n">rx_multi_cast_frame_discard</span><span class="p">;</span>
<span class="cm">/*0x23a*/</span>	<span class="n">u8</span> <span class="n">unused10</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="cm">/*0x240*/</span>	<span class="n">u32</span> <span class="n">rx_frm_transferred</span><span class="p">;</span>
<span class="cm">/*0x244*/</span>	<span class="n">u32</span> <span class="n">unused11</span><span class="p">;</span>
<span class="cm">/*0x248*/</span>	<span class="n">u16</span> <span class="n">rxd_returned</span><span class="p">;</span>
<span class="cm">/*0x24a*/</span>	<span class="n">u8</span> <span class="n">unused12</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="cm">/*0x252*/</span>	<span class="n">u16</span> <span class="n">rx_mpa_len_fail_frms</span><span class="p">;</span>
<span class="cm">/*0x254*/</span>	<span class="n">u16</span> <span class="n">rx_mpa_mrk_fail_frms</span><span class="p">;</span>
<span class="cm">/*0x256*/</span>	<span class="n">u16</span> <span class="n">rx_mpa_crc_fail_frms</span><span class="p">;</span>
<span class="cm">/*0x258*/</span>	<span class="n">u16</span> <span class="n">rx_permitted_frms</span><span class="p">;</span>
<span class="cm">/*0x25c*/</span>	<span class="n">u64</span> <span class="n">rx_vp_reset_discarded_frms</span><span class="p">;</span>
<span class="cm">/*0x25e*/</span>	<span class="n">u64</span> <span class="n">rx_wol_frms</span><span class="p">;</span>
<span class="cm">/*0x260*/</span>	<span class="n">u64</span> <span class="n">tx_vp_reset_discarded_frms</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_device_stats_mrpcim_info - Titan mrpcim hardware statistics.</span>
<span class="cm"> * @pic.ini_rd_drop  	 0x0000  	 4  	 Number of DMA reads initiated</span>
<span class="cm"> *  by the adapter that were discarded because the VPATH is out of service</span>
<span class="cm"> * @pic.ini_wr_drop 	0x0004 	4 	Number of DMA writes initiated by the</span>
<span class="cm"> *  adapter that were discared because the VPATH is out of service</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane0] 	0x0008 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane1] 	0x0010 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane2] 	0x0018 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane3] 	0x0020 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane4] 	0x0028 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane5] 	0x0030 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane6] 	0x0038 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane7] 	0x0040 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane8] 	0x0048 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane9] 	0x0050 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane10] 	0x0058 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane11] 	0x0060 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane12] 	0x0068 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane13] 	0x0070 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane14] 	0x0078 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane15] 	0x0080 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_ph_crdt_depleted[vplane16] 	0x0088 	4 	Number of times</span>
<span class="cm"> *  the posted header credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane0] 	0x0090 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane1] 	0x0098 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane2] 	0x00a0 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane3] 	0x00a8 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane4] 	0x00b0 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane5] 	0x00b8 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane6] 	0x00c0 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane7] 	0x00c8 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane8] 	0x00d0 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane9] 	0x00d8 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane10] 	0x00e0 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane11] 	0x00e8 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane12] 	0x00f0 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane13] 	0x00f8 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane14] 	0x0100 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane15] 	0x0108 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.wrcrdtarb_pd_crdt_depleted[vplane16] 	0x0110 	4 	Number of times</span>
<span class="cm"> *  the posted data credits for upstream PCI writes were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane0] 	0x0118 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane1] 	0x0120 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane2] 	0x0128 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane3] 	0x0130 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane4] 	0x0138 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane5] 	0x0140 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane6] 	0x0148 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane7] 	0x0150 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane8] 	0x0158 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane9] 	0x0160 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane10] 	0x0168 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane11] 	0x0170 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane12] 	0x0178 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane13] 	0x0180 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane14] 	0x0188 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane15] 	0x0190 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.rdcrdtarb_nph_crdt_depleted[vplane16] 	0x0198 	4 	Number of times</span>
<span class="cm"> *  the non-posted header credits for upstream PCI reads were depleted</span>
<span class="cm"> * @pic.ini_rd_vpin_drop 	0x01a0 	4 	Number of DMA reads initiated by</span>
<span class="cm"> *  the adapter that were discarded because the VPATH instance number does</span>
<span class="cm"> *  not match</span>
<span class="cm"> * @pic.ini_wr_vpin_drop 	0x01a4 	4 	Number of DMA writes initiated</span>
<span class="cm"> *  by the adapter that were discarded because the VPATH instance number</span>
<span class="cm"> *  does not match</span>
<span class="cm"> * @pic.genstats_count0 	0x01a8 	4 	Configurable statistic #1. Refer</span>
<span class="cm"> *  to the GENSTATS0_CFG for information on configuring this statistic</span>
<span class="cm"> * @pic.genstats_count1 	0x01ac 	4 	Configurable statistic #2. Refer</span>
<span class="cm"> *  to the GENSTATS1_CFG for information on configuring this statistic</span>
<span class="cm"> * @pic.genstats_count2 	0x01b0 	4 	Configurable statistic #3. Refer</span>
<span class="cm"> *  to the GENSTATS2_CFG for information on configuring this statistic</span>
<span class="cm"> * @pic.genstats_count3 	0x01b4 	4 	Configurable statistic #4. Refer</span>
<span class="cm"> *  to the GENSTATS3_CFG for information on configuring this statistic</span>
<span class="cm"> * @pic.genstats_count4 	0x01b8 	4 	Configurable statistic #5. Refer</span>
<span class="cm"> *  to the GENSTATS4_CFG for information on configuring this statistic</span>
<span class="cm"> * @pic.genstats_count5 	0x01c0 	4 	Configurable statistic #6. Refer</span>
<span class="cm"> *  to the GENSTATS5_CFG for information on configuring this statistic</span>
<span class="cm"> * @pci.rstdrop_cpl 	0x01c8 	4</span>
<span class="cm"> * @pci.rstdrop_msg 	0x01cc 	4</span>
<span class="cm"> * @pci.rstdrop_client1 	0x01d0 	4</span>
<span class="cm"> * @pci.rstdrop_client0 	0x01d4 	4</span>
<span class="cm"> * @pci.rstdrop_client2 	0x01d8 	4</span>
<span class="cm"> * @pci.depl_cplh[vplane0] 	0x01e2 	2 	Number of times completion</span>
<span class="cm"> *  header credits were depleted</span>
<span class="cm"> * @pci.depl_nph[vplane0] 	0x01e4 	2 	Number of times non posted</span>
<span class="cm"> *  header credits were depleted</span>
<span class="cm"> * @pci.depl_ph[vplane0] 	0x01e6 	2 	Number of times the posted</span>
<span class="cm"> *  header credits were depleted</span>
<span class="cm"> * @pci.depl_cplh[vplane1] 	0x01ea 	2</span>
<span class="cm"> * @pci.depl_nph[vplane1] 	0x01ec 	2</span>
<span class="cm"> * @pci.depl_ph[vplane1] 	0x01ee 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane2] 	0x01f2 	2</span>
<span class="cm"> * @pci.depl_nph[vplane2] 	0x01f4 	2</span>
<span class="cm"> * @pci.depl_ph[vplane2] 	0x01f6 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane3] 	0x01fa 	2</span>
<span class="cm"> * @pci.depl_nph[vplane3] 	0x01fc 	2</span>
<span class="cm"> * @pci.depl_ph[vplane3] 	0x01fe 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane4] 	0x0202 	2</span>
<span class="cm"> * @pci.depl_nph[vplane4] 	0x0204 	2</span>
<span class="cm"> * @pci.depl_ph[vplane4] 	0x0206 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane5] 	0x020a 	2</span>
<span class="cm"> * @pci.depl_nph[vplane5] 	0x020c 	2</span>
<span class="cm"> * @pci.depl_ph[vplane5] 	0x020e 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane6] 	0x0212 	2</span>
<span class="cm"> * @pci.depl_nph[vplane6] 	0x0214 	2</span>
<span class="cm"> * @pci.depl_ph[vplane6] 	0x0216 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane7] 	0x021a 	2</span>
<span class="cm"> * @pci.depl_nph[vplane7] 	0x021c 	2</span>
<span class="cm"> * @pci.depl_ph[vplane7] 	0x021e 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane8] 	0x0222 	2</span>
<span class="cm"> * @pci.depl_nph[vplane8] 	0x0224 	2</span>
<span class="cm"> * @pci.depl_ph[vplane8] 	0x0226 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane9] 	0x022a 	2</span>
<span class="cm"> * @pci.depl_nph[vplane9] 	0x022c 	2</span>
<span class="cm"> * @pci.depl_ph[vplane9] 	0x022e 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane10] 	0x0232 	2</span>
<span class="cm"> * @pci.depl_nph[vplane10] 	0x0234 	2</span>
<span class="cm"> * @pci.depl_ph[vplane10] 	0x0236 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane11] 	0x023a 	2</span>
<span class="cm"> * @pci.depl_nph[vplane11] 	0x023c 	2</span>
<span class="cm"> * @pci.depl_ph[vplane11] 	0x023e 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane12] 	0x0242 	2</span>
<span class="cm"> * @pci.depl_nph[vplane12] 	0x0244 	2</span>
<span class="cm"> * @pci.depl_ph[vplane12] 	0x0246 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane13] 	0x024a 	2</span>
<span class="cm"> * @pci.depl_nph[vplane13] 	0x024c 	2</span>
<span class="cm"> * @pci.depl_ph[vplane13] 	0x024e 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane14] 	0x0252 	2</span>
<span class="cm"> * @pci.depl_nph[vplane14] 	0x0254 	2</span>
<span class="cm"> * @pci.depl_ph[vplane14] 	0x0256 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane15] 	0x025a 	2</span>
<span class="cm"> * @pci.depl_nph[vplane15] 	0x025c 	2</span>
<span class="cm"> * @pci.depl_ph[vplane15] 	0x025e 	2</span>
<span class="cm"> * @pci.depl_cplh[vplane16] 	0x0262 	2</span>
<span class="cm"> * @pci.depl_nph[vplane16] 	0x0264 	2</span>
<span class="cm"> * @pci.depl_ph[vplane16] 	0x0266 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane0] 	0x026a 	2 	Number of times completion data</span>
<span class="cm"> *  credits were depleted</span>
<span class="cm"> * @pci.depl_npd[vplane0] 	0x026c 	2 	Number of times non posted data</span>
<span class="cm"> *  credits were depleted</span>
<span class="cm"> * @pci.depl_pd[vplane0] 	0x026e 	2 	Number of times the posted data</span>
<span class="cm"> *  credits were depleted</span>
<span class="cm"> * @pci.depl_cpld[vplane1] 	0x0272 	2</span>
<span class="cm"> * @pci.depl_npd[vplane1] 	0x0274 	2</span>
<span class="cm"> * @pci.depl_pd[vplane1] 	0x0276 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane2] 	0x027a 	2</span>
<span class="cm"> * @pci.depl_npd[vplane2] 	0x027c 	2</span>
<span class="cm"> * @pci.depl_pd[vplane2] 	0x027e 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane3] 	0x0282 	2</span>
<span class="cm"> * @pci.depl_npd[vplane3] 	0x0284 	2</span>
<span class="cm"> * @pci.depl_pd[vplane3] 	0x0286 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane4] 	0x028a 	2</span>
<span class="cm"> * @pci.depl_npd[vplane4] 	0x028c 	2</span>
<span class="cm"> * @pci.depl_pd[vplane4] 	0x028e 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane5] 	0x0292 	2</span>
<span class="cm"> * @pci.depl_npd[vplane5] 	0x0294 	2</span>
<span class="cm"> * @pci.depl_pd[vplane5] 	0x0296 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane6] 	0x029a 	2</span>
<span class="cm"> * @pci.depl_npd[vplane6] 	0x029c 	2</span>
<span class="cm"> * @pci.depl_pd[vplane6] 	0x029e 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane7] 	0x02a2 	2</span>
<span class="cm"> * @pci.depl_npd[vplane7] 	0x02a4 	2</span>
<span class="cm"> * @pci.depl_pd[vplane7] 	0x02a6 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane8] 	0x02aa 	2</span>
<span class="cm"> * @pci.depl_npd[vplane8] 	0x02ac 	2</span>
<span class="cm"> * @pci.depl_pd[vplane8] 	0x02ae 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane9] 	0x02b2 	2</span>
<span class="cm"> * @pci.depl_npd[vplane9] 	0x02b4 	2</span>
<span class="cm"> * @pci.depl_pd[vplane9] 	0x02b6 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane10] 	0x02ba 	2</span>
<span class="cm"> * @pci.depl_npd[vplane10] 	0x02bc 	2</span>
<span class="cm"> * @pci.depl_pd[vplane10] 	0x02be 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane11] 	0x02c2 	2</span>
<span class="cm"> * @pci.depl_npd[vplane11] 	0x02c4 	2</span>
<span class="cm"> * @pci.depl_pd[vplane11] 	0x02c6 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane12] 	0x02ca 	2</span>
<span class="cm"> * @pci.depl_npd[vplane12] 	0x02cc 	2</span>
<span class="cm"> * @pci.depl_pd[vplane12] 	0x02ce 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane13] 	0x02d2 	2</span>
<span class="cm"> * @pci.depl_npd[vplane13] 	0x02d4 	2</span>
<span class="cm"> * @pci.depl_pd[vplane13] 	0x02d6 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane14] 	0x02da 	2</span>
<span class="cm"> * @pci.depl_npd[vplane14] 	0x02dc 	2</span>
<span class="cm"> * @pci.depl_pd[vplane14] 	0x02de 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane15] 	0x02e2 	2</span>
<span class="cm"> * @pci.depl_npd[vplane15] 	0x02e4 	2</span>
<span class="cm"> * @pci.depl_pd[vplane15] 	0x02e6 	2</span>
<span class="cm"> * @pci.depl_cpld[vplane16] 	0x02ea 	2</span>
<span class="cm"> * @pci.depl_npd[vplane16] 	0x02ec 	2</span>
<span class="cm"> * @pci.depl_pd[vplane16] 	0x02ee 	2</span>
<span class="cm"> * @xgmac_port[3];</span>
<span class="cm"> * @xgmac_aggr[2];</span>
<span class="cm"> * @xgmac.global_prog_event_gnum0 	0x0ae0 	8 	Programmable statistic.</span>
<span class="cm"> *  Increments when internal logic detects a certain event. See register</span>
<span class="cm"> *  XMAC_STATS_GLOBAL_CFG.EVENT_GNUM0_CFG for more information.</span>
<span class="cm"> * @xgmac.global_prog_event_gnum1 	0x0ae8 	8 	Programmable statistic.</span>
<span class="cm"> *  Increments when internal logic detects a certain event. See register</span>
<span class="cm"> *  XMAC_STATS_GLOBAL_CFG.EVENT_GNUM1_CFG for more information.</span>
<span class="cm"> * @xgmac.orp_lro_events 	0x0af8 	8</span>
<span class="cm"> * @xgmac.orp_bs_events 	0x0b00 	8</span>
<span class="cm"> * @xgmac.orp_iwarp_events 	0x0b08 	8</span>
<span class="cm"> * @xgmac.tx_permitted_frms 	0x0b14 	4</span>
<span class="cm"> * @xgmac.port2_tx_any_frms 	0x0b1d 	1</span>
<span class="cm"> * @xgmac.port1_tx_any_frms 	0x0b1e 	1</span>
<span class="cm"> * @xgmac.port0_tx_any_frms 	0x0b1f 	1</span>
<span class="cm"> * @xgmac.port2_rx_any_frms 	0x0b25 	1</span>
<span class="cm"> * @xgmac.port1_rx_any_frms 	0x0b26 	1</span>
<span class="cm"> * @xgmac.port0_rx_any_frms 	0x0b27 	1</span>
<span class="cm"> *</span>
<span class="cm"> * Titan mrpcim hardware statistics.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_device_stats_mrpcim_info</span> <span class="p">{</span>
<span class="cm">/*0x0000*/</span>	<span class="n">u32</span>	<span class="n">pic_ini_rd_drop</span><span class="p">;</span>
<span class="cm">/*0x0004*/</span>	<span class="n">u32</span>	<span class="n">pic_ini_wr_drop</span><span class="p">;</span>
<span class="cm">/*0x0008*/</span>	<span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/*0x0000*/</span>	<span class="n">u32</span>	<span class="n">pic_wrcrdtarb_ph_crdt_depleted</span><span class="p">;</span>
	<span class="cm">/*0x0004*/</span>	<span class="n">u32</span>	<span class="n">unused1</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">pic_wrcrdtarb_ph_crdt_depleted_vplane</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
<span class="cm">/*0x0090*/</span>	<span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/*0x0000*/</span>	<span class="n">u32</span>	<span class="n">pic_wrcrdtarb_pd_crdt_depleted</span><span class="p">;</span>
	<span class="cm">/*0x0004*/</span>	<span class="n">u32</span>	<span class="n">unused2</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">pic_wrcrdtarb_pd_crdt_depleted_vplane</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
<span class="cm">/*0x0118*/</span>	<span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/*0x0000*/</span>	<span class="n">u32</span>	<span class="n">pic_rdcrdtarb_nph_crdt_depleted</span><span class="p">;</span>
	<span class="cm">/*0x0004*/</span>	<span class="n">u32</span>	<span class="n">unused3</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">pic_rdcrdtarb_nph_crdt_depleted_vplane</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
<span class="cm">/*0x01a0*/</span>	<span class="n">u32</span>	<span class="n">pic_ini_rd_vpin_drop</span><span class="p">;</span>
<span class="cm">/*0x01a4*/</span>	<span class="n">u32</span>	<span class="n">pic_ini_wr_vpin_drop</span><span class="p">;</span>
<span class="cm">/*0x01a8*/</span>	<span class="n">u32</span>	<span class="n">pic_genstats_count0</span><span class="p">;</span>
<span class="cm">/*0x01ac*/</span>	<span class="n">u32</span>	<span class="n">pic_genstats_count1</span><span class="p">;</span>
<span class="cm">/*0x01b0*/</span>	<span class="n">u32</span>	<span class="n">pic_genstats_count2</span><span class="p">;</span>
<span class="cm">/*0x01b4*/</span>	<span class="n">u32</span>	<span class="n">pic_genstats_count3</span><span class="p">;</span>
<span class="cm">/*0x01b8*/</span>	<span class="n">u32</span>	<span class="n">pic_genstats_count4</span><span class="p">;</span>
<span class="cm">/*0x01bc*/</span>	<span class="n">u32</span>	<span class="n">unused4</span><span class="p">;</span>
<span class="cm">/*0x01c0*/</span>	<span class="n">u32</span>	<span class="n">pic_genstats_count5</span><span class="p">;</span>
<span class="cm">/*0x01c4*/</span>	<span class="n">u32</span>	<span class="n">unused5</span><span class="p">;</span>
<span class="cm">/*0x01c8*/</span>	<span class="n">u32</span>	<span class="n">pci_rstdrop_cpl</span><span class="p">;</span>
<span class="cm">/*0x01cc*/</span>	<span class="n">u32</span>	<span class="n">pci_rstdrop_msg</span><span class="p">;</span>
<span class="cm">/*0x01d0*/</span>	<span class="n">u32</span>	<span class="n">pci_rstdrop_client1</span><span class="p">;</span>
<span class="cm">/*0x01d4*/</span>	<span class="n">u32</span>	<span class="n">pci_rstdrop_client0</span><span class="p">;</span>
<span class="cm">/*0x01d8*/</span>	<span class="n">u32</span>	<span class="n">pci_rstdrop_client2</span><span class="p">;</span>
<span class="cm">/*0x01dc*/</span>	<span class="n">u32</span>	<span class="n">unused6</span><span class="p">;</span>
<span class="cm">/*0x01e0*/</span>	<span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/*0x0000*/</span>	<span class="n">u16</span>	<span class="n">unused7</span><span class="p">;</span>
	<span class="cm">/*0x0002*/</span>	<span class="n">u16</span>	<span class="n">pci_depl_cplh</span><span class="p">;</span>
	<span class="cm">/*0x0004*/</span>	<span class="n">u16</span>	<span class="n">pci_depl_nph</span><span class="p">;</span>
	<span class="cm">/*0x0006*/</span>	<span class="n">u16</span>	<span class="n">pci_depl_ph</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">pci_depl_h_vplane</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
<span class="cm">/*0x0268*/</span>	<span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/*0x0000*/</span>	<span class="n">u16</span>	<span class="n">unused8</span><span class="p">;</span>
	<span class="cm">/*0x0002*/</span>	<span class="n">u16</span>	<span class="n">pci_depl_cpld</span><span class="p">;</span>
	<span class="cm">/*0x0004*/</span>	<span class="n">u16</span>	<span class="n">pci_depl_npd</span><span class="p">;</span>
	<span class="cm">/*0x0006*/</span>	<span class="n">u16</span>	<span class="n">pci_depl_pd</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">pci_depl_d_vplane</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
<span class="cm">/*0x02f0*/</span>	<span class="k">struct</span> <span class="n">vxge_hw_xmac_port_stats</span> <span class="n">xgmac_port</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="cm">/*0x0a10*/</span>	<span class="k">struct</span> <span class="n">vxge_hw_xmac_aggr_stats</span> <span class="n">xgmac_aggr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="cm">/*0x0ae0*/</span>	<span class="n">u64</span>	<span class="n">xgmac_global_prog_event_gnum0</span><span class="p">;</span>
<span class="cm">/*0x0ae8*/</span>	<span class="n">u64</span>	<span class="n">xgmac_global_prog_event_gnum1</span><span class="p">;</span>
<span class="cm">/*0x0af0*/</span>	<span class="n">u64</span>	<span class="n">unused7</span><span class="p">;</span>
<span class="cm">/*0x0af8*/</span>	<span class="n">u64</span>	<span class="n">unused8</span><span class="p">;</span>
<span class="cm">/*0x0b00*/</span>	<span class="n">u64</span>	<span class="n">unused9</span><span class="p">;</span>
<span class="cm">/*0x0b08*/</span>	<span class="n">u64</span>	<span class="n">unused10</span><span class="p">;</span>
<span class="cm">/*0x0b10*/</span>	<span class="n">u32</span>	<span class="n">unused11</span><span class="p">;</span>
<span class="cm">/*0x0b14*/</span>	<span class="n">u32</span>	<span class="n">xgmac_tx_permitted_frms</span><span class="p">;</span>
<span class="cm">/*0x0b18*/</span>	<span class="n">u32</span>	<span class="n">unused12</span><span class="p">;</span>
<span class="cm">/*0x0b1c*/</span>	<span class="n">u8</span>	<span class="n">unused13</span><span class="p">;</span>
<span class="cm">/*0x0b1d*/</span>	<span class="n">u8</span>	<span class="n">xgmac_port2_tx_any_frms</span><span class="p">;</span>
<span class="cm">/*0x0b1e*/</span>	<span class="n">u8</span>	<span class="n">xgmac_port1_tx_any_frms</span><span class="p">;</span>
<span class="cm">/*0x0b1f*/</span>	<span class="n">u8</span>	<span class="n">xgmac_port0_tx_any_frms</span><span class="p">;</span>
<span class="cm">/*0x0b20*/</span>	<span class="n">u32</span>	<span class="n">unused14</span><span class="p">;</span>
<span class="cm">/*0x0b24*/</span>	<span class="n">u8</span>	<span class="n">unused15</span><span class="p">;</span>
<span class="cm">/*0x0b25*/</span>	<span class="n">u8</span>	<span class="n">xgmac_port2_rx_any_frms</span><span class="p">;</span>
<span class="cm">/*0x0b26*/</span>	<span class="n">u8</span>	<span class="n">xgmac_port1_rx_any_frms</span><span class="p">;</span>
<span class="cm">/*0x0b27*/</span>	<span class="n">u8</span>	<span class="n">xgmac_port0_rx_any_frms</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_device_stats_hw_info - Titan hardware statistics.</span>
<span class="cm"> * @vpath_info: VPath statistics</span>
<span class="cm"> * @vpath_info_sav: Vpath statistics saved</span>
<span class="cm"> *</span>
<span class="cm"> * Titan hardware statistics.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_device_stats_hw_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_hw_info</span>
		<span class="o">*</span><span class="n">vpath_info</span><span class="p">[</span><span class="n">VXGE_HW_MAX_VIRTUAL_PATHS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_hw_info</span>
		<span class="n">vpath_info_sav</span><span class="p">[</span><span class="n">VXGE_HW_MAX_VIRTUAL_PATHS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_vpath_stats_sw_common_info - HW common</span>
<span class="cm"> * statistics for queues.</span>
<span class="cm"> * @full_cnt: Number of times the queue was full</span>
<span class="cm"> * @usage_cnt: usage count.</span>
<span class="cm"> * @usage_max: Maximum usage</span>
<span class="cm"> * @reserve_free_swaps_cnt: Reserve/free swap counter. Internal usage.</span>
<span class="cm"> * @total_compl_cnt: Total descriptor completion count.</span>
<span class="cm"> *</span>
<span class="cm"> * Hw queue counters</span>
<span class="cm"> * See also: struct vxge_hw_vpath_stats_sw_fifo_info{},</span>
<span class="cm"> * struct vxge_hw_vpath_stats_sw_ring_info{},</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_common_info</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">full_cnt</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">usage_cnt</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">usage_max</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">reserve_free_swaps_cnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_compl_cnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_vpath_stats_sw_fifo_info - HW fifo statistics</span>
<span class="cm"> * @common_stats: Common counters for all queues</span>
<span class="cm"> * @total_posts: Total number of postings on the queue.</span>
<span class="cm"> * @total_buffers: Total number of buffers posted.</span>
<span class="cm"> * @txd_t_code_err_cnt: Array of transmit transfer codes. The position</span>
<span class="cm"> * (index) in this array reflects the transfer code type, for instance</span>
<span class="cm"> * 0xA - &quot;loss of link&quot;.</span>
<span class="cm"> * Value txd_t_code_err_cnt[i] reflects the</span>
<span class="cm"> * number of times the corresponding transfer code was encountered.</span>
<span class="cm"> *</span>
<span class="cm"> * HW fifo counters</span>
<span class="cm"> * See also: struct vxge_hw_vpath_stats_sw_common_info{},</span>
<span class="cm"> * struct vxge_hw_vpath_stats_sw_ring_info{},</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_fifo_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_common_info</span> <span class="n">common_stats</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_posts</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_buffers</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">txd_t_code_err_cnt</span><span class="p">[</span><span class="n">VXGE_HW_DTR_MAX_T_CODE</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_vpath_stats_sw_ring_info - HW ring statistics</span>
<span class="cm"> * @common_stats: Common counters for all queues</span>
<span class="cm"> * @rxd_t_code_err_cnt: Array of receive transfer codes. The position</span>
<span class="cm"> *             (index) in this array reflects the transfer code type,</span>
<span class="cm"> *             for instance</span>
<span class="cm"> *             0x7 - for &quot;invalid receive buffer size&quot;, or 0x8 - for ECC.</span>
<span class="cm"> *             Value rxd_t_code_err_cnt[i] reflects the</span>
<span class="cm"> *             number of times the corresponding transfer code was encountered.</span>
<span class="cm"> *</span>
<span class="cm"> * HW ring counters</span>
<span class="cm"> * See also: struct vxge_hw_vpath_stats_sw_common_info{},</span>
<span class="cm"> * struct vxge_hw_vpath_stats_sw_fifo_info{},</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_ring_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_common_info</span> <span class="n">common_stats</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rxd_t_code_err_cnt</span><span class="p">[</span><span class="n">VXGE_HW_DTR_MAX_T_CODE</span><span class="p">];</span>

<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_vpath_stats_sw_err - HW vpath error statistics</span>
<span class="cm"> * @unknown_alarms:</span>
<span class="cm"> * @network_sustained_fault:</span>
<span class="cm"> * @network_sustained_ok:</span>
<span class="cm"> * @kdfcctl_fifo0_overwrite:</span>
<span class="cm"> * @kdfcctl_fifo0_poison:</span>
<span class="cm"> * @kdfcctl_fifo0_dma_error:</span>
<span class="cm"> * @dblgen_fifo0_overflow:</span>
<span class="cm"> * @statsb_pif_chain_error:</span>
<span class="cm"> * @statsb_drop_timeout:</span>
<span class="cm"> * @target_illegal_access:</span>
<span class="cm"> * @ini_serr_det:</span>
<span class="cm"> * @prc_ring_bumps:</span>
<span class="cm"> * @prc_rxdcm_sc_err:</span>
<span class="cm"> * @prc_rxdcm_sc_abort:</span>
<span class="cm"> * @prc_quanta_size_err:</span>
<span class="cm"> *</span>
<span class="cm"> * HW vpath error statistics</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_err</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">unknown_alarms</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">network_sustained_fault</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">network_sustained_ok</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">kdfcctl_fifo0_overwrite</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">kdfcctl_fifo0_poison</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">kdfcctl_fifo0_dma_error</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dblgen_fifo0_overflow</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">statsb_pif_chain_error</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">statsb_drop_timeout</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">target_illegal_access</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">ini_serr_det</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">prc_ring_bumps</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">prc_rxdcm_sc_err</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">prc_rxdcm_sc_abort</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">prc_quanta_size_err</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_vpath_stats_sw_info - HW vpath sw statistics</span>
<span class="cm"> * @soft_reset_cnt: Number of times soft reset is done on this vpath.</span>
<span class="cm"> * @error_stats: error counters for the vpath</span>
<span class="cm"> * @ring_stats: counters for ring belonging to the vpath</span>
<span class="cm"> * @fifo_stats: counters for fifo belonging to the vpath</span>
<span class="cm"> *</span>
<span class="cm"> * HW vpath sw statistics</span>
<span class="cm"> * See also: struct vxge_hw_device_info{} }.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_info</span> <span class="p">{</span>
	<span class="n">u32</span>    <span class="n">soft_reset_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_err</span>	<span class="n">error_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_ring_info</span>	<span class="n">ring_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_fifo_info</span>	<span class="n">fifo_stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_device_stats_sw_info - HW own per-device statistics.</span>
<span class="cm"> *</span>
<span class="cm"> * @not_traffic_intr_cnt: Number of times the host was interrupted</span>
<span class="cm"> *                        without new completions.</span>
<span class="cm"> *                        &quot;Non-traffic interrupt counter&quot;.</span>
<span class="cm"> * @traffic_intr_cnt: Number of traffic interrupts for the device.</span>
<span class="cm"> * @total_intr_cnt: Total number of traffic interrupts for the device.</span>
<span class="cm"> *                  @total_intr_cnt == @traffic_intr_cnt +</span>
<span class="cm"> *                              @not_traffic_intr_cnt</span>
<span class="cm"> * @soft_reset_cnt: Number of times soft reset is done on this device.</span>
<span class="cm"> * @vpath_info: please see struct vxge_hw_vpath_stats_sw_info{}</span>
<span class="cm"> * HW per-device statistics.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_device_stats_sw_info</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">not_traffic_intr_cnt</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">traffic_intr_cnt</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">total_intr_cnt</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">soft_reset_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_info</span>
		<span class="n">vpath_info</span><span class="p">[</span><span class="n">VXGE_HW_MAX_VIRTUAL_PATHS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_device_stats_sw_err - HW device error statistics.</span>
<span class="cm"> * @vpath_alarms: Number of vpath alarms</span>
<span class="cm"> *</span>
<span class="cm"> * HW Device error stats</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_device_stats_sw_err</span> <span class="p">{</span>
	<span class="n">u32</span>     <span class="n">vpath_alarms</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_device_stats - Contains HW per-device statistics,</span>
<span class="cm"> * including hw.</span>
<span class="cm"> * @devh: HW device handle.</span>
<span class="cm"> * @dma_addr: DMA address of the %hw_info. Given to device to fill-in the stats.</span>
<span class="cm"> * @hw_info_dmah: DMA handle used to map hw statistics onto the device memory</span>
<span class="cm"> *                space.</span>
<span class="cm"> * @hw_info_dma_acch: One more DMA handle used subsequently to free the</span>
<span class="cm"> *                    DMA object. Note that this and the previous handle have</span>
<span class="cm"> *                    physical meaning for Solaris; on Windows and Linux the</span>
<span class="cm"> *                    corresponding value will be simply pointer to PCI device.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw_dev_info_stats: Titan statistics maintained by the hardware.</span>
<span class="cm"> * @sw_dev_info_stats: HW&#39;s &quot;soft&quot; device informational statistics, e.g. number</span>
<span class="cm"> *                     of completions per interrupt.</span>
<span class="cm"> * @sw_dev_err_stats: HW&#39;s &quot;soft&quot; device error statistics.</span>
<span class="cm"> *</span>
<span class="cm"> * Structure-container of HW per-device statistics. Note that per-channel</span>
<span class="cm"> * statistics are kept in separate structures under HW&#39;s fifo and ring</span>
<span class="cm"> * channels.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_device_stats</span> <span class="p">{</span>
	<span class="cm">/* handles */</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">;</span>

	<span class="cm">/* HW device hardware statistics */</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_stats_hw_info</span>	<span class="n">hw_dev_info_stats</span><span class="p">;</span>

	<span class="cm">/* HW device &quot;soft&quot; stats */</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_stats_sw_err</span>   <span class="n">sw_dev_err_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_stats_sw_info</span>  <span class="n">sw_dev_info_stats</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_device_hw_stats_enable</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_device_stats_get</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vxge_hw_device_stats_hw_info</span> <span class="o">*</span><span class="n">hw_stats</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_driver_stats_get</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vxge_hw_device_stats_sw_info</span> <span class="o">*</span><span class="n">sw_stats</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_mrpcim_stats_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_mrpcim_stats_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_mrpcim_stats_access</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">operation</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">location</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">stat</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_device_xmac_stats_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">vxge_hw_xmac_stats</span> <span class="o">*</span><span class="n">xmac_stats</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * enum enum vxge_hw_mgmt_reg_type - Register types.</span>
<span class="cm"> *</span>
<span class="cm"> * @vxge_hw_mgmt_reg_type_legacy: Legacy registers</span>
<span class="cm"> * @vxge_hw_mgmt_reg_type_toc: TOC Registers</span>
<span class="cm"> * @vxge_hw_mgmt_reg_type_common: Common Registers</span>
<span class="cm"> * @vxge_hw_mgmt_reg_type_mrpcim: mrpcim registers</span>
<span class="cm"> * @vxge_hw_mgmt_reg_type_srpcim: srpcim registers</span>
<span class="cm"> * @vxge_hw_mgmt_reg_type_vpmgmt: vpath management registers</span>
<span class="cm"> * @vxge_hw_mgmt_reg_type_vpath: vpath registers</span>
<span class="cm"> *</span>
<span class="cm"> * Register type enumaration</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_hw_mgmt_reg_type</span> <span class="p">{</span>
	<span class="n">vxge_hw_mgmt_reg_type_legacy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">vxge_hw_mgmt_reg_type_toc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">vxge_hw_mgmt_reg_type_common</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">vxge_hw_mgmt_reg_type_mrpcim</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">vxge_hw_mgmt_reg_type_srpcim</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">vxge_hw_mgmt_reg_type_vpmgmt</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">vxge_hw_mgmt_reg_type_vpath</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_mgmt_reg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
		      <span class="k">enum</span> <span class="n">vxge_hw_mgmt_reg_type</span> <span class="n">type</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="n">u64</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_mgmt_reg_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
		      <span class="k">enum</span> <span class="n">vxge_hw_mgmt_reg_type</span> <span class="n">type</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="n">u64</span> <span class="n">value</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * enum enum vxge_hw_rxd_state - Descriptor (RXD) state.</span>
<span class="cm"> * @VXGE_HW_RXD_STATE_NONE: Invalid state.</span>
<span class="cm"> * @VXGE_HW_RXD_STATE_AVAIL: Descriptor is available for reservation.</span>
<span class="cm"> * @VXGE_HW_RXD_STATE_POSTED: Descriptor is posted for processing by the</span>
<span class="cm"> * device.</span>
<span class="cm"> * @VXGE_HW_RXD_STATE_FREED: Descriptor is free and can be reused for</span>
<span class="cm"> * filling-in and posting later.</span>
<span class="cm"> *</span>
<span class="cm"> * Titan/HW descriptor states.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_hw_rxd_state</span> <span class="p">{</span>
	<span class="n">VXGE_HW_RXD_STATE_NONE</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VXGE_HW_RXD_STATE_AVAIL</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_HW_RXD_STATE_POSTED</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VXGE_HW_RXD_STATE_FREED</span>		<span class="o">=</span> <span class="mi">3</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_ring_rxd_info - Extended information associated with a</span>
<span class="cm"> * completed ring descriptor.</span>
<span class="cm"> * @syn_flag: SYN flag</span>
<span class="cm"> * @is_icmp: Is ICMP</span>
<span class="cm"> * @fast_path_eligible: Fast Path Eligible flag</span>
<span class="cm"> * @l3_cksum: in L3 checksum is valid</span>
<span class="cm"> * @l3_cksum: Result of IP checksum check (by Titan hardware).</span>
<span class="cm"> *            This field containing VXGE_HW_L3_CKSUM_OK would mean that</span>
<span class="cm"> *            the checksum is correct, otherwise - the datagram is</span>
<span class="cm"> *            corrupted.</span>
<span class="cm"> * @l4_cksum: in L4 checksum is valid</span>
<span class="cm"> * @l4_cksum: Result of TCP/UDP checksum check (by Titan hardware).</span>
<span class="cm"> *            This field containing VXGE_HW_L4_CKSUM_OK would mean that</span>
<span class="cm"> *            the checksum is correct. Otherwise - the packet is</span>
<span class="cm"> *            corrupted.</span>
<span class="cm"> * @frame: Zero or more of enum vxge_hw_frame_type flags.</span>
<span class="cm"> * 		See enum vxge_hw_frame_type{}.</span>
<span class="cm"> * @proto: zero or more of enum vxge_hw_frame_proto flags.  Reporting bits for</span>
<span class="cm"> *            various higher-layer protocols, including (but note restricted to)</span>
<span class="cm"> *            TCP and UDP. See enum vxge_hw_frame_proto{}.</span>
<span class="cm"> * @is_vlan: If vlan tag is valid</span>
<span class="cm"> * @vlan: VLAN tag extracted from the received frame.</span>
<span class="cm"> * @rth_bucket: RTH bucket</span>
<span class="cm"> * @rth_it_hit: Set, If RTH hash value calculated by the Titan hardware</span>
<span class="cm"> *             has a matching entry in the Indirection table.</span>
<span class="cm"> * @rth_spdm_hit: Set, If RTH hash value calculated by the Titan hardware</span>
<span class="cm"> *             has a matching entry in the Socket Pair Direct Match table.</span>
<span class="cm"> * @rth_hash_type: RTH hash code of the function used to calculate the hash.</span>
<span class="cm"> * @rth_value: Receive Traffic Hashing(RTH) hash value. Produced by Titan</span>
<span class="cm"> *             hardware if RTH is enabled.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_info</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">syn_flag</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">is_icmp</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">fast_path_eligible</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">l3_cksum_valid</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">l3_cksum</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">l4_cksum_valid</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">l4_cksum</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">frame</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">proto</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">is_vlan</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">vlan</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">rth_bucket</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">rth_it_hit</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">rth_spdm_hit</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">rth_hash_type</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">rth_value</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/**</span>
<span class="cm"> * enum vxge_hw_ring_tcode - Transfer codes returned by adapter</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_OK: Transfer ok.</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_L3_CKSUM_MISMATCH: Layer 3 checksum presentation</span>
<span class="cm"> *		configuration mismatch.</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_L4_CKSUM_MISMATCH: Layer 4 checksum presentation</span>
<span class="cm"> *		configuration mismatch.</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_L3_L4_CKSUM_MISMATCH: Layer 3 and Layer 4 checksum</span>
<span class="cm"> *		presentation configuration mismatch.</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_L3_PKT_ERR: Layer 3 error unparseable packet,</span>
<span class="cm"> *		such as unknown IPv6 header.</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_L2_FRM_ERR: Layer 2 error frame integrity</span>
<span class="cm"> *		error, such as FCS or ECC).</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_BUF_SIZE_ERR: Buffer size error the RxD buffer(</span>
<span class="cm"> *		s) were not appropriately sized and data loss occurred.</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_INT_ECC_ERR: Internal ECC error RxD corrupted.</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_BENIGN_OVFLOW: Benign overflow the contents of</span>
<span class="cm"> *		Segment1 exceeded the capacity of Buffer1 and the remainder</span>
<span class="cm"> *		was placed in Buffer2. Segment2 now starts in Buffer3.</span>
<span class="cm"> *		No data loss or errors occurred.</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_ZERO_LEN_BUFF: Buffer size 0 one of the RxDs</span>
<span class="cm"> *		assigned buffers has a size of 0 bytes.</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_FRM_DROP: Frame dropped either due to</span>
<span class="cm"> *		VPath Reset or because of a VPIN mismatch.</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_UNUSED: Unused</span>
<span class="cm"> * @VXGE_HW_RING_T_CODE_MULTI_ERR: Multiple errors more than one</span>
<span class="cm"> *		transfer code condition occurred.</span>
<span class="cm"> *</span>
<span class="cm"> * Transfer codes returned by adapter.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_hw_ring_tcode</span> <span class="p">{</span>
	<span class="n">VXGE_HW_RING_T_CODE_OK</span>				<span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_L3_CKSUM_MISMATCH</span>		<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_L4_CKSUM_MISMATCH</span>		<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_L3_L4_CKSUM_MISMATCH</span>	<span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_L3_PKT_ERR</span>			<span class="o">=</span> <span class="mh">0x5</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_L2_FRM_ERR</span>			<span class="o">=</span> <span class="mh">0x6</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_BUF_SIZE_ERR</span>		<span class="o">=</span> <span class="mh">0x7</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_INT_ECC_ERR</span>			<span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_BENIGN_OVFLOW</span>		<span class="o">=</span> <span class="mh">0x9</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_ZERO_LEN_BUFF</span>		<span class="o">=</span> <span class="mh">0xA</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_FRM_DROP</span>			<span class="o">=</span> <span class="mh">0xC</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_UNUSED</span>			<span class="o">=</span> <span class="mh">0xE</span><span class="p">,</span>
	<span class="n">VXGE_HW_RING_T_CODE_MULTI_ERR</span>			<span class="o">=</span> <span class="mh">0xF</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_ring_rxd_reserve</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring_handle</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">rxdh</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_ring_rxd_pre_post</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring_handle</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_ring_rxd_post_post</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring_handle</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_ring_replenish</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring_handle</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_ring_rxd_post_post_wmb</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring_handle</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_ring_rxd_post</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring_handle</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_ring_rxd_next_completed</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring_handle</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">rxdh</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">t_code</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_ring_handle_tcode</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring_handle</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">t_code</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_ring_rxd_free</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring_handle</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * enum enum vxge_hw_frame_proto - Higher-layer ethernet protocols.</span>
<span class="cm"> * @VXGE_HW_FRAME_PROTO_VLAN_TAGGED: VLAN.</span>
<span class="cm"> * @VXGE_HW_FRAME_PROTO_IPV4: IPv4.</span>
<span class="cm"> * @VXGE_HW_FRAME_PROTO_IPV6: IPv6.</span>
<span class="cm"> * @VXGE_HW_FRAME_PROTO_IP_FRAG: IP fragmented.</span>
<span class="cm"> * @VXGE_HW_FRAME_PROTO_TCP: TCP.</span>
<span class="cm"> * @VXGE_HW_FRAME_PROTO_UDP: UDP.</span>
<span class="cm"> * @VXGE_HW_FRAME_PROTO_TCP_OR_UDP: TCP or UDP.</span>
<span class="cm"> *</span>
<span class="cm"> * Higher layer ethernet protocols and options.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_hw_frame_proto</span> <span class="p">{</span>
	<span class="n">VXGE_HW_FRAME_PROTO_VLAN_TAGGED</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
	<span class="n">VXGE_HW_FRAME_PROTO_IPV4</span>		<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">VXGE_HW_FRAME_PROTO_IPV6</span>		<span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="n">VXGE_HW_FRAME_PROTO_IP_FRAG</span>		<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">VXGE_HW_FRAME_PROTO_TCP</span>			<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">VXGE_HW_FRAME_PROTO_UDP</span>			<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">VXGE_HW_FRAME_PROTO_TCP_OR_UDP</span>	<span class="o">=</span> <span class="p">(</span><span class="n">VXGE_HW_FRAME_PROTO_TCP</span> <span class="o">|</span> \
						   <span class="n">VXGE_HW_FRAME_PROTO_UDP</span><span class="p">)</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum enum vxge_hw_fifo_gather_code - Gather codes used in fifo TxD</span>
<span class="cm"> * @VXGE_HW_FIFO_GATHER_CODE_FIRST: First TxDL</span>
<span class="cm"> * @VXGE_HW_FIFO_GATHER_CODE_MIDDLE: Middle TxDL</span>
<span class="cm"> * @VXGE_HW_FIFO_GATHER_CODE_LAST: Last TxDL</span>
<span class="cm"> * @VXGE_HW_FIFO_GATHER_CODE_FIRST_LAST: First and Last TxDL.</span>
<span class="cm"> *</span>
<span class="cm"> * These gather codes are used to indicate the position of a TxD in a TxD list</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_hw_fifo_gather_code</span> <span class="p">{</span>
	<span class="n">VXGE_HW_FIFO_GATHER_CODE_FIRST</span>		<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">VXGE_HW_FIFO_GATHER_CODE_MIDDLE</span>		<span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">VXGE_HW_FIFO_GATHER_CODE_LAST</span>		<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">VXGE_HW_FIFO_GATHER_CODE_FIRST_LAST</span>	<span class="o">=</span> <span class="mh">0x3</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum enum vxge_hw_fifo_tcode - tcodes used in fifo</span>
<span class="cm"> * @VXGE_HW_FIFO_T_CODE_OK: Transfer OK</span>
<span class="cm"> * @VXGE_HW_FIFO_T_CODE_PCI_READ_CORRUPT: PCI read transaction (either TxD or</span>
<span class="cm"> *             frame data) returned with corrupt data.</span>
<span class="cm"> * @VXGE_HW_FIFO_T_CODE_PCI_READ_FAIL:PCI read transaction was returned</span>
<span class="cm"> *             with no data.</span>
<span class="cm"> * @VXGE_HW_FIFO_T_CODE_INVALID_MSS: The host attempted to send either a</span>
<span class="cm"> *             frame or LSO MSS that was too long (&gt;9800B).</span>
<span class="cm"> * @VXGE_HW_FIFO_T_CODE_LSO_ERROR: Error detected during TCP/UDP Large Send</span>
<span class="cm">	*	       Offload operation, due to improper header template,</span>
<span class="cm">	*	       unsupported protocol, etc.</span>
<span class="cm"> * @VXGE_HW_FIFO_T_CODE_UNUSED: Unused</span>
<span class="cm"> * @VXGE_HW_FIFO_T_CODE_MULTI_ERROR: Set to 1 by the adapter if multiple</span>
<span class="cm"> *             data buffer transfer errors are encountered (see below).</span>
<span class="cm"> *             Otherwise it is set to 0.</span>
<span class="cm"> *</span>
<span class="cm"> * These tcodes are returned in various API for TxD status</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_hw_fifo_tcode</span> <span class="p">{</span>
	<span class="n">VXGE_HW_FIFO_T_CODE_OK</span>			<span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">VXGE_HW_FIFO_T_CODE_PCI_READ_CORRUPT</span>	<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">VXGE_HW_FIFO_T_CODE_PCI_READ_FAIL</span>	<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">VXGE_HW_FIFO_T_CODE_INVALID_MSS</span>		<span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>
	<span class="n">VXGE_HW_FIFO_T_CODE_LSO_ERROR</span>		<span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
	<span class="n">VXGE_HW_FIFO_T_CODE_UNUSED</span>		<span class="o">=</span> <span class="mh">0x7</span><span class="p">,</span>
	<span class="n">VXGE_HW_FIFO_T_CODE_MULTI_ERROR</span>		<span class="o">=</span> <span class="mh">0x8</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_fifo_txdl_reserve</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifoh</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">txdlh</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">txdl_priv</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_fifo_txdl_buffer_set</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifo_handle</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">frag_idx</span><span class="p">,</span>
			<span class="n">dma_addr_t</span> <span class="n">dma_pointer</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">size</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_fifo_txdl_post</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifo_handle</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">);</span>

<span class="n">u32</span> <span class="n">vxge_hw_fifo_free_txdl_count_get</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifo_handle</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_fifo_txdl_next_completed</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifoh</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">txdlh</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">vxge_hw_fifo_tcode</span> <span class="o">*</span><span class="n">t_code</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_fifo_handle_tcode</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifoh</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">vxge_hw_fifo_tcode</span> <span class="n">t_code</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_fifo_txdl_free</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifoh</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Device</span>
<span class="cm"> */</span>

<span class="cp">#define VXGE_HW_RING_NEXT_BLOCK_POINTER_OFFSET	(VXGE_HW_BLOCK_SIZE-8)</span>
<span class="cp">#define VXGE_HW_RING_MEMBLOCK_IDX_OFFSET		(VXGE_HW_BLOCK_SIZE-16)</span>

<span class="cm">/*</span>
<span class="cm"> * struct __vxge_hw_ring_rxd_priv - Receive descriptor HW-private data.</span>
<span class="cm"> * @dma_addr: DMA (mapped) address of _this_ descriptor.</span>
<span class="cm"> * @dma_handle: DMA handle used to map the descriptor onto device.</span>
<span class="cm"> * @dma_offset: Descriptor&#39;s offset in the memory block. HW allocates</span>
<span class="cm"> *              descriptors in memory blocks of %VXGE_HW_BLOCK_SIZE</span>
<span class="cm"> *              bytes. Each memblock is contiguous DMA-able memory. Each</span>
<span class="cm"> *              memblock contains 1 or more 4KB RxD blocks visible to the</span>
<span class="cm"> *              Titan hardware.</span>
<span class="cm"> * @dma_object: DMA address and handle of the memory block that contains</span>
<span class="cm"> *              the descriptor. This member is used only in the &quot;checked&quot;</span>
<span class="cm"> *              version of the HW (to enforce certain assertions);</span>
<span class="cm"> *              otherwise it gets compiled out.</span>
<span class="cm"> * @allocated: True if the descriptor is reserved, 0 otherwise. Internal usage.</span>
<span class="cm"> *</span>
<span class="cm"> * Per-receive decsriptor HW-private data. HW uses the space to keep DMA</span>
<span class="cm"> * information associated with the descriptor. Note that driver can ask HW</span>
<span class="cm"> * to allocate additional per-descriptor space for its own (driver-specific)</span>
<span class="cm"> * purposes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_ring_rxd_priv</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">;</span>
	<span class="kt">ptrdiff_t</span>	<span class="n">dma_offset</span><span class="p">;</span>
<span class="cp">#ifdef VXGE_DEBUG_ASSERT</span>
	<span class="k">struct</span> <span class="n">vxge_hw_mempool_dma</span>	<span class="o">*</span><span class="n">dma_object</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vxge_hw_mempool_cbs</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">item_func_alloc</span><span class="p">)(</span>
			<span class="k">struct</span> <span class="n">vxge_hw_mempool</span> <span class="o">*</span><span class="n">mempoolh</span><span class="p">,</span>
			<span class="n">u32</span>			<span class="n">memblock_index</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vxge_hw_mempool_dma</span>	<span class="o">*</span><span class="n">dma_object</span><span class="p">,</span>
			<span class="n">u32</span>			<span class="n">index</span><span class="p">,</span>
			<span class="n">u32</span>			<span class="n">is_last</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define VXGE_HW_VIRTUAL_PATH_HANDLE(vpath)				\</span>
<span class="cp">		((struct __vxge_hw_vpath_handle *)(vpath)-&gt;vpath_handles.next)</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">__vxge_hw_vpath_rts_table_get</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">action</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">rts_table</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">offset</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="o">*</span><span class="n">data1</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="o">*</span><span class="n">data2</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">__vxge_hw_vpath_rts_table_set</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">action</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">rts_table</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">offset</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="n">data1</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="n">data2</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">__vxge_hw_vpath_enable</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">vp_id</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_device_intr_enable</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="n">u32</span> <span class="n">vxge_hw_device_set_intr_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span> <span class="n">u32</span> <span class="n">intr_mode</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_device_intr_disable</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_device_mask_all</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_device_unmask_all</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_device_begin_irq</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">skip_alarms</span><span class="p">,</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">reason</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_device_clear_tx_rx</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  Virtual Paths</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">vxge_hw_vpath_dynamic_rti_rtimer_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_vpath_dynamic_tti_rtimer_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">);</span>

<span class="n">u32</span> <span class="n">vxge_hw_vpath_id</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_vpath_mac_addr_add_mode</span> <span class="p">{</span>
	<span class="n">VXGE_HW_VPATH_MAC_ADDR_ADD_DUPLICATE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VXGE_HW_VPATH_MAC_ADDR_DISCARD_DUPLICATE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_HW_VPATH_MAC_ADDR_REPLACE_DUPLICATE</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_mac_addr_add</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">macaddr</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">macaddr_mask</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">vxge_hw_vpath_mac_addr_add_mode</span> <span class="n">duplicate_mode</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_mac_addr_get</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">macaddr</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">macaddr_mask</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_mac_addr_get_next</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">macaddr</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">macaddr_mask</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_mac_addr_delete</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">macaddr</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">macaddr_mask</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_vid_add</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="n">vid</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_vid_get</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="o">*</span><span class="n">vid</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_vid_delete</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="n">vid</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_etype_add</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="n">etype</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_etype_get</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="o">*</span><span class="n">etype</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_etype_get_next</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="o">*</span><span class="n">etype</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_etype_delete</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="n">etype</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_promisc_enable</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_promisc_disable</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_bcast_enable</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_mcast_enable</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_mcast_disable</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_poll_rx</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ringh</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_poll_tx</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifoh</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">***</span><span class="n">skb_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_skb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">more</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_alarm_process</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">skip_alarms</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_vpath_msix_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="o">*</span><span class="n">tim_msix_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alarm_msix_id</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_vpath_msix_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">msix_id</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_vpath_msix_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msix_id</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_device_flush_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_vpath_msix_unmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">msix_id</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_intr_enable</span><span class="p">(</span>
				<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_intr_disable</span><span class="p">(</span>
				<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_vpath_inta_mask_tx_rx</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_vpath_inta_unmask_tx_rx</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_channel_msix_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_channel</span> <span class="o">*</span><span class="n">channelh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msix_id</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_channel_msix_unmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_channel</span> <span class="o">*</span><span class="n">channelh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msix_id</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_channel_msix_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_channel</span> <span class="o">*</span><span class="n">channelh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msix_id</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_channel_dtr_try_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">**</span><span class="n">dtrh</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_channel_dtr_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_channel_dtr_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dtrh</span><span class="p">);</span>

<span class="kt">int</span>
<span class="n">vxge_hw_channel_dtr_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_vpath_tti_ci_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vxge_hw_vpath_dynamic_rti_ci_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
