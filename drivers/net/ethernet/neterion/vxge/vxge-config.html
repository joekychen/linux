<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › neterion › vxge › vxge-config.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>vxge-config.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * This software may be used and distributed according to the terms of</span>
<span class="cm"> * the GNU General Public License (GPL), incorporated herein by reference.</span>
<span class="cm"> * Drivers based on or derived from this code fall under the GPL and must</span>
<span class="cm"> * retain the authorship, copyright and license notice.  This file is not</span>
<span class="cm"> * a complete program and may only be used when the entire operating</span>
<span class="cm"> * system is licensed under the GPL.</span>
<span class="cm"> * See the file COPYING in this distribution for more information.</span>
<span class="cm"> *</span>
<span class="cm"> * vxge-config.h: Driver for Exar Corp&#39;s X3100 Series 10GbE PCIe I/O</span>
<span class="cm"> *                Virtualized Server Adapter.</span>
<span class="cm"> * Copyright(c) 2002-2010 Exar Corp.</span>
<span class="cm"> ******************************************************************************/</span>
<span class="cp">#ifndef VXGE_CONFIG_H</span>
<span class="cp">#define VXGE_CONFIG_H</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#ifndef VXGE_CACHE_LINE_SIZE</span>
<span class="cp">#define VXGE_CACHE_LINE_SIZE 128</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef VXGE_ALIGN</span>
<span class="cp">#define VXGE_ALIGN(adrs, size) \</span>
<span class="cp">	(((size) - (((u64)adrs) &amp; ((size)-1))) &amp; ((size)-1))</span>
<span class="cp">#endif</span>

<span class="cp">#define VXGE_HW_MIN_MTU				68</span>
<span class="cp">#define VXGE_HW_MAX_MTU				9600</span>
<span class="cp">#define VXGE_HW_DEFAULT_MTU			1500</span>

<span class="cp">#define VXGE_HW_MAX_ROM_IMAGES			8</span>

<span class="k">struct</span> <span class="n">eprom_image</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">is_valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">version</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef VXGE_DEBUG_ASSERT</span>
<span class="cm">/**</span>
<span class="cm"> * vxge_assert</span>
<span class="cm"> * @test: C-condition to check</span>
<span class="cm"> * @fmt: printf like format string</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements traditional assert. By default assertions</span>
<span class="cm"> * are enabled. It can be disabled by undefining VXGE_DEBUG_ASSERT macro in</span>
<span class="cm"> * compilation</span>
<span class="cm"> * time.</span>
<span class="cm"> */</span>
<span class="cp">#define vxge_assert(test) BUG_ON(!(test))</span>
<span class="cp">#else</span>
<span class="cp">#define vxge_assert(test)</span>
<span class="cp">#endif </span><span class="cm">/* end of VXGE_DEBUG_ASSERT */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * enum vxge_debug_level</span>
<span class="cm"> * @VXGE_NONE: debug disabled</span>
<span class="cm"> * @VXGE_ERR: all errors going to be logged out</span>
<span class="cm"> * @VXGE_TRACE: all errors plus all kind of verbose tracing print outs</span>
<span class="cm"> *                 going to be logged out. Very noisy.</span>
<span class="cm"> *</span>
<span class="cm"> * This enumeration going to be used to switch between different</span>
<span class="cm"> * debug levels during runtime if DEBUG macro defined during</span>
<span class="cm"> * compilation. If DEBUG macro not defined than code will be</span>
<span class="cm"> * compiled out.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_debug_level</span> <span class="p">{</span>
	<span class="n">VXGE_NONE</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VXGE_TRACE</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_ERR</span>    <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="cp">#define NULL_VPID					0xFFFFFFFF</span>
<span class="cp">#ifdef CONFIG_VXGE_DEBUG_TRACE_ALL</span>
<span class="cp">#define VXGE_DEBUG_MODULE_MASK  0xffffffff</span>
<span class="cp">#define VXGE_DEBUG_TRACE_MASK   0xffffffff</span>
<span class="cp">#define VXGE_DEBUG_ERR_MASK     0xffffffff</span>
<span class="cp">#define VXGE_DEBUG_MASK         0x000001ff</span>
<span class="cp">#else</span>
<span class="cp">#define VXGE_DEBUG_MODULE_MASK  0x20000000</span>
<span class="cp">#define VXGE_DEBUG_TRACE_MASK   0x20000000</span>
<span class="cp">#define VXGE_DEBUG_ERR_MASK     0x20000000</span>
<span class="cp">#define VXGE_DEBUG_MASK         0x00000001</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * @VXGE_COMPONENT_LL: do debug for vxge link layer module</span>
<span class="cm"> * @VXGE_COMPONENT_ALL: activate debug for all modules with no exceptions</span>
<span class="cm"> *</span>
<span class="cm"> * This enumeration going to be used to distinguish modules</span>
<span class="cm"> * or libraries during compilation and runtime.  Makefile must declare</span>
<span class="cm"> * VXGE_DEBUG_MODULE_MASK macro and set it to proper value.</span>
<span class="cm"> */</span>
<span class="cp">#define	VXGE_COMPONENT_LL				0x20000000</span>
<span class="cp">#define	VXGE_COMPONENT_ALL				0xffffffff</span>

<span class="cp">#define VXGE_HW_BASE_INF	100</span>
<span class="cp">#define VXGE_HW_BASE_ERR	200</span>
<span class="cp">#define VXGE_HW_BASE_BADCFG	300</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="p">{</span>
	<span class="n">VXGE_HW_OK</span>				  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VXGE_HW_FAIL</span>				  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_HW_PENDING</span>				  <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VXGE_HW_COMPLETIONS_REMAIN</span>		  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

	<span class="n">VXGE_HW_INF_NO_MORE_COMPLETED_DESCRIPTORS</span> <span class="o">=</span> <span class="n">VXGE_HW_BASE_INF</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_HW_INF_OUT_OF_DESCRIPTORS</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_INF</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>

	<span class="n">VXGE_HW_ERR_INVALID_HANDLE</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_OUT_OF_MEMORY</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_VPATH_NOT_AVAILABLE</span>	  	  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_VPATH_NOT_OPEN</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_WRONG_IRQ</span>			  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_SWAPPER_CTRL</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_INVALID_MTU_SIZE</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_INVALID_INDEX</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_INVALID_TYPE</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_INVALID_OFFSET</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_INVALID_DEVICE</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_VERSION_CONFLICT</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_INVALID_PCI_INFO</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_INVALID_TCODE</span> 		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_INVALID_BLOCK_SIZE</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_INVALID_STATE</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_PRIVILAGED_OPEARATION</span>	  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">17</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_INVALID_PORT</span> 		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">18</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_FIFO</span>		 	  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">19</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_VPATH</span>			  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_CRITICAL</span>			  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">21</span><span class="p">,</span>
	<span class="n">VXGE_HW_ERR_SLOT_FREEZE</span> 		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_ERR</span> <span class="o">+</span> <span class="mi">22</span><span class="p">,</span>

	<span class="n">VXGE_HW_BADCFG_RING_INDICATE_MAX_PKTS</span>	  <span class="o">=</span> <span class="n">VXGE_HW_BASE_BADCFG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_HW_BADCFG_FIFO_BLOCKS</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_BADCFG</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VXGE_HW_BADCFG_VPATH_MTU</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_BADCFG</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">VXGE_HW_BADCFG_VPATH_RPA_STRIP_VLAN_TAG</span>	  <span class="o">=</span> <span class="n">VXGE_HW_BASE_BADCFG</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">VXGE_HW_BADCFG_VPATH_MIN_BANDWIDTH</span>	  <span class="o">=</span> <span class="n">VXGE_HW_BASE_BADCFG</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">VXGE_HW_BADCFG_INTR_MODE</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_BADCFG</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">VXGE_HW_BADCFG_RTS_MAC_EN</span>		  <span class="o">=</span> <span class="n">VXGE_HW_BASE_BADCFG</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span>

	<span class="n">VXGE_HW_EOF_TRACE_BUF</span>			  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum enum vxge_hw_device_link_state - Link state enumeration.</span>
<span class="cm"> * @VXGE_HW_LINK_NONE: Invalid link state.</span>
<span class="cm"> * @VXGE_HW_LINK_DOWN: Link is down.</span>
<span class="cm"> * @VXGE_HW_LINK_UP: Link is up.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_hw_device_link_state</span> <span class="p">{</span>
	<span class="n">VXGE_HW_LINK_NONE</span><span class="p">,</span>
	<span class="n">VXGE_HW_LINK_DOWN</span><span class="p">,</span>
	<span class="n">VXGE_HW_LINK_UP</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum enum vxge_hw_fw_upgrade_code - FW upgrade return codes.</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_OK: All OK send next 16 bytes</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_DONE:  upload completed</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_ERR:  upload error</span>
<span class="cm"> * @VXGE_FW_UPGRADE_BYTES2SKIP:  skip bytes in the stream</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_hw_fw_upgrade_code</span> <span class="p">{</span>
	<span class="n">VXGE_HW_FW_UPGRADE_OK</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VXGE_HW_FW_UPGRADE_DONE</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_HW_FW_UPGRADE_ERR</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VXGE_FW_UPGRADE_BYTES2SKIP</span>	<span class="o">=</span> <span class="mi">3</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum enum vxge_hw_fw_upgrade_err_code - FW upgrade error codes.</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_ERR_CORRUPT_DATA_1: corrupt data</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_ERR_BUFFER_OVERFLOW: buffer overflow</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_ERR_INV_NCF_FILE_3: invalid .ncf file</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_ERR_INV_NCF_FILE_4: invalid .ncf file</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_ERR_INV_NCF_FILE_5: invalid .ncf file</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_ERR_INV_NCF_FILE_6: invalid .ncf file</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_ERR_CORRUPT_DATA_7: corrupt data</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_ERR_INV_NCF_FILE_8: invalid .ncf file</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_ERR_GENERIC_ERROR_UNKNOWN: generic error unknown type</span>
<span class="cm"> * @VXGE_HW_FW_UPGRADE_ERR_FAILED_TO_FLASH: failed to flash image check failed</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_hw_fw_upgrade_err_code</span> <span class="p">{</span>
	<span class="n">VXGE_HW_FW_UPGRADE_ERR_CORRUPT_DATA_1</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_HW_FW_UPGRADE_ERR_BUFFER_OVERFLOW</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VXGE_HW_FW_UPGRADE_ERR_INV_NCF_FILE_3</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">VXGE_HW_FW_UPGRADE_ERR_INV_NCF_FILE_4</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">VXGE_HW_FW_UPGRADE_ERR_INV_NCF_FILE_5</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">VXGE_HW_FW_UPGRADE_ERR_INV_NCF_FILE_6</span>		<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">VXGE_HW_FW_UPGRADE_ERR_CORRUPT_DATA_7</span>		<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">VXGE_HW_FW_UPGRADE_ERR_INV_NCF_FILE_8</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">VXGE_HW_FW_UPGRADE_ERR_GENERIC_ERROR_UNKNOWN</span>	<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">VXGE_HW_FW_UPGRADE_ERR_FAILED_TO_FLASH</span>		<span class="o">=</span> <span class="mi">10</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_device_date - Date Format</span>
<span class="cm"> * @day: Day</span>
<span class="cm"> * @month: Month</span>
<span class="cm"> * @year: Year</span>
<span class="cm"> * @date: Date in string format</span>
<span class="cm"> *</span>
<span class="cm"> * Structure for returning date</span>
<span class="cm"> */</span>

<span class="cp">#define VXGE_HW_FW_STRLEN	32</span>
<span class="k">struct</span> <span class="n">vxge_hw_device_date</span> <span class="p">{</span>
	<span class="n">u32</span>     <span class="n">day</span><span class="p">;</span>
	<span class="n">u32</span>     <span class="n">month</span><span class="p">;</span>
	<span class="n">u32</span>     <span class="n">year</span><span class="p">;</span>
	<span class="kt">char</span>    <span class="n">date</span><span class="p">[</span><span class="n">VXGE_HW_FW_STRLEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vxge_hw_device_version</span> <span class="p">{</span>
	<span class="n">u32</span>     <span class="n">major</span><span class="p">;</span>
	<span class="n">u32</span>     <span class="n">minor</span><span class="p">;</span>
	<span class="n">u32</span>     <span class="n">build</span><span class="p">;</span>
	<span class="kt">char</span>    <span class="n">version</span><span class="p">[</span><span class="n">VXGE_HW_FW_STRLEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_fifo_config - Configuration of fifo.</span>
<span class="cm"> * @enable: Is this fifo to be commissioned</span>
<span class="cm"> * @fifo_blocks: Numbers of TxDL (that is, lists of Tx descriptors)</span>
<span class="cm"> * 		blocks per queue.</span>
<span class="cm"> * @max_frags: Max number of Tx buffers per TxDL (that is, per single</span>
<span class="cm"> *             transmit operation).</span>
<span class="cm"> *             No more than 256 transmit buffers can be specified.</span>
<span class="cm"> * @memblock_size: Fifo descriptors are allocated in blocks of @mem_block_size</span>
<span class="cm"> *             bytes. Setting @memblock_size to page size ensures</span>
<span class="cm"> *             by-page allocation of descriptors. 128K bytes is the</span>
<span class="cm"> *             maximum supported block size.</span>
<span class="cm"> * @alignment_size: per Tx fragment DMA-able memory used to align transmit data</span>
<span class="cm"> *             (e.g., to align on a cache line).</span>
<span class="cm"> * @intr: Boolean. Use 1 to generate interrupt for each completed TxDL.</span>
<span class="cm"> *             Use 0 otherwise.</span>
<span class="cm"> * @no_snoop_bits: If non-zero, specifies no-snoop PCI operation,</span>
<span class="cm"> *             which generally improves latency of the host bridge operation</span>
<span class="cm"> *             (see PCI specification). For valid values please refer</span>
<span class="cm"> *             to struct vxge_hw_fifo_config{} in the driver sources.</span>
<span class="cm"> * Configuration of all Titan fifos.</span>
<span class="cm"> * Note: Valid (min, max) range for each attribute is specified in the body of</span>
<span class="cm"> * the struct vxge_hw_fifo_config{} structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_fifo_config</span> <span class="p">{</span>
	<span class="n">u32</span>				<span class="n">enable</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_FIFO_ENABLE				1</span>
<span class="cp">#define VXGE_HW_FIFO_DISABLE				0</span>

	<span class="n">u32</span>				<span class="n">fifo_blocks</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_FIFO_BLOCKS				2</span>
<span class="cp">#define VXGE_HW_MAX_FIFO_BLOCKS				128</span>

	<span class="n">u32</span>				<span class="n">max_frags</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_FIFO_FRAGS				1</span>
<span class="cp">#define VXGE_HW_MAX_FIFO_FRAGS				256</span>

	<span class="n">u32</span>				<span class="n">memblock_size</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_FIFO_MEMBLOCK_SIZE			VXGE_HW_BLOCK_SIZE</span>
<span class="cp">#define VXGE_HW_MAX_FIFO_MEMBLOCK_SIZE			131072</span>
<span class="cp">#define VXGE_HW_DEF_FIFO_MEMBLOCK_SIZE			8096</span>

	<span class="n">u32</span>		                <span class="n">alignment_size</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_FIFO_ALIGNMENT_SIZE		0</span>
<span class="cp">#define VXGE_HW_MAX_FIFO_ALIGNMENT_SIZE		65536</span>
<span class="cp">#define VXGE_HW_DEF_FIFO_ALIGNMENT_SIZE		VXGE_CACHE_LINE_SIZE</span>

	<span class="n">u32</span>		                <span class="n">intr</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_FIFO_QUEUE_INTR_ENABLE			1</span>
<span class="cp">#define VXGE_HW_FIFO_QUEUE_INTR_DISABLE			0</span>
<span class="cp">#define VXGE_HW_FIFO_QUEUE_INTR_DEFAULT			0</span>

	<span class="n">u32</span>				<span class="n">no_snoop_bits</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_FIFO_NO_SNOOP_DISABLED			0</span>
<span class="cp">#define VXGE_HW_FIFO_NO_SNOOP_TXD			1</span>
<span class="cp">#define VXGE_HW_FIFO_NO_SNOOP_FRM			2</span>
<span class="cp">#define VXGE_HW_FIFO_NO_SNOOP_ALL			3</span>
<span class="cp">#define VXGE_HW_FIFO_NO_SNOOP_DEFAULT			0</span>

<span class="p">};</span>
<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_ring_config - Ring configurations.</span>
<span class="cm"> * @enable: Is this ring to be commissioned</span>
<span class="cm"> * @ring_blocks: Numbers of RxD blocks in the ring</span>
<span class="cm"> * @buffer_mode: Receive buffer mode (1, 2, 3, or 5); for details please refer</span>
<span class="cm"> *             to Titan User Guide.</span>
<span class="cm"> * @scatter_mode: Titan supports two receive scatter modes: A and B.</span>
<span class="cm"> *             For details please refer to Titan User Guide.</span>
<span class="cm"> * @rx_timer_val: The number of 32ns periods that would be counted between two</span>
<span class="cm"> *             timer interrupts.</span>
<span class="cm"> * @greedy_return: If Set it forces the device to return absolutely all RxD</span>
<span class="cm"> *             that are consumed and still on board when a timer interrupt</span>
<span class="cm"> *             triggers. If Clear, then if the device has already returned</span>
<span class="cm"> *             RxD before current timer interrupt trigerred and after the</span>
<span class="cm"> *             previous timer interrupt triggered, then the device is not</span>
<span class="cm"> *             forced to returned the rest of the consumed RxD that it has</span>
<span class="cm"> *             on board which account for a byte count less than the one</span>
<span class="cm"> *             programmed into PRC_CFG6.RXD_CRXDT field</span>
<span class="cm"> * @rx_timer_ci: TBD</span>
<span class="cm"> * @backoff_interval_us: Time (in microseconds), after which Titan</span>
<span class="cm"> *             tries to download RxDs posted by the host.</span>
<span class="cm"> *             Note that the &quot;backoff&quot; does not happen if host posts receive</span>
<span class="cm"> *             descriptors in the timely fashion.</span>
<span class="cm"> * Ring configuration.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_ring_config</span> <span class="p">{</span>
	<span class="n">u32</span>				<span class="n">enable</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_RING_ENABLE					1</span>
<span class="cp">#define VXGE_HW_RING_DISABLE					0</span>
<span class="cp">#define VXGE_HW_RING_DEFAULT					1</span>

	<span class="n">u32</span>				<span class="n">ring_blocks</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_RING_BLOCKS					1</span>
<span class="cp">#define VXGE_HW_MAX_RING_BLOCKS					128</span>
<span class="cp">#define VXGE_HW_DEF_RING_BLOCKS					2</span>

	<span class="n">u32</span>				<span class="n">buffer_mode</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_RING_RXD_BUFFER_MODE_1				1</span>
<span class="cp">#define VXGE_HW_RING_RXD_BUFFER_MODE_3				3</span>
<span class="cp">#define VXGE_HW_RING_RXD_BUFFER_MODE_5				5</span>
<span class="cp">#define VXGE_HW_RING_RXD_BUFFER_MODE_DEFAULT			1</span>

	<span class="n">u32</span>				<span class="n">scatter_mode</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_RING_SCATTER_MODE_A				0</span>
<span class="cp">#define VXGE_HW_RING_SCATTER_MODE_B				1</span>
<span class="cp">#define VXGE_HW_RING_SCATTER_MODE_C				2</span>
<span class="cp">#define VXGE_HW_RING_SCATTER_MODE_USE_FLASH_DEFAULT		0xffffffff</span>

	<span class="n">u64</span>				<span class="n">rxds_limit</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_DEF_RING_RXDS_LIMIT				44</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_vp_config - Configuration of virtual path</span>
<span class="cm"> * @vp_id: Virtual Path Id</span>
<span class="cm"> * @min_bandwidth: Minimum Guaranteed bandwidth</span>
<span class="cm"> * @ring: See struct vxge_hw_ring_config{}.</span>
<span class="cm"> * @fifo: See struct vxge_hw_fifo_config{}.</span>
<span class="cm"> * @tti: Configuration of interrupt associated with Transmit.</span>
<span class="cm"> *             see struct vxge_hw_tim_intr_config();</span>
<span class="cm"> * @rti: Configuration of interrupt associated with Receive.</span>
<span class="cm"> *              see struct vxge_hw_tim_intr_config();</span>
<span class="cm"> * @mtu: mtu size used on this port.</span>
<span class="cm"> * @rpa_strip_vlan_tag: Strip VLAN Tag enable/disable. Instructs the device to</span>
<span class="cm"> *             remove the VLAN tag from all received tagged frames that are not</span>
<span class="cm"> *             replicated at the internal L2 switch.</span>
<span class="cm"> *             0 - Do not strip the VLAN tag.</span>
<span class="cm"> *             1 - Strip the VLAN tag. Regardless of this setting, VLAN tags are</span>
<span class="cm"> *                 always placed into the RxDMA descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used by the driver to pass the configuration parameters to</span>
<span class="cm"> * configure Virtual Path.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_vp_config</span> <span class="p">{</span>
	<span class="n">u32</span>				<span class="n">vp_id</span><span class="p">;</span>

<span class="cp">#define	VXGE_HW_VPATH_PRIORITY_MIN			0</span>
<span class="cp">#define	VXGE_HW_VPATH_PRIORITY_MAX			16</span>
<span class="cp">#define	VXGE_HW_VPATH_PRIORITY_DEFAULT			0</span>

	<span class="n">u32</span>				<span class="n">min_bandwidth</span><span class="p">;</span>
<span class="cp">#define	VXGE_HW_VPATH_BANDWIDTH_MIN			0</span>
<span class="cp">#define	VXGE_HW_VPATH_BANDWIDTH_MAX			100</span>
<span class="cp">#define	VXGE_HW_VPATH_BANDWIDTH_DEFAULT			0</span>

	<span class="k">struct</span> <span class="n">vxge_hw_ring_config</span>		<span class="n">ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_fifo_config</span>		<span class="n">fifo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_tim_intr_config</span>	<span class="n">tti</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_tim_intr_config</span>	<span class="n">rti</span><span class="p">;</span>

	<span class="n">u32</span>				<span class="n">mtu</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_VPATH_MIN_INITIAL_MTU			VXGE_HW_MIN_MTU</span>
<span class="cp">#define VXGE_HW_VPATH_MAX_INITIAL_MTU			VXGE_HW_MAX_MTU</span>
<span class="cp">#define VXGE_HW_VPATH_USE_FLASH_DEFAULT_INITIAL_MTU	0xffffffff</span>

	<span class="n">u32</span>				<span class="n">rpa_strip_vlan_tag</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_VPATH_RPA_STRIP_VLAN_TAG_ENABLE			1</span>
<span class="cp">#define VXGE_HW_VPATH_RPA_STRIP_VLAN_TAG_DISABLE		0</span>
<span class="cp">#define VXGE_HW_VPATH_RPA_STRIP_VLAN_TAG_USE_FLASH_DEFAULT	0xffffffff</span>

<span class="p">};</span>
<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_device_config - Device configuration.</span>
<span class="cm"> * @dma_blockpool_initial: Initial size of DMA Pool</span>
<span class="cm"> * @dma_blockpool_max: Maximum blocks in DMA pool</span>
<span class="cm"> * @intr_mode: Line, or MSI-X interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * @rth_en: Enable Receive Traffic Hashing(RTH) using IT(Indirection Table).</span>
<span class="cm"> * @rth_it_type: RTH IT table programming type</span>
<span class="cm"> * @rts_mac_en: Enable Receive Traffic Steering using MAC destination address</span>
<span class="cm"> * @vp_config: Configuration for virtual paths</span>
<span class="cm"> * @device_poll_millis: Specify the interval (in mulliseconds)</span>
<span class="cm"> * 			to wait for register reads</span>
<span class="cm"> *</span>
<span class="cm"> * Titan configuration.</span>
<span class="cm"> * Contains per-device configuration parameters, including:</span>
<span class="cm"> * - stats sampling interval, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * In addition, struct vxge_hw_device_config{} includes &quot;subordinate&quot;</span>
<span class="cm"> * configurations, including:</span>
<span class="cm"> * - fifos and rings;</span>
<span class="cm"> * - MAC (done at firmware level).</span>
<span class="cm"> *</span>
<span class="cm"> * See Titan User Guide for more details.</span>
<span class="cm"> * Note: Valid (min, max) range for each attribute is specified in the body of</span>
<span class="cm"> * the struct vxge_hw_device_config{} structure. Please refer to the</span>
<span class="cm"> * corresponding include file.</span>
<span class="cm"> * See also: struct vxge_hw_tim_intr_config{}.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_device_config</span> <span class="p">{</span>
	<span class="n">u32</span>					<span class="n">device_poll_millis</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_DEVICE_POLL_MILLIS		1</span>
<span class="cp">#define VXGE_HW_MAX_DEVICE_POLL_MILLIS		100000</span>
<span class="cp">#define VXGE_HW_DEF_DEVICE_POLL_MILLIS		1000</span>

	<span class="n">u32</span>					<span class="n">dma_blockpool_initial</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">dma_blockpool_max</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_MIN_DMA_BLOCK_POOL_SIZE		0</span>
<span class="cp">#define VXGE_HW_INITIAL_DMA_BLOCK_POOL_SIZE	0</span>
<span class="cp">#define VXGE_HW_INCR_DMA_BLOCK_POOL_SIZE	4</span>
<span class="cp">#define VXGE_HW_MAX_DMA_BLOCK_POOL_SIZE		4096</span>

<span class="cp">#define	VXGE_HW_MAX_PAYLOAD_SIZE_512		2</span>

	<span class="n">u32</span>					<span class="n">intr_mode</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span>
<span class="cp">#define VXGE_HW_INTR_MODE_IRQLINE		0</span>
<span class="cp">#define VXGE_HW_INTR_MODE_MSIX			1</span>
<span class="cp">#define VXGE_HW_INTR_MODE_MSIX_ONE_SHOT		2</span>

<span class="cp">#define VXGE_HW_INTR_MODE_DEF			0</span>

						<span class="nl">rth_en:</span><span class="mi">1</span><span class="p">,</span>
<span class="cp">#define VXGE_HW_RTH_DISABLE			0</span>
<span class="cp">#define VXGE_HW_RTH_ENABLE			1</span>
<span class="cp">#define VXGE_HW_RTH_DEFAULT			0</span>

						<span class="nl">rth_it_type:</span><span class="mi">1</span><span class="p">,</span>
<span class="cp">#define VXGE_HW_RTH_IT_TYPE_SOLO_IT		0</span>
<span class="cp">#define VXGE_HW_RTH_IT_TYPE_MULTI_IT		1</span>
<span class="cp">#define VXGE_HW_RTH_IT_TYPE_DEFAULT		0</span>

						<span class="nl">rts_mac_en:</span><span class="mi">1</span><span class="p">,</span>
<span class="cp">#define VXGE_HW_RTS_MAC_DISABLE			0</span>
<span class="cp">#define VXGE_HW_RTS_MAC_ENABLE			1</span>
<span class="cp">#define VXGE_HW_RTS_MAC_DEFAULT			0</span>

						<span class="nl">hwts_en:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#define	VXGE_HW_HWTS_DISABLE			0</span>
<span class="cp">#define	VXGE_HW_HWTS_ENABLE			1</span>
<span class="cp">#define	VXGE_HW_HWTS_DEFAULT			1</span>

	<span class="k">struct</span> <span class="n">vxge_hw_vp_config</span> <span class="n">vp_config</span><span class="p">[</span><span class="n">VXGE_HW_MAX_VIRTUAL_PATHS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * function vxge_uld_link_up_f - Link-Up callback provided by driver.</span>
<span class="cm"> * @devh: HW device handle.</span>
<span class="cm"> * Link-up notification callback provided by the driver.</span>
<span class="cm"> * This is one of the per-driver callbacks, see struct vxge_hw_uld_cbs{}.</span>
<span class="cm"> *</span>
<span class="cm"> * See also: struct vxge_hw_uld_cbs{}, vxge_uld_link_down_f{},</span>
<span class="cm"> * vxge_hw_driver_initialize().</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * function vxge_uld_link_down_f - Link-Down callback provided by</span>
<span class="cm"> * driver.</span>
<span class="cm"> * @devh: HW device handle.</span>
<span class="cm"> *</span>
<span class="cm"> * Link-Down notification callback provided by the driver.</span>
<span class="cm"> * This is one of the per-driver callbacks, see struct vxge_hw_uld_cbs{}.</span>
<span class="cm"> *</span>
<span class="cm"> * See also: struct vxge_hw_uld_cbs{}, vxge_uld_link_up_f{},</span>
<span class="cm"> * vxge_hw_driver_initialize().</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * function vxge_uld_crit_err_f - Critical Error notification callback.</span>
<span class="cm"> * @devh: HW device handle.</span>
<span class="cm"> * (typically - at HW device iinitialization time).</span>
<span class="cm"> * @type: Enumerated hw error, e.g.: double ECC.</span>
<span class="cm"> * @serr_data: Titan status.</span>
<span class="cm"> * @ext_data: Extended data. The contents depends on the @type.</span>
<span class="cm"> *</span>
<span class="cm"> * Link-Down notification callback provided by the driver.</span>
<span class="cm"> * This is one of the per-driver callbacks, see struct vxge_hw_uld_cbs{}.</span>
<span class="cm"> *</span>
<span class="cm"> * See also: struct vxge_hw_uld_cbs{}, enum vxge_hw_event{},</span>
<span class="cm"> * vxge_hw_driver_initialize().</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_uld_cbs - driver &quot;slow-path&quot; callbacks.</span>
<span class="cm"> * @link_up: See vxge_uld_link_up_f{}.</span>
<span class="cm"> * @link_down: See vxge_uld_link_down_f{}.</span>
<span class="cm"> * @crit_err: See vxge_uld_crit_err_f{}.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver slow-path (per-driver) callbacks.</span>
<span class="cm"> * Implemented by driver and provided to HW via</span>
<span class="cm"> * vxge_hw_driver_initialize().</span>
<span class="cm"> * Note that these callbacks are not mandatory: HW will not invoke</span>
<span class="cm"> * a callback if NULL is specified.</span>
<span class="cm"> *</span>
<span class="cm"> * See also: vxge_hw_driver_initialize().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_uld_cbs</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">link_up</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">link_down</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">crit_err</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">vxge_hw_event</span> <span class="n">type</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ext_data</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct __vxge_hw_blockpool_entry - Block private data structure</span>
<span class="cm"> * @item: List header used to link.</span>
<span class="cm"> * @length: Length of the block</span>
<span class="cm"> * @memblock: Virtual address block</span>
<span class="cm"> * @dma_addr: DMA Address of the block.</span>
<span class="cm"> * @dma_handle: DMA handle of the block.</span>
<span class="cm"> * @acc_handle: DMA acc handle</span>
<span class="cm"> *</span>
<span class="cm"> * Block is allocated with a header to put the blocks into list.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_blockpool_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">item</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">length</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">memblock</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">dma_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> 		<span class="o">*</span><span class="n">dma_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> 		<span class="o">*</span><span class="n">acc_handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct __vxge_hw_blockpool - Block Pool</span>
<span class="cm"> * @hldev: HW device</span>
<span class="cm"> * @block_size: size of each block.</span>
<span class="cm"> * @Pool_size: Number of blocks in the pool</span>
<span class="cm"> * @pool_max: Maximum number of blocks above which to free additional blocks</span>
<span class="cm"> * @req_out: Number of block requests with OS out standing</span>
<span class="cm"> * @free_block_list: List of free blocks</span>
<span class="cm"> *</span>
<span class="cm"> * Block pool contains the DMA blocks preallocated.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_blockpool</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">hldev</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">block_size</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">pool_size</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">pool_max</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">req_out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">free_block_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">free_entry_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * enum enum __vxge_hw_channel_type - Enumerated channel types.</span>
<span class="cm"> * @VXGE_HW_CHANNEL_TYPE_UNKNOWN: Unknown channel.</span>
<span class="cm"> * @VXGE_HW_CHANNEL_TYPE_FIFO: fifo.</span>
<span class="cm"> * @VXGE_HW_CHANNEL_TYPE_RING: ring.</span>
<span class="cm"> * @VXGE_HW_CHANNEL_TYPE_MAX: Maximum number of HW-supported</span>
<span class="cm"> * (and recognized) channel types. Currently: 2.</span>
<span class="cm"> *</span>
<span class="cm"> * Enumerated channel types. Currently there are only two link-layer</span>
<span class="cm"> * channels - Titan fifo and Titan ring. In the future the list will grow.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">__vxge_hw_channel_type</span> <span class="p">{</span>
	<span class="n">VXGE_HW_CHANNEL_TYPE_UNKNOWN</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VXGE_HW_CHANNEL_TYPE_FIFO</span>			<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_HW_CHANNEL_TYPE_RING</span>			<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VXGE_HW_CHANNEL_TYPE_MAX</span>			<span class="o">=</span> <span class="mi">3</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct __vxge_hw_channel</span>
<span class="cm"> * @item: List item; used to maintain a list of open channels.</span>
<span class="cm"> * @type: Channel type. See enum vxge_hw_channel_type{}.</span>
<span class="cm"> * @devh: Device handle. HW device object that contains _this_ channel.</span>
<span class="cm"> * @vph: Virtual path handle. Virtual Path Object that contains _this_ channel.</span>
<span class="cm"> * @length: Channel length. Currently allocated number of descriptors.</span>
<span class="cm"> *          The channel length &quot;grows&quot; when more descriptors get allocated.</span>
<span class="cm"> *          See _hw_mempool_grow.</span>
<span class="cm"> * @reserve_arr: Reserve array. Contains descriptors that can be reserved</span>
<span class="cm"> *               by driver for the subsequent send or receive operation.</span>
<span class="cm"> *               See vxge_hw_fifo_txdl_reserve(),</span>
<span class="cm"> *               vxge_hw_ring_rxd_reserve().</span>
<span class="cm"> * @reserve_ptr: Current pointer in the resrve array</span>
<span class="cm"> * @reserve_top: Reserve top gives the maximum number of dtrs available in</span>
<span class="cm"> *          reserve array.</span>
<span class="cm"> * @work_arr: Work array. Contains descriptors posted to the channel.</span>
<span class="cm"> *            Note that at any point in time @work_arr contains 3 types of</span>
<span class="cm"> *            descriptors:</span>
<span class="cm"> *            1) posted but not yet consumed by Titan device;</span>
<span class="cm"> *            2) consumed but not yet completed;</span>
<span class="cm"> *            3) completed but not yet freed</span>
<span class="cm"> *            (via vxge_hw_fifo_txdl_free() or vxge_hw_ring_rxd_free())</span>
<span class="cm"> * @post_index: Post index. At any point in time points on the</span>
<span class="cm"> *              position in the channel, which&#39;ll contain next to-be-posted</span>
<span class="cm"> *              descriptor.</span>
<span class="cm"> * @compl_index: Completion index. At any point in time points on the</span>
<span class="cm"> *               position in the channel, which will contain next</span>
<span class="cm"> *               to-be-completed descriptor.</span>
<span class="cm"> * @free_arr: Free array. Contains completed descriptors that were freed</span>
<span class="cm"> *            (i.e., handed over back to HW) by driver.</span>
<span class="cm"> *            See vxge_hw_fifo_txdl_free(), vxge_hw_ring_rxd_free().</span>
<span class="cm"> * @free_ptr: current pointer in free array</span>
<span class="cm"> * @per_dtr_space: Per-descriptor space (in bytes) that channel user can utilize</span>
<span class="cm"> *                 to store per-operation control information.</span>
<span class="cm"> * @stats: Pointer to common statistics</span>
<span class="cm"> * @userdata: Per-channel opaque (void*) user-defined context, which may be</span>
<span class="cm"> *            driver object, ULP connection, etc.</span>
<span class="cm"> *            Once channel is open, @userdata is passed back to user via</span>
<span class="cm"> *            vxge_hw_channel_callback_f.</span>
<span class="cm"> *</span>
<span class="cm"> * HW channel object.</span>
<span class="cm"> *</span>
<span class="cm"> * See also: enum vxge_hw_channel_type{}, enum vxge_hw_channel_flag</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_channel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">item</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">__vxge_hw_channel_type</span>	<span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> 	<span class="o">*</span><span class="n">devh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> 	<span class="o">*</span><span class="n">vph</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">length</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">vp_id</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">**</span><span class="n">reserve_arr</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">reserve_ptr</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">reserve_top</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">**</span><span class="n">work_arr</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">post_index</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">compl_index</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">**</span><span class="n">free_arr</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">free_ptr</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">**</span><span class="n">orig_arr</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">per_dtr_space</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">userdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_common_reg</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">common_reg</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">first_vp_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_common_info</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>

<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * struct __vxge_hw_virtualpath - Virtual Path</span>
<span class="cm"> *</span>
<span class="cm"> * @vp_id: Virtual path id</span>
<span class="cm"> * @vp_open: This flag specifies if vxge_hw_vp_open is called from LL Driver</span>
<span class="cm"> * @hldev: Hal device</span>
<span class="cm"> * @vp_config: Virtual Path Config</span>
<span class="cm"> * @vp_reg: VPATH Register map address in BAR0</span>
<span class="cm"> * @vpmgmt_reg: VPATH_MGMT register map address</span>
<span class="cm"> * @max_mtu: Max mtu that can be supported</span>
<span class="cm"> * @vsport_number: vsport attached to this vpath</span>
<span class="cm"> * @max_kdfc_db: Maximum kernel mode doorbells</span>
<span class="cm"> * @max_nofl_db: Maximum non offload doorbells</span>
<span class="cm"> * @tx_intr_num: Interrupt Number associated with the TX</span>

<span class="cm"> * @ringh: Ring Queue</span>
<span class="cm"> * @fifoh: FIFO Queue</span>
<span class="cm"> * @vpath_handles: Virtual Path handles list</span>
<span class="cm"> * @stats_block: Memory for DMAing stats</span>
<span class="cm"> * @stats: Vpath statistics</span>
<span class="cm"> *</span>
<span class="cm"> * Virtual path structure to encapsulate the data related to a virtual path.</span>
<span class="cm"> * Virtual paths are allocated by the HW upon getting configuration from the</span>
<span class="cm"> * driver and inserted into the list of virtual paths.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_virtualpath</span> <span class="p">{</span>
	<span class="n">u32</span>				<span class="n">vp_id</span><span class="p">;</span>

	<span class="n">u32</span>				<span class="n">vp_open</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_VP_NOT_OPEN	0</span>
<span class="cp">#define	VXGE_HW_VP_OPEN		1</span>

	<span class="k">struct</span> <span class="n">__vxge_hw_device</span>		<span class="o">*</span><span class="n">hldev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vp_config</span>	<span class="o">*</span><span class="n">vp_config</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_reg</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">vp_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpmgmt_reg</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">vpmgmt_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_non_offload_db_wrapper</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">nofl_db</span><span class="p">;</span>

	<span class="n">u32</span>				<span class="n">max_mtu</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">vsport_number</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">max_kdfc_db</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">max_nofl_db</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">tim_tti_cfg1_saved</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">tim_tti_cfg3_saved</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">tim_rti_cfg1_saved</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">tim_rti_cfg3_saved</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">____cacheline_aligned</span> <span class="n">ringh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">____cacheline_aligned</span> <span class="n">fifoh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">vpath_handles</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_blockpool_entry</span>		<span class="o">*</span><span class="n">stats_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_hw_info</span>	<span class="o">*</span><span class="n">hw_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_hw_info</span>	<span class="o">*</span><span class="n">hw_stats_sav</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_info</span>	<span class="o">*</span><span class="n">sw_stats</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct __vxge_hw_vpath_handle - List item to store callback information</span>
<span class="cm"> * @item: List head to keep the item in linked list</span>
<span class="cm"> * @vpath: Virtual path to which this item belongs</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used to store the callback information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_virtualpath</span>	<span class="o">*</span><span class="n">vpath</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct __vxge_hw_device</span>
<span class="cm"> *</span>
<span class="cm"> * HW device object.</span>
<span class="cm"> */</span>
<span class="cm">/**</span>
<span class="cm"> * struct __vxge_hw_device  - Hal device object</span>
<span class="cm"> * @magic: Magic Number</span>
<span class="cm"> * @bar0: BAR0 virtual address.</span>
<span class="cm"> * @pdev: Physical device handle</span>
<span class="cm"> * @config: Confguration passed by the LL driver at initialization</span>
<span class="cm"> * @link_state: Link state</span>
<span class="cm"> *</span>
<span class="cm"> * HW device object. Represents Titan adapter</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="p">{</span>
	<span class="n">u32</span>				<span class="n">magic</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_DEVICE_MAGIC		0x12345678</span>
<span class="cp">#define VXGE_HW_DEVICE_DEAD		0xDEADDEAD</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">bar0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>			<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span>		<span class="o">*</span><span class="n">ndev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_config</span>	<span class="n">config</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">vxge_hw_device_link_state</span>	<span class="n">link_state</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">vxge_hw_uld_cbs</span>	<span class="o">*</span><span class="n">uld_callbacks</span><span class="p">;</span>

	<span class="n">u32</span>				<span class="n">host_type</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">func_id</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">access_rights</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_DEVICE_ACCESS_RIGHT_VPATH      0x1</span>
<span class="cp">#define VXGE_HW_DEVICE_ACCESS_RIGHT_SRPCIM     0x2</span>
<span class="cp">#define VXGE_HW_DEVICE_ACCESS_RIGHT_MRPCIM     0x4</span>
	<span class="k">struct</span> <span class="n">vxge_hw_legacy_reg</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">legacy_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_toc_reg</span>		<span class="n">__iomem</span> <span class="o">*</span><span class="n">toc_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_common_reg</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">common_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_mrpcim_reg</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">mrpcim_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_srpcim_reg</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">srpcim_reg</span> \
					<span class="p">[</span><span class="n">VXGE_HW_TITAN_SRPCIM_REG_SPACES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpmgmt_reg</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">vpmgmt_reg</span> \
					<span class="p">[</span><span class="n">VXGE_HW_TITAN_VPMGMT_REG_SPACES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_reg</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">vpath_reg</span> \
					<span class="p">[</span><span class="n">VXGE_HW_TITAN_VPATH_REG_SPACES</span><span class="p">];</span>
	<span class="n">u8</span>				<span class="n">__iomem</span> <span class="o">*</span><span class="n">kdfc</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">__iomem</span> <span class="o">*</span><span class="n">usdc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_virtualpath</span>	<span class="n">virtual_paths</span> \
					<span class="p">[</span><span class="n">VXGE_HW_MAX_VIRTUAL_PATHS</span><span class="p">];</span>
	<span class="n">u64</span>				<span class="n">vpath_assignments</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">vpaths_deployed</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">first_vp_id</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">tim_int_mask0</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span>				<span class="n">tim_int_mask1</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">__vxge_hw_blockpool</span>	<span class="n">block_pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_stats</span>	<span class="n">stats</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">debug_module_mask</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">debug_level</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">level_err</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">level_trace</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eprom_versions</span><span class="p">[</span><span class="n">VXGE_HW_MAX_ROM_IMAGES</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define VXGE_HW_INFO_LEN	64</span>
<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_device_hw_info - Device information</span>
<span class="cm"> * @host_type: Host Type</span>
<span class="cm"> * @func_id: Function Id</span>
<span class="cm"> * @vpath_mask: vpath bit mask</span>
<span class="cm"> * @fw_version: Firmware version</span>
<span class="cm"> * @fw_date: Firmware Date</span>
<span class="cm"> * @flash_version: Firmware version</span>
<span class="cm"> * @flash_date: Firmware Date</span>
<span class="cm"> * @mac_addrs: Mac addresses for each vpath</span>
<span class="cm"> * @mac_addr_masks: Mac address masks for each vpath</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the vpath mask that has the bits set for each vpath allocated</span>
<span class="cm"> * for the driver and the first mac address for each vpath</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_device_hw_info</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">host_type</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_NO_MR_NO_SR_NORMAL_FUNCTION			0</span>
<span class="cp">#define VXGE_HW_MR_NO_SR_VH0_BASE_FUNCTION			1</span>
<span class="cp">#define VXGE_HW_NO_MR_SR_VH0_FUNCTION0				2</span>
<span class="cp">#define VXGE_HW_NO_MR_SR_VH0_VIRTUAL_FUNCTION			3</span>
<span class="cp">#define VXGE_HW_MR_SR_VH0_INVALID_CONFIG			4</span>
<span class="cp">#define VXGE_HW_SR_VH_FUNCTION0					5</span>
<span class="cp">#define VXGE_HW_SR_VH_VIRTUAL_FUNCTION				6</span>
<span class="cp">#define VXGE_HW_VH_NORMAL_FUNCTION				7</span>
	<span class="n">u64</span>		<span class="n">function_mode</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_FUNCTION_MODE_SINGLE_FUNCTION			0</span>
<span class="cp">#define VXGE_HW_FUNCTION_MODE_MULTI_FUNCTION			1</span>
<span class="cp">#define VXGE_HW_FUNCTION_MODE_SRIOV				2</span>
<span class="cp">#define VXGE_HW_FUNCTION_MODE_MRIOV				3</span>
<span class="cp">#define VXGE_HW_FUNCTION_MODE_MRIOV_8				4</span>
<span class="cp">#define VXGE_HW_FUNCTION_MODE_MULTI_FUNCTION_17			5</span>
<span class="cp">#define VXGE_HW_FUNCTION_MODE_SRIOV_8				6</span>
<span class="cp">#define VXGE_HW_FUNCTION_MODE_SRIOV_4				7</span>
<span class="cp">#define VXGE_HW_FUNCTION_MODE_MULTI_FUNCTION_2			8</span>
<span class="cp">#define VXGE_HW_FUNCTION_MODE_MULTI_FUNCTION_4			9</span>
<span class="cp">#define VXGE_HW_FUNCTION_MODE_MRIOV_4				10</span>

	<span class="n">u32</span>		<span class="n">func_id</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">vpath_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_version</span> <span class="n">fw_version</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_date</span>    <span class="n">fw_date</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_version</span> <span class="n">flash_version</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_date</span>    <span class="n">flash_date</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">serial_number</span><span class="p">[</span><span class="n">VXGE_HW_INFO_LEN</span><span class="p">];</span>
	<span class="n">u8</span>		<span class="n">part_number</span><span class="p">[</span><span class="n">VXGE_HW_INFO_LEN</span><span class="p">];</span>
	<span class="n">u8</span>		<span class="n">product_desc</span><span class="p">[</span><span class="n">VXGE_HW_INFO_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">mac_addrs</span><span class="p">[</span><span class="n">VXGE_HW_MAX_VIRTUAL_PATHS</span><span class="p">][</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">mac_addr_masks</span><span class="p">[</span><span class="n">VXGE_HW_MAX_VIRTUAL_PATHS</span><span class="p">][</span><span class="n">ETH_ALEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_device_attr - Device memory spaces.</span>
<span class="cm"> * @bar0: BAR0 virtual address.</span>
<span class="cm"> * @pdev: PCI device object.</span>
<span class="cm"> *</span>
<span class="cm"> * Device memory spaces. Includes configuration, BAR0 etc. per device</span>
<span class="cm"> * mapped memories. Also, includes a pointer to OS-specific PCI device object.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_device_attr</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">bar0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> 		<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vxge_hw_uld_cbs</span> <span class="o">*</span><span class="n">uld_callbacks</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define VXGE_HW_DEVICE_LINK_STATE_SET(hldev, ls)	(hldev-&gt;link_state = ls)</span>

<span class="cp">#define VXGE_HW_DEVICE_TIM_INT_MASK_SET(m0, m1, i) {	\</span>
<span class="cp">	if (i &lt; 16) {				\</span>
<span class="cp">		m0[0] |= vxge_vBIT(0x8, (i*4), 4);	\</span>
<span class="cp">		m0[1] |= vxge_vBIT(0x4, (i*4), 4);	\</span>
<span class="cp">	}			       		\</span>
<span class="cp">	else {					\</span>
<span class="cp">		m1[0] = 0x80000000;		\</span>
<span class="cp">		m1[1] = 0x40000000;		\</span>
<span class="cp">	}					\</span>
<span class="cp">}</span>

<span class="cp">#define VXGE_HW_DEVICE_TIM_INT_MASK_RESET(m0, m1, i) {	\</span>
<span class="cp">	if (i &lt; 16) {					\</span>
<span class="cp">		m0[0] &amp;= ~vxge_vBIT(0x8, (i*4), 4);		\</span>
<span class="cp">		m0[1] &amp;= ~vxge_vBIT(0x4, (i*4), 4);		\</span>
<span class="cp">	}						\</span>
<span class="cp">	else {						\</span>
<span class="cp">		m1[0] = 0;				\</span>
<span class="cp">		m1[1] = 0;				\</span>
<span class="cp">	}						\</span>
<span class="cp">}</span>

<span class="cp">#define VXGE_HW_DEVICE_STATS_PIO_READ(loc, offset) {		\</span>
<span class="cp">	status = vxge_hw_mrpcim_stats_access(hldev, \</span>
<span class="cp">				VXGE_HW_STATS_OP_READ, \</span>
<span class="cp">				loc, \</span>
<span class="cp">				offset, \</span>
<span class="cp">				&amp;val64);			\</span>
<span class="cp">	if (status != VXGE_HW_OK)				\</span>
<span class="cp">		return status;						\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * struct __vxge_hw_ring - Ring channel.</span>
<span class="cm"> * @channel: Channel &quot;base&quot; of this ring, the common part of all HW</span>
<span class="cm"> *           channels.</span>
<span class="cm"> * @mempool: Memory pool, the pool from which descriptors get allocated.</span>
<span class="cm"> *           (See vxge_hw_mm.h).</span>
<span class="cm"> * @config: Ring configuration, part of device configuration</span>
<span class="cm"> *          (see struct vxge_hw_device_config{}).</span>
<span class="cm"> * @ring_length: Length of the ring</span>
<span class="cm"> * @buffer_mode: 1, 3, or 5. The value specifies a receive buffer mode,</span>
<span class="cm"> *          as per Titan User Guide.</span>
<span class="cm"> * @rxd_size: RxD sizes for 1-, 3- or 5- buffer modes. As per Titan spec,</span>
<span class="cm"> *            1-buffer mode descriptor is 32 byte long, etc.</span>
<span class="cm"> * @rxd_priv_size: Per RxD size reserved (by HW) for driver to keep</span>
<span class="cm"> *                 per-descriptor data (e.g., DMA handle for Solaris)</span>
<span class="cm"> * @per_rxd_space: Per rxd space requested by driver</span>
<span class="cm"> * @rxds_per_block: Number of descriptors per hardware-defined RxD</span>
<span class="cm"> *                  block. Depends on the (1-, 3-, 5-) buffer mode.</span>
<span class="cm"> * @rxdblock_priv_size: Reserved at the end of each RxD block. HW internal</span>
<span class="cm"> *                      usage. Not to confuse with @rxd_priv_size.</span>
<span class="cm"> * @cmpl_cnt: Completion counter. Is reset to zero upon entering the ISR.</span>
<span class="cm"> * @callback: Channel completion callback. HW invokes the callback when there</span>
<span class="cm"> *            are new completions on that channel. In many implementations</span>
<span class="cm"> *            the @callback executes in the hw interrupt context.</span>
<span class="cm"> * @rxd_init: Channel&#39;s descriptor-initialize callback.</span>
<span class="cm"> *            See vxge_hw_ring_rxd_init_f{}.</span>
<span class="cm"> *            If not NULL, HW invokes the callback when opening</span>
<span class="cm"> *            the ring.</span>
<span class="cm"> * @rxd_term: Channel&#39;s descriptor-terminate callback. If not NULL,</span>
<span class="cm"> *          HW invokes the callback when closing the corresponding channel.</span>
<span class="cm"> *          See also vxge_hw_channel_rxd_term_f{}.</span>
<span class="cm"> * @stats: Statistics for ring</span>
<span class="cm"> * Ring channel.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The structure is cache line aligned to better utilize</span>
<span class="cm"> *       CPU cache performance.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_channel</span>		<span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_mempool</span>			<span class="o">*</span><span class="n">mempool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_reg</span>		<span class="n">__iomem</span>	<span class="o">*</span><span class="n">vp_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_common_reg</span>		<span class="n">__iomem</span>	<span class="o">*</span><span class="n">common_reg</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">ring_length</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">buffer_mode</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">rxd_size</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">rxd_priv_size</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">per_rxd_space</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">rxds_per_block</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">rxdblock_priv_size</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">cmpl_cnt</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">vp_id</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">doorbell_cnt</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">total_db_cnt</span><span class="p">;</span>
	<span class="n">u64</span>					<span class="n">rxds_limit</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">rtimer</span><span class="p">;</span>
	<span class="n">u64</span>					<span class="n">tim_rti_cfg1_saved</span><span class="p">;</span>
	<span class="n">u64</span>					<span class="n">tim_rti_cfg3_saved</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span>
			<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ringh</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">t_code</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">);</span>

	<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="p">(</span><span class="o">*</span><span class="n">rxd_init</span><span class="p">)(</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rxd_term</span><span class="p">)(</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">vxge_hw_rxd_state</span> <span class="n">state</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_ring_info</span> <span class="o">*</span><span class="n">stats</span>	<span class="n">____cacheline_aligned</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_ring_config</span>		<span class="o">*</span><span class="n">config</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * enum enum vxge_hw_txdl_state - Descriptor (TXDL) state.</span>
<span class="cm"> * @VXGE_HW_TXDL_STATE_NONE: Invalid state.</span>
<span class="cm"> * @VXGE_HW_TXDL_STATE_AVAIL: Descriptor is available for reservation.</span>
<span class="cm"> * @VXGE_HW_TXDL_STATE_POSTED: Descriptor is posted for processing by the</span>
<span class="cm"> * device.</span>
<span class="cm"> * @VXGE_HW_TXDL_STATE_FREED: Descriptor is free and can be reused for</span>
<span class="cm"> * filling-in and posting later.</span>
<span class="cm"> *</span>
<span class="cm"> * Titan/HW descriptor states.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vxge_hw_txdl_state</span> <span class="p">{</span>
	<span class="n">VXGE_HW_TXDL_STATE_NONE</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VXGE_HW_TXDL_STATE_AVAIL</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VXGE_HW_TXDL_STATE_POSTED</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VXGE_HW_TXDL_STATE_FREED</span>	<span class="o">=</span> <span class="mi">3</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * struct __vxge_hw_fifo - Fifo.</span>
<span class="cm"> * @channel: Channel &quot;base&quot; of this fifo, the common part of all HW</span>
<span class="cm"> *             channels.</span>
<span class="cm"> * @mempool: Memory pool, from which descriptors get allocated.</span>
<span class="cm"> * @config: Fifo configuration, part of device configuration</span>
<span class="cm"> *             (see struct vxge_hw_device_config{}).</span>
<span class="cm"> * @interrupt_type: Interrupt type to be used</span>
<span class="cm"> * @no_snoop_bits: See struct vxge_hw_fifo_config{}.</span>
<span class="cm"> * @txdl_per_memblock: Number of TxDLs (TxD lists) per memblock.</span>
<span class="cm"> *             on TxDL please refer to Titan UG.</span>
<span class="cm"> * @txdl_size: Configured TxDL size (i.e., number of TxDs in a list), plus</span>
<span class="cm"> *             per-TxDL HW private space (struct __vxge_hw_fifo_txdl_priv).</span>
<span class="cm"> * @priv_size: Per-Tx descriptor space reserved for driver</span>
<span class="cm"> *             usage.</span>
<span class="cm"> * @per_txdl_space: Per txdl private space for the driver</span>
<span class="cm"> * @callback: Fifo completion callback. HW invokes the callback when there</span>
<span class="cm"> *             are new completions on that fifo. In many implementations</span>
<span class="cm"> *             the @callback executes in the hw interrupt context.</span>
<span class="cm"> * @txdl_term: Fifo&#39;s descriptor-terminate callback. If not NULL,</span>
<span class="cm"> *             HW invokes the callback when closing the corresponding fifo.</span>
<span class="cm"> *             See also vxge_hw_fifo_txdl_term_f{}.</span>
<span class="cm"> * @stats: Statistics of this fifo</span>
<span class="cm"> *</span>
<span class="cm"> * Fifo channel.</span>
<span class="cm"> * Note: The structure is cache line aligned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_channel</span>		<span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_mempool</span>			<span class="o">*</span><span class="n">mempool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_fifo_config</span>		<span class="o">*</span><span class="n">config</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_reg</span>		<span class="n">__iomem</span> <span class="o">*</span><span class="n">vp_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_non_offload_db_wrapper</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">nofl_db</span><span class="p">;</span>
	<span class="n">u64</span>					<span class="n">interrupt_type</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">no_snoop_bits</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">txdl_per_memblock</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">txdl_size</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">priv_size</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">per_txdl_space</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">vp_id</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">tx_intr_num</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">rtimer</span><span class="p">;</span>
	<span class="n">u64</span>					<span class="n">tim_tti_cfg1_saved</span><span class="p">;</span>
	<span class="n">u64</span>					<span class="n">tim_tti_cfg3_saved</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span>
			<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifo_handle</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">vxge_hw_fifo_tcode</span> <span class="n">t_code</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">***</span><span class="n">skb_ptr</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nr_skb</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">more</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">txdl_term</span><span class="p">)(</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">vxge_hw_txdl_state</span> <span class="n">state</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">vxge_hw_vpath_stats_sw_fifo_info</span> <span class="o">*</span><span class="n">stats</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * struct __vxge_hw_fifo_txdl_priv - Transmit descriptor HW-private data.</span>
<span class="cm"> * @dma_addr: DMA (mapped) address of _this_ descriptor.</span>
<span class="cm"> * @dma_handle: DMA handle used to map the descriptor onto device.</span>
<span class="cm"> * @dma_offset: Descriptor&#39;s offset in the memory block. HW allocates</span>
<span class="cm"> *	 descriptors in memory blocks (see struct vxge_hw_fifo_config{})</span>
<span class="cm"> *             Each memblock is a contiguous block of DMA-able memory.</span>
<span class="cm"> * @frags: Total number of fragments (that is, contiguous data buffers)</span>
<span class="cm"> * carried by this TxDL.</span>
<span class="cm"> * @align_vaddr_start: Aligned virtual address start</span>
<span class="cm"> * @align_vaddr: Virtual address of the per-TxDL area in memory used for</span>
<span class="cm"> *             alignement. Used to place one or more mis-aligned fragments</span>
<span class="cm"> * @align_dma_addr: DMA address translated from the @align_vaddr.</span>
<span class="cm"> * @align_dma_handle: DMA handle that corresponds to @align_dma_addr.</span>
<span class="cm"> * @align_dma_acch: DMA access handle corresponds to @align_dma_addr.</span>
<span class="cm"> * @align_dma_offset: The current offset into the @align_vaddr area.</span>
<span class="cm"> * Grows while filling the descriptor, gets reset.</span>
<span class="cm"> * @align_used_frags: Number of fragments used.</span>
<span class="cm"> * @alloc_frags: Total number of fragments allocated.</span>
<span class="cm"> * @unused: TODO</span>
<span class="cm"> * @next_txdl_priv: (TODO).</span>
<span class="cm"> * @first_txdp: (TODO).</span>
<span class="cm"> * @linked_txdl_priv: Pointer to any linked TxDL for creating contiguous</span>
<span class="cm"> *             TxDL list.</span>
<span class="cm"> * @txdlh: Corresponding txdlh to this TxDL.</span>
<span class="cm"> * @memblock: Pointer to the TxDL memory block or memory page.</span>
<span class="cm"> *             on the next send operation.</span>
<span class="cm"> * @dma_object: DMA address and handle of the memory block that contains</span>
<span class="cm"> *             the descriptor. This member is used only in the &quot;checked&quot;</span>
<span class="cm"> *             version of the HW (to enforce certain assertions);</span>
<span class="cm"> *             otherwise it gets compiled out.</span>
<span class="cm"> * @allocated: True if the descriptor is reserved, 0 otherwise. Internal usage.</span>
<span class="cm"> *</span>
<span class="cm"> * Per-transmit decsriptor HW-private data. HW uses the space to keep DMA</span>
<span class="cm"> * information associated with the descriptor. Note that driver can ask HW</span>
<span class="cm"> * to allocate additional per-descriptor space for its own (driver-specific)</span>
<span class="cm"> * purposes.</span>
<span class="cm"> *</span>
<span class="cm"> * See also: struct vxge_hw_ring_rxd_priv{}.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_fifo_txdl_priv</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span>		<span class="n">dma_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">dma_handle</span><span class="p">;</span>
	<span class="kt">ptrdiff_t</span>		<span class="n">dma_offset</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">frags</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="o">*</span><span class="n">align_vaddr_start</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="o">*</span><span class="n">align_vaddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">align_dma_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> 	<span class="o">*</span><span class="n">align_dma_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">align_dma_acch</span><span class="p">;</span>
	<span class="kt">ptrdiff_t</span>		<span class="n">align_dma_offset</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">align_used_frags</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">alloc_frags</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">unused</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_fifo_txdl_priv</span>	<span class="o">*</span><span class="n">next_txdl_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_fifo_txd</span>		<span class="o">*</span><span class="n">first_txdp</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">memblock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct __vxge_hw_non_offload_db_wrapper - Non-offload Doorbell Wrapper</span>
<span class="cm"> * @control_0: Bits 0 to 7 - Doorbell type.</span>
<span class="cm"> *             Bits 8 to 31 - Reserved.</span>
<span class="cm"> *             Bits 32 to 39 - The highest TxD in this TxDL.</span>
<span class="cm"> *             Bits 40 to 47 - Reserved.</span>
<span class="cm">	*	       Bits 48 to 55 - Reserved.</span>
<span class="cm"> *             Bits 56 to 63 - No snoop flags.</span>
<span class="cm"> * @txdl_ptr:  The starting location of the TxDL in host memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Created by the host and written to the adapter via PIO to a Kernel Doorbell</span>
<span class="cm"> * FIFO. All non-offload doorbell wrapper fields must be written by the host as</span>
<span class="cm"> * part of a doorbell write. Consumed by the adapter but is not written by the</span>
<span class="cm"> * adapter.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__vxge_hw_non_offload_db_wrapper</span> <span class="p">{</span>
	<span class="n">u64</span>		<span class="n">control_0</span><span class="p">;</span>
<span class="cp">#define	VXGE_HW_NODBW_GET_TYPE(ctrl0)			vxge_bVALn(ctrl0, 0, 8)</span>
<span class="cp">#define VXGE_HW_NODBW_TYPE(val) vxge_vBIT(val, 0, 8)</span>
<span class="cp">#define	VXGE_HW_NODBW_TYPE_NODBW				0</span>

<span class="cp">#define	VXGE_HW_NODBW_GET_LAST_TXD_NUMBER(ctrl0)	vxge_bVALn(ctrl0, 32, 8)</span>
<span class="cp">#define VXGE_HW_NODBW_LAST_TXD_NUMBER(val) vxge_vBIT(val, 32, 8)</span>

<span class="cp">#define	VXGE_HW_NODBW_GET_NO_SNOOP(ctrl0)		vxge_bVALn(ctrl0, 56, 8)</span>
<span class="cp">#define VXGE_HW_NODBW_LIST_NO_SNOOP(val) vxge_vBIT(val, 56, 8)</span>
<span class="cp">#define	VXGE_HW_NODBW_LIST_NO_SNOOP_TXD_READ_TXD0_WRITE		0x2</span>
<span class="cp">#define	VXGE_HW_NODBW_LIST_NO_SNOOP_TX_FRAME_DATA_READ		0x1</span>

	<span class="n">u64</span>		<span class="n">txdl_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * TX Descriptor</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_fifo_txd - Transmit Descriptor</span>
<span class="cm"> * @control_0: Bits 0 to 6 - Reserved.</span>
<span class="cm"> *             Bit 7 - List Ownership. This field should be initialized</span>
<span class="cm"> *             to &#39;1&#39; by the driver before the transmit list pointer is</span>
<span class="cm"> *             written to the adapter. This field will be set to &#39;0&#39; by the</span>
<span class="cm"> *             adapter once it has completed transmitting the frame or frames in</span>
<span class="cm"> *             the list. Note - This field is only valid in TxD0. Additionally,</span>
<span class="cm"> *             for multi-list sequences, the driver should not release any</span>
<span class="cm"> *             buffers until the ownership of the last list in the multi-list</span>
<span class="cm"> *             sequence has been returned to the host.</span>
<span class="cm"> *             Bits 8 to 11 - Reserved</span>
<span class="cm"> *             Bits 12 to 15 - Transfer_Code. This field is only valid in</span>
<span class="cm"> *             TxD0. It is used to describe the status of the transmit data</span>
<span class="cm"> *             buffer transfer. This field is always overwritten by the</span>
<span class="cm"> *             adapter, so this field may be initialized to any value.</span>
<span class="cm"> *             Bits 16 to 17 - Host steering. This field allows the host to</span>
<span class="cm"> *             override the selection of the physical transmit port.</span>
<span class="cm"> *             Attention:</span>
<span class="cm"> *             Normal sounds as if learned from the switch rather than from</span>
<span class="cm"> *             the aggregation algorythms.</span>
<span class="cm"> *             00: Normal. Use Destination/MAC Address</span>
<span class="cm"> *             lookup to determine the transmit port.</span>
<span class="cm"> *             01: Send on physical Port1.</span>
<span class="cm"> *             10: Send on physical Port0.</span>
<span class="cm"> *	       11: Send on both ports.</span>
<span class="cm"> *             Bits 18 to 21 - Reserved</span>
<span class="cm"> *             Bits 22 to 23 - Gather_Code. This field is set by the host and</span>
<span class="cm"> *             is used to describe how individual buffers comprise a frame.</span>
<span class="cm"> *             10: First descriptor of a frame.</span>
<span class="cm"> *             00: Middle of a multi-descriptor frame.</span>
<span class="cm"> *             01: Last descriptor of a frame.</span>
<span class="cm"> *             11: First and last descriptor of a frame (the entire frame</span>
<span class="cm"> *             resides in a single buffer).</span>
<span class="cm"> *             For multi-descriptor frames, the only valid gather code sequence</span>
<span class="cm"> *             is {10, [00], 01}. In other words, the descriptors must be placed</span>
<span class="cm"> *             in the list in the correct order.</span>
<span class="cm"> *             Bits 24 to 27 - Reserved</span>
<span class="cm"> *             Bits 28 to 29 - LSO_Frm_Encap. LSO Frame Encapsulation</span>
<span class="cm"> *             definition. Only valid in TxD0. This field allows the host to</span>
<span class="cm"> *             indicate the Ethernet encapsulation of an outbound LSO packet.</span>
<span class="cm"> *             00 - classic mode (best guess)</span>
<span class="cm"> *             01 - LLC</span>
<span class="cm"> *             10 - SNAP</span>
<span class="cm"> *             11 - DIX</span>
<span class="cm"> *             If &quot;classic mode&quot; is selected, the adapter will attempt to</span>
<span class="cm"> *             decode the frame&#39;s Ethernet encapsulation by examining the L/T</span>
<span class="cm"> *             field as follows:</span>
<span class="cm"> *             &lt;= 0x05DC LLC/SNAP encoding; must examine DSAP/SSAP to determine</span>
<span class="cm"> *             if packet is IPv4 or IPv6.</span>
<span class="cm"> *             0x8870 Jumbo-SNAP encoding.</span>
<span class="cm"> *             0x0800 IPv4 DIX encoding</span>
<span class="cm"> *             0x86DD IPv6 DIX encoding</span>
<span class="cm"> *             others illegal encapsulation</span>
<span class="cm"> *             Bits 30 - LSO_ Flag. Large Send Offload (LSO) flag.</span>
<span class="cm"> *             Set to 1 to perform segmentation offload for TCP/UDP.</span>
<span class="cm"> *             This field is valid only in TxD0.</span>
<span class="cm"> *             Bits 31 to 33 - Reserved.</span>
<span class="cm"> *             Bits 34 to 47 - LSO_MSS. TCP/UDP LSO Maximum Segment Size</span>
<span class="cm"> *             This field is meaningful only when LSO_Control is non-zero.</span>
<span class="cm"> *             When LSO_Control is set to TCP_LSO, the single (possibly large)</span>
<span class="cm"> *             TCP segment described by this TxDL will be sent as a series of</span>
<span class="cm"> *             TCP segments each of which contains no more than LSO_MSS</span>
<span class="cm"> *             payload bytes.</span>
<span class="cm"> *             When LSO_Control is set to UDP_LSO, the single (possibly large)</span>
<span class="cm"> *             UDP datagram described by this TxDL will be sent as a series of</span>
<span class="cm"> *             UDP datagrams each of which contains no more than LSO_MSS</span>
<span class="cm"> *             payload bytes.</span>
<span class="cm"> *             All outgoing frames from this TxDL will have LSO_MSS bytes of UDP</span>
<span class="cm"> *             or TCP payload, with the exception of the last, which will have</span>
<span class="cm"> *             &lt;= LSO_MSS bytes of payload.</span>
<span class="cm"> *             Bits 48 to 63 - Buffer_Size. Number of valid bytes in the</span>
<span class="cm"> *             buffer to be read by the adapter. This field is written by the</span>
<span class="cm"> *             host. A value of 0 is illegal.</span>
<span class="cm"> *	       Bits 32 to 63 - This value is written by the adapter upon</span>
<span class="cm"> *	       completion of a UDP or TCP LSO operation and indicates the number</span>
<span class="cm"> *             of UDP or TCP payload bytes that were transmitted. 0x0000 will be</span>
<span class="cm"> *             returned for any non-LSO operation.</span>
<span class="cm"> * @control_1: Bits 0 to 4 - Reserved.</span>
<span class="cm"> *             Bit 5 - Tx_CKO_IPv4 Set to a &#39;1&#39; to enable IPv4 header checksum</span>
<span class="cm"> *             offload. This field is only valid in the first TxD of a frame.</span>
<span class="cm"> *             Bit 6 - Tx_CKO_TCP Set to a &#39;1&#39; to enable TCP checksum offload.</span>
<span class="cm"> *             This field is only valid in the first TxD of a frame (the TxD&#39;s</span>
<span class="cm"> *             gather code must be 10 or 11). The driver should only set this</span>
<span class="cm"> *             bit if it can guarantee that TCP is present.</span>
<span class="cm"> *             Bit 7 - Tx_CKO_UDP Set to a &#39;1&#39; to enable UDP checksum offload.</span>
<span class="cm"> *             This field is only valid in the first TxD of a frame (the TxD&#39;s</span>
<span class="cm"> *             gather code must be 10 or 11). The driver should only set this</span>
<span class="cm"> *             bit if it can guarantee that UDP is present.</span>
<span class="cm"> *             Bits 8 to 14 - Reserved.</span>
<span class="cm"> *             Bit 15 - Tx_VLAN_Enable VLAN tag insertion flag. Set to a &#39;1&#39; to</span>
<span class="cm"> *             instruct the adapter to insert the VLAN tag specified by the</span>
<span class="cm"> *             Tx_VLAN_Tag field. This field is only valid in the first TxD of</span>
<span class="cm"> *             a frame.</span>
<span class="cm"> *             Bits 16 to 31 - Tx_VLAN_Tag. Variable portion of the VLAN tag</span>
<span class="cm"> *             to be inserted into the frame by the adapter (the first two bytes</span>
<span class="cm"> *             of a VLAN tag are always 0x8100). This field is only valid if the</span>
<span class="cm"> *             Tx_VLAN_Enable field is set to &#39;1&#39;.</span>
<span class="cm"> *             Bits 32 to 33 - Reserved.</span>
<span class="cm"> *             Bits 34 to 39 - Tx_Int_Number. Indicates which Tx interrupt</span>
<span class="cm"> *             number the frame associated with. This field is written by the</span>
<span class="cm"> *             host. It is only valid in the first TxD of a frame.</span>
<span class="cm"> *             Bits 40 to 42 - Reserved.</span>
<span class="cm"> *             Bit 43 - Set to 1 to exclude the frame from bandwidth metering</span>
<span class="cm"> *             functions. This field is valid only in the first TxD</span>
<span class="cm"> *             of a frame.</span>
<span class="cm"> *             Bits 44 to 45 - Reserved.</span>
<span class="cm"> *             Bit 46 - Tx_Int_Per_List Set to a &#39;1&#39; to instruct the adapter to</span>
<span class="cm"> *             generate an interrupt as soon as all of the frames in the list</span>
<span class="cm"> *             have been transmitted. In order to have per-frame interrupts,</span>
<span class="cm"> *             the driver should place a maximum of one frame per list. This</span>
<span class="cm"> *             field is only valid in the first TxD of a frame.</span>
<span class="cm"> *             Bit 47 - Tx_Int_Utilization Set to a &#39;1&#39; to instruct the adapter</span>
<span class="cm"> *             to count the frame toward the utilization interrupt specified in</span>
<span class="cm"> *             the Tx_Int_Number field. This field is only valid in the first</span>
<span class="cm"> *             TxD of a frame.</span>
<span class="cm"> *             Bits 48 to 63 - Reserved.</span>
<span class="cm"> * @buffer_pointer: Buffer start address.</span>
<span class="cm"> * @host_control: Host_Control.Opaque 64bit data stored by driver inside the</span>
<span class="cm"> *            Titan descriptor prior to posting the latter on the fifo</span>
<span class="cm"> *            via vxge_hw_fifo_txdl_post().The %host_control is returned as is</span>
<span class="cm"> *            to the driver with each completed descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * Transmit descriptor (TxD).Fifo descriptor contains configured number</span>
<span class="cm"> * (list) of TxDs. * For more details please refer to Titan User Guide,</span>
<span class="cm"> * Section 5.4.2 &quot;Transmit Descriptor (TxD) Format&quot;.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_fifo_txd</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">control_0</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_FIFO_TXD_LIST_OWN_ADAPTER		vxge_mBIT(7)</span>

<span class="cp">#define VXGE_HW_FIFO_TXD_T_CODE_GET(ctrl0)		vxge_bVALn(ctrl0, 12, 4)</span>
<span class="cp">#define VXGE_HW_FIFO_TXD_T_CODE(val) 			vxge_vBIT(val, 12, 4)</span>
<span class="cp">#define VXGE_HW_FIFO_TXD_T_CODE_UNUSED		VXGE_HW_FIFO_T_CODE_UNUSED</span>


<span class="cp">#define VXGE_HW_FIFO_TXD_GATHER_CODE(val) 		vxge_vBIT(val, 22, 2)</span>
<span class="cp">#define VXGE_HW_FIFO_TXD_GATHER_CODE_FIRST	VXGE_HW_FIFO_GATHER_CODE_FIRST</span>
<span class="cp">#define VXGE_HW_FIFO_TXD_GATHER_CODE_LAST	VXGE_HW_FIFO_GATHER_CODE_LAST</span>


<span class="cp">#define VXGE_HW_FIFO_TXD_LSO_EN				vxge_mBIT(30)</span>

<span class="cp">#define VXGE_HW_FIFO_TXD_LSO_MSS(val) 			vxge_vBIT(val, 34, 14)</span>

<span class="cp">#define VXGE_HW_FIFO_TXD_BUFFER_SIZE(val) 		vxge_vBIT(val, 48, 16)</span>

	<span class="n">u64</span> <span class="n">control_1</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_FIFO_TXD_TX_CKO_IPV4_EN			vxge_mBIT(5)</span>
<span class="cp">#define VXGE_HW_FIFO_TXD_TX_CKO_TCP_EN			vxge_mBIT(6)</span>
<span class="cp">#define VXGE_HW_FIFO_TXD_TX_CKO_UDP_EN			vxge_mBIT(7)</span>
<span class="cp">#define VXGE_HW_FIFO_TXD_VLAN_ENABLE			vxge_mBIT(15)</span>

<span class="cp">#define VXGE_HW_FIFO_TXD_VLAN_TAG(val) 			vxge_vBIT(val, 16, 16)</span>

<span class="cp">#define VXGE_HW_FIFO_TXD_INT_NUMBER(val) 		vxge_vBIT(val, 34, 6)</span>

<span class="cp">#define VXGE_HW_FIFO_TXD_INT_TYPE_PER_LIST		vxge_mBIT(46)</span>
<span class="cp">#define VXGE_HW_FIFO_TXD_INT_TYPE_UTILZ			vxge_mBIT(47)</span>

	<span class="n">u64</span> <span class="n">buffer_pointer</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">host_control</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_ring_rxd_1 - One buffer mode RxD for ring</span>
<span class="cm"> * @host_control: This field is exclusively for host use and is &quot;readonly&quot;</span>
<span class="cm"> *             from the adapter&#39;s perspective.</span>
<span class="cm"> * @control_0:Bits 0 to 6 - RTH_Bucket get</span>
<span class="cm"> *	      Bit 7 - Own Descriptor ownership bit. This bit is set to 1</span>
<span class="cm"> *            by the host, and is set to 0 by the adapter.</span>
<span class="cm"> *	      0 - Host owns RxD and buffer.</span>
<span class="cm"> *	      1 - The adapter owns RxD and buffer.</span>
<span class="cm"> *	      Bit 8 - Fast_Path_Eligible When set, indicates that the</span>
<span class="cm"> *            received frame meets all of the criteria for fast path processing.</span>
<span class="cm"> *            The required criteria are as follows:</span>
<span class="cm"> *            !SYN &amp;</span>
<span class="cm"> *            (Transfer_Code == &quot;Transfer OK&quot;) &amp;</span>
<span class="cm"> *            (!Is_IP_Fragment) &amp;</span>
<span class="cm"> *            ((Is_IPv4 &amp; computed_L3_checksum == 0xFFFF) |</span>
<span class="cm"> *            (Is_IPv6)) &amp;</span>
<span class="cm"> *            ((Is_TCP &amp; computed_L4_checksum == 0xFFFF) |</span>
<span class="cm"> *            (Is_UDP &amp; (computed_L4_checksum == 0xFFFF |</span>
<span class="cm"> *            computed _L4_checksum == 0x0000)))</span>
<span class="cm"> *            (same meaning for all RxD buffer modes)</span>
<span class="cm"> *	      Bit 9 - L3 Checksum Correct</span>
<span class="cm"> *	      Bit 10 - L4 Checksum Correct</span>
<span class="cm"> *	      Bit 11 - Reserved</span>
<span class="cm"> *	      Bit 12 to 15 - This field is written by the adapter. It is</span>
<span class="cm"> *            used to report the status of the frame transfer to the host.</span>
<span class="cm"> *	      0x0 - Transfer OK</span>
<span class="cm"> *	      0x4 - RDA Failure During Transfer</span>
<span class="cm"> *	      0x5 - Unparseable Packet, such as unknown IPv6 header.</span>
<span class="cm"> *	      0x6 - Frame integrity error (FCS or ECC).</span>
<span class="cm"> *	      0x7 - Buffer Size Error. The provided buffer(s) were not</span>
<span class="cm"> *                  appropriately sized and data loss occurred.</span>
<span class="cm"> *	      0x8 - Internal ECC Error. RxD corrupted.</span>
<span class="cm"> *	      0x9 - IPv4 Checksum error</span>
<span class="cm"> *	      0xA - TCP/UDP Checksum error</span>
<span class="cm"> *	      0xF - Unknown Error or Multiple Error. Indicates an</span>
<span class="cm"> *               unknown problem or that more than one of transfer codes is set.</span>
<span class="cm"> *	      Bit 16 - SYN The adapter sets this field to indicate that</span>
<span class="cm"> *                the incoming frame contained a TCP segment with its SYN bit</span>
<span class="cm"> *	          set and its ACK bit NOT set. (same meaning for all RxD buffer</span>
<span class="cm"> *                modes)</span>
<span class="cm"> *	      Bit 17 - Is ICMP</span>
<span class="cm"> *	      Bit 18 - RTH_SPDM_HIT Set to 1 if there was a match in the</span>
<span class="cm"> *                Socket Pair Direct Match Table and the frame was steered based</span>
<span class="cm"> *                on SPDM.</span>
<span class="cm"> *	      Bit 19 - RTH_IT_HIT Set to 1 if there was a match in the</span>
<span class="cm"> *            Indirection Table and the frame was steered based on hash</span>
<span class="cm"> *            indirection.</span>
<span class="cm"> *	      Bit 20 to 23 - RTH_HASH_TYPE Indicates the function (hash</span>
<span class="cm"> *	          type) that was used to calculate the hash.</span>
<span class="cm"> *	      Bit 19 - IS_VLAN Set to &#39;1&#39; if the frame was/is VLAN</span>
<span class="cm"> *	          tagged.</span>
<span class="cm"> *	      Bit 25 to 26 - ETHER_ENCAP Reflects the Ethernet encapsulation</span>
<span class="cm"> *                of the received frame.</span>
<span class="cm"> *	      0x0 - Ethernet DIX</span>
<span class="cm"> *	      0x1 - LLC</span>
<span class="cm"> *	      0x2 - SNAP (includes Jumbo-SNAP)</span>
<span class="cm"> *	      0x3 - IPX</span>
<span class="cm"> *	      Bit 27 - IS_IPV4 Set to &#39;1&#39; if the frame contains an IPv4	packet.</span>
<span class="cm"> *	      Bit 28 - IS_IPV6 Set to &#39;1&#39; if the frame contains an IPv6 packet.</span>
<span class="cm"> *	      Bit 29 - IS_IP_FRAG Set to &#39;1&#39; if the frame contains a fragmented</span>
<span class="cm"> *            IP packet.</span>
<span class="cm"> *	      Bit 30 - IS_TCP Set to &#39;1&#39; if the frame contains a TCP segment.</span>
<span class="cm"> *	      Bit 31 - IS_UDP Set to &#39;1&#39; if the frame contains a UDP message.</span>
<span class="cm"> *	      Bit 32 to 47 - L3_Checksum[0:15] The IPv4 checksum value 	that</span>
<span class="cm"> *            arrived with the frame. If the resulting computed IPv4 header</span>
<span class="cm"> *            checksum for the frame did not produce the expected 0xFFFF value,</span>
<span class="cm"> *            then the transfer code would be set to 0x9.</span>
<span class="cm"> *	      Bit 48 to 63 - L4_Checksum[0:15] The TCP/UDP checksum value that</span>
<span class="cm"> *            arrived with the frame. If the resulting computed TCP/UDP checksum</span>
<span class="cm"> *            for the frame did not produce the expected 0xFFFF value, then the</span>
<span class="cm"> *            transfer code would be set to 0xA.</span>
<span class="cm"> * @control_1:Bits 0 to 1 - Reserved</span>
<span class="cm"> *            Bits 2 to 15 - Buffer0_Size.This field is set by the host and</span>
<span class="cm"> *            eventually overwritten by the adapter. The host writes the</span>
<span class="cm"> *            available buffer size in bytes when it passes the descriptor to</span>
<span class="cm"> *            the adapter. When a frame is delivered the host, the adapter</span>
<span class="cm"> *            populates this field with the number of bytes written into the</span>
<span class="cm"> *            buffer. The largest supported buffer is 16, 383 bytes.</span>
<span class="cm"> *	      Bit 16 to 47 - RTH Hash Value 32-bit RTH hash value. Only valid if</span>
<span class="cm"> *	      RTH_HASH_TYPE (Control_0, bits 20:23) is nonzero.</span>
<span class="cm"> *	      Bit 48 to 63 - VLAN_Tag[0:15] The contents of the variable portion</span>
<span class="cm"> *            of the VLAN tag, if one was detected by the adapter. This field is</span>
<span class="cm"> *            populated even if VLAN-tag stripping is enabled.</span>
<span class="cm"> * @buffer0_ptr: Pointer to buffer. This field is populated by the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * One buffer mode RxD for ring structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_1</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">host_control</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">control_0</span><span class="p">;</span>
<span class="cp">#define VXGE_HW_RING_RXD_RTH_BUCKET_GET(ctrl0)		vxge_bVALn(ctrl0, 0, 7)</span>

<span class="cp">#define VXGE_HW_RING_RXD_LIST_OWN_ADAPTER		vxge_mBIT(7)</span>

<span class="cp">#define VXGE_HW_RING_RXD_FAST_PATH_ELIGIBLE_GET(ctrl0)	vxge_bVALn(ctrl0, 8, 1)</span>

<span class="cp">#define VXGE_HW_RING_RXD_L3_CKSUM_CORRECT_GET(ctrl0)	vxge_bVALn(ctrl0, 9, 1)</span>

<span class="cp">#define VXGE_HW_RING_RXD_L4_CKSUM_CORRECT_GET(ctrl0)	vxge_bVALn(ctrl0, 10, 1)</span>

<span class="cp">#define VXGE_HW_RING_RXD_T_CODE_GET(ctrl0)		vxge_bVALn(ctrl0, 12, 4)</span>
<span class="cp">#define VXGE_HW_RING_RXD_T_CODE(val) 			vxge_vBIT(val, 12, 4)</span>

<span class="cp">#define VXGE_HW_RING_RXD_T_CODE_UNUSED		VXGE_HW_RING_T_CODE_UNUSED</span>

<span class="cp">#define VXGE_HW_RING_RXD_SYN_GET(ctrl0)		vxge_bVALn(ctrl0, 16, 1)</span>

<span class="cp">#define VXGE_HW_RING_RXD_IS_ICMP_GET(ctrl0)		vxge_bVALn(ctrl0, 17, 1)</span>

<span class="cp">#define VXGE_HW_RING_RXD_RTH_SPDM_HIT_GET(ctrl0)	vxge_bVALn(ctrl0, 18, 1)</span>

<span class="cp">#define VXGE_HW_RING_RXD_RTH_IT_HIT_GET(ctrl0)		vxge_bVALn(ctrl0, 19, 1)</span>

<span class="cp">#define VXGE_HW_RING_RXD_RTH_HASH_TYPE_GET(ctrl0)	vxge_bVALn(ctrl0, 20, 4)</span>

<span class="cp">#define VXGE_HW_RING_RXD_IS_VLAN_GET(ctrl0)		vxge_bVALn(ctrl0, 24, 1)</span>

<span class="cp">#define VXGE_HW_RING_RXD_ETHER_ENCAP_GET(ctrl0)		vxge_bVALn(ctrl0, 25, 2)</span>

<span class="cp">#define VXGE_HW_RING_RXD_FRAME_PROTO_GET(ctrl0)		vxge_bVALn(ctrl0, 27, 5)</span>

<span class="cp">#define VXGE_HW_RING_RXD_L3_CKSUM_GET(ctrl0)	vxge_bVALn(ctrl0, 32, 16)</span>

<span class="cp">#define VXGE_HW_RING_RXD_L4_CKSUM_GET(ctrl0)	vxge_bVALn(ctrl0, 48, 16)</span>

	<span class="n">u64</span> <span class="n">control_1</span><span class="p">;</span>

<span class="cp">#define VXGE_HW_RING_RXD_1_BUFFER0_SIZE_GET(ctrl1)	vxge_bVALn(ctrl1, 2, 14)</span>
<span class="cp">#define VXGE_HW_RING_RXD_1_BUFFER0_SIZE(val) vxge_vBIT(val, 2, 14)</span>
<span class="cp">#define VXGE_HW_RING_RXD_1_BUFFER0_SIZE_MASK		vxge_vBIT(0x3FFF, 2, 14)</span>

<span class="cp">#define VXGE_HW_RING_RXD_1_RTH_HASH_VAL_GET(ctrl1)    vxge_bVALn(ctrl1, 16, 32)</span>

<span class="cp">#define VXGE_HW_RING_RXD_VLAN_TAG_GET(ctrl1)	vxge_bVALn(ctrl1, 48, 16)</span>

	<span class="n">u64</span> <span class="n">buffer0_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">vxge_hw_rth_algoritms</span> <span class="p">{</span>
	<span class="n">RTH_ALG_JENKINS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RTH_ALG_MS_RSS</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RTH_ALG_CRC32C</span>	<span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_rth_hash_types - RTH hash types.</span>
<span class="cm"> * @hash_type_tcpipv4_en: Enables RTH field type HashTypeTcpIPv4</span>
<span class="cm"> * @hash_type_ipv4_en: Enables RTH field type HashTypeIPv4</span>
<span class="cm"> * @hash_type_tcpipv6_en: Enables RTH field type HashTypeTcpIPv6</span>
<span class="cm"> * @hash_type_ipv6_en: Enables RTH field type HashTypeIPv6</span>
<span class="cm"> * @hash_type_tcpipv6ex_en: Enables RTH field type HashTypeTcpIPv6Ex</span>
<span class="cm"> * @hash_type_ipv6ex_en: Enables RTH field type HashTypeIPv6Ex</span>
<span class="cm"> *</span>
<span class="cm"> * Used to pass RTH hash types to rts_rts_set.</span>
<span class="cm"> *</span>
<span class="cm"> * See also: vxge_hw_vpath_rts_rth_set(), vxge_hw_vpath_rts_rth_get().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_rth_hash_types</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">hash_type_tcpipv4_en</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
	   <span class="nl">hash_type_ipv4_en:</span><span class="mi">1</span><span class="p">,</span>
	   <span class="nl">hash_type_tcpipv6_en:</span><span class="mi">1</span><span class="p">,</span>
	   <span class="nl">hash_type_ipv6_en:</span><span class="mi">1</span><span class="p">,</span>
	   <span class="nl">hash_type_tcpipv6ex_en:</span><span class="mi">1</span><span class="p">,</span>
	   <span class="nl">hash_type_ipv6ex_en:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">vxge_hw_device_debug_set</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">vxge_debug_level</span> <span class="n">level</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>

<span class="n">u32</span>
<span class="n">vxge_hw_device_error_level_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="n">u32</span>
<span class="n">vxge_hw_device_trace_level_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_hw_ring_rxd_size_get	- Get the size of ring descriptor.</span>
<span class="cm"> * @buf_mode: Buffer mode (1, 3 or 5)</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the size of RxD for given buffer mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">vxge_hw_ring_rxd_size_get</span><span class="p">(</span><span class="n">u32</span> <span class="n">buf_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_hw_ring_rxds_per_block_get - Get the number of rxds per block.</span>
<span class="cm"> * @buf_mode: Buffer mode (1 buffer mode only)</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of RxD for RxD block for given buffer mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">vxge_hw_ring_rxds_per_block_get</span><span class="p">(</span><span class="n">u32</span> <span class="n">buf_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)((</span><span class="n">VXGE_HW_BLOCK_SIZE</span><span class="o">-</span><span class="mi">16</span><span class="p">)</span> <span class="o">/</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_hw_ring_rxd_1b_set - Prepare 1-buffer-mode descriptor.</span>
<span class="cm"> * @rxdh: Descriptor handle.</span>
<span class="cm"> * @dma_pointer: DMA address of	a single receive buffer	this descriptor</span>
<span class="cm"> * should carry. Note that by the time vxge_hw_ring_rxd_1b_set is called,</span>
<span class="cm"> * the receive buffer should be already mapped to the device</span>
<span class="cm"> * @size: Size of the receive @dma_pointer buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare 1-buffer-mode Rx	descriptor for posting</span>
<span class="cm"> * (via	vxge_hw_ring_rxd_post()).</span>
<span class="cm"> *</span>
<span class="cm"> * This	inline helper-function does not	return any parameters and always</span>
<span class="cm"> * succeeds.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">vxge_hw_ring_rxd_1b_set</span><span class="p">(</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">,</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_pointer</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_1</span> <span class="o">*</span><span class="n">rxdp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_1</span> <span class="o">*</span><span class="p">)</span><span class="n">rxdh</span><span class="p">;</span>
	<span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">buffer0_ptr</span> <span class="o">=</span> <span class="n">dma_pointer</span><span class="p">;</span>
	<span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_1</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="n">VXGE_HW_RING_RXD_1_BUFFER0_SIZE_MASK</span><span class="p">;</span>
	<span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_1</span>	<span class="o">|=</span> <span class="n">VXGE_HW_RING_RXD_1_BUFFER0_SIZE</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_hw_ring_rxd_1b_get - Get data from the completed 1-buf</span>
<span class="cm"> * descriptor.</span>
<span class="cm"> * @vpath_handle: Virtual Path handle.</span>
<span class="cm"> * @rxdh: Descriptor handle.</span>
<span class="cm"> * @dma_pointer: DMA address of	a single receive buffer	this descriptor</span>
<span class="cm"> * carries. Returned by HW.</span>
<span class="cm"> * @pkt_length:	Length (in bytes) of the data in the buffer pointed by</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve protocol data from the completed 1-buffer-mode Rx descriptor.</span>
<span class="cm"> * This	inline helper-function uses completed descriptor to populate receive</span>
<span class="cm"> * buffer pointer and other &quot;out&quot; parameters. The function always succeeds.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">vxge_hw_ring_rxd_1b_get</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring_handle</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pkt_length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_1</span> <span class="o">*</span><span class="n">rxdp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_1</span> <span class="o">*</span><span class="p">)</span><span class="n">rxdh</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pkt_length</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_1_BUFFER0_SIZE_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_hw_ring_rxd_1b_info_get - Get extended information associated with</span>
<span class="cm"> * a completed receive descriptor for 1b mode.</span>
<span class="cm"> * @vpath_handle: Virtual Path handle.</span>
<span class="cm"> * @rxdh: Descriptor handle.</span>
<span class="cm"> * @rxd_info: Descriptor information</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve extended information associated with a completed receive descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">vxge_hw_ring_rxd_1b_info_get</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ring_handle</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_info</span> <span class="o">*</span><span class="n">rxd_info</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_1</span> <span class="o">*</span><span class="n">rxdp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_1</span> <span class="o">*</span><span class="p">)</span><span class="n">rxdh</span><span class="p">;</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">syn_flag</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_SYN_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">is_icmp</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_IS_ICMP_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">fast_path_eligible</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_FAST_PATH_ELIGIBLE_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">l3_cksum_valid</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_L3_CKSUM_CORRECT_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">l3_cksum</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_L3_CKSUM_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">l4_cksum_valid</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_L4_CKSUM_CORRECT_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">l4_cksum</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_L4_CKSUM_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_ETHER_ENCAP_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">proto</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_FRAME_PROTO_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">is_vlan</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_IS_VLAN_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">vlan</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_VLAN_TAG_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_1</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">rth_bucket</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_RTH_BUCKET_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">rth_it_hit</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_RTH_IT_HIT_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">rth_spdm_hit</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_RTH_SPDM_HIT_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">rth_hash_type</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_RTH_HASH_TYPE_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_0</span><span class="p">);</span>
	<span class="n">rxd_info</span><span class="o">-&gt;</span><span class="n">rth_value</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">VXGE_HW_RING_RXD_1_RTH_HASH_VAL_GET</span><span class="p">(</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">control_1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_hw_ring_rxd_private_get - Get driver private per-descriptor data</span>
<span class="cm"> *                      of 1b mode 3b mode ring.</span>
<span class="cm"> * @rxdh: Descriptor handle.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: private driver	info associated	with the descriptor.</span>
<span class="cm"> * driver requests	per-descriptor space via vxge_hw_ring_attr.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">vxge_hw_ring_rxd_private_get</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_1</span> <span class="o">*</span><span class="n">rxdp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vxge_hw_ring_rxd_1</span> <span class="o">*</span><span class="p">)</span><span class="n">rxdh</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">rxdp</span><span class="o">-&gt;</span><span class="n">host_control</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_hw_fifo_txdl_cksum_set_bits - Offload checksum.</span>
<span class="cm"> * @txdlh: Descriptor handle.</span>
<span class="cm"> * @cksum_bits: Specifies which checksums are to be offloaded: IPv4,</span>
<span class="cm"> *              and/or TCP and/or UDP.</span>
<span class="cm"> *</span>
<span class="cm"> * Ask Titan to calculate IPv4 &amp; transport checksums for _this_ transmit</span>
<span class="cm"> * descriptor.</span>
<span class="cm"> * This API is part of the preparation of the transmit descriptor for posting</span>
<span class="cm"> * (via vxge_hw_fifo_txdl_post()). The related &quot;preparation&quot; APIs include</span>
<span class="cm"> * vxge_hw_fifo_txdl_mss_set(), vxge_hw_fifo_txdl_buffer_set_aligned(),</span>
<span class="cm"> * and vxge_hw_fifo_txdl_buffer_set().</span>
<span class="cm"> * All these APIs fill in the fields of the fifo descriptor,</span>
<span class="cm"> * in accordance with the Titan specification.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vxge_hw_fifo_txdl_cksum_set_bits</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cksum_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vxge_hw_fifo_txd</span> <span class="o">*</span><span class="n">txdp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vxge_hw_fifo_txd</span> <span class="o">*</span><span class="p">)</span><span class="n">txdlh</span><span class="p">;</span>
	<span class="n">txdp</span><span class="o">-&gt;</span><span class="n">control_1</span> <span class="o">|=</span> <span class="n">cksum_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_hw_fifo_txdl_mss_set - Set MSS.</span>
<span class="cm"> * @txdlh: Descriptor handle.</span>
<span class="cm"> * @mss: MSS size for _this_ TCP connection. Passed by TCP stack down to the</span>
<span class="cm"> *       driver, which in turn inserts the MSS into the @txdlh.</span>
<span class="cm"> *</span>
<span class="cm"> * This API is part of the preparation of the transmit descriptor for posting</span>
<span class="cm"> * (via vxge_hw_fifo_txdl_post()). The related &quot;preparation&quot; APIs include</span>
<span class="cm"> * vxge_hw_fifo_txdl_buffer_set(), vxge_hw_fifo_txdl_buffer_set_aligned(),</span>
<span class="cm"> * and vxge_hw_fifo_txdl_cksum_set_bits().</span>
<span class="cm"> * All these APIs fill in the fields of the fifo descriptor,</span>
<span class="cm"> * in accordance with the Titan specification.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vxge_hw_fifo_txdl_mss_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vxge_hw_fifo_txd</span> <span class="o">*</span><span class="n">txdp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vxge_hw_fifo_txd</span> <span class="o">*</span><span class="p">)</span><span class="n">txdlh</span><span class="p">;</span>

	<span class="n">txdp</span><span class="o">-&gt;</span><span class="n">control_0</span> <span class="o">|=</span> <span class="n">VXGE_HW_FIFO_TXD_LSO_EN</span><span class="p">;</span>
	<span class="n">txdp</span><span class="o">-&gt;</span><span class="n">control_0</span> <span class="o">|=</span> <span class="n">VXGE_HW_FIFO_TXD_LSO_MSS</span><span class="p">(</span><span class="n">mss</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_hw_fifo_txdl_vlan_set - Set VLAN tag.</span>
<span class="cm"> * @txdlh: Descriptor handle.</span>
<span class="cm"> * @vlan_tag: 16bit VLAN tag.</span>
<span class="cm"> *</span>
<span class="cm"> * Insert VLAN tag into specified transmit descriptor.</span>
<span class="cm"> * The actual insertion of the tag into outgoing frame is done by the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vxge_hw_fifo_txdl_vlan_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vlan_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vxge_hw_fifo_txd</span> <span class="o">*</span><span class="n">txdp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vxge_hw_fifo_txd</span> <span class="o">*</span><span class="p">)</span><span class="n">txdlh</span><span class="p">;</span>

	<span class="n">txdp</span><span class="o">-&gt;</span><span class="n">control_1</span> <span class="o">|=</span> <span class="n">VXGE_HW_FIFO_TXD_VLAN_ENABLE</span><span class="p">;</span>
	<span class="n">txdp</span><span class="o">-&gt;</span><span class="n">control_1</span> <span class="o">|=</span> <span class="n">VXGE_HW_FIFO_TXD_VLAN_TAG</span><span class="p">(</span><span class="n">vlan_tag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_hw_fifo_txdl_private_get - Retrieve per-descriptor private data.</span>
<span class="cm"> * @txdlh: Descriptor handle.</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve per-descriptor private data.</span>
<span class="cm"> * Note that driver requests per-descriptor space via</span>
<span class="cm"> * struct vxge_hw_fifo_attr passed to</span>
<span class="cm"> * vxge_hw_vpath_open().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: private driver data associated with the descriptor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">vxge_hw_fifo_txdl_private_get</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vxge_hw_fifo_txd</span> <span class="o">*</span><span class="n">txdp</span>  <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vxge_hw_fifo_txd</span> <span class="o">*</span><span class="p">)</span><span class="n">txdlh</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">txdp</span><span class="o">-&gt;</span><span class="n">host_control</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_ring_attr - Ring open &quot;template&quot;.</span>
<span class="cm"> * @callback: Ring completion callback. HW invokes the callback when there</span>
<span class="cm"> *            are new completions on that ring. In many implementations</span>
<span class="cm"> *            the @callback executes in the hw interrupt context.</span>
<span class="cm"> * @rxd_init: Ring&#39;s descriptor-initialize callback.</span>
<span class="cm"> *            See vxge_hw_ring_rxd_init_f{}.</span>
<span class="cm"> *            If not NULL, HW invokes the callback when opening</span>
<span class="cm"> *            the ring.</span>
<span class="cm"> * @rxd_term: Ring&#39;s descriptor-terminate callback. If not NULL,</span>
<span class="cm"> *          HW invokes the callback when closing the corresponding ring.</span>
<span class="cm"> *          See also vxge_hw_ring_rxd_term_f{}.</span>
<span class="cm"> * @userdata: User-defined &quot;context&quot; of _that_ ring. Passed back to the</span>
<span class="cm"> *            user as one of the @callback, @rxd_init, and @rxd_term arguments.</span>
<span class="cm"> * @per_rxd_space: If specified (i.e., greater than zero): extra space</span>
<span class="cm"> *              reserved by HW per each receive descriptor.</span>
<span class="cm"> *              Can be used to store</span>
<span class="cm"> *              and retrieve on completion, information specific</span>
<span class="cm"> *              to the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Ring open &quot;template&quot;. User fills the structure with ring</span>
<span class="cm"> * attributes and passes it to vxge_hw_vpath_open().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_ring_attr</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span>
			<span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ringh</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">t_code</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">);</span>

	<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="p">(</span><span class="o">*</span><span class="n">rxd_init</span><span class="p">)(</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rxd_term</span><span class="p">)(</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">rxdh</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">vxge_hw_rxd_state</span> <span class="n">state</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="o">*</span><span class="n">userdata</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">per_rxd_space</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * function vxge_hw_fifo_callback_f - FIFO callback.</span>
<span class="cm"> * @vpath_handle: Virtual path whose Fifo &quot;containing&quot; 1 or more completed</span>
<span class="cm"> *             descriptors.</span>
<span class="cm"> * @txdlh: First completed descriptor.</span>
<span class="cm"> * @txdl_priv: Pointer to per txdl space allocated</span>
<span class="cm"> * @t_code: Transfer code, as per Titan User Guide.</span>
<span class="cm"> *          Returned by HW.</span>
<span class="cm"> * @host_control: Opaque 64bit data stored by driver inside the Titan</span>
<span class="cm"> *            descriptor prior to posting the latter on the fifo</span>
<span class="cm"> *            via vxge_hw_fifo_txdl_post(). The @host_control is returned</span>
<span class="cm"> *            as is to the driver with each completed descriptor.</span>
<span class="cm"> * @userdata: Opaque per-fifo data specified at fifo open</span>
<span class="cm"> *            time, via vxge_hw_vpath_open().</span>
<span class="cm"> *</span>
<span class="cm"> * Fifo completion callback (type declaration). A single per-fifo</span>
<span class="cm"> * callback is specified at fifo open time, via</span>
<span class="cm"> * vxge_hw_vpath_open(). Typically gets called as part of the processing</span>
<span class="cm"> * of the Interrupt Service Routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Fifo callback gets called by HW if, and only if, there is at least</span>
<span class="cm"> * one new completion on a given fifo. Upon processing the first @txdlh driver</span>
<span class="cm"> * is _supposed_ to continue consuming completions using:</span>
<span class="cm"> *    - vxge_hw_fifo_txdl_next_completed()</span>
<span class="cm"> *</span>
<span class="cm"> * Note that failure to process new completions in a timely fashion</span>
<span class="cm"> * leads to VXGE_HW_INF_OUT_OF_DESCRIPTORS condition.</span>
<span class="cm"> *</span>
<span class="cm"> * Non-zero @t_code means failure to process transmit descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * In the &quot;transmit&quot; case the failure could happen, for instance, when the</span>
<span class="cm"> * link is down, in which case Titan completes the descriptor because it</span>
<span class="cm"> * is not able to send the data out.</span>
<span class="cm"> *</span>
<span class="cm"> * For details please refer to Titan User Guide.</span>
<span class="cm"> *</span>
<span class="cm"> * See also: vxge_hw_fifo_txdl_next_completed(), vxge_hw_fifo_txdl_term_f{}.</span>
<span class="cm"> */</span>
<span class="cm">/**</span>
<span class="cm"> * function vxge_hw_fifo_txdl_term_f - Terminate descriptor callback.</span>
<span class="cm"> * @txdlh: First completed descriptor.</span>
<span class="cm"> * @txdl_priv: Pointer to per txdl space allocated</span>
<span class="cm"> * @state: One of the enum vxge_hw_txdl_state{} enumerated states.</span>
<span class="cm"> * @userdata: Per-fifo user data (a.k.a. context) specified at</span>
<span class="cm"> * fifo open time, via vxge_hw_vpath_open().</span>
<span class="cm"> *</span>
<span class="cm"> * Terminate descriptor callback. Unless NULL is specified in the</span>
<span class="cm"> * struct vxge_hw_fifo_attr{} structure passed to vxge_hw_vpath_open()),</span>
<span class="cm"> * HW invokes the callback as part of closing fifo, prior to</span>
<span class="cm"> * de-allocating the ring and associated data structures</span>
<span class="cm"> * (including descriptors).</span>
<span class="cm"> * driver should utilize the callback to (for instance) unmap</span>
<span class="cm"> * and free DMA data buffers associated with the posted (state =</span>
<span class="cm"> * VXGE_HW_TXDL_STATE_POSTED) descriptors,</span>
<span class="cm"> * as well as other relevant cleanup functions.</span>
<span class="cm"> *</span>
<span class="cm"> * See also: struct vxge_hw_fifo_attr{}</span>
<span class="cm"> */</span>
<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_fifo_attr - Fifo open &quot;template&quot;.</span>
<span class="cm"> * @callback: Fifo completion callback. HW invokes the callback when there</span>
<span class="cm"> *            are new completions on that fifo. In many implementations</span>
<span class="cm"> *            the @callback executes in the hw interrupt context.</span>
<span class="cm"> * @txdl_term: Fifo&#39;s descriptor-terminate callback. If not NULL,</span>
<span class="cm"> *          HW invokes the callback when closing the corresponding fifo.</span>
<span class="cm"> *          See also vxge_hw_fifo_txdl_term_f{}.</span>
<span class="cm"> * @userdata: User-defined &quot;context&quot; of _that_ fifo. Passed back to the</span>
<span class="cm"> *            user as one of the @callback, and @txdl_term arguments.</span>
<span class="cm"> * @per_txdl_space: If specified (i.e., greater than zero): extra space</span>
<span class="cm"> *              reserved by HW per each transmit descriptor. Can be used to</span>
<span class="cm"> *              store, and retrieve on completion, information specific</span>
<span class="cm"> *              to the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Fifo open &quot;template&quot;. User fills the structure with fifo</span>
<span class="cm"> * attributes and passes it to vxge_hw_vpath_open().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_fifo_attr</span> <span class="p">{</span>

	<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span>
			<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifo_handle</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">vxge_hw_fifo_tcode</span> <span class="n">t_code</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">***</span><span class="n">skb_ptr</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nr_skb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">more</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">txdl_term</span><span class="p">)(</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">txdlh</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">vxge_hw_txdl_state</span> <span class="n">state</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="o">*</span><span class="n">userdata</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">per_txdl_space</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vxge_hw_vpath_attr - Attributes of virtual path</span>
<span class="cm"> * @vp_id: Identifier of Virtual Path</span>
<span class="cm"> * @ring_attr: Attributes of ring for non-offload receive</span>
<span class="cm"> * @fifo_attr: Attributes of fifo for non-offload transmit</span>
<span class="cm"> *</span>
<span class="cm"> * Attributes of virtual path.  This structure is passed as parameter</span>
<span class="cm"> * to the vxge_hw_vpath_open() routine to set the attributes of ring and fifo.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vxge_hw_vpath_attr</span> <span class="p">{</span>
	<span class="n">u32</span>				<span class="n">vp_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_ring_attr</span>	<span class="n">ring_attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vxge_hw_fifo_attr</span>	<span class="n">fifo_attr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">__devinit</span> <span class="n">vxge_hw_device_hw_info_get</span><span class="p">(</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">bar0</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_hw_info</span> <span class="o">*</span><span class="n">hw_info</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">__devinit</span> <span class="n">vxge_hw_device_config_default_get</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_config</span> <span class="o">*</span><span class="n">device_config</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_hw_device_link_state_get - Get link state.</span>
<span class="cm"> * @devh: HW device handle.</span>
<span class="cm"> *</span>
<span class="cm"> * Get link state.</span>
<span class="cm"> * Returns: link state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="k">enum</span> <span class="n">vxge_hw_device_link_state</span> <span class="nf">vxge_hw_device_link_state_get</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">devh</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">vxge_hw_device_terminate</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span>
<span class="n">vxge_hw_device_serial_number_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">vxge_hw_device_link_width_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span>
<span class="n">vxge_hw_device_product_name_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">__devinit</span> <span class="n">vxge_hw_device_initialize</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">**</span><span class="n">devh</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vxge_hw_device_config</span> <span class="o">*</span><span class="n">device_config</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_device_getpause_data</span><span class="p">(</span>
	 <span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
	 <span class="n">u32</span> <span class="n">port</span><span class="p">,</span>
	 <span class="n">u32</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span>
	 <span class="n">u32</span> <span class="o">*</span><span class="n">rx</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_device_setpause_data</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">port</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">tx</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">rx</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">vxge_os_dma_malloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">**</span><span class="n">p_dmah</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">**</span><span class="n">p_dma_acch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfp_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">misaligned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">realloc_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p_dma_acch</span> <span class="o">=</span> <span class="o">*</span><span class="n">p_dmah</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">())</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">;</span>
<span class="nl">realloc:</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">((</span><span class="n">size</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="n">misaligned</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">VXGE_ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span>
				<span class="n">VXGE_CACHE_LINE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">realloc_flag</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">misaligned</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* misaligned, free current one and try allocating</span>
<span class="cm">		 * size + VXGE_CACHE_LINE_SIZE memory</span>
<span class="cm">		 */</span>
		<span class="n">kfree</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">vaddr</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">VXGE_CACHE_LINE_SIZE</span><span class="p">;</span>
		<span class="n">realloc_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">realloc</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">p_dma_acch</span> <span class="o">=</span> <span class="n">misaligned</span><span class="p">;</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">misaligned</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vxge_os_dma_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">**</span><span class="n">p_dma_acch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">misaligned</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">p_dma_acch</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">-=</span> <span class="n">misaligned</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __vxge_hw_mempool_item_priv - will return pointer on per item private space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span><span class="o">*</span>
<span class="nf">__vxge_hw_mempool_item_priv</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">vxge_hw_mempool</span> <span class="o">*</span><span class="n">mempool</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">memblock_idx</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">memblock_item_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ptrdiff_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">memblock</span> <span class="o">=</span> <span class="n">mempool</span><span class="o">-&gt;</span><span class="n">memblocks_arr</span><span class="p">[</span><span class="n">memblock_idx</span><span class="p">];</span>


	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">item</span> <span class="o">-</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">memblock</span><span class="p">);</span>
	<span class="n">vxge_assert</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">mempool</span><span class="o">-&gt;</span><span class="n">memblock_size</span><span class="p">);</span>

	<span class="p">(</span><span class="o">*</span><span class="n">memblock_item_idx</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">mempool</span><span class="o">-&gt;</span><span class="n">item_size</span><span class="p">;</span>
	<span class="n">vxge_assert</span><span class="p">((</span><span class="o">*</span><span class="n">memblock_item_idx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mempool</span><span class="o">-&gt;</span><span class="n">items_per_memblock</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">mempool</span><span class="o">-&gt;</span><span class="n">memblocks_priv_arr</span><span class="p">[</span><span class="n">memblock_idx</span><span class="p">]</span> <span class="o">+</span>
			    <span class="p">(</span><span class="o">*</span><span class="n">memblock_item_idx</span><span class="p">)</span> <span class="o">*</span> <span class="n">mempool</span><span class="o">-&gt;</span><span class="n">items_priv_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __vxge_hw_fifo_txdl_priv - Return the max fragments allocated</span>
<span class="cm"> * for the fifo.</span>
<span class="cm"> * @fifo: Fifo</span>
<span class="cm"> * @txdp: Poniter to a TxD</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">__vxge_hw_fifo_txdl_priv</span> <span class="o">*</span>
<span class="nf">__vxge_hw_fifo_txdl_priv</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_fifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vxge_hw_fifo_txd</span> <span class="o">*</span><span class="n">txdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_fifo_txdl_priv</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)((</span><span class="n">ulong</span><span class="p">)</span><span class="n">txdp</span><span class="o">-&gt;</span><span class="n">host_control</span><span class="p">))</span> <span class="o">+</span>
				<span class="n">fifo</span><span class="o">-&gt;</span><span class="n">per_txdl_space</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_open</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vxge_hw_vpath_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">**</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_close</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_reset</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_recover_from_reset</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_vpath_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vp</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_check_leak</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_ring</span> <span class="o">*</span><span class="n">ringh</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_mtu_set</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">new_mtu</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">vxge_hw_vpath_rx_doorbell_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vp</span><span class="p">);</span>

<span class="cp">#ifndef readq</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">readq</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">&lt;&lt;=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">readl</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef writeq</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">writeq</span><span class="p">(</span><span class="n">u64</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">),</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__vxge_hw_pio_mem_write32_upper</span><span class="p">(</span><span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__vxge_hw_pio_mem_write32_lower</span><span class="p">(</span><span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_device_flick_link_led</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">devh</span><span class="p">,</span> <span class="n">u64</span> <span class="n">on_off</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_strip_fcs_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">hldev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">vpath_mask</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vxge_debug_ll</span>
<span class="cm"> * @level: level of debug verbosity.</span>
<span class="cm"> * @mask: mask for the debug</span>
<span class="cm"> * @buf: Circular buffer for tracing</span>
<span class="cm"> * @fmt: printf like format string</span>
<span class="cm"> *</span>
<span class="cm"> * Provides logging facilities. Can be customized on per-module</span>
<span class="cm"> * basis or/and with debug levels. Input parameters, except</span>
<span class="cm"> * module and level, are the same as posix printf. This function</span>
<span class="cm"> * may be compiled out if DEBUG macro was never defined.</span>
<span class="cm"> * See also: enum vxge_debug_level{}.</span>
<span class="cm"> */</span>
<span class="cp">#if (VXGE_COMPONENT_LL &amp; VXGE_DEBUG_MODULE_MASK)</span>
<span class="cp">#define vxge_debug_ll(level, mask, fmt, ...) do {			       \</span>
<span class="cp">	if ((level &gt;= VXGE_ERR &amp;&amp; VXGE_COMPONENT_LL &amp; VXGE_DEBUG_ERR_MASK) ||  \</span>
<span class="cp">	    (level &gt;= VXGE_TRACE &amp;&amp; VXGE_COMPONENT_LL &amp; VXGE_DEBUG_TRACE_MASK))\</span>
<span class="cp">		if ((mask &amp; VXGE_DEBUG_MASK) == mask)			       \</span>
<span class="cp">			printk(fmt &quot;\n&quot;, __VA_ARGS__);			       \</span>
<span class="cp">} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define vxge_debug_ll(level, mask, fmt, ...)</span>
<span class="cp">#endif</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_rts_rth_itable_set</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">**</span><span class="n">vpath_handles</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">vpath_count</span><span class="p">,</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">mtable</span><span class="p">,</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">itable</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">itable_size</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_vpath_rts_rth_set</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">__vxge_hw_vpath_handle</span> <span class="o">*</span><span class="n">vpath_handle</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">vxge_hw_rth_algoritms</span> <span class="n">algorithm</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vxge_hw_rth_hash_types</span> <span class="o">*</span><span class="n">hash_type</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">bucket_size</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">__vxge_hw_device_is_privilaged</span><span class="p">(</span><span class="n">u32</span> <span class="n">host_type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">func_id</span><span class="p">);</span>

<span class="cp">#define VXGE_HW_MIN_SUCCESSIVE_IDLE_COUNT 5</span>
<span class="cp">#define VXGE_HW_MAX_POLLING_COUNT 100</span>

<span class="kt">void</span>
<span class="n">vxge_hw_device_wait_receive_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">hldev</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_upgrade_read_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">hldev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">major</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="o">*</span><span class="n">minor</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">build</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span> <span class="n">vxge_hw_flash_fw</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">hldev</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_update_fw_image</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">hldev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">filebuf</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">vxge_hw_status</span>
<span class="n">vxge_hw_vpath_eprom_img_ver_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">hldev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">eprom_image</span> <span class="o">*</span><span class="n">eprom_image_data</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">vxge_hw_vpath_wait_receive_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">__vxge_hw_device</span> <span class="o">*</span><span class="n">hldev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vp_id</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
