<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › xilinx › xilinx_emaclite.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>xilinx_emaclite.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Xilinx EmacLite Linux driver for the Xilinx Ethernet MAC Lite device.</span>
<span class="cm"> *</span>
<span class="cm"> * This is a new flat driver which is based on the original emac_lite</span>
<span class="cm"> * driver from John Williams &lt;john.williams@petalogix.com&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * 2007-2009 (c) Xilinx, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/of_address.h&gt;</span>
<span class="cp">#include &lt;linux/of_device.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>
<span class="cp">#include &lt;linux/of_mdio.h&gt;</span>
<span class="cp">#include &lt;linux/of_net.h&gt;</span>
<span class="cp">#include &lt;linux/phy.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cp">#define DRIVER_NAME &quot;xilinx_emaclite&quot;</span>

<span class="cm">/* Register offsets for the EmacLite Core */</span>
<span class="cp">#define XEL_TXBUFF_OFFSET 	0x0		</span><span class="cm">/* Transmit Buffer */</span><span class="cp"></span>
<span class="cp">#define XEL_MDIOADDR_OFFSET	0x07E4		</span><span class="cm">/* MDIO Address Register */</span><span class="cp"></span>
<span class="cp">#define XEL_MDIOWR_OFFSET	0x07E8		</span><span class="cm">/* MDIO Write Data Register */</span><span class="cp"></span>
<span class="cp">#define XEL_MDIORD_OFFSET	0x07EC		</span><span class="cm">/* MDIO Read Data Register */</span><span class="cp"></span>
<span class="cp">#define XEL_MDIOCTRL_OFFSET	0x07F0		</span><span class="cm">/* MDIO Control Register */</span><span class="cp"></span>
<span class="cp">#define XEL_GIER_OFFSET		0x07F8		</span><span class="cm">/* GIE Register */</span><span class="cp"></span>
<span class="cp">#define XEL_TSR_OFFSET		0x07FC		</span><span class="cm">/* Tx status */</span><span class="cp"></span>
<span class="cp">#define XEL_TPLR_OFFSET		0x07F4		</span><span class="cm">/* Tx packet length */</span><span class="cp"></span>

<span class="cp">#define XEL_RXBUFF_OFFSET	0x1000		</span><span class="cm">/* Receive Buffer */</span><span class="cp"></span>
<span class="cp">#define XEL_RPLR_OFFSET		0x100C		</span><span class="cm">/* Rx packet length */</span><span class="cp"></span>
<span class="cp">#define XEL_RSR_OFFSET		0x17FC		</span><span class="cm">/* Rx status */</span><span class="cp"></span>

<span class="cp">#define XEL_BUFFER_OFFSET	0x0800		</span><span class="cm">/* Next Tx/Rx buffer&#39;s offset */</span><span class="cp"></span>

<span class="cm">/* MDIO Address Register Bit Masks */</span>
<span class="cp">#define XEL_MDIOADDR_REGADR_MASK  0x0000001F	</span><span class="cm">/* Register Address */</span><span class="cp"></span>
<span class="cp">#define XEL_MDIOADDR_PHYADR_MASK  0x000003E0	</span><span class="cm">/* PHY Address */</span><span class="cp"></span>
<span class="cp">#define XEL_MDIOADDR_PHYADR_SHIFT 5</span>
<span class="cp">#define XEL_MDIOADDR_OP_MASK	  0x00000400	</span><span class="cm">/* RD/WR Operation */</span><span class="cp"></span>

<span class="cm">/* MDIO Write Data Register Bit Masks */</span>
<span class="cp">#define XEL_MDIOWR_WRDATA_MASK	  0x0000FFFF	</span><span class="cm">/* Data to be Written */</span><span class="cp"></span>

<span class="cm">/* MDIO Read Data Register Bit Masks */</span>
<span class="cp">#define XEL_MDIORD_RDDATA_MASK	  0x0000FFFF	</span><span class="cm">/* Data to be Read */</span><span class="cp"></span>

<span class="cm">/* MDIO Control Register Bit Masks */</span>
<span class="cp">#define XEL_MDIOCTRL_MDIOSTS_MASK 0x00000001	</span><span class="cm">/* MDIO Status Mask */</span><span class="cp"></span>
<span class="cp">#define XEL_MDIOCTRL_MDIOEN_MASK  0x00000008	</span><span class="cm">/* MDIO Enable */</span><span class="cp"></span>

<span class="cm">/* Global Interrupt Enable Register (GIER) Bit Masks */</span>
<span class="cp">#define XEL_GIER_GIE_MASK	0x80000000 	</span><span class="cm">/* Global Enable */</span><span class="cp"></span>

<span class="cm">/* Transmit Status Register (TSR) Bit Masks */</span>
<span class="cp">#define XEL_TSR_XMIT_BUSY_MASK	 0x00000001 	</span><span class="cm">/* Tx complete */</span><span class="cp"></span>
<span class="cp">#define XEL_TSR_PROGRAM_MASK	 0x00000002 	</span><span class="cm">/* Program the MAC address */</span><span class="cp"></span>
<span class="cp">#define XEL_TSR_XMIT_IE_MASK	 0x00000008 	</span><span class="cm">/* Tx interrupt enable bit */</span><span class="cp"></span>
<span class="cp">#define XEL_TSR_XMIT_ACTIVE_MASK 0x80000000 	</span><span class="cm">/* Buffer is active, SW bit</span>
<span class="cm">						 * only. This is not documented</span>
<span class="cm">						 * in the HW spec */</span><span class="cp"></span>

<span class="cm">/* Define for programming the MAC address into the EmacLite */</span>
<span class="cp">#define XEL_TSR_PROG_MAC_ADDR	(XEL_TSR_XMIT_BUSY_MASK | XEL_TSR_PROGRAM_MASK)</span>

<span class="cm">/* Receive Status Register (RSR) */</span>
<span class="cp">#define XEL_RSR_RECV_DONE_MASK	0x00000001 	</span><span class="cm">/* Rx complete */</span><span class="cp"></span>
<span class="cp">#define XEL_RSR_RECV_IE_MASK	0x00000008 	</span><span class="cm">/* Rx interrupt enable bit */</span><span class="cp"></span>

<span class="cm">/* Transmit Packet Length Register (TPLR) */</span>
<span class="cp">#define XEL_TPLR_LENGTH_MASK	0x0000FFFF 	</span><span class="cm">/* Tx packet length */</span><span class="cp"></span>

<span class="cm">/* Receive Packet Length Register (RPLR) */</span>
<span class="cp">#define XEL_RPLR_LENGTH_MASK	0x0000FFFF 	</span><span class="cm">/* Rx packet length */</span><span class="cp"></span>

<span class="cp">#define XEL_HEADER_OFFSET	12 		</span><span class="cm">/* Offset to length field */</span><span class="cp"></span>
<span class="cp">#define XEL_HEADER_SHIFT	16 		</span><span class="cm">/* Shift value for length */</span><span class="cp"></span>

<span class="cm">/* General Ethernet Definitions */</span>
<span class="cp">#define XEL_ARP_PACKET_SIZE		28 	</span><span class="cm">/* Max ARP packet size */</span><span class="cp"></span>
<span class="cp">#define XEL_HEADER_IP_LENGTH_OFFSET	16 	</span><span class="cm">/* IP Length Offset */</span><span class="cp"></span>



<span class="cp">#define TX_TIMEOUT		(60*HZ)		</span><span class="cm">/* Tx timeout is 60 seconds. */</span><span class="cp"></span>
<span class="cp">#define ALIGNMENT		4</span>

<span class="cm">/* BUFFER_ALIGN(adr) calculates the number of bytes to the next alignment. */</span>
<span class="cp">#define BUFFER_ALIGN(adr) ((ALIGNMENT - ((u32) adr)) % ALIGNMENT)</span>

<span class="cm">/**</span>
<span class="cm"> * struct net_local - Our private per device data</span>
<span class="cm"> * @ndev:		instance of the network device</span>
<span class="cm"> * @tx_ping_pong:	indicates whether Tx Pong buffer is configured in HW</span>
<span class="cm"> * @rx_ping_pong:	indicates whether Rx Pong buffer is configured in HW</span>
<span class="cm"> * @next_tx_buf_to_use:	next Tx buffer to write to</span>
<span class="cm"> * @next_rx_buf_to_use:	next Rx buffer to read from</span>
<span class="cm"> * @base_addr:		base address of the Emaclite device</span>
<span class="cm"> * @reset_lock:		lock used for synchronization</span>
<span class="cm"> * @deferred_skb:	holds an skb (for transmission at a later time) when the</span>
<span class="cm"> *			Tx buffer is not free</span>
<span class="cm"> * @phy_dev:		pointer to the PHY device</span>
<span class="cm"> * @phy_node:		pointer to the PHY device node</span>
<span class="cm"> * @mii_bus:		pointer to the MII bus</span>
<span class="cm"> * @mdio_irqs:		IRQs table for MDIO bus</span>
<span class="cm"> * @last_link:		last link status</span>
<span class="cm"> * @has_mdio:		indicates whether MDIO is included in the HW</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">net_local</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">tx_ping_pong</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rx_ping_pong</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next_tx_buf_to_use</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next_rx_buf_to_use</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">reset_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">deferred_skb</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phy_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">phy_node</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">mii_bus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mdio_irqs</span><span class="p">[</span><span class="n">PHY_MAX_ADDR</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">last_link</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_mdio</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*************************/</span>
<span class="cm">/* EmacLite driver calls */</span>
<span class="cm">/*************************/</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_enable_interrupts - Enable the interrupts for the EmacLite device</span>
<span class="cm"> * @drvdata:	Pointer to the Emaclite device private data</span>
<span class="cm"> *</span>
<span class="cm"> * This function enables the Tx and Rx interrupts for the Emaclite device along</span>
<span class="cm"> * with the Global Interrupt Enable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xemaclite_enable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg_data</span><span class="p">;</span>

	<span class="cm">/* Enable the Tx interrupts for the first Buffer */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">,</span>
		 <span class="n">reg_data</span> <span class="o">|</span> <span class="n">XEL_TSR_XMIT_IE_MASK</span><span class="p">);</span>

	<span class="cm">/* Enable the Tx interrupts for the second Buffer if</span>
<span class="cm">	 * configured in HW */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">tx_ping_pong</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span>
				   <span class="n">XEL_BUFFER_OFFSET</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">);</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_BUFFER_OFFSET</span> <span class="o">+</span>
			 <span class="n">XEL_TSR_OFFSET</span><span class="p">,</span>
			 <span class="n">reg_data</span> <span class="o">|</span> <span class="n">XEL_TSR_XMIT_IE_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable the Rx interrupts for the first buffer */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_RSR_OFFSET</span><span class="p">,</span>
		 <span class="n">XEL_RSR_RECV_IE_MASK</span><span class="p">);</span>

	<span class="cm">/* Enable the Rx interrupts for the second Buffer if</span>
<span class="cm">	 * configured in HW */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">rx_ping_pong</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_BUFFER_OFFSET</span> <span class="o">+</span>
			 <span class="n">XEL_RSR_OFFSET</span><span class="p">,</span>
			 <span class="n">XEL_RSR_RECV_IE_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable the Global Interrupt Enable */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_GIER_OFFSET</span><span class="p">,</span> <span class="n">XEL_GIER_GIE_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_disable_interrupts - Disable the interrupts for the EmacLite device</span>
<span class="cm"> * @drvdata:	Pointer to the Emaclite device private data</span>
<span class="cm"> *</span>
<span class="cm"> * This function disables the Tx and Rx interrupts for the Emaclite device,</span>
<span class="cm"> * along with the Global Interrupt Enable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xemaclite_disable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg_data</span><span class="p">;</span>

	<span class="cm">/* Disable the Global Interrupt Enable */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_GIER_OFFSET</span><span class="p">,</span> <span class="n">XEL_GIER_GIE_MASK</span><span class="p">);</span>

	<span class="cm">/* Disable the Tx interrupts for the first buffer */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">,</span>
		 <span class="n">reg_data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">XEL_TSR_XMIT_IE_MASK</span><span class="p">));</span>

	<span class="cm">/* Disable the Tx interrupts for the second Buffer</span>
<span class="cm">	 * if configured in HW */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">tx_ping_pong</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_BUFFER_OFFSET</span> <span class="o">+</span>
				   <span class="n">XEL_TSR_OFFSET</span><span class="p">);</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_BUFFER_OFFSET</span> <span class="o">+</span>
			 <span class="n">XEL_TSR_OFFSET</span><span class="p">,</span>
			 <span class="n">reg_data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">XEL_TSR_XMIT_IE_MASK</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Disable the Rx interrupts for the first buffer */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_RSR_OFFSET</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_RSR_OFFSET</span><span class="p">,</span>
		 <span class="n">reg_data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">XEL_RSR_RECV_IE_MASK</span><span class="p">));</span>

	<span class="cm">/* Disable the Rx interrupts for the second buffer</span>
<span class="cm">	 * if configured in HW */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">rx_ping_pong</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_BUFFER_OFFSET</span> <span class="o">+</span>
				   <span class="n">XEL_RSR_OFFSET</span><span class="p">);</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_BUFFER_OFFSET</span> <span class="o">+</span>
			 <span class="n">XEL_RSR_OFFSET</span><span class="p">,</span>
			 <span class="n">reg_data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">XEL_RSR_RECV_IE_MASK</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_aligned_write - Write from 16-bit aligned to 32-bit aligned address</span>
<span class="cm"> * @src_ptr:	Void pointer to the 16-bit aligned source address</span>
<span class="cm"> * @dest_ptr:	Pointer to the 32-bit aligned destination address</span>
<span class="cm"> * @length:	Number bytes to write from source to destination</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes data from a 16-bit aligned buffer to a 32-bit aligned</span>
<span class="cm"> * address in the EmacLite device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xemaclite_aligned_write</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">src_ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dest_ptr</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">align_buffer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">to_u32_ptr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">from_u16_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">to_u16_ptr</span><span class="p">;</span>

	<span class="n">to_u32_ptr</span> <span class="o">=</span> <span class="n">dest_ptr</span><span class="p">;</span>
	<span class="n">from_u16_ptr</span> <span class="o">=</span> <span class="n">src_ptr</span><span class="p">;</span>
	<span class="n">align_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">length</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to_u16_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">align_buffer</span><span class="p">;</span>
		<span class="o">*</span><span class="n">to_u16_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">from_u16_ptr</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">to_u16_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">from_u16_ptr</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Output a word */</span>
		<span class="o">*</span><span class="n">to_u32_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">align_buffer</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">from_u8_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">to_u8_ptr</span><span class="p">;</span>

		<span class="cm">/* Set up to output the remaining data */</span>
		<span class="n">align_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">to_u8_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">align_buffer</span><span class="p">;</span>
		<span class="n">from_u8_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">from_u16_ptr</span><span class="p">;</span>

		<span class="cm">/* Output the remaining data */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">length</span><span class="o">--</span><span class="p">)</span>
			<span class="o">*</span><span class="n">to_u8_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">from_u8_ptr</span><span class="o">++</span><span class="p">;</span>

		<span class="o">*</span><span class="n">to_u32_ptr</span> <span class="o">=</span> <span class="n">align_buffer</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_aligned_read - Read from 32-bit aligned to 16-bit aligned buffer</span>
<span class="cm"> * @src_ptr:	Pointer to the 32-bit aligned source address</span>
<span class="cm"> * @dest_ptr:	Pointer to the 16-bit aligned destination address</span>
<span class="cm"> * @length:	Number bytes to read from source to destination</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads data from a 32-bit aligned address in the EmacLite device</span>
<span class="cm"> * to a 16-bit aligned buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xemaclite_aligned_read</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">src_ptr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">dest_ptr</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">to_u16_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">from_u16_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">from_u32_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">align_buffer</span><span class="p">;</span>

	<span class="n">from_u32_ptr</span> <span class="o">=</span> <span class="n">src_ptr</span><span class="p">;</span>
	<span class="n">to_u16_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">dest_ptr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">length</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Copy each word into the temporary buffer */</span>
		<span class="n">align_buffer</span> <span class="o">=</span> <span class="o">*</span><span class="n">from_u32_ptr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">from_u16_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">align_buffer</span><span class="p">;</span>

		<span class="cm">/* Read data from source */</span>
		<span class="o">*</span><span class="n">to_u16_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">from_u16_ptr</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">to_u16_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">from_u16_ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">to_u8_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">from_u8_ptr</span><span class="p">;</span>

		<span class="cm">/* Set up to read the remaining data */</span>
		<span class="n">to_u8_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">to_u16_ptr</span><span class="p">;</span>
		<span class="n">align_buffer</span> <span class="o">=</span> <span class="o">*</span><span class="n">from_u32_ptr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">from_u8_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">align_buffer</span><span class="p">;</span>

		<span class="cm">/* Read the remaining data */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">length</span><span class="o">--</span><span class="p">)</span>
			<span class="o">*</span><span class="n">to_u8_ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">from_u8_ptr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_send_data - Send an Ethernet frame</span>
<span class="cm"> * @drvdata:	Pointer to the Emaclite device private data</span>
<span class="cm"> * @data:	Pointer to the data to be sent</span>
<span class="cm"> * @byte_count:	Total frame size, including header</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if the Tx buffer of the Emaclite device is free to send</span>
<span class="cm"> * data. If so, it fills the Tx buffer with data for transmission. Otherwise, it</span>
<span class="cm"> * returns an error.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:	0 upon success or -1 if the buffer(s) are full.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:	The maximum Tx packet size can not be more than Ethernet header</span>
<span class="cm"> *		(14 Bytes) + Maximum MTU (1500 bytes). This is excluding FCS.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xemaclite_send_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">byte_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="cm">/* Determine the expected Tx buffer address */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">next_tx_buf_to_use</span><span class="p">;</span>

	<span class="cm">/* If the length is too large, truncate it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">byte_count</span> <span class="o">&gt;</span> <span class="n">ETH_FRAME_LEN</span><span class="p">)</span>
		<span class="n">byte_count</span> <span class="o">=</span> <span class="n">ETH_FRAME_LEN</span><span class="p">;</span>

	<span class="cm">/* Check if the expected buffer is available */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">reg_data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XEL_TSR_XMIT_BUSY_MASK</span> <span class="o">|</span>
	     <span class="n">XEL_TSR_XMIT_ACTIVE_MASK</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Switch to next buffer if configured */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">tx_ping_pong</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">next_tx_buf_to_use</span> <span class="o">^=</span> <span class="n">XEL_BUFFER_OFFSET</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">tx_ping_pong</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the expected buffer is full, try the other buffer,</span>
<span class="cm">		 * if it is configured in HW */</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span> <span class="n">__force</span><span class="p">)</span><span class="n">addr</span> <span class="o">^</span>
						 <span class="n">XEL_BUFFER_OFFSET</span><span class="p">);</span>
		<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">reg_data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XEL_TSR_XMIT_BUSY_MASK</span> <span class="o">|</span>
		     <span class="n">XEL_TSR_XMIT_ACTIVE_MASK</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Buffers were full, return failure */</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Buffer was full, return failure */</span>

	<span class="cm">/* Write the frame to the buffer */</span>
	<span class="n">xemaclite_aligned_write</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">byte_count</span><span class="p">);</span>

	<span class="n">out_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_TPLR_OFFSET</span><span class="p">,</span> <span class="p">(</span><span class="n">byte_count</span> <span class="o">&amp;</span> <span class="n">XEL_TPLR_LENGTH_MASK</span><span class="p">));</span>

	<span class="cm">/* Update the Tx Status Register to indicate that there is a</span>
<span class="cm">	 * frame to send. Set the XEL_TSR_XMIT_ACTIVE_MASK flag which</span>
<span class="cm">	 * is used by the interrupt handler to check whether a frame</span>
<span class="cm">	 * has been transmitted */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">);</span>
	<span class="n">reg_data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">XEL_TSR_XMIT_BUSY_MASK</span> <span class="o">|</span> <span class="n">XEL_TSR_XMIT_ACTIVE_MASK</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_recv_data - Receive a frame</span>
<span class="cm"> * @drvdata:	Pointer to the Emaclite device private data</span>
<span class="cm"> * @data:	Address where the data is to be received</span>
<span class="cm"> *</span>
<span class="cm"> * This function is intended to be called from the interrupt context or</span>
<span class="cm"> * with a wrapper which waits for the receive frame to be available.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:	Total number of bytes received</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">xemaclite_recv_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">length</span><span class="p">,</span> <span class="n">proto_type</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_data</span><span class="p">;</span>

	<span class="cm">/* Determine the expected buffer address */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">next_rx_buf_to_use</span><span class="p">);</span>

	<span class="cm">/* Verify which buffer has valid data */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_RSR_OFFSET</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">reg_data</span> <span class="o">&amp;</span> <span class="n">XEL_RSR_RECV_DONE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">XEL_RSR_RECV_DONE_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">rx_ping_pong</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">next_rx_buf_to_use</span> <span class="o">^=</span> <span class="n">XEL_BUFFER_OFFSET</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* The instance is out of sync, try other buffer if other</span>
<span class="cm">		 * buffer is configured, return 0 otherwise. If the instance is</span>
<span class="cm">		 * out of sync, do not update the &#39;next_rx_buf_to_use&#39; since it</span>
<span class="cm">		 * will correct on subsequent calls */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">rx_ping_pong</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span> <span class="n">__force</span><span class="p">)</span><span class="n">addr</span> <span class="o">^</span>
							 <span class="n">XEL_BUFFER_OFFSET</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* No data was available */</span>

		<span class="cm">/* Verify that buffer has valid data */</span>
		<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_RSR_OFFSET</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reg_data</span> <span class="o">&amp;</span> <span class="n">XEL_RSR_RECV_DONE_MASK</span><span class="p">)</span> <span class="o">!=</span>
		     <span class="n">XEL_RSR_RECV_DONE_MASK</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* No data was available */</span>
	<span class="p">}</span>

	<span class="cm">/* Get the protocol type of the ethernet frame that arrived */</span>
	<span class="n">proto_type</span> <span class="o">=</span> <span class="p">((</span><span class="n">ntohl</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_HEADER_OFFSET</span> <span class="o">+</span>
			<span class="n">XEL_RXBUFF_OFFSET</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">XEL_HEADER_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">XEL_RPLR_LENGTH_MASK</span><span class="p">);</span>

	<span class="cm">/* Check if received ethernet frame is a raw ethernet frame</span>
<span class="cm">	 * or an IP packet or an ARP packet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proto_type</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">proto_type</span> <span class="o">==</span> <span class="n">ETH_P_IP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">length</span> <span class="o">=</span> <span class="p">((</span><span class="n">ntohl</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span>
					<span class="n">XEL_HEADER_IP_LENGTH_OFFSET</span> <span class="o">+</span>
					<span class="n">XEL_RXBUFF_OFFSET</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
					<span class="n">XEL_HEADER_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="n">XEL_RPLR_LENGTH_MASK</span><span class="p">);</span>
			<span class="n">length</span> <span class="o">+=</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">proto_type</span> <span class="o">==</span> <span class="n">ETH_P_ARP</span><span class="p">)</span>
			<span class="n">length</span> <span class="o">=</span> <span class="n">XEL_ARP_PACKET_SIZE</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* Field contains type other than IP or ARP, use max</span>
<span class="cm">			 * frame size and let user parse it */</span>
			<span class="n">length</span> <span class="o">=</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Use the length in the frame, plus the header and trailer */</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">proto_type</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>

	<span class="cm">/* Read from the EmacLite device */</span>
	<span class="n">xemaclite_aligned_read</span><span class="p">((</span><span class="n">u32</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_RXBUFF_OFFSET</span><span class="p">),</span>
				<span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="cm">/* Acknowledge the frame */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_RSR_OFFSET</span><span class="p">);</span>
	<span class="n">reg_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XEL_RSR_RECV_DONE_MASK</span><span class="p">;</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_RSR_OFFSET</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_update_address - Update the MAC address in the device</span>
<span class="cm"> * @drvdata:	Pointer to the Emaclite device private data</span>
<span class="cm"> * @address_ptr:Pointer to the MAC address (MAC address is a 48-bit value)</span>
<span class="cm"> *</span>
<span class="cm"> * Tx must be idle and Rx should be idle for deterministic results.</span>
<span class="cm"> * It is recommended that this function should be called after the</span>
<span class="cm"> * initialization and before transmission of any packets from the device.</span>
<span class="cm"> * The MAC address can be programmed using any of the two transmit</span>
<span class="cm"> * buffers (if configured).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xemaclite_update_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">,</span>
				     <span class="n">u8</span> <span class="o">*</span><span class="n">address_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_data</span><span class="p">;</span>

	<span class="cm">/* Determine the expected Tx buffer address */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">next_tx_buf_to_use</span><span class="p">;</span>

	<span class="n">xemaclite_aligned_write</span><span class="p">(</span><span class="n">address_ptr</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">out_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_TPLR_OFFSET</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="cm">/* Update the MAC address in the EmacLite */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">,</span> <span class="n">reg_data</span> <span class="o">|</span> <span class="n">XEL_TSR_PROG_MAC_ADDR</span><span class="p">);</span>

	<span class="cm">/* Wait for EmacLite to finish with the MAC address update */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">in_be32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">XEL_TSR_PROG_MAC_ADDR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_set_mac_address - Set the MAC address for this device</span>
<span class="cm"> * @dev:	Pointer to the network device instance</span>
<span class="cm"> * @addr:	Void pointer to the sockaddr structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function copies the HW address from the sockaddr strucutre to the</span>
<span class="cm"> * net_device structure and updates the address in HW.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:	Error if the net device is busy or 0 if the addr is set</span>
<span class="cm"> *		successfully</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xemaclite_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">xemaclite_update_address</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_tx_timeout - Callback for Tx Timeout</span>
<span class="cm"> * @dev:	Pointer to the network device</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when Tx time out occurs for Emaclite device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xemaclite_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Exceeded transmit timeout of %lu ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">TX_TIMEOUT</span> <span class="o">*</span> <span class="mi">1000UL</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Reset the device */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">reset_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Shouldn&#39;t really be necessary, but shouldn&#39;t hurt */</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">xemaclite_disable_interrupts</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
	<span class="n">xemaclite_enable_interrupts</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">deferred_skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">deferred_skb</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">deferred_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* To exclude tx timeout */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>

	<span class="cm">/* We&#39;re all ready to go. Start the queue */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">reset_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**********************/</span>
<span class="cm">/* Interrupt Handlers */</span>
<span class="cm">/**********************/</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_tx_handler - Interrupt handler for frames sent</span>
<span class="cm"> * @dev:	Pointer to the network device</span>
<span class="cm"> *</span>
<span class="cm"> * This function updates the number of packets transmitted and handles the</span>
<span class="cm"> * deferred skb, if there is one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xemaclite_tx_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">deferred_skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xemaclite_send_data</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span>
					<span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">deferred_skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
					<span class="n">lp</span><span class="o">-&gt;</span><span class="n">deferred_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">deferred_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">deferred_skb</span><span class="p">);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">deferred_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_rx_handler- Interrupt handler for frames received</span>
<span class="cm"> * @dev:	Pointer to the network device</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates memory for a socket buffer, fills it with data</span>
<span class="cm"> * received and hands it over to the TCP/IP stack.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xemaclite_rx_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">align</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="n">ALIGNMENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Couldn&#39;t get memory. */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate receive buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * A new skb should have the data halfword aligned, but this code is</span>
<span class="cm">	 * here just in case that isn&#39;t true. Calculate how many</span>
<span class="cm">	 * bytes we should reserve to get the data to start on a word</span>
<span class="cm">	 * boundary */</span>
	<span class="n">align</span> <span class="o">=</span> <span class="n">BUFFER_ALIGN</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">align</span><span class="p">)</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">xemaclite_recv_data</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>	<span class="cm">/* Tell the skb how much data we got */</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_defer_rx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>	<span class="cm">/* Send the packet upstream */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_interrupt - Interrupt handler for this driver</span>
<span class="cm"> * @irq:	Irq of the Emaclite device</span>
<span class="cm"> * @dev_id:	Void pointer to the network device instance used as callback</span>
<span class="cm"> *		reference</span>
<span class="cm"> *</span>
<span class="cm"> * This function handles the Tx and Rx interrupts of the EmacLite device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">xemaclite_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">tx_complete</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_status</span><span class="p">;</span>

	<span class="cm">/* Check if there is Rx Data available */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">in_be32</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_RSR_OFFSET</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">XEL_RSR_RECV_DONE_MASK</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_BUFFER_OFFSET</span> <span class="o">+</span> <span class="n">XEL_RSR_OFFSET</span><span class="p">)</span>
			 <span class="o">&amp;</span> <span class="n">XEL_RSR_RECV_DONE_MASK</span><span class="p">))</span>

		<span class="n">xemaclite_rx_handler</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Check if the Transmission for the first buffer is completed */</span>
	<span class="n">tx_status</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">XEL_TSR_XMIT_BUSY_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">XEL_TSR_XMIT_ACTIVE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">tx_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XEL_TSR_XMIT_ACTIVE_MASK</span><span class="p">;</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">,</span> <span class="n">tx_status</span><span class="p">);</span>

		<span class="n">tx_complete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if the Transmission for the second buffer is completed */</span>
	<span class="n">tx_status</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_BUFFER_OFFSET</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">XEL_TSR_XMIT_BUSY_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">XEL_TSR_XMIT_ACTIVE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">tx_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XEL_TSR_XMIT_ACTIVE_MASK</span><span class="p">;</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_BUFFER_OFFSET</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">,</span>
			 <span class="n">tx_status</span><span class="p">);</span>

		<span class="n">tx_complete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If there was a Tx interrupt, call the Tx Handler */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_complete</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xemaclite_tx_handler</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**********************/</span>
<span class="cm">/* MDIO Bus functions */</span>
<span class="cm">/**********************/</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_mdio_wait - Wait for the MDIO to be ready to use</span>
<span class="cm"> * @lp:		Pointer to the Emaclite device private data</span>
<span class="cm"> *</span>
<span class="cm"> * This function waits till the device is ready to accept a new MDIO</span>
<span class="cm"> * request.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:	0 for success or ETIMEDOUT for a timeout</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xemaclite_mdio_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* wait for the MDIO interface to not be busy or timeout</span>
<span class="cm">	   after some time.</span>
<span class="cm">	*/</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_MDIOCTRL_OFFSET</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">XEL_MDIOCTRL_MDIOSTS_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">jiffies</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_mdio_read - Read from a given MII management register</span>
<span class="cm"> * @bus:	the mii_bus struct</span>
<span class="cm"> * @phy_id:	the phy address</span>
<span class="cm"> * @reg:	register number to read from</span>
<span class="cm"> *</span>
<span class="cm"> * This function waits till the device is ready to accept a new MDIO</span>
<span class="cm"> * request and then writes the phy address to the MDIO Address register</span>
<span class="cm"> * and reads data from MDIO Read Data register, when its available.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:	Value read from the MII management register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xemaclite_mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xemaclite_mdio_wait</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="cm">/* Write the PHY address, register number and set the OP bit in the</span>
<span class="cm">	 * MDIO Address register. Set the Status bit in the MDIO Control</span>
<span class="cm">	 * register to start a MDIO read transaction.</span>
<span class="cm">	 */</span>
	<span class="n">ctrl_reg</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_MDIOCTRL_OFFSET</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_MDIOADDR_OFFSET</span><span class="p">,</span>
		 <span class="n">XEL_MDIOADDR_OP_MASK</span> <span class="o">|</span>
		 <span class="p">((</span><span class="n">phy_id</span> <span class="o">&lt;&lt;</span> <span class="n">XEL_MDIOADDR_PHYADR_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">reg</span><span class="p">));</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_MDIOCTRL_OFFSET</span><span class="p">,</span>
		 <span class="n">ctrl_reg</span> <span class="o">|</span> <span class="n">XEL_MDIOCTRL_MDIOSTS_MASK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xemaclite_mdio_wait</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_MDIORD_OFFSET</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;xemaclite_mdio_read(phy_id=%i, reg=%x) == %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">phy_id</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_mdio_write - Write to a given MII management register</span>
<span class="cm"> * @bus:	the mii_bus struct</span>
<span class="cm"> * @phy_id:	the phy address</span>
<span class="cm"> * @reg:	register number to write to</span>
<span class="cm"> * @val:	value to write to the register number specified by reg</span>
<span class="cm"> *</span>
<span class="cm"> * This function waits till the device is ready to accept a new MDIO</span>
<span class="cm"> * request and then writes the val to the MDIO Write Data register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xemaclite_mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_reg</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;xemaclite_mdio_write(phy_id=%i, reg=%x, val=%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">phy_id</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xemaclite_mdio_wait</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="cm">/* Write the PHY address, register number and clear the OP bit in the</span>
<span class="cm">	 * MDIO Address register and then write the value into the MDIO Write</span>
<span class="cm">	 * Data register. Finally, set the Status bit in the MDIO Control</span>
<span class="cm">	 * register to start a MDIO write transaction.</span>
<span class="cm">	 */</span>
	<span class="n">ctrl_reg</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_MDIOCTRL_OFFSET</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_MDIOADDR_OFFSET</span><span class="p">,</span>
		 <span class="o">~</span><span class="n">XEL_MDIOADDR_OP_MASK</span> <span class="o">&amp;</span>
		 <span class="p">((</span><span class="n">phy_id</span> <span class="o">&lt;&lt;</span> <span class="n">XEL_MDIOADDR_PHYADR_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">reg</span><span class="p">));</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_MDIOWR_OFFSET</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_MDIOCTRL_OFFSET</span><span class="p">,</span>
		 <span class="n">ctrl_reg</span> <span class="o">|</span> <span class="n">XEL_MDIOCTRL_MDIOSTS_MASK</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_mdio_reset - Reset the mdio bus.</span>
<span class="cm"> * @bus:	Pointer to the MII bus</span>
<span class="cm"> *</span>
<span class="cm"> * This function is required(?) as per Documentation/networking/phy.txt.</span>
<span class="cm"> * There is no reset in this device; this function always returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xemaclite_mdio_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_mdio_setup - Register mii_bus for the Emaclite device</span>
<span class="cm"> * @lp:		Pointer to the Emaclite device private data</span>
<span class="cm"> * @ofdev:	Pointer to OF device structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function enables MDIO bus in the Emaclite device and registers a</span>
<span class="cm"> * mii_bus.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:	0 upon success or a negative error upon failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xemaclite_mdio_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">of_get_parent</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_node</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t register the MDIO bus if the phy_node or its parent node</span>
<span class="cm">	 * can&#39;t be found.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Enable the MDIO bus by asserting the enable bit in MDIO Control</span>
<span class="cm">	 * register.</span>
<span class="cm">	 */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_MDIOCTRL_OFFSET</span><span class="p">,</span>
		 <span class="n">XEL_MDIOCTRL_MDIOEN_MASK</span><span class="p">);</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="n">mdiobus_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">of_address_to_resource</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">MII_BUS_ID_SIZE</span><span class="p">,</span> <span class="s">&quot;%.8llx&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">lp</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Xilinx Emaclite MDIO&quot;</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">xemaclite_mdio_read</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">xemaclite_mdio_write</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="o">=</span> <span class="n">xemaclite_mdio_reset</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">mdio_irqs</span><span class="p">;</span> <span class="cm">/* preallocated IRQ table */</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_bus</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">of_mdiobus_register</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">np</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_register</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_register:</span>
	<span class="n">mdiobus_free</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_adjust_link - Link state callback for the Emaclite device</span>
<span class="cm"> * @ndev: pointer to net_device struct</span>
<span class="cm"> *</span>
<span class="cm"> * There&#39;s nothing in the Emaclite device to be configured when the link</span>
<span class="cm"> * state changes. We just print the status.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xemaclite_adjust_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">link_state</span><span class="p">;</span>

	<span class="cm">/* hash together the state values to decide if something has changed */</span>
	<span class="n">link_state</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">|</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">last_link</span> <span class="o">!=</span> <span class="n">link_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">last_link</span> <span class="o">=</span> <span class="n">link_state</span><span class="p">;</span>
		<span class="n">phy_print_status</span><span class="p">(</span><span class="n">phy</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_open - Open the network device</span>
<span class="cm"> * @dev:	Pointer to the network device</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets the MAC address, requests an IRQ and enables interrupts</span>
<span class="cm"> * for the Emaclite device and starts the Tx queue.</span>
<span class="cm"> * It also connects to the phy device, if MDIO is included in Emaclite device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xemaclite_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Just to be safe, stop the device first */</span>
	<span class="n">xemaclite_disable_interrupts</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">bmcr</span><span class="p">;</span>

		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span> <span class="o">=</span> <span class="n">of_phy_connect</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_node</span><span class="p">,</span>
					     <span class="n">xemaclite_adjust_link</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					     <span class="n">PHY_INTERFACE_MODE_MII</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;of_phy_connect() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* EmacLite doesn&#39;t support giga-bit speeds */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">PHY_BASIC_FEATURES</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="o">-&gt;</span><span class="n">supported</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t advertise 1000BASE-T Full/Half duplex speeds */</span>
		<span class="n">phy_write</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">,</span> <span class="n">MII_CTRL1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Advertise only 10 and 100mbps full/half duplex speeds */</span>
		<span class="n">phy_write</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">,</span> <span class="n">MII_ADVERTISE</span><span class="p">,</span> <span class="n">ADVERTISE_ALL</span><span class="p">);</span>

		<span class="cm">/* Restart auto negotiation */</span>
		<span class="n">bmcr</span> <span class="o">=</span> <span class="n">phy_read</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
		<span class="n">bmcr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">BMCR_ANENABLE</span> <span class="o">|</span> <span class="n">BMCR_ANRESTART</span><span class="p">);</span>
		<span class="n">phy_write</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">bmcr</span><span class="p">);</span>

		<span class="n">phy_start</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set the MAC address each time opened */</span>
	<span class="n">xemaclite_update_address</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="cm">/* Grab the IRQ */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">xemaclite_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate interrupt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">)</span>
			<span class="n">phy_disconnect</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable Interrupts */</span>
	<span class="n">xemaclite_enable_interrupts</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>

	<span class="cm">/* We&#39;re ready to go */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_close - Close the network device</span>
<span class="cm"> * @dev:	Pointer to the network device</span>
<span class="cm"> *</span>
<span class="cm"> * This function stops the Tx queue, disables interrupts and frees the IRQ for</span>
<span class="cm"> * the Emaclite device.</span>
<span class="cm"> * It also disconnects the phy device associated with the Emaclite device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xemaclite_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">xemaclite_disable_interrupts</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">)</span>
		<span class="n">phy_disconnect</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_send - Transmit a frame</span>
<span class="cm"> * @orig_skb:	Pointer to the socket buffer to be transmitted</span>
<span class="cm"> * @dev:	Pointer to the network device</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if the Tx buffer of the Emaclite device is free to send</span>
<span class="cm"> * data. If so, it fills the Tx buffer with data from socket buffer data,</span>
<span class="cm"> * updates the stats and frees the socket buffer. The Tx completion is signaled</span>
<span class="cm"> * by an interrupt. If the Tx buffer isn&#39;t free, then the socket buffer is</span>
<span class="cm"> * deferred and the Tx queue is stopped so that the deferred socket buffer can</span>
<span class="cm"> * be transmitted when the Emaclite device is free to transmit data.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:	0, always.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xemaclite_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">orig_skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">new_skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">orig_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">new_skb</span> <span class="o">=</span> <span class="n">orig_skb</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">reset_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xemaclite_send_data</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">new_skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the Emaclite Tx buffer is busy, stop the Tx queue and</span>
<span class="cm">		 * defer the skb for transmission during the ISR, after the</span>
<span class="cm">		 * current transmission is complete */</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">deferred_skb</span> <span class="o">=</span> <span class="n">new_skb</span><span class="p">;</span>
		<span class="cm">/* Take the time stamp now, since we can&#39;t do this in an ISR. */</span>
		<span class="n">skb_tx_timestamp</span><span class="p">(</span><span class="n">new_skb</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">reset_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">reset_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">skb_tx_timestamp</span><span class="p">(</span><span class="n">new_skb</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">new_skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_remove_ndev - Free the network device</span>
<span class="cm"> * @ndev:	Pointer to the network device to be freed</span>
<span class="cm"> *</span>
<span class="cm"> * This function un maps the IO region of the Emaclite device and frees the net</span>
<span class="cm"> * device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xemaclite_remove_ndev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">)</span>
			<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">));</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_bool - Get a parameter from the OF device</span>
<span class="cm"> * @ofdev:	Pointer to OF device structure</span>
<span class="cm"> * @s:		Property to be retrieved</span>
<span class="cm"> *</span>
<span class="cm"> * This function looks for a property in the device node and returns the value</span>
<span class="cm"> * of the property if its found or 0 if the property is not found.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:	Value of the parameter if the parameter is found, or 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">get_bool</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">bool</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Parameter %s not found,&quot;</span>
			<span class="s">&quot;defaulting to false</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">xemaclite_netdev_ops</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_of_probe - Probe method for the Emaclite device.</span>
<span class="cm"> * @ofdev:	Pointer to OF device structure</span>
<span class="cm"> * @match:	Pointer to the structure used for matching a device</span>
<span class="cm"> *</span>
<span class="cm"> * This function probes for the Emaclite device in the device tree.</span>
<span class="cm"> * It initializes the driver data structure and the hardware, sets the MAC</span>
<span class="cm"> * address and registers the network device.</span>
<span class="cm"> * It also registers a mii_bus for the Emaclite device, if MDIO is included</span>
<span class="cm"> * in the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:	0, if the driver is bound to the Emaclite device, or</span>
<span class="cm"> *		a negative error if there is failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">xemaclite_of_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">r_irq</span><span class="p">;</span> <span class="cm">/* Interrupt resources */</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">r_mem</span><span class="p">;</span> <span class="cm">/* IO mem resources */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mac_address</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device Tree Probing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Get iospace for the device */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">of_address_to_resource</span><span class="p">(</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r_mem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get IRQ for the device */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">of_irq_to_resource</span><span class="p">(</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r_irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no IRQ found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create an ethernet device instance */</span>
	<span class="n">ndev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_local</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ndev</span><span class="p">);</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">r_irq</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">=</span> <span class="n">r_mem</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">=</span> <span class="n">r_mem</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">ndev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">,</span>
				<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">-</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">DRIVER_NAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t lock memory region at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the virtual base address for the device */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">r_mem</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r_mem</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;EmacLite: Could not allocate iomem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">reset_lock</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">next_tx_buf_to_use</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">next_rx_buf_to_use</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tx_ping_pong</span> <span class="o">=</span> <span class="n">get_bool</span><span class="p">(</span><span class="n">ofdev</span><span class="p">,</span> <span class="s">&quot;xlnx,tx-ping-pong&quot;</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">rx_ping_pong</span> <span class="o">=</span> <span class="n">get_bool</span><span class="p">(</span><span class="n">ofdev</span><span class="p">,</span> <span class="s">&quot;xlnx,rx-ping-pong&quot;</span><span class="p">);</span>
	<span class="n">mac_address</span> <span class="o">=</span> <span class="n">of_get_mac_address</span><span class="p">(</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mac_address</span><span class="p">)</span>
		<span class="cm">/* Set the MAC address. */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">mac_address</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No MAC address found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear the Tx CSR&#39;s in case this is a restart */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">XEL_BUFFER_OFFSET</span> <span class="o">+</span> <span class="n">XEL_TSR_OFFSET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Set the MAC address in the EmacLite device */</span>
	<span class="n">xemaclite_update_address</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_node</span> <span class="o">=</span> <span class="n">of_parse_phandle</span><span class="p">(</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="s">&quot;phy-handle&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">xemaclite_mdio_setup</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error registering MDIO bus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MAC address is now %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xemaclite_netdev_ops</span><span class="p">;</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IFF_MULTICAST</span><span class="p">;</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TX_TIMEOUT</span><span class="p">;</span>

	<span class="cm">/* Finally, register the device */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Cannot register network device, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
		 <span class="s">&quot;Xilinx EmacLite at 0x%08X mapped to 0x%08X, irq=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__force</span><span class="p">)</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__force</span><span class="p">)</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error1:</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r_mem</span><span class="p">));</span>

<span class="nl">error2:</span>
	<span class="n">xemaclite_remove_ndev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xemaclite_of_remove - Unbind the driver from the Emaclite device.</span>
<span class="cm"> * @of_dev:	Pointer to OF device structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called if a device is physically removed from the system or</span>
<span class="cm"> * if the driver module is being unloaded. It frees any resources allocated to</span>
<span class="cm"> * the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:	0, always.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">xemaclite_of_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">of_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">of_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">net_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="cm">/* Un-register the mii_bus, if configured */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">has_mdio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mdiobus_unregister</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">mdiobus_free</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">mii_bus</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_node</span><span class="p">)</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_node</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">phy_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">,</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mem_end</span><span class="o">-</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">xemaclite_remove_ndev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xemaclite_poll_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_irq</span><span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">xemaclite_interrupt</span><span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ndev</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">xemaclite_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">xemaclite_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">xemaclite_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">xemaclite_send</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">xemaclite_set_mac_address</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">xemaclite_tx_timeout</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span> <span class="o">=</span> <span class="n">xemaclite_poll_controller</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Match table for OF platform binding */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">xemaclite_of_match</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;xlnx,opb-ethernetlite-1.01.a&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;xlnx,opb-ethernetlite-1.01.b&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;xlnx,xps-ethernetlite-1.00.a&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;xlnx,xps-ethernetlite-2.00.a&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;xlnx,xps-ethernetlite-2.01.a&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;xlnx,xps-ethernetlite-3.00.a&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* end of list */</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">xemaclite_of_match</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">xemaclite_of_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">xemaclite_of_match</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">xemaclite_of_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">xemaclite_of_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">xemaclite_of_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Xilinx, Inc.&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Xilinx Ethernet MAC Lite driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
