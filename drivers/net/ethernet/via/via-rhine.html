<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › via › via-rhine.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>via-rhine.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* via-rhine.c: A Linux Ethernet device driver for VIA Rhine family chips. */</span>
<span class="cm">/*</span>
<span class="cm">	Written 1998-2001 by Donald Becker.</span>

<span class="cm">	Current Maintainer: Roger Luethi &lt;rl@hellgate.ch&gt;</span>

<span class="cm">	This software may be used and distributed according to the terms of</span>
<span class="cm">	the GNU General Public License (GPL), incorporated herein by reference.</span>
<span class="cm">	Drivers based on or derived from this code fall under the GPL and must</span>
<span class="cm">	retain the authorship, copyright and license notice.  This file is not</span>
<span class="cm">	a complete program and may only be used when the entire operating</span>
<span class="cm">	system is licensed under the GPL.</span>

<span class="cm">	This driver is designed for the VIA VT86C100A Rhine-I.</span>
<span class="cm">	It also works with the Rhine-II (6102) and Rhine-III (6105/6105L/6105LOM</span>
<span class="cm">	and management NIC 6105M).</span>

<span class="cm">	The author may be reached as becker@scyld.com, or C/O</span>
<span class="cm">	Scyld Computing Corporation</span>
<span class="cm">	410 Severn Ave., Suite 210</span>
<span class="cm">	Annapolis MD 21403</span>


<span class="cm">	This driver contains some changes from the original Donald Becker</span>
<span class="cm">	version. He may or may not be interested in bug reports on this</span>
<span class="cm">	code. You can find his versions at:</span>
<span class="cm">	http://www.scyld.com/network/via-rhine.html</span>
<span class="cm">	[link no longer provides useful info -jgarzik]</span>

<span class="cm">*/</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#define DRV_NAME	&quot;via-rhine&quot;</span>
<span class="cp">#define DRV_VERSION	&quot;1.5.0&quot;</span>
<span class="cp">#define DRV_RELDATE	&quot;2010-10-09&quot;</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/* A few user-configurable values.</span>
<span class="cm">   These may be modified when a driver module is loaded. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#define RHINE_MSG_DEFAULT \</span>
<span class="cp">        (0x0000)</span>

<span class="cm">/* Set the copy breakpoint for the copy-only-tiny-frames scheme.</span>
<span class="cm">   Setting to &gt; 1518 effectively disables this feature. */</span>
<span class="cp">#if defined(__alpha__) || defined(__arm__) || defined(__hppa__) || \</span>
<span class="cp">	defined(CONFIG_SPARC) || defined(__ia64__) ||		   \</span>
<span class="cp">	defined(__sh__) || defined(__mips__)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rx_copybreak</span> <span class="o">=</span> <span class="mi">1518</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rx_copybreak</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* Work-around for broken BIOSes: they are unable to get the chip back out of</span>
<span class="cm">   power state D3 so PXE booting fails. bootparam(7): via-rhine.avoid_D3=1 */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">avoid_D3</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * In case you are looking for &#39;options[]&#39; or &#39;full_duplex[]&#39;, they</span>
<span class="cm"> * are gone. Use ethtool(8) instead.</span>
<span class="cm"> */</span>

<span class="cm">/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).</span>
<span class="cm">   The Rhine has a 64 element 8390-like hash table. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">multicast_filter_limit</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>


<span class="cm">/* Operational parameters that are set at compile time. */</span>

<span class="cm">/* Keep the ring sizes a power of two for compile efficiency.</span>
<span class="cm">   The compiler will convert &lt;unsigned&gt;&#39;%&#39;&lt;2^N&gt; into a bit mask.</span>
<span class="cm">   Making the Tx ring too large decreases the effectiveness of channel</span>
<span class="cm">   bonding and packet priority.</span>
<span class="cm">   There are no ill effects from too-large receive rings. */</span>
<span class="cp">#define TX_RING_SIZE	16</span>
<span class="cp">#define TX_QUEUE_LEN	10	</span><span class="cm">/* Limit ring entries actually used. */</span><span class="cp"></span>
<span class="cp">#define RX_RING_SIZE	64</span>

<span class="cm">/* Operational parameters that usually are not changed. */</span>

<span class="cm">/* Time in jiffies before concluding the transmitter is hung. */</span>
<span class="cp">#define TX_TIMEOUT	(2*HZ)</span>

<span class="cp">#define PKT_BUF_SZ	1536	</span><span class="cm">/* Size of each temporary Rx buffer.*/</span><span class="cp"></span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;	</span><span class="cm">/* Processor type for cache alignment. */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>

<span class="cm">/* These identify the driver base version and may not be removed. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="n">__devinitconst</span> <span class="o">=</span>
	<span class="s">&quot;v1.10-LK&quot;</span> <span class="n">DRV_VERSION</span> <span class="s">&quot; &quot;</span> <span class="n">DRV_RELDATE</span> <span class="s">&quot; Written by Donald Becker&quot;</span><span class="p">;</span>

<span class="cm">/* This driver was written to use PCI memory space. Some early versions</span>
<span class="cm">   of the Rhine may only work correctly with I/O space accesses. */</span>
<span class="cp">#ifdef CONFIG_VIA_RHINE_MMIO</span>
<span class="cp">#define USE_MMIO</span>
<span class="cp">#else</span>
<span class="cp">#endif</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Donald Becker &lt;becker@scyld.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;VIA Rhine PCI Fast Ethernet driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">rx_copybreak</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">avoid_D3</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;VIA Rhine debug message flags&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">rx_copybreak</span><span class="p">,</span> <span class="s">&quot;VIA Rhine copy breakpoint for copy-only-tiny-frames&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">avoid_D3</span><span class="p">,</span> <span class="s">&quot;Avoid power state D3 (work-around for broken BIOSes)&quot;</span><span class="p">);</span>

<span class="cp">#define MCAM_SIZE	32</span>
<span class="cp">#define VCAM_SIZE	32</span>

<span class="cm">/*</span>
<span class="cm">		Theory of Operation</span>

<span class="cm">I. Board Compatibility</span>

<span class="cm">This driver is designed for the VIA 86c100A Rhine-II PCI Fast Ethernet</span>
<span class="cm">controller.</span>

<span class="cm">II. Board-specific settings</span>

<span class="cm">Boards with this chip are functional only in a bus-master PCI slot.</span>

<span class="cm">Many operational settings are loaded from the EEPROM to the Config word at</span>
<span class="cm">offset 0x78. For most of these settings, this driver assumes that they are</span>
<span class="cm">correct.</span>
<span class="cm">If this driver is compiled to use PCI memory space operations the EEPROM</span>
<span class="cm">must be configured to enable memory ops.</span>

<span class="cm">III. Driver operation</span>

<span class="cm">IIIa. Ring buffers</span>

<span class="cm">This driver uses two statically allocated fixed-size descriptor lists</span>
<span class="cm">formed into rings by a branch from the final descriptor to the beginning of</span>
<span class="cm">the list. The ring sizes are set at compile time by RX/TX_RING_SIZE.</span>

<span class="cm">IIIb/c. Transmit/Receive Structure</span>

<span class="cm">This driver attempts to use a zero-copy receive and transmit scheme.</span>

<span class="cm">Alas, all data buffers are required to start on a 32 bit boundary, so</span>
<span class="cm">the driver must often copy transmit packets into bounce buffers.</span>

<span class="cm">The driver allocates full frame size skbuffs for the Rx ring buffers at</span>
<span class="cm">open() time and passes the skb-&gt;data field to the chip as receive data</span>
<span class="cm">buffers. When an incoming frame is less than RX_COPYBREAK bytes long,</span>
<span class="cm">a fresh skbuff is allocated and the frame is copied to the new skbuff.</span>
<span class="cm">When the incoming frame is larger, the skbuff is passed directly up the</span>
<span class="cm">protocol stack. Buffers consumed this way are replaced by newly allocated</span>
<span class="cm">skbuffs in the last phase of rhine_rx().</span>

<span class="cm">The RX_COPYBREAK value is chosen to trade-off the memory wasted by</span>
<span class="cm">using a full-sized skbuff for small frames vs. the copying costs of larger</span>
<span class="cm">frames. New boards are typically used in generously configured machines</span>
<span class="cm">and the underfilled buffers have negligible impact compared to the benefit of</span>
<span class="cm">a single allocation size, so the default value of zero results in never</span>
<span class="cm">copying packets. When copying is done, the cost is usually mitigated by using</span>
<span class="cm">a combined copy/checksum routine. Copying also preloads the cache, which is</span>
<span class="cm">most useful with small frames.</span>

<span class="cm">Since the VIA chips are only able to transfer data to buffers on 32 bit</span>
<span class="cm">boundaries, the IP header at offset 14 in an ethernet frame isn&#39;t</span>
<span class="cm">longword aligned for further processing. Copying these unaligned buffers</span>
<span class="cm">has the beneficial effect of 16-byte aligning the IP header.</span>

<span class="cm">IIId. Synchronization</span>

<span class="cm">The driver runs as two independent, single-threaded flows of control. One</span>
<span class="cm">is the send-packet routine, which enforces single-threaded use by the</span>
<span class="cm">netdev_priv(dev)-&gt;lock spinlock. The other thread is the interrupt handler,</span>
<span class="cm">which is single threaded by the hardware and interrupt handling software.</span>

<span class="cm">The send packet thread has partial control over the Tx ring. It locks the</span>
<span class="cm">netdev_priv(dev)-&gt;lock whenever it&#39;s queuing a Tx packet. If the next slot in</span>
<span class="cm">the ring is not available it stops the transmit queue by</span>
<span class="cm">calling netif_stop_queue.</span>

<span class="cm">The interrupt handler has exclusive control over the Rx ring and records stats</span>
<span class="cm">from the Tx ring. After reaping the stats, it marks the Tx queue entry as</span>
<span class="cm">empty by incrementing the dirty_tx mark. If at least half of the entries in</span>
<span class="cm">the Rx ring are available the transmit queue is woken up if it was stopped.</span>

<span class="cm">IV. Notes</span>

<span class="cm">IVb. References</span>

<span class="cm">Preliminary VT86C100A manual from http://www.via.com.tw/</span>
<span class="cm">http://www.scyld.com/expert/100mbps.html</span>
<span class="cm">http://www.scyld.com/expert/NWay.html</span>
<span class="cm">ftp://ftp.via.com.tw/public/lan/Products/NIC/VT86C100A/Datasheet/VT86C100A03.pdf</span>
<span class="cm">ftp://ftp.via.com.tw/public/lan/Products/NIC/VT6102/Datasheet/VT6102_021.PDF</span>


<span class="cm">IVc. Errata</span>

<span class="cm">The VT86C100A manual is not reliable information.</span>
<span class="cm">The 3043 chip does not handle unaligned transmit or receive buffers, resulting</span>
<span class="cm">in significant performance degradation for bounce buffer copies on transmit</span>
<span class="cm">and unaligned IP headers on receive.</span>
<span class="cm">The chip does not pad to minimum transmit length.</span>

<span class="cm">*/</span>


<span class="cm">/* This table drives the PCI probe routines. It&#39;s mostly boilerplate in all</span>
<span class="cm">   of the drivers, and will likely be provided by some future kernel.</span>
<span class="cm">   Note the matching code -- the first table entry matchs all 56** cards but</span>
<span class="cm">   second only the 1234 card.</span>
<span class="cm">*/</span>

<span class="k">enum</span> <span class="n">rhine_revs</span> <span class="p">{</span>
	<span class="n">VT86C100A</span>	<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">VTunknown0</span>	<span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">VT6102</span>		<span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">VT8231</span>		<span class="o">=</span> <span class="mh">0x50</span><span class="p">,</span>	<span class="cm">/* Integrated MAC */</span>
	<span class="n">VT8233</span>		<span class="o">=</span> <span class="mh">0x60</span><span class="p">,</span>	<span class="cm">/* Integrated MAC */</span>
	<span class="n">VT8235</span>		<span class="o">=</span> <span class="mh">0x74</span><span class="p">,</span>	<span class="cm">/* Integrated MAC */</span>
	<span class="n">VT8237</span>		<span class="o">=</span> <span class="mh">0x78</span><span class="p">,</span>	<span class="cm">/* Integrated MAC */</span>
	<span class="n">VTunknown1</span>	<span class="o">=</span> <span class="mh">0x7C</span><span class="p">,</span>
	<span class="n">VT6105</span>		<span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
	<span class="n">VT6105_B0</span>	<span class="o">=</span> <span class="mh">0x83</span><span class="p">,</span>
	<span class="n">VT6105L</span>		<span class="o">=</span> <span class="mh">0x8A</span><span class="p">,</span>
	<span class="n">VT6107</span>		<span class="o">=</span> <span class="mh">0x8C</span><span class="p">,</span>
	<span class="n">VTunknown2</span>	<span class="o">=</span> <span class="mh">0x8E</span><span class="p">,</span>
	<span class="n">VT6105M</span>		<span class="o">=</span> <span class="mh">0x90</span><span class="p">,</span>	<span class="cm">/* Management adapter */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">rhine_quirks</span> <span class="p">{</span>
	<span class="n">rqWOL</span>		<span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>	<span class="cm">/* Wake-On-LAN support */</span>
	<span class="n">rqForceReset</span>	<span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">rq6patterns</span>	<span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span>	<span class="cm">/* 6 instead of 4 patterns for WOL */</span>
	<span class="n">rqStatusWBRace</span>	<span class="o">=</span> <span class="mh">0x0080</span><span class="p">,</span>	<span class="cm">/* Tx Status Writeback Error possible */</span>
	<span class="n">rqRhineI</span>	<span class="o">=</span> <span class="mh">0x0100</span><span class="p">,</span>	<span class="cm">/* See comment below */</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * rqRhineI: VT86C100A (aka Rhine-I) uses different bits to enable</span>
<span class="cm"> * MMIO as well as for the collision counter and the Tx FIFO underflow</span>
<span class="cm"> * indicator. In addition, Tx and Rx buffers need to 4 byte aligned.</span>
<span class="cm"> */</span>

<span class="cm">/* Beware of PCI posted writes */</span>
<span class="cp">#define IOSYNC	do { ioread8(ioaddr + StationAddr); } while (0)</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">rhine_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x1106</span><span class="p">,</span> <span class="mh">0x3043</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>	<span class="cm">/* VT86C100A */</span>
	<span class="p">{</span> <span class="mh">0x1106</span><span class="p">,</span> <span class="mh">0x3065</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>	<span class="cm">/* VT6102 */</span>
	<span class="p">{</span> <span class="mh">0x1106</span><span class="p">,</span> <span class="mh">0x3106</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>	<span class="cm">/* 6105{,L,LOM} */</span>
	<span class="p">{</span> <span class="mh">0x1106</span><span class="p">,</span> <span class="mh">0x3053</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>	<span class="cm">/* VT6105M */</span>
	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* terminate list */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">rhine_pci_tbl</span><span class="p">);</span>


<span class="cm">/* Offsets to the device registers. */</span>
<span class="k">enum</span> <span class="n">register_offsets</span> <span class="p">{</span>
	<span class="n">StationAddr</span><span class="o">=</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">RxConfig</span><span class="o">=</span><span class="mh">0x06</span><span class="p">,</span> <span class="n">TxConfig</span><span class="o">=</span><span class="mh">0x07</span><span class="p">,</span> <span class="n">ChipCmd</span><span class="o">=</span><span class="mh">0x08</span><span class="p">,</span>
	<span class="n">ChipCmd1</span><span class="o">=</span><span class="mh">0x09</span><span class="p">,</span> <span class="n">TQWake</span><span class="o">=</span><span class="mh">0x0A</span><span class="p">,</span>
	<span class="n">IntrStatus</span><span class="o">=</span><span class="mh">0x0C</span><span class="p">,</span> <span class="n">IntrEnable</span><span class="o">=</span><span class="mh">0x0E</span><span class="p">,</span>
	<span class="n">MulticastFilter0</span><span class="o">=</span><span class="mh">0x10</span><span class="p">,</span> <span class="n">MulticastFilter1</span><span class="o">=</span><span class="mh">0x14</span><span class="p">,</span>
	<span class="n">RxRingPtr</span><span class="o">=</span><span class="mh">0x18</span><span class="p">,</span> <span class="n">TxRingPtr</span><span class="o">=</span><span class="mh">0x1C</span><span class="p">,</span> <span class="n">GFIFOTest</span><span class="o">=</span><span class="mh">0x54</span><span class="p">,</span>
	<span class="n">MIIPhyAddr</span><span class="o">=</span><span class="mh">0x6C</span><span class="p">,</span> <span class="n">MIIStatus</span><span class="o">=</span><span class="mh">0x6D</span><span class="p">,</span> <span class="n">PCIBusConfig</span><span class="o">=</span><span class="mh">0x6E</span><span class="p">,</span> <span class="n">PCIBusConfig1</span><span class="o">=</span><span class="mh">0x6F</span><span class="p">,</span>
	<span class="n">MIICmd</span><span class="o">=</span><span class="mh">0x70</span><span class="p">,</span> <span class="n">MIIRegAddr</span><span class="o">=</span><span class="mh">0x71</span><span class="p">,</span> <span class="n">MIIData</span><span class="o">=</span><span class="mh">0x72</span><span class="p">,</span> <span class="n">MACRegEEcsr</span><span class="o">=</span><span class="mh">0x74</span><span class="p">,</span>
	<span class="n">ConfigA</span><span class="o">=</span><span class="mh">0x78</span><span class="p">,</span> <span class="n">ConfigB</span><span class="o">=</span><span class="mh">0x79</span><span class="p">,</span> <span class="n">ConfigC</span><span class="o">=</span><span class="mh">0x7A</span><span class="p">,</span> <span class="n">ConfigD</span><span class="o">=</span><span class="mh">0x7B</span><span class="p">,</span>
	<span class="n">RxMissed</span><span class="o">=</span><span class="mh">0x7C</span><span class="p">,</span> <span class="n">RxCRCErrs</span><span class="o">=</span><span class="mh">0x7E</span><span class="p">,</span> <span class="n">MiscCmd</span><span class="o">=</span><span class="mh">0x81</span><span class="p">,</span>
	<span class="n">StickyHW</span><span class="o">=</span><span class="mh">0x83</span><span class="p">,</span> <span class="n">IntrStatus2</span><span class="o">=</span><span class="mh">0x84</span><span class="p">,</span>
	<span class="n">CamMask</span><span class="o">=</span><span class="mh">0x88</span><span class="p">,</span> <span class="n">CamCon</span><span class="o">=</span><span class="mh">0x92</span><span class="p">,</span> <span class="n">CamAddr</span><span class="o">=</span><span class="mh">0x93</span><span class="p">,</span>
	<span class="n">WOLcrSet</span><span class="o">=</span><span class="mh">0xA0</span><span class="p">,</span> <span class="n">PwcfgSet</span><span class="o">=</span><span class="mh">0xA1</span><span class="p">,</span> <span class="n">WOLcgSet</span><span class="o">=</span><span class="mh">0xA3</span><span class="p">,</span> <span class="n">WOLcrClr</span><span class="o">=</span><span class="mh">0xA4</span><span class="p">,</span>
	<span class="n">WOLcrClr1</span><span class="o">=</span><span class="mh">0xA6</span><span class="p">,</span> <span class="n">WOLcgClr</span><span class="o">=</span><span class="mh">0xA7</span><span class="p">,</span>
	<span class="n">PwrcsrSet</span><span class="o">=</span><span class="mh">0xA8</span><span class="p">,</span> <span class="n">PwrcsrSet1</span><span class="o">=</span><span class="mh">0xA9</span><span class="p">,</span> <span class="n">PwrcsrClr</span><span class="o">=</span><span class="mh">0xAC</span><span class="p">,</span> <span class="n">PwrcsrClr1</span><span class="o">=</span><span class="mh">0xAD</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Bits in ConfigD */</span>
<span class="k">enum</span> <span class="n">backoff_bits</span> <span class="p">{</span>
	<span class="n">BackOptional</span><span class="o">=</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">BackModify</span><span class="o">=</span><span class="mh">0x02</span><span class="p">,</span>
	<span class="n">BackCaptureEffect</span><span class="o">=</span><span class="mh">0x04</span><span class="p">,</span> <span class="n">BackRandom</span><span class="o">=</span><span class="mh">0x08</span>
<span class="p">};</span>

<span class="cm">/* Bits in the TxConfig (TCR) register */</span>
<span class="k">enum</span> <span class="n">tcr_bits</span> <span class="p">{</span>
	<span class="n">TCR_PQEN</span><span class="o">=</span><span class="mh">0x01</span><span class="p">,</span>
	<span class="n">TCR_LB0</span><span class="o">=</span><span class="mh">0x02</span><span class="p">,</span>		<span class="cm">/* loopback[0] */</span>
	<span class="n">TCR_LB1</span><span class="o">=</span><span class="mh">0x04</span><span class="p">,</span>		<span class="cm">/* loopback[1] */</span>
	<span class="n">TCR_OFSET</span><span class="o">=</span><span class="mh">0x08</span><span class="p">,</span>
	<span class="n">TCR_RTGOPT</span><span class="o">=</span><span class="mh">0x10</span><span class="p">,</span>
	<span class="n">TCR_RTFT0</span><span class="o">=</span><span class="mh">0x20</span><span class="p">,</span>
	<span class="n">TCR_RTFT1</span><span class="o">=</span><span class="mh">0x40</span><span class="p">,</span>
	<span class="n">TCR_RTSF</span><span class="o">=</span><span class="mh">0x80</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Bits in the CamCon (CAMC) register */</span>
<span class="k">enum</span> <span class="n">camcon_bits</span> <span class="p">{</span>
	<span class="n">CAMC_CAMEN</span><span class="o">=</span><span class="mh">0x01</span><span class="p">,</span>
	<span class="n">CAMC_VCAMSL</span><span class="o">=</span><span class="mh">0x02</span><span class="p">,</span>
	<span class="n">CAMC_CAMWR</span><span class="o">=</span><span class="mh">0x04</span><span class="p">,</span>
	<span class="n">CAMC_CAMRD</span><span class="o">=</span><span class="mh">0x08</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Bits in the PCIBusConfig1 (BCR1) register */</span>
<span class="k">enum</span> <span class="n">bcr1_bits</span> <span class="p">{</span>
	<span class="n">BCR1_POT0</span><span class="o">=</span><span class="mh">0x01</span><span class="p">,</span>
	<span class="n">BCR1_POT1</span><span class="o">=</span><span class="mh">0x02</span><span class="p">,</span>
	<span class="n">BCR1_POT2</span><span class="o">=</span><span class="mh">0x04</span><span class="p">,</span>
	<span class="n">BCR1_CTFT0</span><span class="o">=</span><span class="mh">0x08</span><span class="p">,</span>
	<span class="n">BCR1_CTFT1</span><span class="o">=</span><span class="mh">0x10</span><span class="p">,</span>
	<span class="n">BCR1_CTSF</span><span class="o">=</span><span class="mh">0x20</span><span class="p">,</span>
	<span class="n">BCR1_TXQNOBK</span><span class="o">=</span><span class="mh">0x40</span><span class="p">,</span>	<span class="cm">/* for VT6105 */</span>
	<span class="n">BCR1_VIDFR</span><span class="o">=</span><span class="mh">0x80</span><span class="p">,</span>	<span class="cm">/* for VT6105 */</span>
	<span class="n">BCR1_MED0</span><span class="o">=</span><span class="mh">0x40</span><span class="p">,</span>		<span class="cm">/* for VT6102 */</span>
	<span class="n">BCR1_MED1</span><span class="o">=</span><span class="mh">0x80</span><span class="p">,</span>		<span class="cm">/* for VT6102 */</span>
<span class="p">};</span>

<span class="cp">#ifdef USE_MMIO</span>
<span class="cm">/* Registers we check that mmio and reg are the same. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">mmio_verify_registers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">RxConfig</span><span class="p">,</span> <span class="n">TxConfig</span><span class="p">,</span> <span class="n">IntrEnable</span><span class="p">,</span> <span class="n">ConfigA</span><span class="p">,</span> <span class="n">ConfigB</span><span class="p">,</span> <span class="n">ConfigC</span><span class="p">,</span> <span class="n">ConfigD</span><span class="p">,</span>
	<span class="mi">0</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/* Bits in the interrupt status/mask registers. */</span>
<span class="k">enum</span> <span class="n">intr_status_bits</span> <span class="p">{</span>
	<span class="n">IntrRxDone</span>	<span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>
	<span class="n">IntrTxDone</span>	<span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">IntrRxErr</span>	<span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>
	<span class="n">IntrTxError</span>	<span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="n">IntrRxEmpty</span>	<span class="o">=</span> <span class="mh">0x0020</span><span class="p">,</span>
	<span class="n">IntrPCIErr</span>	<span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span>
	<span class="n">IntrStatsMax</span>	<span class="o">=</span> <span class="mh">0x0080</span><span class="p">,</span>
	<span class="n">IntrRxEarly</span>	<span class="o">=</span> <span class="mh">0x0100</span><span class="p">,</span>
	<span class="n">IntrTxUnderrun</span>	<span class="o">=</span> <span class="mh">0x0210</span><span class="p">,</span>
	<span class="n">IntrRxOverflow</span>	<span class="o">=</span> <span class="mh">0x0400</span><span class="p">,</span>
	<span class="n">IntrRxDropped</span>	<span class="o">=</span> <span class="mh">0x0800</span><span class="p">,</span>
	<span class="n">IntrRxNoBuf</span>	<span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>
	<span class="n">IntrTxAborted</span>	<span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>
	<span class="n">IntrLinkChange</span>	<span class="o">=</span> <span class="mh">0x4000</span><span class="p">,</span>
	<span class="n">IntrRxWakeUp</span>	<span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span>
	<span class="n">IntrTxDescRace</span>		<span class="o">=</span> <span class="mh">0x080000</span><span class="p">,</span>	<span class="cm">/* mapped from IntrStatus2 */</span>
	<span class="n">IntrNormalSummary</span>	<span class="o">=</span> <span class="n">IntrRxDone</span> <span class="o">|</span> <span class="n">IntrTxDone</span><span class="p">,</span>
	<span class="n">IntrTxErrSummary</span>	<span class="o">=</span> <span class="n">IntrTxDescRace</span> <span class="o">|</span> <span class="n">IntrTxAborted</span> <span class="o">|</span> <span class="n">IntrTxError</span> <span class="o">|</span>
				  <span class="n">IntrTxUnderrun</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Bits in WOLcrSet/WOLcrClr and PwrcsrSet/PwrcsrClr */</span>
<span class="k">enum</span> <span class="n">wol_bits</span> <span class="p">{</span>
	<span class="n">WOLucast</span>	<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">WOLmagic</span>	<span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">WOLbmcast</span>	<span class="o">=</span> <span class="mh">0x30</span><span class="p">,</span>
	<span class="n">WOLlnkon</span>	<span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">WOLlnkoff</span>	<span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* The Rx and Tx buffer descriptors. */</span>
<span class="k">struct</span> <span class="n">rx_desc</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">rx_status</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">desc_length</span><span class="p">;</span> <span class="cm">/* Chain flag, Buffer/frame length */</span>
	<span class="n">__le32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">next_desc</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">tx_desc</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">tx_status</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">desc_length</span><span class="p">;</span> <span class="cm">/* Chain flag, Tx Config, Frame length */</span>
	<span class="n">__le32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">next_desc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Initial value for tx_desc.desc_length, Buffer size goes to bits 0-10 */</span>
<span class="cp">#define TXDESC		0x00e08000</span>

<span class="k">enum</span> <span class="n">rx_status_bits</span> <span class="p">{</span>
	<span class="n">RxOK</span><span class="o">=</span><span class="mh">0x8000</span><span class="p">,</span> <span class="n">RxWholePkt</span><span class="o">=</span><span class="mh">0x0300</span><span class="p">,</span> <span class="n">RxErr</span><span class="o">=</span><span class="mh">0x008F</span>
<span class="p">};</span>

<span class="cm">/* Bits in *_desc.*_status */</span>
<span class="k">enum</span> <span class="n">desc_status_bits</span> <span class="p">{</span>
	<span class="n">DescOwn</span><span class="o">=</span><span class="mh">0x80000000</span>
<span class="p">};</span>

<span class="cm">/* Bits in *_desc.*_length */</span>
<span class="k">enum</span> <span class="n">desc_length_bits</span> <span class="p">{</span>
	<span class="n">DescTag</span><span class="o">=</span><span class="mh">0x00010000</span>
<span class="p">};</span>

<span class="cm">/* Bits in ChipCmd. */</span>
<span class="k">enum</span> <span class="n">chip_cmd_bits</span> <span class="p">{</span>
	<span class="n">CmdInit</span><span class="o">=</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">CmdStart</span><span class="o">=</span><span class="mh">0x02</span><span class="p">,</span> <span class="n">CmdStop</span><span class="o">=</span><span class="mh">0x04</span><span class="p">,</span> <span class="n">CmdRxOn</span><span class="o">=</span><span class="mh">0x08</span><span class="p">,</span>
	<span class="n">CmdTxOn</span><span class="o">=</span><span class="mh">0x10</span><span class="p">,</span> <span class="n">Cmd1TxDemand</span><span class="o">=</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">CmdRxDemand</span><span class="o">=</span><span class="mh">0x40</span><span class="p">,</span>
	<span class="n">Cmd1EarlyRx</span><span class="o">=</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">Cmd1EarlyTx</span><span class="o">=</span><span class="mh">0x02</span><span class="p">,</span> <span class="n">Cmd1FDuplex</span><span class="o">=</span><span class="mh">0x04</span><span class="p">,</span>
	<span class="n">Cmd1NoTxPoll</span><span class="o">=</span><span class="mh">0x08</span><span class="p">,</span> <span class="n">Cmd1Reset</span><span class="o">=</span><span class="mh">0x80</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rhine_private</span> <span class="p">{</span>
	<span class="cm">/* Bit mask for configured VLAN ids */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active_vlans</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">VLAN_N_VID</span><span class="p">)];</span>

	<span class="cm">/* Descriptor rings */</span>
	<span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rx_ring_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_ring_dma</span><span class="p">;</span>

	<span class="cm">/* The addresses of receive-in-place skbuffs. */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">rx_skbuff_dma</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="p">];</span>

	<span class="cm">/* The saved address of a sent-in-place packet/buffer, for later free(). */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_skbuff_dma</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="p">];</span>

	<span class="cm">/* Tx bounce buffers (Rhine-I only) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tx_buf</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tx_bufs</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_bufs_dma</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">pioaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">task_lock</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">task_enable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">slow_event_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reset_task</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">msg_enable</span><span class="p">;</span>

	<span class="cm">/* Frequently used values: keep some adjacent for cache effect. */</span>
	<span class="n">u32</span> <span class="n">quirks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">rx_head_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_rx</span><span class="p">,</span> <span class="n">dirty_rx</span><span class="p">;</span>	<span class="cm">/* Producer/consumer ring indices */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_tx</span><span class="p">,</span> <span class="n">dirty_tx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_buf_sz</span><span class="p">;</span>		<span class="cm">/* Based on MTU+slack. */</span>
	<span class="n">u8</span> <span class="n">wolopts</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">tx_thresh</span><span class="p">,</span> <span class="n">rx_thresh</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mii_if_info</span> <span class="n">mii_if</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define BYTE_REG_BITS_ON(x, p)      do { iowrite8((ioread8((p))|(x)), (p)); } while (0)</span>
<span class="cp">#define WORD_REG_BITS_ON(x, p)      do { iowrite16((ioread16((p))|(x)), (p)); } while (0)</span>
<span class="cp">#define DWORD_REG_BITS_ON(x, p)     do { iowrite32((ioread32((p))|(x)), (p)); } while (0)</span>

<span class="cp">#define BYTE_REG_BITS_IS_ON(x, p)   (ioread8((p)) &amp; (x))</span>
<span class="cp">#define WORD_REG_BITS_IS_ON(x, p)   (ioread16((p)) &amp; (x))</span>
<span class="cp">#define DWORD_REG_BITS_IS_ON(x, p)  (ioread32((p)) &amp; (x))</span>

<span class="cp">#define BYTE_REG_BITS_OFF(x, p)     do { iowrite8(ioread8((p)) &amp; (~(x)), (p)); } while (0)</span>
<span class="cp">#define WORD_REG_BITS_OFF(x, p)     do { iowrite16(ioread16((p)) &amp; (~(x)), (p)); } while (0)</span>
<span class="cp">#define DWORD_REG_BITS_OFF(x, p)    do { iowrite32(ioread32((p)) &amp; (~(x)), (p)); } while (0)</span>

<span class="cp">#define BYTE_REG_BITS_SET(x, m, p)   do { iowrite8((ioread8((p)) &amp; (~(m)))|(x), (p)); } while (0)</span>
<span class="cp">#define WORD_REG_BITS_SET(x, m, p)   do { iowrite16((ioread16((p)) &amp; (~(m)))|(x), (p)); } while (0)</span>
<span class="cp">#define DWORD_REG_BITS_SET(x, m, p)  do { iowrite32((ioread32((p)) &amp; (~(m)))|(x), (p)); } while (0)</span>


<span class="k">static</span> <span class="kt">int</span>  <span class="n">mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">rhine_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rhine_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rhine_slow_event_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rhine_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">rhine_start_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">rhine_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rhine_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rhine_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rhine_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">rhine_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">netdev_ethtool_ops</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">rhine_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rhine_vlan_rx_add_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vid</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rhine_vlan_rx_kill_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vid</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rhine_restart_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_wait_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">low</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">has_mask_bits</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">^</span> <span class="n">has_mask_bits</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s bit wait (%02x/%02x) cycle &quot;</span>
			  <span class="s">&quot;count: %04d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">low</span> <span class="o">?</span> <span class="s">&quot;low&quot;</span> <span class="o">:</span> <span class="s">&quot;high&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_wait_bit_high</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rhine_wait_bit</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_wait_bit_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rhine_wait_bit</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">rhine_get_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intr_status</span><span class="p">;</span>

	<span class="n">intr_status</span> <span class="o">=</span> <span class="n">ioread16</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus</span><span class="p">);</span>
	<span class="cm">/* On Rhine-II, Bit 3 indicates Tx descriptor write-back race. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqStatusWBRace</span><span class="p">)</span>
		<span class="n">intr_status</span> <span class="o">|=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">intr_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_ack_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqStatusWBRace</span><span class="p">)</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus2</span><span class="p">);</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus</span><span class="p">);</span>
	<span class="n">mmiowb</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get power related registers into sane state.</span>
<span class="cm"> * Notify user about past WOL event.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_power_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">wolstat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqWOL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make sure chip is in power state D0 */</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StickyHW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFC</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StickyHW</span><span class="p">);</span>

		<span class="cm">/* Disable &quot;force PME-enable&quot; */</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLcgClr</span><span class="p">);</span>

		<span class="cm">/* Clear power-event config bits (WOL) */</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLcrClr</span><span class="p">);</span>
		<span class="cm">/* More recent cards can manage two additional patterns */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rq6patterns</span><span class="p">)</span>
			<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x03</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLcrClr1</span><span class="p">);</span>

		<span class="cm">/* Save power-event status bits */</span>
		<span class="n">wolstat</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PwrcsrSet</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rq6patterns</span><span class="p">)</span>
			<span class="n">wolstat</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PwrcsrSet1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>

		<span class="cm">/* Clear power-event status bits */</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PwrcsrClr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rq6patterns</span><span class="p">)</span>
			<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x03</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PwrcsrClr1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wolstat</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">wolstat</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">WOLmagic</span>:
				<span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;Magic packet&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">WOLlnkon</span>:
				<span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;Link went up&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">WOLlnkoff</span>:
				<span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;Link went down&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">WOLucast</span>:
				<span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;Unicast packet&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">WOLbmcast</span>:
				<span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;Multicast/broadcast packet&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Woke system up. Reason: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">reason</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_chip_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cmd1</span><span class="p">;</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="n">Cmd1Reset</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd1</span><span class="p">);</span>
	<span class="n">IOSYNC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Cmd1Reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Reset not complete yet. Trying harder.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Force reset */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqForceReset</span><span class="p">)</span>
			<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MiscCmd</span><span class="p">);</span>

		<span class="cm">/* Reset can take somewhat longer (rare) */</span>
		<span class="n">rhine_wait_bit_low</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">ChipCmd1</span><span class="p">,</span> <span class="n">Cmd1Reset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cmd1</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd1</span><span class="p">);</span>
	<span class="n">netif_info</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Reset %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">cmd1</span> <span class="o">&amp;</span> <span class="n">Cmd1Reset</span><span class="p">)</span> <span class="o">?</span>
		   <span class="s">&quot;failed&quot;</span> <span class="o">:</span> <span class="s">&quot;succeeded&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef USE_MMIO</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_mmio</span><span class="p">(</span><span class="kt">long</span> <span class="n">pioaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">quirks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqRhineI</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* More recent docs say that this bit is reserved ... */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">pioaddr</span> <span class="o">+</span> <span class="n">ConfigA</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x20</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">pioaddr</span> <span class="o">+</span> <span class="n">ConfigA</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">pioaddr</span> <span class="o">+</span> <span class="n">ConfigD</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x80</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">pioaddr</span> <span class="o">+</span> <span class="n">ConfigD</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Loads bytes 0x00-0x05, 0x6E-0x6F, 0x78-0x7B from EEPROM</span>
<span class="cm"> * (plus 0x6C for Rhine-I/II)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">rhine_reload_eeprom</span><span class="p">(</span><span class="kt">long</span> <span class="n">pioaddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">pioaddr</span> <span class="o">+</span> <span class="n">MACRegEEcsr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">pioaddr</span> <span class="o">+</span> <span class="n">MACRegEEcsr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%4d cycles used @ %s:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>

<span class="cp">#ifdef USE_MMIO</span>
	<span class="cm">/*</span>
<span class="cm">	 * Reloading from EEPROM overwrites ConfigA-D, so we must re-enable</span>
<span class="cm">	 * MMIO. If reloading EEPROM was done first this could be avoided, but</span>
<span class="cm">	 * it is not known if that still works with the &quot;win98-reboot&quot; problem.</span>
<span class="cm">	 */</span>
	<span class="n">enable_mmio</span><span class="p">(</span><span class="n">pioaddr</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Turn off EEPROM-controlled wake-up (magic packet) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqWOL</span><span class="p">)</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ConfigA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFC</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ConfigA</span><span class="p">);</span>

<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">rhine_interrupt</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_kick_tx_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_thresh</span> <span class="o">&lt;</span> <span class="mh">0xe0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_thresh</span> <span class="o">+=</span> <span class="mh">0x20</span><span class="p">;</span>
		<span class="n">BYTE_REG_BITS_SET</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_thresh</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxConfig</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_tx_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IntrTxAborted</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;Abort %08x, frame dropped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IntrTxUnderrun</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rhine_kick_tx_threshold</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">tx_err</span> <span class="p">,</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Transmitter underrun, &quot;</span>
			   <span class="s">&quot;Tx threshold now %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_thresh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IntrTxDescRace</span><span class="p">)</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tx descriptor write-back race</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IntrTxError</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IntrTxAborted</span> <span class="o">|</span> <span class="n">IntrTxUnderrun</span> <span class="o">|</span> <span class="n">IntrTxDescRace</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rhine_kick_tx_threshold</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unspecified error. &quot;</span>
			   <span class="s">&quot;Tx threshold now %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_thresh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rhine_restart_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_update_rx_crc_and_missed_errord</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span>    <span class="o">+=</span> <span class="n">ioread16</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxCRCErrs</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_missed_errors</span> <span class="o">+=</span> <span class="n">ioread16</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxMissed</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clears the &quot;tally counters&quot; for CRC errors and missed frames(?).</span>
<span class="cm">	 * It has been reported that some chips need a write of 0 to clear</span>
<span class="cm">	 * these, for others the counters are set to 1 when written to and</span>
<span class="cm">	 * instead cleared when read. So we clear them both ways ...</span>
<span class="cm">	 */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxMissed</span><span class="p">);</span>
	<span class="n">ioread16</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxCRCErrs</span><span class="p">);</span>
	<span class="n">ioread16</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxMissed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define RHINE_EVENT_NAPI_RX	(IntrRxDone | \</span>
<span class="cp">				 IntrRxErr | \</span>
<span class="cp">				 IntrRxEmpty | \</span>
<span class="cp">				 IntrRxOverflow	| \</span>
<span class="cp">				 IntrRxDropped | \</span>
<span class="cp">				 IntrRxNoBuf | \</span>
<span class="cp">				 IntrRxWakeUp)</span>

<span class="cp">#define RHINE_EVENT_NAPI_TX_ERR	(IntrTxError | \</span>
<span class="cp">				 IntrTxAborted | \</span>
<span class="cp">				 IntrTxUnderrun | \</span>
<span class="cp">				 IntrTxDescRace)</span>
<span class="cp">#define RHINE_EVENT_NAPI_TX	(IntrTxDone | RHINE_EVENT_NAPI_TX_ERR)</span>

<span class="cp">#define RHINE_EVENT_NAPI	(RHINE_EVENT_NAPI_RX | \</span>
<span class="cp">				 RHINE_EVENT_NAPI_TX | \</span>
<span class="cp">				 IntrStatsMax)</span>
<span class="cp">#define RHINE_EVENT_SLOW	(IntrPCIErr | IntrLinkChange)</span>
<span class="cp">#define RHINE_EVENT		(RHINE_EVENT_NAPI | RHINE_EVENT_SLOW)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rhine_napipoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rhine_private</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">enable_mask</span> <span class="o">=</span> <span class="n">RHINE_EVENT</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">rhine_get_events</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="n">rhine_ack_events</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RHINE_EVENT_SLOW</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RHINE_EVENT_NAPI_RX</span><span class="p">)</span>
		<span class="n">work_done</span> <span class="o">+=</span> <span class="n">rhine_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RHINE_EVENT_NAPI_TX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RHINE_EVENT_NAPI_TX_ERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Avoid scavenging before Tx engine turned off */</span>
			<span class="n">rhine_wait_bit_low</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">ChipCmd</span><span class="p">,</span> <span class="n">CmdTxOn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CmdTxOn</span><span class="p">)</span>
				<span class="n">netif_warn</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tx still on</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">rhine_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RHINE_EVENT_NAPI_TX_ERR</span><span class="p">)</span>
			<span class="n">rhine_tx_err</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IntrStatsMax</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">rhine_update_rx_crc_and_missed_errord</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RHINE_EVENT_SLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enable_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RHINE_EVENT_SLOW</span><span class="p">;</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">slow_event_task</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">iowrite16</span><span class="p">(</span><span class="n">enable_mask</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrEnable</span><span class="p">);</span>
		<span class="n">mmiowb</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">rhine_hw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pioaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Reset the chip to erase previous misconfiguration. */</span>
	<span class="n">rhine_chip_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Rhine-I needs extra time to recuperate before EEPROM reload */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqRhineI</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

	<span class="cm">/* Reload EEPROM controlled bytes cleared by soft reset */</span>
	<span class="n">rhine_reload_eeprom</span><span class="p">(</span><span class="n">pioaddr</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">rhine_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		 <span class="o">=</span> <span class="n">rhine_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		 <span class="o">=</span> <span class="n">rhine_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		 <span class="o">=</span> <span class="n">rhine_start_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		 <span class="o">=</span> <span class="n">rhine_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	 <span class="o">=</span> <span class="n">rhine_set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		 <span class="o">=</span> <span class="n">eth_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	 <span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> 	 <span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		 <span class="o">=</span> <span class="n">netdev_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span> 	 <span class="o">=</span> <span class="n">rhine_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_add_vid</span>	 <span class="o">=</span> <span class="n">rhine_vlan_rx_add_vid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_kill_vid</span>	 <span class="o">=</span> <span class="n">rhine_vlan_rx_kill_vid</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	 <span class="o">=</span> <span class="n">rhine_poll</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">rhine_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">quirks</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">pioaddr</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">memaddr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">io_size</span><span class="p">,</span> <span class="n">phy_id</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="cp">#ifdef USE_MMIO</span>
	<span class="kt">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* when built into the kernel, we only print version if device is found */</span>
<span class="cp">#ifndef MODULE</span>
	<span class="n">pr_info_once</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">io_size</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
	<span class="n">phy_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">quirks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Rhine&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="n">VTunknown0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">quirks</span> <span class="o">=</span> <span class="n">rqRhineI</span><span class="p">;</span>
		<span class="n">io_size</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">VT6102</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">quirks</span> <span class="o">=</span> <span class="n">rqWOL</span> <span class="o">|</span> <span class="n">rqForceReset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="n">VT6105</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Rhine II&quot;</span><span class="p">;</span>
			<span class="n">quirks</span> <span class="o">|=</span> <span class="n">rqStatusWBRace</span><span class="p">;</span>	<span class="cm">/* Rhine-II exclusive */</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">phy_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Integrated PHY, phy_id fixed to 1 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">VT6105_B0</span><span class="p">)</span>
				<span class="n">quirks</span> <span class="o">|=</span> <span class="n">rq6patterns</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="n">VT6105M</span><span class="p">)</span>
				<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Rhine III&quot;</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Rhine III (Management Adapter)&quot;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="cm">/* this should always be supported */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;32-bit PCI DMA addresses not supported by the card!?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">io_size</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">io_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Insufficient PCI resources, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pioaddr</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">memaddr</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">=</span> <span class="n">quirks</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">pioaddr</span> <span class="o">=</span> <span class="n">pioaddr</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">netif_msg_init</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">RHINE_MSG_DEFAULT</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_free_netdev</span><span class="p">;</span>

	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="n">io_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;ioremap failed for device %s, region 0x%X @ 0x%lX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="n">io_size</span><span class="p">,</span> <span class="n">memaddr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_free_res</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef USE_MMIO</span>
	<span class="n">enable_mmio</span><span class="p">(</span><span class="n">pioaddr</span><span class="p">,</span> <span class="n">quirks</span><span class="p">);</span>

	<span class="cm">/* Check that selected MMIO registers match the PIO ones */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mmio_verify_registers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">mmio_verify_registers</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">pioaddr</span><span class="o">+</span><span class="n">reg</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;MMIO do not match PIO [%02x] (%02x != %02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">reg</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out_unmap</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* USE_MMIO */</span><span class="cp"></span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="p">;</span>

	<span class="cm">/* Get chip registers into a sane state */</span>
	<span class="n">rhine_power_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rhine_hw_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pioaddr</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StationAddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Report it and use a random ethernet address instead */</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid MAC address: %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
		<span class="n">eth_hw_addr_random</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Using random MAC address: %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="cm">/* For Rhine-I/II, phy_id is loaded from EEPROM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy_id</span><span class="p">)</span>
		<span class="n">phy_id</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x6C</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">,</span> <span class="n">rhine_reset_task</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">slow_event_task</span><span class="p">,</span> <span class="n">rhine_slow_event_task</span><span class="p">);</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">mdio_read</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">mdio_write</span> <span class="o">=</span> <span class="n">mdio_write</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">reg_num_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>

	<span class="cm">/* The chip-specific entries in the device structure. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rhine_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">netdev_ethtool_ops</span><span class="p">,</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TX_TIMEOUT</span><span class="p">;</span>

	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">rhine_napipoll</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqRhineI</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_SG</span><span class="o">|</span><span class="n">NETIF_F_HW_CSUM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">VT6105M</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_VLAN_TX</span> <span class="o">|</span> <span class="n">NETIF_F_HW_VLAN_RX</span> <span class="o">|</span>
		<span class="n">NETIF_F_HW_VLAN_FILTER</span><span class="p">;</span>

	<span class="cm">/* dev-&gt;name not defined before register_netdev()! */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_unmap</span><span class="p">;</span>

	<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VIA %s at 0x%lx, %pM, IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">name</span><span class="p">,</span>
<span class="cp">#ifdef USE_MMIO</span>
		    <span class="n">memaddr</span><span class="p">,</span>
<span class="cp">#else</span>
		    <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">ioaddr</span><span class="p">,</span>
<span class="cp">#endif</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="p">{</span>
		<span class="n">u16</span> <span class="n">mii_cmd</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">mii_status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">phy_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mii_cmd</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">phy_id</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BMCR_ISOLATE</span><span class="p">;</span>
		<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">phy_id</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">mii_cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mii_status</span> <span class="o">!=</span> <span class="mh">0xffff</span> <span class="o">&amp;&amp;</span> <span class="n">mii_status</span> <span class="o">!=</span> <span class="mh">0x0000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">advertising</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">phy_id</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				    <span class="s">&quot;MII PHY found at address %d, status 0x%04x advertising %04x Link %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">phy_id</span><span class="p">,</span>
				    <span class="n">mii_status</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">advertising</span><span class="p">,</span>
				    <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">phy_id</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>

			<span class="cm">/* set IFF_RUNNING */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mii_status</span> <span class="o">&amp;</span> <span class="n">BMSR_LSTATUS</span><span class="p">)</span>
				<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">phy_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">avoid_D3</span><span class="p">)</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No D3 power state at shutdown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_unmap:</span>
	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">);</span>
<span class="nl">err_out_free_res:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">err_out_free_netdev:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">ring_dma</span><span class="p">;</span>

	<span class="n">ring</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="n">RX_RING_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">)</span> <span class="o">+</span>
				    <span class="n">TX_RING_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">),</span>
				    <span class="o">&amp;</span><span class="n">ring_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate DMA memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqRhineI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_bufs</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						   <span class="n">PKT_BUF_SZ</span> <span class="o">*</span> <span class="n">TX_RING_SIZE</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_bufs_dma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_bufs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="n">RX_RING_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">)</span> <span class="o">+</span>
				    <span class="n">TX_RING_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">),</span>
				    <span class="n">ring</span><span class="p">,</span> <span class="n">ring_dma</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">ring</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">ring</span> <span class="o">+</span> <span class="n">RX_RING_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">);</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span> <span class="o">=</span> <span class="n">ring_dma</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span> <span class="o">=</span> <span class="n">ring_dma</span> <span class="o">+</span> <span class="n">RX_RING_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			    <span class="n">RX_RING_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">)</span> <span class="o">+</span>
			    <span class="n">TX_RING_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">),</span>
			    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">);</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_bufs</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PKT_BUF_SZ</span> <span class="o">*</span> <span class="n">TX_RING_SIZE</span><span class="p">,</span>
				    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_bufs</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_bufs_dma</span><span class="p">);</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_bufs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">alloc_rbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dma_addr_t</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&lt;=</span> <span class="mi">1500</span> <span class="o">?</span> <span class="n">PKT_BUF_SZ</span> <span class="o">:</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_head_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">;</span>

	<span class="cm">/* Init the ring entries */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">);</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_desc</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Mark the last entry as wrapping the ring. */</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">next_desc</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">);</span>

	<span class="cm">/* Fill in the Rx buffers.  Handle allocation failure gracefully. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">);</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff_dma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">pci_map_single</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span>
				       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff_dma</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_status</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">i</span> <span class="o">-</span> <span class="n">RX_RING_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_rbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Free all the skbuffs in the Rx queue. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xBADF00D0</span><span class="p">);</span> <span class="cm">/* An invalid address. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					 <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff_dma</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					 <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">alloc_tbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dma_addr_t</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">TXDESC</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">);</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_desc</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqRhineI</span><span class="p">)</span>
			<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_bufs</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">PKT_BUF_SZ</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">next_desc</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_tbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">TXDESC</span><span class="p">);</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xBADF00D0</span><span class="p">);</span> <span class="cm">/* An invalid address. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff_dma</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						 <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff_dma</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						 <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_check_media</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">init_media</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">mii_check_media</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">netif_msg_link</span><span class="p">(</span><span class="n">rp</span><span class="p">),</span> <span class="n">init_media</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">full_duplex</span><span class="p">)</span>
	    <span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Cmd1FDuplex</span><span class="p">,</span>
		   <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd1</span><span class="p">);</span>
	<span class="k">else</span>
	    <span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">Cmd1FDuplex</span><span class="p">,</span>
		   <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd1</span><span class="p">);</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;force_media %d, carrier %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">force_media</span><span class="p">,</span> <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Called after status of force_media possibly changed */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_set_carrier</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_if_info</span> <span class="o">*</span><span class="n">mii</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">mii</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mii</span><span class="o">-&gt;</span><span class="n">force_media</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* autoneg is off: Link is always assumed to be up */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>	<span class="cm">/* Let MMI library update carrier status */</span>
		<span class="n">rhine_check_media</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;force_media %d, carrier %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">mii</span><span class="o">-&gt;</span><span class="n">force_media</span><span class="p">,</span> <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rhine_set_cam - set CAM multicast filters</span>
<span class="cm"> * @ioaddr: register block of this Rhine</span>
<span class="cm"> * @idx: multicast CAM index [0..MCAM_SIZE-1]</span>
<span class="cm"> * @addr: multicast address (6 bytes)</span>
<span class="cm"> *</span>
<span class="cm"> * Load addresses into multicast filters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_set_cam</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="n">CAMC_CAMEN</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamCon</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="cm">/* Paranoid -- idx out of range should never happen */</span>
	<span class="n">idx</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">MCAM_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">iowrite8</span><span class="p">((</span><span class="n">u8</span><span class="p">)</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamAddr</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span><span class="o">++</span><span class="p">)</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MulticastFilter0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="n">CAMC_CAMWR</span> <span class="o">|</span> <span class="n">CAMC_CAMEN</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamCon</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamCon</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rhine_set_vlan_cam - set CAM VLAN filters</span>
<span class="cm"> * @ioaddr: register block of this Rhine</span>
<span class="cm"> * @idx: VLAN CAM index [0..VCAM_SIZE-1]</span>
<span class="cm"> * @addr: VLAN ID (2 bytes)</span>
<span class="cm"> *</span>
<span class="cm"> * Load addresses into VLAN filters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_set_vlan_cam</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">CAMC_CAMEN</span> <span class="o">|</span> <span class="n">CAMC_VCAMSL</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamCon</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="cm">/* Paranoid -- idx out of range should never happen */</span>
	<span class="n">idx</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">VCAM_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">iowrite8</span><span class="p">((</span><span class="n">u8</span><span class="p">)</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamAddr</span><span class="p">);</span>

	<span class="n">iowrite16</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">),</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MulticastFilter0</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="n">CAMC_CAMWR</span> <span class="o">|</span> <span class="n">CAMC_CAMEN</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamCon</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamCon</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rhine_set_cam_mask - set multicast CAM mask</span>
<span class="cm"> * @ioaddr: register block of this Rhine</span>
<span class="cm"> * @mask: multicast CAM mask</span>
<span class="cm"> *</span>
<span class="cm"> * Mask sets multicast filters active/inactive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_set_cam_mask</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">CAMC_CAMEN</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamCon</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="cm">/* write mask */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamMask</span><span class="p">);</span>

	<span class="cm">/* disable CAMEN */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamCon</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rhine_set_vlan_cam_mask - set VLAN CAM mask</span>
<span class="cm"> * @ioaddr: register block of this Rhine</span>
<span class="cm"> * @mask: VLAN CAM mask</span>
<span class="cm"> *</span>
<span class="cm"> * Mask sets VLAN filters active/inactive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_set_vlan_cam_mask</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">CAMC_CAMEN</span> <span class="o">|</span> <span class="n">CAMC_VCAMSL</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamCon</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="cm">/* write mask */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamMask</span><span class="p">);</span>

	<span class="cm">/* disable CAMEN */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CamCon</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rhine_init_cam_filter - initialize CAM filters</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize (disable) hardware VLAN and multicast support on this</span>
<span class="cm"> * Rhine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_init_cam_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="cm">/* Disable all CAMs */</span>
	<span class="n">rhine_set_vlan_cam_mask</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rhine_set_cam_mask</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* disable hardware VLAN support */</span>
	<span class="n">BYTE_REG_BITS_ON</span><span class="p">(</span><span class="n">TCR_PQEN</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxConfig</span><span class="p">);</span>
	<span class="n">BYTE_REG_BITS_OFF</span><span class="p">(</span><span class="n">BCR1_VIDFR</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PCIBusConfig1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rhine_update_vcam - update VLAN CAM filters</span>
<span class="cm"> * @rp: rhine_private data of this Rhine</span>
<span class="cm"> *</span>
<span class="cm"> * Update VLAN CAM filters to match configuration change.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_update_vcam</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vCAMmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* 32 vCAMs (6105M and better) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">,</span> <span class="n">VLAN_N_VID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rhine_set_vlan_cam</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vid</span><span class="p">);</span>
		<span class="n">vCAMmask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">VCAM_SIZE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rhine_set_vlan_cam_mask</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">vCAMmask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rhine_vlan_rx_add_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>
	<span class="n">rhine_update_vcam</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rhine_vlan_rx_kill_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>
	<span class="n">rhine_update_vcam</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StationAddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/* Initialize other registers. */</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="mh">0x0006</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PCIBusConfig</span><span class="p">);</span>	<span class="cm">/* Tune configuration??? */</span>
	<span class="cm">/* Configure initial FIFO thresholds. */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxConfig</span><span class="p">);</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_thresh</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_thresh</span> <span class="o">=</span> <span class="mh">0x60</span><span class="p">;</span>		<span class="cm">/* Written in rhine_set_rx_mode(). */</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxRingPtr</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxRingPtr</span><span class="p">);</span>

	<span class="n">rhine_set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">VT6105M</span><span class="p">)</span>
		<span class="n">rhine_init_cam_filter</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">iowrite16</span><span class="p">(</span><span class="n">RHINE_EVENT</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrEnable</span><span class="p">);</span>

	<span class="n">iowrite16</span><span class="p">(</span><span class="n">CmdStart</span> <span class="o">|</span> <span class="n">CmdTxOn</span> <span class="o">|</span> <span class="n">CmdRxOn</span> <span class="o">|</span> <span class="p">(</span><span class="n">Cmd1NoTxPoll</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
	       <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>
	<span class="n">rhine_check_media</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Enable MII link status auto-polling (required for IntrLinkChange) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_enable_linkmon</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIICmd</span><span class="p">);</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">MII_BMSR</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIIRegAddr</span><span class="p">);</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIICmd</span><span class="p">);</span>

	<span class="n">rhine_wait_bit_high</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">MIIRegAddr</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="n">MII_BMSR</span> <span class="o">|</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIIRegAddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Disable MII link status auto-polling (required for MDIO access) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_disable_linkmon</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIICmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqRhineI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIIRegAddr</span><span class="p">);</span>	<span class="c1">// MII_BMSR</span>

		<span class="cm">/* Can be called from ISR. Evil. */</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* 0x80 must be set immediately before turning it off */</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIICmd</span><span class="p">);</span>

		<span class="n">rhine_wait_bit_high</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">MIIRegAddr</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>

		<span class="cm">/* Heh. Now clear 0x80 again. */</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIICmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">rhine_wait_bit_high</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">MIIRegAddr</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Read and write over the MII Management Data I/O (MDIO) interface. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">rhine_disable_linkmon</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>

	<span class="cm">/* rhine_disable_linkmon already cleared MIICmd */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">phy_id</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIIPhyAddr</span><span class="p">);</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">regnum</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIIRegAddr</span><span class="p">);</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIICmd</span><span class="p">);</span>		<span class="cm">/* Trigger read */</span>
	<span class="n">rhine_wait_bit_low</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">MIICmd</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">ioread16</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIIData</span><span class="p">);</span>

	<span class="n">rhine_enable_linkmon</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">rhine_disable_linkmon</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>

	<span class="cm">/* rhine_disable_linkmon already cleared MIICmd */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">phy_id</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIIPhyAddr</span><span class="p">);</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">regnum</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIIRegAddr</span><span class="p">);</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIIData</span><span class="p">);</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIICmd</span><span class="p">);</span>		<span class="cm">/* Trigger write */</span>
	<span class="n">rhine_wait_bit_low</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">MIICmd</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>

	<span class="n">rhine_enable_linkmon</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_task_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">slow_event_task</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_task_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_enable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rhine_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">rhine_interrupt</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s() irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">alloc_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">alloc_rbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">alloc_tbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rhine_chip_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rhine_task_enable</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="n">init_registers</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">ifup</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s() Done - status %04x MII status: %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">__func__</span><span class="p">,</span> <span class="n">ioread16</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">),</span>
		  <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">));</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rhine_private</span><span class="p">,</span>
						<span class="n">reset_task</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_enable</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* clear all descriptors */</span>
	<span class="n">free_tbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">free_rbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">alloc_tbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">alloc_rbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Reinitialize the hardware. */</span>
	<span class="n">rhine_chip_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">init_registers</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Transmit timed out, status %04x, PHY status %04x, resetting...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">ioread16</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus</span><span class="p">),</span>
		    <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">));</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">rhine_start_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">entry</span><span class="p">;</span>

	<span class="cm">/* Caution: the write order is important here, set the field</span>
<span class="cm">	   with the &quot;ownership&quot; bits last. */</span>

	<span class="cm">/* Calculate the next Tx descriptor entry. */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">%</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_padto</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_ZLEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqRhineI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Must use alignment buffer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">PKT_BUF_SZ</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* packet too long, drop it */</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Padding is not copied and so must be redone. */</span>
		<span class="n">skb_copy_and_csum_dev</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ETH_ZLEN</span><span class="p">)</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			       <span class="n">ETH_ZLEN</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_bufs_dma</span> <span class="o">+</span>
						      <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">-</span>
						       <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_bufs</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">pci_map_single</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				       <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">desc_length</span> <span class="o">=</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">TXDESC</span> <span class="o">|</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">ETH_ZLEN</span> <span class="o">?</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">:</span> <span class="n">ETH_ZLEN</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">tx_status</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="cm">/* request tagging */</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">desc_length</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x020000</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">tx_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* lock eth irq */</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">tx_status</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Non-x86 Todo: explicitly flush cache lines here. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="cm">/* Tx queues are bits 7-0 (first Tx queue: bit 7) */</span>
		<span class="n">BYTE_REG_BITS_ON</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TQWake</span><span class="p">);</span>

	<span class="cm">/* Wake the potentially-idle transmit channel */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Cmd1TxDemand</span><span class="p">,</span>
	       <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd1</span><span class="p">);</span>
	<span class="n">IOSYNC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">==</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">+</span> <span class="n">TX_QUEUE_LEN</span><span class="p">)</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">tx_queued</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Transmit frame #%d queued in slot %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">rp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_irq_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">IntrEnable</span><span class="p">);</span>
	<span class="n">mmiowb</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* The interrupt handler does all of the Rx thread work and cleans up</span>
<span class="cm">   after the Tx thread. */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">rhine_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">rhine_get_events</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Interrupt, status %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RHINE_EVENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">rhine_irq_disable</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">IntrLinkChange</span> <span class="o">|</span> <span class="n">IntrStatsMax</span> <span class="o">|</span> <span class="n">RHINE_EVENT_NAPI</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_err</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Something Wicked happened! %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This routine is logically part of the interrupt handler, but isolated</span>
<span class="cm">   for clarity. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">txstatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">%</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>

	<span class="cm">/* find and cleanup dirty tx descriptors */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">!=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">txstatus</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">tx_status</span><span class="p">);</span>
		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">tx_done</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tx scavenge %d status %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">entry</span><span class="p">,</span> <span class="n">txstatus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">txstatus</span> <span class="o">&amp;</span> <span class="n">DescOwn</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">txstatus</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">tx_done</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				  <span class="s">&quot;Transmit error, Tx status %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txstatus</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">txstatus</span> <span class="o">&amp;</span> <span class="mh">0x0400</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_carrier_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">txstatus</span> <span class="o">&amp;</span> <span class="mh">0x0200</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">txstatus</span> <span class="o">&amp;</span> <span class="mh">0x0100</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">txstatus</span> <span class="o">&amp;</span> <span class="mh">0x0080</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_heartbeat_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqRhineI</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">txstatus</span> <span class="o">&amp;</span> <span class="mh">0x0002</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">txstatus</span> <span class="o">&amp;</span> <span class="mh">0x0800</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">txstatus</span> <span class="o">&amp;</span> <span class="mh">0x1000</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">tx_status</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* Keep the skb - we try again */</span>
			<span class="p">}</span>
			<span class="cm">/* Transmitter restarted in &#39;abnormal&#39; handler. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqRhineI</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span> <span class="o">+=</span> <span class="p">(</span><span class="n">txstatus</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span> <span class="o">+=</span> <span class="n">txstatus</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
			<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">tx_done</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;collisions: %1.1x:%1.1x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">txstatus</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="n">txstatus</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Free the original skb. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					 <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
					 <span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">)</span> <span class="o">%</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">TX_QUEUE_LEN</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rhine_get_vlan_tci - extract TCI from Rx data buffer</span>
<span class="cm"> * @skb: pointer to sk_buff</span>
<span class="cm"> * @data_size: used data area of the buffer including CRC</span>
<span class="cm"> *</span>
<span class="cm"> * If hardware VLAN tag extraction is enabled and the chip indicates a 802.1Q</span>
<span class="cm"> * packet, the extracted 802.1Q header (2 bytes TPID + 2 bytes TCI) is 4-byte</span>
<span class="cm"> * aligned following the CRC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">rhine_get_vlan_tci</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">trailer</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="p">((</span><span class="n">data_size</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">be16_to_cpup</span><span class="p">((</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span><span class="n">trailer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Process up to limit frames from receive ring */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rhine_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">rx_status</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s(), entry %d status %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		  <span class="n">entry</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_head_desc</span><span class="o">-&gt;</span><span class="n">rx_status</span><span class="p">));</span>

	<span class="cm">/* If EOP is set on the next entry, it&#39;s a new packet. Send it up. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="o">++</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_head_desc</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">desc_status</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">rx_status</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">desc_length</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">desc_length</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">data_size</span> <span class="o">=</span> <span class="n">desc_status</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="n">DescOwn</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">rx_status</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s() status %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			  <span class="n">desc_status</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RxWholePkt</span> <span class="o">|</span> <span class="n">RxErr</span><span class="p">))</span> <span class="o">!=</span> <span class="n">RxWholePkt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="n">RxWholePkt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RxWholePkt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
	<span class="s">&quot;Oversized Ethernet frame spanned multiple buffers, &quot;</span>
	<span class="s">&quot;entry %#x length %d status %08x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">entry</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span>
					    <span class="n">desc_status</span><span class="p">);</span>
				<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					    <span class="s">&quot;Oversized Ethernet frame %p vs %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_head_desc</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="n">RxErr</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* There was a error. */</span>
				<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
					  <span class="s">&quot;%s() Rx error %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
					  <span class="n">desc_status</span><span class="p">);</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="mh">0x0030</span><span class="p">)</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="mh">0x0048</span><span class="p">)</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="mh">0x0004</span><span class="p">)</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="mh">0x0002</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* this can also be updated outside the interrupt handler */</span>
					<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="cm">/* Length should omit the CRC */</span>
			<span class="kt">int</span> <span class="n">pkt_len</span> <span class="o">=</span> <span class="n">data_size</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">vlan_tci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Check if the packet is long enough to accept without</span>
<span class="cm">			   copying to a minimally-sized skbuff. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&lt;</span> <span class="n">rx_copybreak</span><span class="p">)</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
							    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
							    <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span>
							    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

				<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
						 <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						 <span class="n">pkt_len</span><span class="p">);</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>
				<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
							       <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
							       <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span>
							       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Inconsistent Rx descriptor chain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>
				<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						 <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
						 <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span>
						 <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">desc_length</span> <span class="o">&amp;</span> <span class="n">DescTag</span><span class="p">))</span>
				<span class="n">vlan_tci</span> <span class="o">=</span> <span class="n">rhine_get_vlan_tci</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>

			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">desc_length</span> <span class="o">&amp;</span> <span class="n">DescTag</span><span class="p">))</span>
				<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vlan_tci</span><span class="p">);</span>
			<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">pkt_len</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">)</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_head_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/* Refill the Rx ring buffers. */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">-</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">);</span>
			<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>	<span class="cm">/* Better luck next round. */</span>
			<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">pci_map_single</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
					       <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span>
					       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_skbuff_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">rx_status</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_restart_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">%</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intr_status</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If new errors occurred, we need to sort them out before doing Tx.</span>
<span class="cm">	 * In that case the ISR will be back here RSN anyway.</span>
<span class="cm">	 */</span>
	<span class="n">intr_status</span> <span class="o">=</span> <span class="n">rhine_get_events</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">IntrTxErrSummary</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* We know better than the chip where it should continue. */</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span> <span class="o">+</span> <span class="n">entry</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">),</span>
		       <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxRingPtr</span><span class="p">);</span>

		<span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">)</span> <span class="o">|</span> <span class="n">CmdTxOn</span><span class="p">,</span>
		       <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">desc_length</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x020000</span><span class="p">))</span>
			<span class="cm">/* Tx queues are bits 7-0 (first Tx queue: bit 7) */</span>
			<span class="n">BYTE_REG_BITS_ON</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TQWake</span><span class="p">);</span>

		<span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Cmd1TxDemand</span><span class="p">,</span>
		       <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd1</span><span class="p">);</span>
		<span class="n">IOSYNC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* This should never happen */</span>
		<span class="n">netif_warn</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;another error occurred %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">intr_status</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_slow_event_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rhine_private</span><span class="p">,</span> <span class="n">slow_event_task</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intr_status</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_enable</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">intr_status</span> <span class="o">=</span> <span class="n">rhine_get_events</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="n">rhine_ack_events</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">RHINE_EVENT_SLOW</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">IntrLinkChange</span><span class="p">)</span>
		<span class="n">rhine_check_media</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">IntrPCIErr</span><span class="p">)</span>
		<span class="n">netif_warn</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCI error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">rhine_irq_disable</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="cm">/* Slow and safe. Consider __napi_schedule as a replacement ? */</span>
	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">rhine_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rhine_update_rx_crc_and_missed_errord</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mc_filter</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* Multicast hash filter */</span>
	<span class="n">u8</span> <span class="n">rx_mode</span> <span class="o">=</span> <span class="mh">0x0C</span><span class="p">;</span>	<span class="cm">/* Note: 0x02=accept runt, 0x01=accept errs */</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* Set promiscuous. */</span>
		<span class="n">rx_mode</span> <span class="o">=</span> <span class="mh">0x1C</span><span class="p">;</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MulticastFilter0</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MulticastFilter1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">multicast_filter_limit</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Too many to match, or accept all multicasts. */</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MulticastFilter0</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MulticastFilter1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">VT6105M</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">mCAMmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* 32 mCAMs (6105M and better) */</span>
		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MCAM_SIZE</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">rhine_set_cam</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">mCAMmask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rhine_set_cam_mask</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">mCAMmask</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">mc_filter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mc_filter</span><span class="p">));</span>
		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">bit_nr</span> <span class="o">=</span> <span class="n">ether_crc</span><span class="p">(</span><span class="n">ETH_ALEN</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">;</span>

			<span class="n">mc_filter</span><span class="p">[</span><span class="n">bit_nr</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bit_nr</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">mc_filter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MulticastFilter0</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">mc_filter</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MulticastFilter1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* enable/disable VLAN receive filtering */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">VT6105M</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
			<span class="n">BYTE_REG_BITS_OFF</span><span class="p">(</span><span class="n">BCR1_VIDFR</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PCIBusConfig1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">BYTE_REG_BITS_ON</span><span class="p">(</span><span class="n">BCR1_VIDFR</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PCIBusConfig1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BYTE_REG_BITS_ON</span><span class="p">(</span><span class="n">rx_mode</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxConfig</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mii_ethtool_gset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_set_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mii_ethtool_sset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">rhine_set_carrier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_nway_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mii_nway_restart</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">netdev_get_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mii_link_ok</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">netdev_get_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_set_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_get_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqWOL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">wol</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">=</span> <span class="n">WAKE_PHY</span> <span class="o">|</span> <span class="n">WAKE_MAGIC</span> <span class="o">|</span>
			 <span class="n">WAKE_UCAST</span> <span class="o">|</span> <span class="n">WAKE_MCAST</span> <span class="o">|</span> <span class="n">WAKE_BCAST</span><span class="p">;</span>	<span class="cm">/* Untested */</span>
	<span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">wolopts</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rhine_set_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">support</span> <span class="o">=</span> <span class="n">WAKE_PHY</span> <span class="o">|</span> <span class="n">WAKE_MAGIC</span> <span class="o">|</span>
		      <span class="n">WAKE_UCAST</span> <span class="o">|</span> <span class="n">WAKE_MCAST</span> <span class="o">|</span> <span class="n">WAKE_BCAST</span><span class="p">;</span>	<span class="cm">/* Untested */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqWOL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">support</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">=</span> <span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">netdev_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_drvinfo</span>		<span class="o">=</span> <span class="n">netdev_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_settings</span>		<span class="o">=</span> <span class="n">netdev_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span>		<span class="o">=</span> <span class="n">netdev_set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nway_reset</span>		<span class="o">=</span> <span class="n">netdev_nway_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span>		<span class="o">=</span> <span class="n">netdev_get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span>		<span class="o">=</span> <span class="n">netdev_get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span>		<span class="o">=</span> <span class="n">netdev_set_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_wol</span>		<span class="o">=</span> <span class="n">rhine_get_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_wol</span>		<span class="o">=</span> <span class="n">rhine_set_wol</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">generic_mii_ioctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">cmd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">rhine_set_carrier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">task_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rhine_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">rhine_task_disable</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">ifdown</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Shutting down ethercard, status was %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">ioread16</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">));</span>

	<span class="cm">/* Switch to loopback mode to avoid hardware races. */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">tx_thresh</span> <span class="o">|</span> <span class="mh">0x02</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxConfig</span><span class="p">);</span>

	<span class="n">rhine_irq_disable</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>

	<span class="cm">/* Stop the chip&#39;s Tx and Rx processes. */</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">CmdStop</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">free_rbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">free_tbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">free_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">rhine_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rhine_shutdown</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rqWOL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* Nothing to do for non-WOL adapters */</span>

	<span class="n">rhine_power_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Make sure we use pattern 0, 1 and not 4, 5 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">rq6patterns</span><span class="p">)</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x04</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLcgClr</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">&amp;</span> <span class="n">WAKE_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">WOLmagic</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLcrSet</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Turn EEPROM-controlled wake-up back on -- some hardware may</span>
<span class="cm">		 * not cooperate otherwise.</span>
<span class="cm">		 */</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ConfigA</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x03</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ConfigA</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">WAKE_BCAST</span><span class="o">|</span><span class="n">WAKE_MCAST</span><span class="p">))</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">WOLbmcast</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLcgSet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">&amp;</span> <span class="n">WAKE_PHY</span><span class="p">)</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">WOLlnkon</span> <span class="o">|</span> <span class="n">WOLlnkoff</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLcrSet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">wolopts</span> <span class="o">&amp;</span> <span class="n">WAKE_UCAST</span><span class="p">)</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">WOLucast</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLcrSet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">wolopts</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable legacy WOL (for old motherboards) */</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PwcfgSet</span><span class="p">);</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StickyHW</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x04</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StickyHW</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_POWER_OFF</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">avoid_D3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StickyHW</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x03</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StickyHW</span><span class="p">);</span>

		<span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rhine_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rhine_task_disable</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="n">rhine_irq_disable</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">rhine_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rhine_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rhine_private</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef USE_MMIO</span>
	<span class="n">enable_mmio</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">pioaddr</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">rhine_power_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">free_tbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">free_rbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">alloc_tbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">alloc_rbufs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rhine_task_enable</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_registers</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">SIMPLE_DEV_PM_OPS</span><span class="p">(</span><span class="n">rhine_pm_ops</span><span class="p">,</span> <span class="n">rhine_suspend</span><span class="p">,</span> <span class="n">rhine_resume</span><span class="p">);</span>
<span class="cp">#define RHINE_PM_OPS	(&amp;rhine_pm_ops)</span>

<span class="cp">#else</span>

<span class="cp">#define RHINE_PM_OPS	NULL</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">rhine_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">rhine_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">rhine_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">rhine_remove_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">rhine_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">pm</span>	<span class="o">=</span> <span class="n">RHINE_PM_OPS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="n">__initdata</span> <span class="n">rhine_dmi_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">ident</span> <span class="o">=</span> <span class="s">&quot;EPIA-M&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Award Software International, Inc.&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;6.00 PG&quot;</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">ident</span> <span class="o">=</span> <span class="s">&quot;KV7&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies, LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;6.00 PG&quot;</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">rhine_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* when a module, this is printed whether or not devices are found in probe */</span>
<span class="cp">#ifdef MODULE</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmi_check_system</span><span class="p">(</span><span class="n">rhine_dmi_table</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* these BIOSes fail at PXE boot if chip is in D3 */</span>
		<span class="n">avoid_D3</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Broken BIOS detected, avoid_D3 enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">avoid_D3</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;avoid_D3 set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhine_driver</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">rhine_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhine_driver</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">module_init</span><span class="p">(</span><span class="n">rhine_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">rhine_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
