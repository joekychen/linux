<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › natsemi › natsemi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>natsemi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* natsemi.c: A Linux PCI Ethernet driver for the NatSemi DP8381x series. */</span>
<span class="cm">/*</span>
<span class="cm">	Written/copyright 1999-2001 by Donald Becker.</span>
<span class="cm">	Portions copyright (c) 2001,2002 Sun Microsystems (thockin@sun.com)</span>
<span class="cm">	Portions copyright 2001,2002 Manfred Spraul (manfred@colorfullife.com)</span>
<span class="cm">	Portions copyright 2004 Harald Welte &lt;laforge@gnumonks.org&gt;</span>

<span class="cm">	This software may be used and distributed according to the terms of</span>
<span class="cm">	the GNU General Public License (GPL), incorporated herein by reference.</span>
<span class="cm">	Drivers based on or derived from this code fall under the GPL and must</span>
<span class="cm">	retain the authorship, copyright and license notice.  This file is not</span>
<span class="cm">	a complete program and may only be used when the entire operating</span>
<span class="cm">	system is licensed under the GPL.  License for under other terms may be</span>
<span class="cm">	available.  Contact the original author for details.</span>

<span class="cm">	The original author may be reached as becker@scyld.com, or at</span>
<span class="cm">	Scyld Computing Corporation</span>
<span class="cm">	410 Severn Ave., Suite 210</span>
<span class="cm">	Annapolis MD 21403</span>

<span class="cm">	Support information and updates available at</span>
<span class="cm">	http://www.scyld.com/network/netsemi.html</span>
<span class="cm">	[link no longer provides useful info -jgarzik]</span>


<span class="cm">	TODO:</span>
<span class="cm">	* big endian support with CFG:BEM instead of cpu_to_le32</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;	</span><span class="cm">/* Processor type for cache alignment. */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#define DRV_NAME	&quot;natsemi&quot;</span>
<span class="cp">#define DRV_VERSION	&quot;2.1&quot;</span>
<span class="cp">#define DRV_RELDATE	&quot;Sept 11, 2006&quot;</span>

<span class="cp">#define RX_OFFSET	2</span>

<span class="cm">/* Updated to recommendations in pci-skeleton v2.03. */</span>

<span class="cm">/* The user-configurable values.</span>
<span class="cm">   These may be modified when a driver module is loaded.*/</span>

<span class="cp">#define NATSEMI_DEF_MSG		(NETIF_MSG_DRV		| \</span>
<span class="cp">				 NETIF_MSG_LINK		| \</span>
<span class="cp">				 NETIF_MSG_WOL		| \</span>
<span class="cp">				 NETIF_MSG_RX_ERR	| \</span>
<span class="cp">				 NETIF_MSG_TX_ERR)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mtu</span><span class="p">;</span>

<span class="cm">/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).</span>
<span class="cm">   This chip uses a 512 element hash table based on the Ethernet CRC.  */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">multicast_filter_limit</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="cm">/* Set the copy breakpoint for the copy-only-tiny-frames scheme.</span>
<span class="cm">   Setting to &gt; 1518 effectively disables this feature. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rx_copybreak</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dspcfg_workaround</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/* Used to pass the media type, etc.</span>
<span class="cm">   Both &#39;options[]&#39; and &#39;full_duplex[]&#39; should exist for driver</span>
<span class="cm">   interoperability.</span>
<span class="cm">   The media type is usually passed in &#39;options[]&#39;.</span>
<span class="cm">*/</span>
<span class="cp">#define MAX_UNITS 8		</span><span class="cm">/* More are supported, limit only on options */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">options</span><span class="p">[</span><span class="n">MAX_UNITS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">full_duplex</span><span class="p">[</span><span class="n">MAX_UNITS</span><span class="p">];</span>

<span class="cm">/* Operational parameters that are set at compile time. */</span>

<span class="cm">/* Keep the ring sizes a power of two for compile efficiency.</span>
<span class="cm">   The compiler will convert &lt;unsigned&gt;&#39;%&#39;&lt;2^N&gt; into a bit mask.</span>
<span class="cm">   Making the Tx ring too large decreases the effectiveness of channel</span>
<span class="cm">   bonding and packet priority.</span>
<span class="cm">   There are no ill effects from too-large receive rings. */</span>
<span class="cp">#define TX_RING_SIZE	16</span>
<span class="cp">#define TX_QUEUE_LEN	10 </span><span class="cm">/* Limit ring entries actually used, min 4. */</span><span class="cp"></span>
<span class="cp">#define RX_RING_SIZE	32</span>

<span class="cm">/* Operational parameters that usually are not changed. */</span>
<span class="cm">/* Time in jiffies before concluding the transmitter is hung. */</span>
<span class="cp">#define TX_TIMEOUT  (2*HZ)</span>

<span class="cp">#define NATSEMI_HW_TIMEOUT	400</span>
<span class="cp">#define NATSEMI_TIMER_FREQ	5*HZ</span>
<span class="cp">#define NATSEMI_PG0_NREGS	64</span>
<span class="cp">#define NATSEMI_RFDR_NREGS	8</span>
<span class="cp">#define NATSEMI_PG1_NREGS	4</span>
<span class="cp">#define NATSEMI_NREGS		(NATSEMI_PG0_NREGS + NATSEMI_RFDR_NREGS + \</span>
<span class="cp">				 NATSEMI_PG1_NREGS)</span>
<span class="cp">#define NATSEMI_REGS_VER	1 </span><span class="cm">/* v1 added RFDR registers */</span><span class="cp"></span>
<span class="cp">#define NATSEMI_REGS_SIZE	(NATSEMI_NREGS * sizeof(u32))</span>

<span class="cm">/* Buffer sizes:</span>
<span class="cm"> * The nic writes 32-bit values, even if the upper bytes of</span>
<span class="cm"> * a 32-bit value are beyond the end of the buffer.</span>
<span class="cm"> */</span>
<span class="cp">#define NATSEMI_HEADERS		22	</span><span class="cm">/* 2*mac,type,vlan,crc */</span><span class="cp"></span>
<span class="cp">#define NATSEMI_PADDING		16	</span><span class="cm">/* 2 bytes should be sufficient */</span><span class="cp"></span>
<span class="cp">#define NATSEMI_LONGPKT		1518	</span><span class="cm">/* limit for normal packets */</span><span class="cp"></span>
<span class="cp">#define NATSEMI_RX_LIMIT	2046	</span><span class="cm">/* maximum supported by hardware */</span><span class="cp"></span>

<span class="cm">/* These identify the driver base version and may not be removed. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="n">__devinitconst</span> <span class="o">=</span>
  <span class="n">KERN_INFO</span> <span class="n">DRV_NAME</span> <span class="s">&quot; dp8381x driver, version &quot;</span>
      <span class="n">DRV_VERSION</span> <span class="s">&quot;, &quot;</span> <span class="n">DRV_RELDATE</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
  <span class="s">&quot;  originally by Donald Becker &lt;becker@scyld.com&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
  <span class="s">&quot;  2.4.x kernel port by Jeff Garzik, Tjeerd Mulder</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Donald Becker &lt;becker@scyld.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;National Semiconductor DP8381x series PCI Ethernet driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">mtu</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">rx_copybreak</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">dspcfg_workaround</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">full_duplex</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">mtu</span><span class="p">,</span> <span class="s">&quot;DP8381x MTU (all boards)&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;DP8381x default debug level&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">rx_copybreak</span><span class="p">,</span>
	<span class="s">&quot;DP8381x copy breakpoint for copy-only-tiny-frames&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">dspcfg_workaround</span><span class="p">,</span> <span class="s">&quot;DP8381x: control DspCfg workaround&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">options</span><span class="p">,</span>
	<span class="s">&quot;DP8381x: Bits 0-3: media type, bit 17: full duplex&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">full_duplex</span><span class="p">,</span> <span class="s">&quot;DP8381x full duplex setting(s) (1)&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">				Theory of Operation</span>

<span class="cm">I. Board Compatibility</span>

<span class="cm">This driver is designed for National Semiconductor DP83815 PCI Ethernet NIC.</span>
<span class="cm">It also works with other chips in in the DP83810 series.</span>

<span class="cm">II. Board-specific settings</span>

<span class="cm">This driver requires the PCI interrupt line to be valid.</span>
<span class="cm">It honors the EEPROM-set values.</span>

<span class="cm">III. Driver operation</span>

<span class="cm">IIIa. Ring buffers</span>

<span class="cm">This driver uses two statically allocated fixed-size descriptor lists</span>
<span class="cm">formed into rings by a branch from the final descriptor to the beginning of</span>
<span class="cm">the list.  The ring sizes are set at compile time by RX/TX_RING_SIZE.</span>
<span class="cm">The NatSemi design uses a &#39;next descriptor&#39; pointer that the driver forms</span>
<span class="cm">into a list.</span>

<span class="cm">IIIb/c. Transmit/Receive Structure</span>

<span class="cm">This driver uses a zero-copy receive and transmit scheme.</span>
<span class="cm">The driver allocates full frame size skbuffs for the Rx ring buffers at</span>
<span class="cm">open() time and passes the skb-&gt;data field to the chip as receive data</span>
<span class="cm">buffers.  When an incoming frame is less than RX_COPYBREAK bytes long,</span>
<span class="cm">a fresh skbuff is allocated and the frame is copied to the new skbuff.</span>
<span class="cm">When the incoming frame is larger, the skbuff is passed directly up the</span>
<span class="cm">protocol stack.  Buffers consumed this way are replaced by newly allocated</span>
<span class="cm">skbuffs in a later phase of receives.</span>

<span class="cm">The RX_COPYBREAK value is chosen to trade-off the memory wasted by</span>
<span class="cm">using a full-sized skbuff for small frames vs. the copying costs of larger</span>
<span class="cm">frames.  New boards are typically used in generously configured machines</span>
<span class="cm">and the underfilled buffers have negligible impact compared to the benefit of</span>
<span class="cm">a single allocation size, so the default value of zero results in never</span>
<span class="cm">copying packets.  When copying is done, the cost is usually mitigated by using</span>
<span class="cm">a combined copy/checksum routine.  Copying also preloads the cache, which is</span>
<span class="cm">most useful with small frames.</span>

<span class="cm">A subtle aspect of the operation is that unaligned buffers are not permitted</span>
<span class="cm">by the hardware.  Thus the IP header at offset 14 in an ethernet frame isn&#39;t</span>
<span class="cm">longword aligned for further processing.  On copies frames are put into the</span>
<span class="cm">skbuff at an offset of &quot;+2&quot;, 16-byte aligning the IP header.</span>

<span class="cm">IIId. Synchronization</span>

<span class="cm">Most operations are synchronized on the np-&gt;lock irq spinlock, except the</span>
<span class="cm">receive and transmit paths which are synchronised using a combination of</span>
<span class="cm">hardware descriptor ownership, disabling interrupts and NAPI poll scheduling.</span>

<span class="cm">IVb. References</span>

<span class="cm">http://www.scyld.com/expert/100mbps.html</span>
<span class="cm">http://www.scyld.com/expert/NWay.html</span>
<span class="cm">Datasheet is available from:</span>
<span class="cm">http://www.national.com/pf/DP/DP83815.html</span>

<span class="cm">IVc. Errata</span>

<span class="cm">None characterised.</span>
<span class="cm">*/</span>



<span class="cm">/*</span>
<span class="cm"> * Support for fibre connections on Am79C874:</span>
<span class="cm"> * This phy needs a special setup when connected to a fibre cable.</span>
<span class="cm"> * http://www.amd.com/files/connectivitysolutions/networking/archivednetworking/22235.pdf</span>
<span class="cm"> */</span>
<span class="cp">#define PHYID_AM79C874	0x0022561b</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">MII_MCTRL</span>	<span class="o">=</span> <span class="mh">0x15</span><span class="p">,</span>		<span class="cm">/* mode control register */</span>
	<span class="n">MII_FX_SEL</span>	<span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>	<span class="cm">/* 100BASE-FX (fiber) */</span>
	<span class="n">MII_EN_SCRM</span>	<span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>	<span class="cm">/* enable scrambler (tp) */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NATSEMI_FLAG_IGNORE_PHY</span>		<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* array of board data directly indexed by pci_tbl[x].driver_data */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eeprom_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">natsemi_pci_info</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;Aculab E1/T1 PMXc cPCI carrier card&quot;</span><span class="p">,</span> <span class="n">NATSEMI_FLAG_IGNORE_PHY</span><span class="p">,</span> <span class="mi">128</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;NatSemi DP8381[56]&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">24</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">natsemi_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_NS</span><span class="p">,</span> <span class="mh">0x0020</span><span class="p">,</span> <span class="mh">0x12d9</span><span class="p">,</span>     <span class="mh">0x000c</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_NS</span><span class="p">,</span> <span class="mh">0x0020</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* terminate list */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">natsemi_pci_tbl</span><span class="p">);</span>

<span class="cm">/* Offsets to the device registers.</span>
<span class="cm">   Unlike software-only systems, device drivers interact with complex hardware.</span>
<span class="cm">   It&#39;s not useful to define symbolic names for every register bit in the</span>
<span class="cm">   device.</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">register_offsets</span> <span class="p">{</span>
	<span class="n">ChipCmd</span>			<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">ChipConfig</span>		<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">EECtrl</span>			<span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="n">PCIBusCfg</span>		<span class="o">=</span> <span class="mh">0x0C</span><span class="p">,</span>
	<span class="n">IntrStatus</span>		<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">IntrMask</span>		<span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
	<span class="n">IntrEnable</span>		<span class="o">=</span> <span class="mh">0x18</span><span class="p">,</span>
	<span class="n">IntrHoldoff</span>		<span class="o">=</span> <span class="mh">0x1C</span><span class="p">,</span> <span class="cm">/* DP83816 only */</span>
	<span class="n">TxRingPtr</span>		<span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">TxConfig</span>		<span class="o">=</span> <span class="mh">0x24</span><span class="p">,</span>
	<span class="n">RxRingPtr</span>		<span class="o">=</span> <span class="mh">0x30</span><span class="p">,</span>
	<span class="n">RxConfig</span>		<span class="o">=</span> <span class="mh">0x34</span><span class="p">,</span>
	<span class="n">ClkRun</span>			<span class="o">=</span> <span class="mh">0x3C</span><span class="p">,</span>
	<span class="n">WOLCmd</span>			<span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">PauseCmd</span>		<span class="o">=</span> <span class="mh">0x44</span><span class="p">,</span>
	<span class="n">RxFilterAddr</span>		<span class="o">=</span> <span class="mh">0x48</span><span class="p">,</span>
	<span class="n">RxFilterData</span>		<span class="o">=</span> <span class="mh">0x4C</span><span class="p">,</span>
	<span class="n">BootRomAddr</span>		<span class="o">=</span> <span class="mh">0x50</span><span class="p">,</span>
	<span class="n">BootRomData</span>		<span class="o">=</span> <span class="mh">0x54</span><span class="p">,</span>
	<span class="n">SiliconRev</span>		<span class="o">=</span> <span class="mh">0x58</span><span class="p">,</span>
	<span class="n">StatsCtrl</span>		<span class="o">=</span> <span class="mh">0x5C</span><span class="p">,</span>
	<span class="n">StatsData</span>		<span class="o">=</span> <span class="mh">0x60</span><span class="p">,</span>
	<span class="n">RxPktErrs</span>		<span class="o">=</span> <span class="mh">0x60</span><span class="p">,</span>
	<span class="n">RxMissed</span>		<span class="o">=</span> <span class="mh">0x68</span><span class="p">,</span>
	<span class="n">RxCRCErrs</span>		<span class="o">=</span> <span class="mh">0x64</span><span class="p">,</span>
	<span class="n">BasicControl</span>		<span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
	<span class="n">BasicStatus</span>		<span class="o">=</span> <span class="mh">0x84</span><span class="p">,</span>
	<span class="n">AnegAdv</span>			<span class="o">=</span> <span class="mh">0x90</span><span class="p">,</span>
	<span class="n">AnegPeer</span>		<span class="o">=</span> <span class="mh">0x94</span><span class="p">,</span>
	<span class="n">PhyStatus</span>		<span class="o">=</span> <span class="mh">0xC0</span><span class="p">,</span>
	<span class="n">MIntrCtrl</span>		<span class="o">=</span> <span class="mh">0xC4</span><span class="p">,</span>
	<span class="n">MIntrStatus</span>		<span class="o">=</span> <span class="mh">0xC8</span><span class="p">,</span>
	<span class="n">PhyCtrl</span>			<span class="o">=</span> <span class="mh">0xE4</span><span class="p">,</span>

	<span class="cm">/* These are from the spec, around page 78... on a separate table.</span>
<span class="cm">	 * The meaning of these registers depend on the value of PGSEL. */</span>
	<span class="n">PGSEL</span>			<span class="o">=</span> <span class="mh">0xCC</span><span class="p">,</span>
	<span class="n">PMDCSR</span>			<span class="o">=</span> <span class="mh">0xE4</span><span class="p">,</span>
	<span class="n">TSTDAT</span>			<span class="o">=</span> <span class="mh">0xFC</span><span class="p">,</span>
	<span class="n">DSPCFG</span>			<span class="o">=</span> <span class="mh">0xF4</span><span class="p">,</span>
	<span class="n">SDCFG</span>			<span class="o">=</span> <span class="mh">0xF8</span>
<span class="p">};</span>
<span class="cm">/* the values for the &#39;magic&#39; registers above (PGSEL=1) */</span>
<span class="cp">#define PMDCSR_VAL	0x189c	</span><span class="cm">/* enable preferred adaptation circuitry */</span><span class="cp"></span>
<span class="cp">#define TSTDAT_VAL	0x0</span>
<span class="cp">#define DSPCFG_VAL	0x5040</span>
<span class="cp">#define SDCFG_VAL	0x008c	</span><span class="cm">/* set voltage thresholds for Signal Detect */</span><span class="cp"></span>
<span class="cp">#define DSPCFG_LOCK	0x20	</span><span class="cm">/* coefficient lock bit in DSPCFG */</span><span class="cp"></span>
<span class="cp">#define DSPCFG_COEF	0x1000	</span><span class="cm">/* see coefficient (in TSTDAT) bit in DSPCFG */</span><span class="cp"></span>
<span class="cp">#define TSTDAT_FIXED	0xe8	</span><span class="cm">/* magic number for bad coefficients */</span><span class="cp"></span>

<span class="cm">/* misc PCI space registers */</span>
<span class="k">enum</span> <span class="n">pci_register_offsets</span> <span class="p">{</span>
	<span class="n">PCIPM</span>			<span class="o">=</span> <span class="mh">0x44</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ChipCmd_bits</span> <span class="p">{</span>
	<span class="n">ChipReset</span>		<span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span>
	<span class="n">RxReset</span>			<span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">TxReset</span>			<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">RxOff</span>			<span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="n">RxOn</span>			<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">TxOff</span>			<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">TxOn</span>			<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ChipConfig_bits</span> <span class="p">{</span>
	<span class="n">CfgPhyDis</span>		<span class="o">=</span> <span class="mh">0x200</span><span class="p">,</span>
	<span class="n">CfgPhyRst</span>		<span class="o">=</span> <span class="mh">0x400</span><span class="p">,</span>
	<span class="n">CfgExtPhy</span>		<span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>
	<span class="n">CfgAnegEnable</span>		<span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>
	<span class="n">CfgAneg100</span>		<span class="o">=</span> <span class="mh">0x4000</span><span class="p">,</span>
	<span class="n">CfgAnegFull</span>		<span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span>
	<span class="n">CfgAnegDone</span>		<span class="o">=</span> <span class="mh">0x8000000</span><span class="p">,</span>
	<span class="n">CfgFullDuplex</span>		<span class="o">=</span> <span class="mh">0x20000000</span><span class="p">,</span>
	<span class="n">CfgSpeed100</span>		<span class="o">=</span> <span class="mh">0x40000000</span><span class="p">,</span>
	<span class="n">CfgLink</span>			<span class="o">=</span> <span class="mh">0x80000000</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">EECtrl_bits</span> <span class="p">{</span>
	<span class="n">EE_ShiftClk</span>		<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">EE_DataIn</span>		<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">EE_ChipSelect</span>		<span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="n">EE_DataOut</span>		<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">MII_Data</span> 		<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">MII_Write</span>		<span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">MII_ShiftClk</span>		<span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">PCIBusCfg_bits</span> <span class="p">{</span>
	<span class="n">EepromReload</span>		<span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Bits in the interrupt status/mask registers. */</span>
<span class="k">enum</span> <span class="n">IntrStatus_bits</span> <span class="p">{</span>
	<span class="n">IntrRxDone</span>		<span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>
	<span class="n">IntrRxIntr</span>		<span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">IntrRxErr</span>		<span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>
	<span class="n">IntrRxEarly</span>		<span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="n">IntrRxIdle</span>		<span class="o">=</span> <span class="mh">0x0010</span><span class="p">,</span>
	<span class="n">IntrRxOverrun</span>		<span class="o">=</span> <span class="mh">0x0020</span><span class="p">,</span>
	<span class="n">IntrTxDone</span>		<span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span>
	<span class="n">IntrTxIntr</span>		<span class="o">=</span> <span class="mh">0x0080</span><span class="p">,</span>
	<span class="n">IntrTxErr</span>		<span class="o">=</span> <span class="mh">0x0100</span><span class="p">,</span>
	<span class="n">IntrTxIdle</span>		<span class="o">=</span> <span class="mh">0x0200</span><span class="p">,</span>
	<span class="n">IntrTxUnderrun</span>		<span class="o">=</span> <span class="mh">0x0400</span><span class="p">,</span>
	<span class="n">StatsMax</span>		<span class="o">=</span> <span class="mh">0x0800</span><span class="p">,</span>
	<span class="n">SWInt</span>			<span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>
	<span class="n">WOLPkt</span>			<span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>
	<span class="n">LinkChange</span>		<span class="o">=</span> <span class="mh">0x4000</span><span class="p">,</span>
	<span class="n">IntrHighBits</span>		<span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span>
	<span class="n">RxStatusFIFOOver</span>	<span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span>
	<span class="n">IntrPCIErr</span>		<span class="o">=</span> <span class="mh">0xf00000</span><span class="p">,</span>
	<span class="n">RxResetDone</span>		<span class="o">=</span> <span class="mh">0x1000000</span><span class="p">,</span>
	<span class="n">TxResetDone</span>		<span class="o">=</span> <span class="mh">0x2000000</span><span class="p">,</span>
	<span class="n">IntrAbnormalSummary</span>	<span class="o">=</span> <span class="mh">0xCD20</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Default Interrupts:</span>
<span class="cm"> * Rx OK, Rx Packet Error, Rx Overrun,</span>
<span class="cm"> * Tx OK, Tx Packet Error, Tx Underrun,</span>
<span class="cm"> * MIB Service, Phy Interrupt, High Bits,</span>
<span class="cm"> * Rx Status FIFO overrun,</span>
<span class="cm"> * Received Target Abort, Received Master Abort,</span>
<span class="cm"> * Signalled System Error, Received Parity Error</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_INTR 0x00f1cd65</span>

<span class="k">enum</span> <span class="n">TxConfig_bits</span> <span class="p">{</span>
	<span class="n">TxDrthMask</span>		<span class="o">=</span> <span class="mh">0x3f</span><span class="p">,</span>
	<span class="n">TxFlthMask</span>		<span class="o">=</span> <span class="mh">0x3f00</span><span class="p">,</span>
	<span class="n">TxMxdmaMask</span>		<span class="o">=</span> <span class="mh">0x700000</span><span class="p">,</span>
	<span class="n">TxMxdma_512</span>		<span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">TxMxdma_4</span>		<span class="o">=</span> <span class="mh">0x100000</span><span class="p">,</span>
	<span class="n">TxMxdma_8</span>		<span class="o">=</span> <span class="mh">0x200000</span><span class="p">,</span>
	<span class="n">TxMxdma_16</span>		<span class="o">=</span> <span class="mh">0x300000</span><span class="p">,</span>
	<span class="n">TxMxdma_32</span>		<span class="o">=</span> <span class="mh">0x400000</span><span class="p">,</span>
	<span class="n">TxMxdma_64</span>		<span class="o">=</span> <span class="mh">0x500000</span><span class="p">,</span>
	<span class="n">TxMxdma_128</span>		<span class="o">=</span> <span class="mh">0x600000</span><span class="p">,</span>
	<span class="n">TxMxdma_256</span>		<span class="o">=</span> <span class="mh">0x700000</span><span class="p">,</span>
	<span class="n">TxCollRetry</span>		<span class="o">=</span> <span class="mh">0x800000</span><span class="p">,</span>
	<span class="n">TxAutoPad</span>		<span class="o">=</span> <span class="mh">0x10000000</span><span class="p">,</span>
	<span class="n">TxMacLoop</span>		<span class="o">=</span> <span class="mh">0x20000000</span><span class="p">,</span>
	<span class="n">TxHeartIgn</span>		<span class="o">=</span> <span class="mh">0x40000000</span><span class="p">,</span>
	<span class="n">TxCarrierIgn</span>		<span class="o">=</span> <span class="mh">0x80000000</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Tx Configuration:</span>
<span class="cm"> * - 256 byte DMA burst length</span>
<span class="cm"> * - fill threshold 512 bytes (i.e. restart DMA when 512 bytes are free)</span>
<span class="cm"> * - 64 bytes initial drain threshold (i.e. begin actual transmission</span>
<span class="cm"> *   when 64 byte are in the fifo)</span>
<span class="cm"> * - on tx underruns, increase drain threshold by 64.</span>
<span class="cm"> * - at most use a drain threshold of 1472 bytes: The sum of the fill</span>
<span class="cm"> *   threshold and the drain threshold must be less than 2016 bytes.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define TX_FLTH_VAL		((512/32) &lt;&lt; 8)</span>
<span class="cp">#define TX_DRTH_VAL_START	(64/32)</span>
<span class="cp">#define TX_DRTH_VAL_INC		2</span>
<span class="cp">#define TX_DRTH_VAL_LIMIT	(1472/32)</span>

<span class="k">enum</span> <span class="n">RxConfig_bits</span> <span class="p">{</span>
	<span class="n">RxDrthMask</span>		<span class="o">=</span> <span class="mh">0x3e</span><span class="p">,</span>
	<span class="n">RxMxdmaMask</span>		<span class="o">=</span> <span class="mh">0x700000</span><span class="p">,</span>
	<span class="n">RxMxdma_512</span>		<span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">RxMxdma_4</span>		<span class="o">=</span> <span class="mh">0x100000</span><span class="p">,</span>
	<span class="n">RxMxdma_8</span>		<span class="o">=</span> <span class="mh">0x200000</span><span class="p">,</span>
	<span class="n">RxMxdma_16</span>		<span class="o">=</span> <span class="mh">0x300000</span><span class="p">,</span>
	<span class="n">RxMxdma_32</span>		<span class="o">=</span> <span class="mh">0x400000</span><span class="p">,</span>
	<span class="n">RxMxdma_64</span>		<span class="o">=</span> <span class="mh">0x500000</span><span class="p">,</span>
	<span class="n">RxMxdma_128</span>		<span class="o">=</span> <span class="mh">0x600000</span><span class="p">,</span>
	<span class="n">RxMxdma_256</span>		<span class="o">=</span> <span class="mh">0x700000</span><span class="p">,</span>
	<span class="n">RxAcceptLong</span>		<span class="o">=</span> <span class="mh">0x8000000</span><span class="p">,</span>
	<span class="n">RxAcceptTx</span>		<span class="o">=</span> <span class="mh">0x10000000</span><span class="p">,</span>
	<span class="n">RxAcceptRunt</span>		<span class="o">=</span> <span class="mh">0x40000000</span><span class="p">,</span>
	<span class="n">RxAcceptErr</span>		<span class="o">=</span> <span class="mh">0x80000000</span>
<span class="p">};</span>
<span class="cp">#define RX_DRTH_VAL		(128/8)</span>

<span class="k">enum</span> <span class="n">ClkRun_bits</span> <span class="p">{</span>
	<span class="n">PMEEnable</span>		<span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span>
	<span class="n">PMEStatus</span>		<span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">WolCmd_bits</span> <span class="p">{</span>
	<span class="n">WakePhy</span>			<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">WakeUnicast</span>		<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">WakeMulticast</span>		<span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
	<span class="n">WakeBroadcast</span>		<span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>
	<span class="n">WakeArp</span>			<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">WakePMatch0</span>		<span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">WakePMatch1</span>		<span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">WakePMatch2</span>		<span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
	<span class="n">WakePMatch3</span>		<span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span>
	<span class="n">WakeMagic</span>		<span class="o">=</span> <span class="mh">0x200</span><span class="p">,</span>
	<span class="n">WakeMagicSecure</span>		<span class="o">=</span> <span class="mh">0x400</span><span class="p">,</span>
	<span class="n">SecureHack</span>		<span class="o">=</span> <span class="mh">0x100000</span><span class="p">,</span>
	<span class="n">WokePhy</span>			<span class="o">=</span> <span class="mh">0x400000</span><span class="p">,</span>
	<span class="n">WokeUnicast</span>		<span class="o">=</span> <span class="mh">0x800000</span><span class="p">,</span>
	<span class="n">WokeMulticast</span>		<span class="o">=</span> <span class="mh">0x1000000</span><span class="p">,</span>
	<span class="n">WokeBroadcast</span>		<span class="o">=</span> <span class="mh">0x2000000</span><span class="p">,</span>
	<span class="n">WokeArp</span>			<span class="o">=</span> <span class="mh">0x4000000</span><span class="p">,</span>
	<span class="n">WokePMatch0</span>		<span class="o">=</span> <span class="mh">0x8000000</span><span class="p">,</span>
	<span class="n">WokePMatch1</span>		<span class="o">=</span> <span class="mh">0x10000000</span><span class="p">,</span>
	<span class="n">WokePMatch2</span>		<span class="o">=</span> <span class="mh">0x20000000</span><span class="p">,</span>
	<span class="n">WokePMatch3</span>		<span class="o">=</span> <span class="mh">0x40000000</span><span class="p">,</span>
	<span class="n">WokeMagic</span>		<span class="o">=</span> <span class="mh">0x80000000</span><span class="p">,</span>
	<span class="n">WakeOptsSummary</span>		<span class="o">=</span> <span class="mh">0x7ff</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">RxFilterAddr_bits</span> <span class="p">{</span>
	<span class="n">RFCRAddressMask</span>		<span class="o">=</span> <span class="mh">0x3ff</span><span class="p">,</span>
	<span class="n">AcceptMulticast</span>		<span class="o">=</span> <span class="mh">0x00200000</span><span class="p">,</span>
	<span class="n">AcceptMyPhys</span>		<span class="o">=</span> <span class="mh">0x08000000</span><span class="p">,</span>
	<span class="n">AcceptAllPhys</span>		<span class="o">=</span> <span class="mh">0x10000000</span><span class="p">,</span>
	<span class="n">AcceptAllMulticast</span>	<span class="o">=</span> <span class="mh">0x20000000</span><span class="p">,</span>
	<span class="n">AcceptBroadcast</span>		<span class="o">=</span> <span class="mh">0x40000000</span><span class="p">,</span>
	<span class="n">RxFilterEnable</span>		<span class="o">=</span> <span class="mh">0x80000000</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">StatsCtrl_bits</span> <span class="p">{</span>
	<span class="n">StatsWarn</span>		<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">StatsFreeze</span>		<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">StatsClear</span>		<span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
	<span class="n">StatsStrobe</span>		<span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">MIntrCtrl_bits</span> <span class="p">{</span>
	<span class="n">MICRIntEn</span>		<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">PhyCtrl_bits</span> <span class="p">{</span>
	<span class="n">PhyAddrMask</span>		<span class="o">=</span> <span class="mh">0x1f</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define PHY_ADDR_NONE		32</span>
<span class="cp">#define PHY_ADDR_INTERNAL	1</span>

<span class="cm">/* values we might find in the silicon revision register */</span>
<span class="cp">#define SRR_DP83815_C	0x0302</span>
<span class="cp">#define SRR_DP83815_D	0x0403</span>
<span class="cp">#define SRR_DP83816_A4	0x0504</span>
<span class="cp">#define SRR_DP83816_A5	0x0505</span>

<span class="cm">/* The Rx and Tx buffer descriptors. */</span>
<span class="cm">/* Note that using only 32 bit fields simplifies conversion to big-endian</span>
<span class="cm">   architectures. */</span>
<span class="k">struct</span> <span class="n">netdev_desc</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">next_desc</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">cmd_status</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">software_use</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Bits in network_desc.status */</span>
<span class="k">enum</span> <span class="n">desc_status_bits</span> <span class="p">{</span>
	<span class="n">DescOwn</span><span class="o">=</span><span class="mh">0x80000000</span><span class="p">,</span> <span class="n">DescMore</span><span class="o">=</span><span class="mh">0x40000000</span><span class="p">,</span> <span class="n">DescIntr</span><span class="o">=</span><span class="mh">0x20000000</span><span class="p">,</span>
	<span class="n">DescNoCRC</span><span class="o">=</span><span class="mh">0x10000000</span><span class="p">,</span> <span class="n">DescPktOK</span><span class="o">=</span><span class="mh">0x08000000</span><span class="p">,</span>
	<span class="n">DescSizeMask</span><span class="o">=</span><span class="mh">0xfff</span><span class="p">,</span>

	<span class="n">DescTxAbort</span><span class="o">=</span><span class="mh">0x04000000</span><span class="p">,</span> <span class="n">DescTxFIFO</span><span class="o">=</span><span class="mh">0x02000000</span><span class="p">,</span>
	<span class="n">DescTxCarrier</span><span class="o">=</span><span class="mh">0x01000000</span><span class="p">,</span> <span class="n">DescTxDefer</span><span class="o">=</span><span class="mh">0x00800000</span><span class="p">,</span>
	<span class="n">DescTxExcDefer</span><span class="o">=</span><span class="mh">0x00400000</span><span class="p">,</span> <span class="n">DescTxOOWCol</span><span class="o">=</span><span class="mh">0x00200000</span><span class="p">,</span>
	<span class="n">DescTxExcColl</span><span class="o">=</span><span class="mh">0x00100000</span><span class="p">,</span> <span class="n">DescTxCollCount</span><span class="o">=</span><span class="mh">0x000f0000</span><span class="p">,</span>

	<span class="n">DescRxAbort</span><span class="o">=</span><span class="mh">0x04000000</span><span class="p">,</span> <span class="n">DescRxOver</span><span class="o">=</span><span class="mh">0x02000000</span><span class="p">,</span>
	<span class="n">DescRxDest</span><span class="o">=</span><span class="mh">0x01800000</span><span class="p">,</span> <span class="n">DescRxLong</span><span class="o">=</span><span class="mh">0x00400000</span><span class="p">,</span>
	<span class="n">DescRxRunt</span><span class="o">=</span><span class="mh">0x00200000</span><span class="p">,</span> <span class="n">DescRxInvalid</span><span class="o">=</span><span class="mh">0x00100000</span><span class="p">,</span>
	<span class="n">DescRxCRC</span><span class="o">=</span><span class="mh">0x00080000</span><span class="p">,</span> <span class="n">DescRxAlign</span><span class="o">=</span><span class="mh">0x00040000</span><span class="p">,</span>
	<span class="n">DescRxLoop</span><span class="o">=</span><span class="mh">0x00020000</span><span class="p">,</span> <span class="n">DesRxColl</span><span class="o">=</span><span class="mh">0x00010000</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">netdev_private</span> <span class="p">{</span>
	<span class="cm">/* Descriptor rings first for alignment */</span>
	<span class="n">dma_addr_t</span> <span class="n">ring_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_desc</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_desc</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="cm">/* The addresses of receive-in-place skbuffs */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">rx_dma</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="p">];</span>
	<span class="cm">/* address of a sent-in-place packet/buffer, for later free() */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_dma</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>
	<span class="cm">/* Media monitoring timer */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="cm">/* Frequently used values: keep some adjacent for cache effect */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_desc</span> <span class="o">*</span><span class="n">rx_head_desc</span><span class="p">;</span>
	<span class="cm">/* Producer/consumer ring indices */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_rx</span><span class="p">,</span> <span class="n">dirty_rx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_tx</span><span class="p">,</span> <span class="n">dirty_tx</span><span class="p">;</span>
	<span class="cm">/* Based on MTU+slack. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_buf_sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oom</span><span class="p">;</span>
	<span class="cm">/* Interrupt status */</span>
	<span class="n">u32</span> <span class="n">intr_status</span><span class="p">;</span>
	<span class="cm">/* Do not touch the nic registers */</span>
	<span class="kt">int</span> <span class="n">hands_off</span><span class="p">;</span>
	<span class="cm">/* Don&#39;t pay attention to the reported link state. */</span>
	<span class="kt">int</span> <span class="n">ignore_phy</span><span class="p">;</span>
	<span class="cm">/* external phy that is used: only valid if dev-&gt;if_port != PORT_TP */</span>
	<span class="kt">int</span> <span class="n">mii</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">phy_addr_external</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">full_duplex</span><span class="p">;</span>
	<span class="cm">/* Rx filter */</span>
	<span class="n">u32</span> <span class="n">cur_rx_mode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_filter</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="cm">/* FIFO and PCI burst thresholds */</span>
	<span class="n">u32</span> <span class="n">tx_config</span><span class="p">,</span> <span class="n">rx_config</span><span class="p">;</span>
	<span class="cm">/* original contents of ClkRun register */</span>
	<span class="n">u32</span> <span class="n">SavedClkRun</span><span class="p">;</span>
	<span class="cm">/* silicon revision */</span>
	<span class="n">u32</span> <span class="n">srr</span><span class="p">;</span>
	<span class="cm">/* expected DSPCFG value */</span>
	<span class="n">u16</span> <span class="n">dspcfg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dspcfg_workaround</span><span class="p">;</span>
	<span class="cm">/* parms saved in ethtool format */</span>
	<span class="n">u16</span>	<span class="n">speed</span><span class="p">;</span>		<span class="cm">/* The forced speed, 10Mb, 100Mb, gigabit */</span>
	<span class="n">u8</span>	<span class="n">duplex</span><span class="p">;</span>		<span class="cm">/* Duplex, half or full */</span>
	<span class="n">u8</span>	<span class="n">autoneg</span><span class="p">;</span>	<span class="cm">/* Autonegotiation enabled */</span>
	<span class="cm">/* MII transceiver section */</span>
	<span class="n">u16</span> <span class="n">advertising</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iosize</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_enable</span><span class="p">;</span>
	<span class="cm">/* EEPROM data */</span>
	<span class="kt">int</span> <span class="n">eeprom_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">move_int_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">eeprom_read</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">init_phy_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">miiport_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">miiport_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">find_mii</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">natsemi_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">natsemi_reload_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">natsemi_stop_rxtx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">do_cable_magic</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">undo_cable_magic</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">check_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">netdev_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dump_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ns_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">alloc_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">refill_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">init_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">drain_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">drain_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">free_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">reinit_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">init_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">start_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">intr_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">netdev_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">intr_status</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">natsemi_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">netdev_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">work_done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">netdev_tx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">natsemi_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">natsemi_poll_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_set_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">newval</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_get_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">supported</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">cur</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_set_sopass</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">newval</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_get_sopass</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_get_ecmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_set_ecmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">enable_wol_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable_intr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_get_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">ethtool_ops</span><span class="p">;</span>

<span class="cp">#define NATSEMI_ATTR(_name) \</span>
<span class="cp">static ssize_t natsemi_show_##_name(struct device *dev, \</span>
<span class="cp">         struct device_attribute *attr, char *buf); \</span>
<span class="cp">	 static ssize_t natsemi_set_##_name(struct device *dev, \</span>
<span class="cp">		struct device_attribute *attr, \</span>
<span class="cp">	        const char *buf, size_t count); \</span>
<span class="cp">	 static DEVICE_ATTR(_name, 0644, natsemi_show_##_name, natsemi_set_##_name)</span>

<span class="cp">#define NATSEMI_CREATE_FILE(_dev, _name) \</span>
<span class="cp">         device_create_file(&amp;_dev-&gt;dev, &amp;dev_attr_##_name)</span>
<span class="cp">#define NATSEMI_REMOVE_FILE(_dev, _name) \</span>
<span class="cp">         device_remove_file(&amp;_dev-&gt;dev, &amp;dev_attr_##_name)</span>

<span class="n">NATSEMI_ATTR</span><span class="p">(</span><span class="n">dspcfg_workaround</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">natsemi_show_dspcfg_workaround</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  	      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">to_net_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg_workaround</span> <span class="o">?</span> <span class="s">&quot;on&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">natsemi_set_dspcfg_workaround</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">to_net_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">new_setting</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="cm">/* Find out the new setting */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">new_setting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
                 <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="s">&quot;0&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">new_setting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
                 <span class="k">return</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg_workaround</span> <span class="o">=</span> <span class="n">new_setting</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">ns_ioaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">natsemi_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="n">IntrEnable</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="n">IntrEnable</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">natsemi_irq_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="n">IntrEnable</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="n">IntrEnable</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">move_int_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The internal phy is visible on the external mii bus. Therefore we must</span>
<span class="cm">	 * move it away before we can send commands to an external phy.</span>
<span class="cm">	 * There are two addresses we must avoid:</span>
<span class="cm">	 * - the address on the external phy that is used for transmission.</span>
<span class="cm">	 * - the address that we want to access. User space can access phys</span>
<span class="cm">	 *   on the mii bus with SIOCGMIIREG/SIOCSMIIREG, independent from the</span>
<span class="cm">	 *   phy that is used for transmission.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
		<span class="n">target</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span><span class="p">)</span>
		<span class="n">target</span><span class="o">--</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PhyCtrl</span><span class="p">);</span>
	<span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PhyCtrl</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">natsemi_init_media</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ignore_phy</span><span class="p">)</span>
		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* get the initial settings from hardware */</span>
	<span class="n">tmp</span>            <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">speed</span>      <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">BMCR_SPEED100</span><span class="p">)</span><span class="o">?</span> <span class="n">SPEED_100</span>     <span class="o">:</span> <span class="n">SPEED_10</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">duplex</span>     <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">BMCR_FULLDPLX</span><span class="p">)</span><span class="o">?</span> <span class="n">DUPLEX_FULL</span>   <span class="o">:</span> <span class="n">DUPLEX_HALF</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">autoneg</span>    <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span><span class="p">)</span><span class="o">?</span> <span class="n">AUTONEG_ENABLE</span><span class="o">:</span> <span class="n">AUTONEG_DISABLE</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span><span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_ADVERTISE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_ALL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ADVERTISE_ALL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">netif_msg_probe</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;natsemi %s: Transceiver default autonegotiation %s &quot;</span>
			<span class="s">&quot;10%s %s duplex.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span>
			<span class="p">(</span><span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span><span class="p">)</span><span class="o">?</span>
			  <span class="s">&quot;enabled, advertise&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled, force&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span>
			  <span class="p">(</span><span class="n">ADVERTISE_100FULL</span><span class="o">|</span><span class="n">ADVERTISE_100HALF</span><span class="p">))</span><span class="o">?</span>
			    <span class="s">&quot;0&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span>
			  <span class="p">(</span><span class="n">ADVERTISE_100FULL</span><span class="o">|</span><span class="n">ADVERTISE_10FULL</span><span class="p">))</span><span class="o">?</span>
			    <span class="s">&quot;full&quot;</span> <span class="o">:</span> <span class="s">&quot;half&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_probe</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			<span class="s">&quot;natsemi %s: Transceiver status %#04x advertising %#04x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">),</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">natsemi_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">netdev_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">netdev_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">start_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">natsemi_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">netdev_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span> 	<span class="o">=</span> <span class="n">ns_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> 	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">natsemi_poll_controller</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">natsemi_probe1</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">chip_idx</span> <span class="o">=</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">find_cnt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">iostart</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iosize</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">pcibar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* PCI base address register */</span>
	<span class="kt">int</span> <span class="n">prev_eedata</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

<span class="cm">/* when built into the kernel, we only print version if device is found */</span>
<span class="cp">#ifndef MODULE</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">printed_version</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printed_version</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* natsemi has a non-standard PM control register</span>
<span class="cm">	 * in PCI config space.  Some boards apparently need</span>
<span class="cm">	 * to be brought to D0 in this manner.</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCIPM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* D0 state, disable PME assertion */</span>
		<span class="n">u32</span> <span class="n">newtmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">;</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCIPM</span><span class="p">,</span> <span class="n">newtmp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">find_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">iostart</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pcibar</span><span class="p">);</span>
	<span class="n">iosize</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pcibar</span><span class="p">);</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">netdev_private</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_pci_request_regions</span><span class="p">;</span>

	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">iostart</span><span class="p">,</span> <span class="n">iosize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_ioremap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Work around the dropped serial bit. */</span>
	<span class="n">prev_eedata</span> <span class="o">=</span> <span class="n">eeprom_read</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">eedata</span> <span class="o">=</span> <span class="n">eeprom_read</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">eedata</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">prev_eedata</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">eedata</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">prev_eedata</span> <span class="o">=</span> <span class="n">eedata</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Store MAC Address in perm_addr */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="p">;</span>

	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">natsemi_poll</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">iosize</span> <span class="o">=</span> <span class="n">iosize</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">debug</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">NATSEMI_DEF_MSG</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">eeprom_size</span> <span class="o">=</span> <span class="n">natsemi_pci_info</span><span class="p">[</span><span class="n">chip_idx</span><span class="p">].</span><span class="n">eeprom_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">natsemi_pci_info</span><span class="p">[</span><span class="n">chip_idx</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NATSEMI_FLAG_IGNORE_PHY</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">ignore_phy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">ignore_phy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg_workaround</span> <span class="o">=</span> <span class="n">dspcfg_workaround</span><span class="p">;</span>

	<span class="cm">/* Initial port:</span>
<span class="cm">	 * - If configured to ignore the PHY set up for external.</span>
<span class="cm">	 * - If the nic was configured to use an external phy and if find_mii</span>
<span class="cm">	 *   finds a phy: use external port, first phy that replies.</span>
<span class="cm">	 * - Otherwise: internal port.</span>
<span class="cm">	 * Note that the phy address for the internal phy doesn&#39;t matter:</span>
<span class="cm">	 * The address would be used to access a phy over the mii bus, but</span>
<span class="cm">	 * the internal phy is accessed through mapped registers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ignore_phy</span> <span class="o">||</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CfgExtPhy</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">=</span> <span class="n">PORT_MII</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">=</span> <span class="n">PORT_TP</span><span class="p">;</span>
	<span class="cm">/* Reset the chip to erase previous misconfiguration. */</span>
	<span class="n">natsemi_reload_eeprom</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">natsemi_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">!=</span> <span class="n">PORT_TP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span> <span class="o">=</span> <span class="n">find_mii</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="cm">/* If we&#39;re ignoring the PHY it doesn&#39;t matter if we can&#39;t</span>
<span class="cm">		 * find one. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ignore_phy</span> <span class="o">&amp;&amp;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span> <span class="o">==</span> <span class="n">PHY_ADDR_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">=</span> <span class="n">PORT_TP</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span> <span class="o">=</span> <span class="n">PHY_ADDR_INTERNAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span> <span class="o">=</span> <span class="n">PHY_ADDR_INTERNAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">option</span> <span class="o">=</span> <span class="n">find_cnt</span> <span class="o">&lt;</span> <span class="n">MAX_UNITS</span> <span class="o">?</span> <span class="n">options</span><span class="p">[</span><span class="n">find_cnt</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* The lower four bits are the media type. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">option</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">option</span> <span class="o">&amp;</span> <span class="mh">0x200</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">full_duplex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">option</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;natsemi %s: ignoring user supplied media type %d&quot;</span><span class="p">,</span>
				<span class="n">pci_name</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span> <span class="n">option</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">find_cnt</span> <span class="o">&lt;</span> <span class="n">MAX_UNITS</span>  <span class="o">&amp;&amp;</span>  <span class="n">full_duplex</span><span class="p">[</span><span class="n">find_cnt</span><span class="p">])</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">full_duplex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">natsemi_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TX_TIMEOUT</span><span class="p">;</span>

	<span class="n">SET_ETHTOOL_OPS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ethtool_ops</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mtu</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">mtu</span><span class="p">;</span>

	<span class="n">natsemi_init_media</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* save the silicon revision for later querying */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">srr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">SiliconRev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;natsemi %s: silicon revision %#04x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pci_name</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">srr</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_register_netdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NATSEMI_CREATE_FILE</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dspcfg_workaround</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_create_file</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_drv</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;natsemi %s: %s at %#08llx &quot;</span>
		       <span class="s">&quot;(%s), %pM, IRQ %d&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">natsemi_pci_info</span><span class="p">[</span><span class="n">chip_idx</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">iostart</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="n">PORT_TP</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, port TP.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ignore_phy</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, port MII, ignoring PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, port MII, phy ad %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_create_file:</span>
 	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

 <span class="nl">err_register_netdev:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>

 <span class="nl">err_ioremap:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

 <span class="nl">err_pci_request_regions:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Read the EEPROM and MII Management Data I/O (MDIO) interfaces.</span>
<span class="cm">   The EEPROM code is for the common 93c06/46 EEPROMs with 6 bit addresses. */</span>

<span class="cm">/* Delay between EEPROM clock transitions.</span>
<span class="cm">   No extra delay is needed with 33Mhz PCI, but future 66Mhz access may need</span>
<span class="cm">   a delay.  Note that pre-2.0.34 kernels had a cache-alignment bug that</span>
<span class="cm">   made udelay() unreliable.</span>
<span class="cm">   The old method of using an ISA access as a delay, __SLOW_DOWN_IO__, is</span>
<span class="cm">   deprecated.</span>
<span class="cm">*/</span>
<span class="cp">#define eeprom_delay(ee_addr)	readl(ee_addr)</span>

<span class="cp">#define EE_Write0 (EE_ChipSelect)</span>
<span class="cp">#define EE_Write1 (EE_ChipSelect | EE_DataIn)</span>

<span class="cm">/* The EEPROM commands include the alway-set leading bit. */</span>
<span class="k">enum</span> <span class="n">EEPROM_Cmds</span> <span class="p">{</span>
	<span class="n">EE_WriteCmd</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="n">EE_ReadCmd</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="n">EE_EraseCmd</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">eeprom_read</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ee_addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">EECtrl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">read_cmd</span> <span class="o">=</span> <span class="n">location</span> <span class="o">|</span> <span class="n">EE_ReadCmd</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">EE_Write0</span><span class="p">,</span> <span class="n">ee_addr</span><span class="p">);</span>

	<span class="cm">/* Shift the read command bits out. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">short</span> <span class="n">dataval</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_cmd</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="n">EE_Write1</span> <span class="o">:</span> <span class="n">EE_Write0</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">dataval</span><span class="p">,</span> <span class="n">ee_addr</span><span class="p">);</span>
		<span class="n">eeprom_delay</span><span class="p">(</span><span class="n">ee_addr</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">dataval</span> <span class="o">|</span> <span class="n">EE_ShiftClk</span><span class="p">,</span> <span class="n">ee_addr</span><span class="p">);</span>
		<span class="n">eeprom_delay</span><span class="p">(</span><span class="n">ee_addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EE_ChipSelect</span><span class="p">,</span> <span class="n">ee_addr</span><span class="p">);</span>
	<span class="n">eeprom_delay</span><span class="p">(</span><span class="n">ee_addr</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">EE_ChipSelect</span> <span class="o">|</span> <span class="n">EE_ShiftClk</span><span class="p">,</span> <span class="n">ee_addr</span><span class="p">);</span>
		<span class="n">eeprom_delay</span><span class="p">(</span><span class="n">ee_addr</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">ee_addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EE_DataOut</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">EE_ChipSelect</span><span class="p">,</span> <span class="n">ee_addr</span><span class="p">);</span>
		<span class="n">eeprom_delay</span><span class="p">(</span><span class="n">ee_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Terminate the EEPROM access. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EE_Write0</span><span class="p">,</span> <span class="n">ee_addr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ee_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* MII transceiver control section.</span>
<span class="cm"> * The 83815 series has an internal transceiver, and we present the</span>
<span class="cm"> * internal management registers as if they were MII connected.</span>
<span class="cm"> * External Phy registers are referenced through the MII interface.</span>
<span class="cm"> */</span>

<span class="cm">/* clock transitions &gt;= 20ns (25MHz)</span>
<span class="cm"> * One readl should be good to PCI @ 100MHz</span>
<span class="cm"> */</span>
<span class="cp">#define mii_delay(ioaddr)  readl(ioaddr + EECtrl)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mii_getbit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">MII_ShiftClk</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EECtrl</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EECtrl</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EECtrl</span><span class="p">);</span>
	<span class="n">mii_delay</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">MII_Data</span><span class="p">)</span><span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mii_send_bits</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">u32</span> <span class="n">mdio_val</span> <span class="o">=</span> <span class="n">MII_Write</span> <span class="o">|</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span><span class="o">?</span> <span class="n">MII_Data</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">mdio_val</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EECtrl</span><span class="p">);</span>
		<span class="n">mii_delay</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">mdio_val</span> <span class="o">|</span> <span class="n">MII_ShiftClk</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EECtrl</span><span class="p">);</span>
		<span class="n">mii_delay</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EECtrl</span><span class="p">);</span>
	<span class="n">mii_delay</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">miiport_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Ensure sync */</span>
	<span class="n">mii_send_bits</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="cm">/* ST(2), OP(2), ADDR(5), REG#(5), TA(2), Data(16) total 32 bits */</span>
	<span class="cm">/* ST,OP = 0110&#39;b for read operation */</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x06</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">phy_id</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">mii_send_bits</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
	<span class="cm">/* Turnaround */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mii_getbit</span> <span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Read data */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">|=</span> <span class="n">mii_getbit</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* End cycle */</span>
	<span class="n">mii_getbit</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">miiport_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/* Ensure sync */</span>
	<span class="n">mii_send_bits</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="cm">/* ST(2), OP(2), ADDR(5), REG#(5), TA(2), Data(16) total 32 bits */</span>
	<span class="cm">/* ST,OP,AAAAA,RRRRR,TA = 0101xxxxxxxxxx10&#39;b = 0x5002 for write */</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x5002</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">phy_id</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">|</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">mii_send_bits</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="cm">/* End cycle */</span>
	<span class="n">mii_getbit</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* The 83815 series has two ports:</span>
<span class="cm">	 * - an internal transceiver</span>
<span class="cm">	 * - an external mii bus</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="n">PORT_TP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">BasicControl</span><span class="o">+</span><span class="p">(</span><span class="n">reg</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">miiport_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* The 83815 series has an internal transceiver; handle separately */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="n">PORT_TP</span><span class="p">)</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">BasicControl</span><span class="o">+</span><span class="p">(</span><span class="n">reg</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">miiport_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_phy_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* restore stuff lost when power was out */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">==</span> <span class="n">AUTONEG_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* renegotiate if something changed */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">!=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_ADVERTISE</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="cm">/* turn on autonegotiation and force negotiation */</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">BMCR_ANENABLE</span> <span class="o">|</span> <span class="n">BMCR_ANRESTART</span><span class="p">);</span>
			<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_ADVERTISE</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* turn off auto negotiation, set speed and duplexity */</span>
		<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BMCR_ANENABLE</span> <span class="o">|</span> <span class="n">BMCR_SPEED100</span> <span class="o">|</span> <span class="n">BMCR_FULLDPLX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_100</span><span class="p">)</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="n">BMCR_SPEED100</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">DUPLEX_FULL</span><span class="p">)</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="n">BMCR_FULLDPLX</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note: there is no good way to inform the link partner</span>
<span class="cm">		 * that our capabilities changed. The user has to unplug</span>
<span class="cm">		 * and replug the network cable after some changes, e.g.</span>
<span class="cm">		 * after switching from 10HD, autoneg off to 100 HD,</span>
<span class="cm">		 * autoneg off.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* find out what phy this is */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">mii</span> <span class="o">=</span> <span class="p">(</span><span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_PHYSID1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
				<span class="o">+</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_PHYSID2</span><span class="p">);</span>

	<span class="cm">/* handle external phys here */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PHYID_AM79C874</span>:
		<span class="cm">/* phy specific configuration for fibre/tp operation */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_MCTRL</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MII_FX_SEL</span> <span class="o">|</span> <span class="n">MII_EN_SCRM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="n">PORT_FIBRE</span><span class="p">)</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="n">MII_FX_SEL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="n">MII_EN_SCRM</span><span class="p">;</span>
		<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_MCTRL</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cfg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">CfgExtPhy</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* On page 78 of the spec, they recommend some settings for &quot;optimum</span>
<span class="cm">	   performance&quot; to be done in sequence.  These settings optimize some</span>
<span class="cm">	   of the 100Mbit autodetection circuitry.  They say we only want to</span>
<span class="cm">	   do this for rev C of the chip, but engineers at NSC (Bradley</span>
<span class="cm">	   Kennedy) recommends always setting them.  If you don&#39;t, you get</span>
<span class="cm">	   errors on some autonegotiations that make the device unusable.</span>

<span class="cm">	   It seems that the DSP needs a few usec to reinitialize after</span>
<span class="cm">	   the start of the phy. Just retry writing these values until they</span>
<span class="cm">	   stick.</span>
<span class="cm">	*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NATSEMI_HW_TIMEOUT</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="kt">int</span> <span class="n">dspcfg</span><span class="p">;</span>
		<span class="n">writew</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PGSEL</span><span class="p">);</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">PMDCSR_VAL</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PMDCSR</span><span class="p">);</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">TSTDAT_VAL</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TSTDAT</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">srr</span> <span class="o">&lt;=</span> <span class="n">SRR_DP83815_C</span><span class="p">)</span><span class="o">?</span>
			<span class="n">DSPCFG_VAL</span> <span class="o">:</span> <span class="p">(</span><span class="n">DSPCFG_COEF</span> <span class="o">|</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DSPCFG</span><span class="p">));</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DSPCFG</span><span class="p">);</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">SDCFG_VAL</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">SDCFG</span><span class="p">);</span>
		<span class="n">writew</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PGSEL</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="n">writew</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PGSEL</span><span class="p">);</span>
		<span class="n">dspcfg</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DSPCFG</span><span class="p">);</span>
		<span class="n">writew</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PGSEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg</span> <span class="o">==</span> <span class="n">dspcfg</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_link</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">NATSEMI_HW_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;%s: DSPCFG mismatch after retrying for %d usec.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;%s: DSPCFG accepted after %d usec.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Enable PHY Specific event based interrupts.  Link state change</span>
<span class="cm">	 * and Auto-Negotiation Completion are among the affected.</span>
<span class="cm">	 * Read the intr status to clear it (needed for wake events).</span>
<span class="cm">	 */</span>
	<span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIntrStatus</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">MICRIntEn</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIntrCtrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">switch_port_external</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">cfg</span><span class="p">;</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">CfgExtPhy</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_link</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: switching to external transceiver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* 1) switch back to external phy */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cfg</span> <span class="o">|</span> <span class="p">(</span><span class="n">CfgExtPhy</span> <span class="o">|</span> <span class="n">CfgPhyDis</span><span class="p">),</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* 2) reset the external phy: */</span>
	<span class="cm">/* resetting the external PHY has been known to cause a hub supplying</span>
<span class="cm">	 * power over Ethernet to kill the power.  We don&#39;t want to kill</span>
<span class="cm">	 * power to this computer, so we avoid resetting the phy.</span>
<span class="cm">	 */</span>

	<span class="cm">/* 3) reinit the phy fixup, it got lost during power down. */</span>
	<span class="n">move_int_phy</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span><span class="p">);</span>
	<span class="n">init_phy_fixup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">switch_port_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bmcr</span><span class="p">;</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span><span class="n">CfgExtPhy</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_link</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: switching to internal transceiver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* 1) switch back to internal phy: */</span>
	<span class="n">cfg</span> <span class="o">=</span> <span class="n">cfg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">CfgExtPhy</span> <span class="o">|</span> <span class="n">CfgPhyDis</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* 2) reset the internal phy: */</span>
	<span class="n">bmcr</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">BasicControl</span><span class="o">+</span><span class="p">(</span><span class="n">MII_BMCR</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">bmcr</span> <span class="o">|</span> <span class="n">BMCR_RESET</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">BasicControl</span><span class="o">+</span><span class="p">(</span><span class="n">MII_BMCR</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">));</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NATSEMI_HW_TIMEOUT</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bmcr</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">BasicControl</span><span class="o">+</span><span class="p">(</span><span class="n">MII_BMCR</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bmcr</span> <span class="o">&amp;</span> <span class="n">BMCR_RESET</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">NATSEMI_HW_TIMEOUT</span> <span class="o">&amp;&amp;</span> <span class="n">netif_msg_link</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			<span class="s">&quot;%s: phy reset did not complete in %d usec.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* 3) reinit the phy fixup, it got lost during power down. */</span>
	<span class="n">init_phy_fixup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Scan for a PHY on the external mii bus.</span>
<span class="cm"> * There are two tricky points:</span>
<span class="cm"> * - Do not scan while the internal phy is enabled. The internal phy will</span>
<span class="cm"> *   crash: e.g. reads from the DSPCFG register will return odd values and</span>
<span class="cm"> *   the nasty random phy reset code will reset the nic every few seconds.</span>
<span class="cm"> * - The internal phy must be moved around, an external phy could</span>
<span class="cm"> *   have the same address as the internal phy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_mii</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">did_switch</span><span class="p">;</span>

	<span class="cm">/* Switch to external phy */</span>
	<span class="n">did_switch</span> <span class="o">=</span> <span class="n">switch_port_external</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Scan the possible phy addresses:</span>
<span class="cm">	 *</span>
<span class="cm">	 * PHY address 0 means that the phy is in isolate mode. Not yet</span>
<span class="cm">	 * supported due to lack of test hardware. User space should</span>
<span class="cm">	 * handle it through ethtool.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">move_int_phy</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">miiport_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="mh">0xffff</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="mh">0x0000</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* found something! */</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">mii</span> <span class="o">=</span> <span class="p">(</span><span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_PHYSID1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
					<span class="o">+</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_PHYSID2</span><span class="p">);</span>
	 		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_probe</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;natsemi %s: found external phy %08x at address %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">pci_name</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">mii</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* And switch back to internal phy: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">did_switch</span><span class="p">)</span>
		<span class="n">switch_port_internal</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* CFG bits [13:16] [18:23] */</span>
<span class="cp">#define CFG_RESET_SAVE 0xfde000</span>
<span class="cm">/* WCSR bits [0:4] [9:10] */</span>
<span class="cp">#define WCSR_RESET_SAVE 0x61f</span>
<span class="cm">/* RFCR bits [20] [22] [27:31] */</span>
<span class="cp">#define RFCR_RESET_SAVE 0xf8500000</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">natsemi_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wcsr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rfcr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pmatch</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">sopass</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Resetting the chip causes some registers to be lost.</span>
<span class="cm">	 * Natsemi suggests NOT reloading the EEPROM while live, so instead</span>
<span class="cm">	 * we save the state that would have been loaded from EEPROM</span>
<span class="cm">	 * on a normal power-up (see the spec EEPROM map).  This assumes</span>
<span class="cm">	 * whoever calls this will follow up with init_registers() eventually.</span>
<span class="cm">	 */</span>

	<span class="cm">/* CFG */</span>
	<span class="n">cfg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CFG_RESET_SAVE</span><span class="p">;</span>
	<span class="cm">/* WCSR */</span>
	<span class="n">wcsr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLCmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">WCSR_RESET_SAVE</span><span class="p">;</span>
	<span class="cm">/* RFCR */</span>
	<span class="n">rfcr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RFCR_RESET_SAVE</span><span class="p">;</span>
	<span class="cm">/* PMATCH */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
		<span class="n">pmatch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* SOPAS */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0xa</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
		<span class="n">sopass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now whack the chip */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ChipReset</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NATSEMI_HW_TIMEOUT</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ChipReset</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">NATSEMI_HW_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: reset did not complete in %d usec.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: reset completed in %d usec.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* restore CFG */</span>
	<span class="n">cfg</span> <span class="o">|=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CFG_RESET_SAVE</span><span class="p">;</span>
	<span class="cm">/* turn on external phy if it was selected */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="n">PORT_TP</span><span class="p">)</span>
		<span class="n">cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CfgExtPhy</span> <span class="o">|</span> <span class="n">CfgPhyDis</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cfg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CfgExtPhy</span> <span class="o">|</span> <span class="n">CfgPhyDis</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">);</span>
	<span class="cm">/* restore WCSR */</span>
	<span class="n">wcsr</span> <span class="o">|=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLCmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">WCSR_RESET_SAVE</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">wcsr</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLCmd</span><span class="p">);</span>
	<span class="cm">/* read RFCR */</span>
	<span class="n">rfcr</span> <span class="o">|=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RFCR_RESET_SAVE</span><span class="p">;</span>
	<span class="cm">/* restore PMATCH */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">pmatch</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0xa</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">sopass</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* restore RFCR */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rfcr</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RxResetDone</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">RxReset</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NATSEMI_HW_TIMEOUT</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span> <span class="o">|=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">RxResetDone</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">NATSEMI_HW_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: RX reset did not complete in %d usec.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">15</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: RX reset took %d usec.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">15</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">natsemi_reload_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">EepromReload</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PCIBusCfg</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NATSEMI_HW_TIMEOUT</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PCIBusCfg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EepromReload</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">NATSEMI_HW_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;natsemi %s: EEPROM did not reload in %d usec.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span> <span class="n">i</span><span class="o">*</span><span class="mi">50</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;natsemi %s: EEPROM reloaded in %d usec.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span> <span class="n">i</span><span class="o">*</span><span class="mi">50</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">natsemi_stop_rxtx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">RxOff</span> <span class="o">|</span> <span class="n">TxOff</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span> <span class="n">NATSEMI_HW_TIMEOUT</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TxOn</span><span class="o">|</span><span class="n">RxOn</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">NATSEMI_HW_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Tx/Rx process did not stop in %d usec.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Tx/Rx process stopped in %d usec.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Reset the chip, just in case. */</span>
	<span class="n">natsemi_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">intr_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_ifup</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: netdev_open() irq %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">alloc_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">init_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_registers</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* now set the MAC address according to dev-&gt;dev_addr */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">mac</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">];</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">mac</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx_mode</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_ifup</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Done netdev_open(), status: %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">));</span>

	<span class="cm">/* Set the timer to check for link beat. */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">NATSEMI_TIMER_FREQ</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">netdev_timer</span><span class="p">;</span> <span class="cm">/* timer handler */</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_cable_magic</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">!=</span> <span class="n">PORT_TP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">srr</span> <span class="o">&gt;=</span> <span class="n">SRR_DP83816_A5</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 100 MBit links with short cables can trip an issue with the chip.</span>
<span class="cm">	 * The problem manifests as lots of CRC errors and/or flickering</span>
<span class="cm">	 * activity LED while idle.  This process is based on instructions</span>
<span class="cm">	 * from engineers at National.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipConfig</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CfgSpeed100</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

		<span class="n">writew</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PGSEL</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * coefficient visibility should already be enabled via</span>
<span class="cm">		 * DSPCFG | 0x1000</span>
<span class="cm">		 */</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TSTDAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * the value must be negative, and within certain values</span>
<span class="cm">		 * (these values all come from National)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="mh">0xd8</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="mh">0xff</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

			<span class="cm">/* the bug has been triggered - fix the coefficient */</span>
			<span class="n">writew</span><span class="p">(</span><span class="n">TSTDAT_FIXED</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TSTDAT</span><span class="p">);</span>
			<span class="cm">/* lock the value */</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DSPCFG</span><span class="p">);</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg</span> <span class="o">=</span> <span class="n">data</span> <span class="o">|</span> <span class="n">DSPCFG_LOCK</span><span class="p">;</span>
			<span class="n">writew</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DSPCFG</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">writew</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PGSEL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">undo_cable_magic</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">!=</span> <span class="n">PORT_TP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">srr</span> <span class="o">&gt;=</span> <span class="n">SRR_DP83816_A5</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">writew</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PGSEL</span><span class="p">);</span>
	<span class="cm">/* make sure the lock bit is clear */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DSPCFG</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DSPCFG_LOCK</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DSPCFG</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PGSEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">duplex</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bmsr</span><span class="p">;</span>

	<span class="cm">/* If we are ignoring the PHY then don&#39;t try reading it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ignore_phy</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">propagate_state</span><span class="p">;</span>

	<span class="cm">/* The link status field is latched: it remains low after a temporary</span>
<span class="cm">	 * link failure until it&#39;s read. We need the current link status,</span>
<span class="cm">	 * thus read twice.</span>
<span class="cm">	 */</span>
	<span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">);</span>
	<span class="n">bmsr</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bmsr</span> <span class="o">&amp;</span> <span class="n">BMSR_LSTATUS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_link</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: link down.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">undo_cable_magic</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_link</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: link up.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">do_cable_magic</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">duplex</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_duplex</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">duplex</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bmsr</span> <span class="o">&amp;</span> <span class="n">BMSR_ANEGCOMPLETE</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">mii_nway_result</span><span class="p">(</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_LPA</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">LPA_100FULL</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">==</span> <span class="n">LPA_10FULL</span><span class="p">)</span>
				<span class="n">duplex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BMCR_FULLDPLX</span><span class="p">)</span>
			<span class="n">duplex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">propagate_state:</span>
	<span class="cm">/* if duplex is set then bit 28 must be set, too */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">duplex</span> <span class="o">^</span> <span class="o">!!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_config</span> <span class="o">&amp;</span> <span class="n">RxAcceptTx</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_link</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;%s: Setting %s-duplex based on negotiated &quot;</span>
				<span class="s">&quot;link capability.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				<span class="n">duplex</span> <span class="o">?</span> <span class="s">&quot;full&quot;</span> <span class="o">:</span> <span class="s">&quot;half&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">duplex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_config</span> <span class="o">|=</span> <span class="n">RxAcceptTx</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_config</span> <span class="o">|=</span> <span class="n">TxCarrierIgn</span> <span class="o">|</span> <span class="n">TxHeartIgn</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_config</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RxAcceptTx</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_config</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">TxCarrierIgn</span> <span class="o">|</span> <span class="n">TxHeartIgn</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_config</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxConfig</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_config</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxConfig</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">init_phy_fixup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* clear any interrupts that are pending, such as wake events */</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ring_dma</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxRingPtr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ring_dma</span> <span class="o">+</span> <span class="n">RX_RING_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_desc</span><span class="p">),</span>
		<span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxRingPtr</span><span class="p">);</span>

	<span class="cm">/* Initialize other registers.</span>
<span class="cm">	 * Configure the PCI bus bursts and FIFO thresholds.</span>
<span class="cm">	 * Configure for standard, in-spec Ethernet.</span>
<span class="cm">	 * Start with half-duplex. check_link will update</span>
<span class="cm">	 * to the correct settings.</span>
<span class="cm">	 */</span>

	<span class="cm">/* DRTH: 2: start tx if 64 bytes are in the fifo</span>
<span class="cm">	 * FLTH: 0x10: refill with next packet if 512 bytes are free</span>
<span class="cm">	 * MXDMA: 0: up to 256 byte bursts.</span>
<span class="cm">	 * 	MXDMA must be &lt;= FLTH</span>
<span class="cm">	 * ECRETRY=1</span>
<span class="cm">	 * ATP=1</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_config</span> <span class="o">=</span> <span class="n">TxAutoPad</span> <span class="o">|</span> <span class="n">TxCollRetry</span> <span class="o">|</span> <span class="n">TxMxdma_256</span> <span class="o">|</span>
				<span class="n">TX_FLTH_VAL</span> <span class="o">|</span> <span class="n">TX_DRTH_VAL_START</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_config</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxConfig</span><span class="p">);</span>

	<span class="cm">/* DRTH 0x10: start copying to memory if 128 bytes are in the fifo</span>
<span class="cm">	 * MXDMA 0: up to 256 byte bursts</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_config</span> <span class="o">=</span> <span class="n">RxMxdma_256</span> <span class="o">|</span> <span class="n">RX_DRTH_VAL</span><span class="p">;</span>
	<span class="cm">/* if receive ring now has bigger buffers than normal, enable jumbo */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span> <span class="o">&gt;</span> <span class="n">NATSEMI_LONGPKT</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_config</span> <span class="o">|=</span> <span class="n">RxAcceptLong</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_config</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxConfig</span><span class="p">);</span>

	<span class="cm">/* Disable PME:</span>
<span class="cm">	 * The PME bit is initialized from the EEPROM contents.</span>
<span class="cm">	 * PCI cards probably have PME disabled, but motherboard</span>
<span class="cm">	 * implementations may have PME set to enable WakeOnLan.</span>
<span class="cm">	 * With PME set the chip will scan incoming packets but</span>
<span class="cm">	 * nothing will be written to memory. */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">SavedClkRun</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ClkRun</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">SavedClkRun</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PMEEnable</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ClkRun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">SavedClkRun</span> <span class="o">&amp;</span> <span class="n">PMEStatus</span> <span class="o">&amp;&amp;</span> <span class="n">netif_msg_wol</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: Wake-up event %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLCmd</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">check_link</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">__set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Enable interrupts by setting the interrupt mask. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">DEFAULT_INTR</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrMask</span><span class="p">);</span>
	<span class="n">natsemi_irq_enable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">RxOn</span> <span class="o">|</span> <span class="n">TxOn</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">StatsClear</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StatsCtrl</span><span class="p">);</span> <span class="cm">/* Clear Stats */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * netdev_timer:</span>
<span class="cm"> * Purpose:</span>
<span class="cm"> * 1) check for link changes. Usually they are handled by the MII interrupt</span>
<span class="cm"> *    but it doesn&#39;t hurt to check twice.</span>
<span class="cm"> * 2) check for sudden death of the NIC:</span>
<span class="cm"> *    It seems that a reference set for this chip went out with incorrect info,</span>
<span class="cm"> *    and there exist boards that aren&#39;t quite right.  An unexpected voltage</span>
<span class="cm"> *    drop can cause the PHY to get itself in a weird state (basically reset).</span>
<span class="cm"> *    NOTE: this only seems to affect revC chips.  The user can disable</span>
<span class="cm"> *    this check via dspcfg_workaround sysfs option.</span>
<span class="cm"> * 3) check of death of the RX path due to OOM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">next_tick</span> <span class="o">=</span> <span class="n">NATSEMI_TIMER_FREQ</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_timer</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* DO NOT read the IntrStatus register,</span>
<span class="cm">		 * a read clears any pending interrupts.</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Media selection timer tick.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="n">PORT_TP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">dspcfg</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* check for a nasty random phy-reset - use dspcfg as a flag */</span>
		<span class="n">writew</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">PGSEL</span><span class="p">);</span>
		<span class="n">dspcfg</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">DSPCFG</span><span class="p">);</span>
		<span class="n">writew</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">+</span><span class="n">PGSEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg_workaround</span> <span class="o">&amp;&amp;</span> <span class="n">dspcfg</span> <span class="o">!=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dspcfg</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_drv</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: possible phy reset: &quot;</span>
						<span class="s">&quot;re-initializing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">natsemi_stop_rxtx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">dump_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">reinit_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">init_registers</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* hurry back */</span>
				<span class="n">next_tick</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* init_registers() calls check_link() for the above case */</span>
			<span class="n">check_link</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">check_link</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">oom</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">oom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">refill_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">oom</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">RxOn</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">next_tick</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next_tick</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">next_tick</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">next_tick</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_pktdata</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  Tx ring at %p:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; #%d desc. %#08x %#08x %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_desc</span><span class="p">,</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd_status</span><span class="p">,</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  Rx ring %p:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; #%d desc. %#08x %#08x %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_desc</span><span class="p">,</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd_status</span><span class="p">,</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ns_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_tx_err</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;%s: Transmit timed out, status %#08x,&quot;</span>
				<span class="s">&quot; resetting...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus</span><span class="p">));</span>
		<span class="n">dump_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">natsemi_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">reinit_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">init_registers</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;%s: tx_timeout while in hands_off state?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_desc</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">RX_RING_SIZE</span><span class="o">+</span><span class="n">TX_RING_SIZE</span><span class="p">),</span>
		<span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ring_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">refill_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Refill the Rx ring buffers. */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_rx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="o">+</span><span class="n">NATSEMI_PADDING</span><span class="p">;</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* Better luck next round. */</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">==</span> <span class="n">RX_RING_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_rx_err</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: going OOM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">oom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_bufsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&lt;=</span> <span class="n">ETH_DATA_LEN</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span> <span class="o">=</span> <span class="n">ETH_DATA_LEN</span> <span class="o">+</span> <span class="n">NATSEMI_HEADERS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">NATSEMI_HEADERS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize the Rx and Tx rings, along with various &#39;dev&#39; bits. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* 1) TX ring */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_desc</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ring_dma</span>
			<span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_desc</span><span class="p">)</span>
			<span class="o">*</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">TX_RING_SIZE</span><span class="o">+</span><span class="n">RX_RING_SIZE</span><span class="p">));</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* 2) RX ring */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">=</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">oom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">set_bufsize</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_head_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* Please be careful before changing this loop - at least gcc-2.95.1</span>
<span class="cm">	 * miscompiles it otherwise.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Initialize all Rx descriptors. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_desc</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ring_dma</span>
				<span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_desc</span><span class="p">)</span>
				<span class="o">*</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">RX_RING_SIZE</span><span class="p">));</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">refill_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dump_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Free all the skbuffs in the Rx queue. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xBADF00D0</span><span class="p">);</span> <span class="cm">/* An invalid address. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				<span class="n">buflen</span> <span class="o">+</span> <span class="n">NATSEMI_PADDING</span><span class="p">,</span>
				<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drain_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">drain_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_desc</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">RX_RING_SIZE</span><span class="o">+</span><span class="n">TX_RING_SIZE</span><span class="p">),</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ring_dma</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reinit_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* RX Ring */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">=</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_head_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/* Initialize all Rx descriptors. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span><span class="p">);</span>

	<span class="n">refill_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reinit_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* drain TX ring */</span>
	<span class="n">drain_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">TX_RING_SIZE</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">reinit_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">start_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Note: Ordering is important here, set the field with the</span>
<span class="cm">	   &quot;ownership&quot; bit last, and only then increment cur_tx. */</span>

	<span class="cm">/* Calculate the next Tx descriptor entry. */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">%</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span> <span class="o">|</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="cm">/* StrongARM: Explicitly cache flush np-&gt;tx_ring and</span>
<span class="cm">		 * skb-&gt;data,skb-&gt;len. */</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">&gt;=</span> <span class="n">TX_QUEUE_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_tx_done</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">&gt;=</span> <span class="n">TX_QUEUE_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Wake the potentially-idle transmit channel. */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">TxOn</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_tx_queued</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Transmit frame #%d queued in slot %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_tx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">%</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmd_status</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_tx_done</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
				<span class="s">&quot;%s: tx frame #%d finished, status %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">,</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmd_status</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmd_status</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescPktOK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* Various Tx errors */</span>
			<span class="kt">int</span> <span class="n">tx_status</span> <span class="o">=</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">cmd_status</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DescTxAbort</span><span class="o">|</span><span class="n">DescTxExcColl</span><span class="p">))</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">DescTxFIFO</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">DescTxCarrier</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_carrier_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">DescTxOOWCol</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
					<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="cm">/* Free the original skb. */</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">&lt;</span> <span class="n">TX_QUEUE_LEN</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The ring is no longer full, wake queue. */</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* The interrupt handler doesn&#39;t actually handle interrupts itself, it</span>
<span class="cm"> * schedules a NAPI poll if there is anything to do. */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">intr_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Reading IntrStatus automatically acknowledges so don&#39;t do</span>
<span class="cm">	 * that while interrupts are disabled, (for example, while a</span>
<span class="cm">	 * poll is scheduled).  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span> <span class="o">||</span> <span class="o">!</span><span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrEnable</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_intr</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
		       <span class="s">&quot;%s: Interrupt, status %#08x, mask %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span><span class="p">,</span>
		       <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrMask</span><span class="p">));</span>

	<span class="n">prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Disable interrupts and register for poll */</span>
		<span class="n">natsemi_irq_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
	       	       <span class="s">&quot;%s: Ignoring interrupt, status %#08x, mask %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span><span class="p">,</span>
		       <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrMask</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is the NAPI poll routine.  As well as the standard RX handling</span>
<span class="cm"> * it also handles all other interrupts that the chip might raise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">natsemi_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netdev_private</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_intr</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
			       <span class="s">&quot;%s: Poll, status %#08x, mask %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span><span class="p">,</span>
			       <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrMask</span><span class="p">));</span>

		<span class="cm">/* netdev_rx() may read IntrStatus again if the RX state</span>
<span class="cm">		 * machine falls over so do it first. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span> <span class="o">&amp;</span>
		    <span class="p">(</span><span class="n">IntrRxDone</span> <span class="o">|</span> <span class="n">IntrRxIntr</span> <span class="o">|</span> <span class="n">RxStatusFIFOOver</span> <span class="o">|</span>
		     <span class="n">IntrRxErr</span> <span class="o">|</span> <span class="n">IntrRxOverrun</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netdev_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_done</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span> <span class="o">&amp;</span>
		    <span class="p">(</span><span class="n">IntrTxDone</span> <span class="o">|</span> <span class="n">IntrTxIntr</span> <span class="o">|</span> <span class="n">IntrTxIdle</span> <span class="o">|</span> <span class="n">IntrTxErr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">netdev_tx_done</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Abnormal error summary/uncommon events handlers. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">IntrAbnormalSummary</span><span class="p">)</span>
			<span class="n">netdev_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&gt;=</span> <span class="n">budget</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>

		<span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">intr_status</span><span class="p">);</span>

	<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>

	<span class="cm">/* Reenable interrupts providing nothing is trying to shut</span>
<span class="cm">	 * the chip down. */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span><span class="p">)</span>
		<span class="n">natsemi_irq_enable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This routine is logically part of the interrupt handler, but separated</span>
<span class="cm">   for clarity and better register allocation. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">work_done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">boguscnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">+</span> <span class="n">RX_RING_SIZE</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">desc_status</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_head_desc</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* If the driver owns the next entry it&#39;s a new packet. Send it up. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* e.g. &amp; DescOwn */</span>
		<span class="kt">int</span> <span class="n">pkt_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_rx_status</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
				<span class="s">&quot;  netdev_rx() entry %d status was %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">entry</span><span class="p">,</span> <span class="n">desc_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">boguscnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">work_done</span> <span class="o">&gt;=</span> <span class="n">work_to_do</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">(</span><span class="o">*</span><span class="n">work_done</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

		<span class="n">pkt_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="n">DescSizeMask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">desc_status</span><span class="o">&amp;</span><span class="p">(</span><span class="n">DescMore</span><span class="o">|</span><span class="n">DescPktOK</span><span class="o">|</span><span class="n">DescRxLong</span><span class="p">))</span> <span class="o">!=</span> <span class="n">DescPktOK</span><span class="p">){</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="n">DescMore</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_rx_err</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
						<span class="s">&quot;%s: Oversized(?) Ethernet &quot;</span>
						<span class="s">&quot;frame spanned multiple &quot;</span>
						<span class="s">&quot;buffers, entry %#08x &quot;</span>
						<span class="s">&quot;status %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						<span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">,</span> <span class="n">desc_status</span><span class="p">);</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>

				<span class="cm">/* The RX state machine has probably</span>
<span class="cm">				 * locked up beneath us.  Follow the</span>
<span class="cm">				 * reset procedure documented in</span>
<span class="cm">				 * AN-1287. */</span>

				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">reset_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">reinit_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ring_dma</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxRingPtr</span><span class="p">);</span>
				<span class="n">check_link</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

				<span class="cm">/* We&#39;ll enable RX on exit from this</span>
<span class="cm">				 * function. */</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* There was an error. */</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DescRxAbort</span><span class="o">|</span><span class="n">DescRxOver</span><span class="p">))</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DescRxLong</span><span class="o">|</span><span class="n">DescRxRunt</span><span class="p">))</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DescRxInvalid</span><span class="o">|</span><span class="n">DescRxAlign</span><span class="p">))</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="n">DescRxCRC</span><span class="p">)</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* if this is the tail of a double buffer</span>
<span class="cm">			 * packet, we&#39;ve already counted the error</span>
<span class="cm">			 * on the first part.  Ignore the second half.</span>
<span class="cm">			 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
			<span class="cm">/* Omit CRC size. */</span>
			<span class="cm">/* Check if the packet is long enough to accept</span>
<span class="cm">			 * without copying to a minimally-sized skbuff. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&lt;</span> <span class="n">rx_copybreak</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pkt_len</span> <span class="o">+</span> <span class="n">RX_OFFSET</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* 16 byte align the IP header */</span>
				<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">RX_OFFSET</span><span class="p">);</span>
				<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
					<span class="n">buflen</span><span class="p">,</span>
					<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
				<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
					<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>
				<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
					<span class="n">buflen</span><span class="p">,</span>
					<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
						 <span class="n">buflen</span> <span class="o">+</span> <span class="n">NATSEMI_PADDING</span><span class="p">,</span>
						 <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span> <span class="n">pkt_len</span><span class="p">);</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">pkt_len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">)</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_head_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
		<span class="n">desc_status</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rx_head_desc</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">refill_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Restart Rx engine if stopped. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">oom</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">RxOn</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">intr_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">LinkChange</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">lpa</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_LPA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">netif_msg_link</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;%s: Autonegotiation advertising&quot;</span>
				<span class="s">&quot; %#04x  partner %#04x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span><span class="p">,</span> <span class="n">lpa</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* read MII int status to clear the flag */</span>
		<span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIntrStatus</span><span class="p">);</span>
		<span class="n">check_link</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">StatsMax</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__get_stats</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">IntrTxUnderrun</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_config</span> <span class="o">&amp;</span> <span class="n">TxDrthMask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">TX_DRTH_VAL_LIMIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_config</span> <span class="o">+=</span> <span class="n">TX_DRTH_VAL_INC</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_tx_err</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
					<span class="s">&quot;%s: increased tx threshold, txcfg %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_config</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_tx_err</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
					<span class="s">&quot;%s: tx underrun with maximum tx threshold, txcfg %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_config</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">tx_config</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxConfig</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">WOLPkt</span> <span class="o">&amp;&amp;</span> <span class="n">netif_msg_wol</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">wol_status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLCmd</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: Link wake-up event %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">wol_status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">RxStatusFIFOOver</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_rx_err</span><span class="p">(</span><span class="n">np</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">netif_msg_intr</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: Rx status FIFO overrun</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Hmmmmm, it&#39;s not clear how to recover from PCI faults. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">IntrPCIErr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: PCI error %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">IntrPCIErr</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* The chip only need report frame silently dropped. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span> <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxCRCErrs</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_missed_errors</span> <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxMissed</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* The chip only need report frame silently dropped. */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span><span class="p">)</span>
		<span class="n">__get_stats</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">natsemi_poll_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">intr_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#define HASH_TABLE	0x200</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">mc_filter</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span> <span class="cm">/* Multicast hash filter */</span>
	<span class="n">u32</span> <span class="n">rx_mode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Set promiscuous. */</span>
		<span class="n">rx_mode</span> <span class="o">=</span> <span class="n">RxFilterEnable</span> <span class="o">|</span> <span class="n">AcceptBroadcast</span>
			<span class="o">|</span> <span class="n">AcceptAllMulticast</span> <span class="o">|</span> <span class="n">AcceptAllPhys</span> <span class="o">|</span> <span class="n">AcceptMyPhys</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">multicast_filter_limit</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rx_mode</span> <span class="o">=</span> <span class="n">RxFilterEnable</span> <span class="o">|</span> <span class="n">AcceptBroadcast</span>
			<span class="o">|</span> <span class="n">AcceptAllMulticast</span> <span class="o">|</span> <span class="n">AcceptMyPhys</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">mc_filter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mc_filter</span><span class="p">));</span>
		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">ether_crc</span><span class="p">(</span><span class="n">ETH_ALEN</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">23</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span><span class="p">;</span>
			<span class="n">mc_filter</span><span class="p">[</span><span class="n">b</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">rx_mode</span> <span class="o">=</span> <span class="n">RxFilterEnable</span> <span class="o">|</span> <span class="n">AcceptBroadcast</span>
			<span class="o">|</span> <span class="n">AcceptMulticast</span> <span class="o">|</span> <span class="n">AcceptMyPhys</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">HASH_TABLE</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">((</span><span class="n">mc_filter</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">mc_filter</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			       <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rx_mode</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx_mode</span> <span class="o">=</span> <span class="n">rx_mode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">natsemi_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">||</span> <span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="n">NATSEMI_RX_LIMIT</span><span class="o">-</span><span class="n">NATSEMI_HEADERS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="cm">/* synchronized against open : rtnl_lock() held by caller */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

		<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* stop engines */</span>
		<span class="n">natsemi_stop_rxtx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="cm">/* drain rx queue */</span>
		<span class="n">drain_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="cm">/* change buffers */</span>
		<span class="n">set_bufsize</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">reinit_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ring_dma</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxRingPtr</span><span class="p">);</span>
		<span class="cm">/* restart engines */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">RxOn</span> <span class="o">|</span> <span class="n">TxOn</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span><span class="p">)</span>
		<span class="n">__set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_regs_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NATSEMI_REGS_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_eeprom_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">eeprom_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">netdev_get_ecmd</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ecmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">netdev_set_ecmd</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ecmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">netdev_get_wol</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">supported</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span><span class="p">);</span>
	<span class="n">netdev_get_sopass</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">wol</span><span class="o">-&gt;</span><span class="n">sopass</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="n">wol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">netdev_set_wol</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">wol</span><span class="o">-&gt;</span><span class="n">wolopts</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">netdev_set_sopass</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">wol</span><span class="o">-&gt;</span><span class="n">sopass</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">NATSEMI_REGS_VER</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">netdev_get_regs</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nway_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/* if autoneg is off, it&#39;s an error */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">BMCR_ANRESTART</span><span class="p">);</span>
		<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* LSTATUS is latched low until a read - so read twice */</span>
	<span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">BMSR_LSTATUS</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_eeprom</span> <span class="o">*</span><span class="n">eeprom</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">eebuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">eebuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">eeprom_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eebuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">PCI_VENDOR_ID_NS</span> <span class="o">|</span> <span class="p">(</span><span class="n">PCI_DEVICE_ID_NS_83815</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">netdev_get_eeprom</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">eebuf</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">eebuf</span><span class="o">+</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">eebuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_drvinfo</span> <span class="o">=</span> <span class="n">get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs_len</span> <span class="o">=</span> <span class="n">get_regs_len</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_eeprom_len</span> <span class="o">=</span> <span class="n">get_eeprom_len</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_settings</span> <span class="o">=</span> <span class="n">get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span> <span class="o">=</span> <span class="n">set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_wol</span> <span class="o">=</span> <span class="n">get_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_wol</span> <span class="o">=</span> <span class="n">set_wol</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs</span> <span class="o">=</span> <span class="n">get_regs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span> <span class="o">=</span> <span class="n">get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span> <span class="o">=</span> <span class="n">set_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nway_reset</span> <span class="o">=</span> <span class="n">nway_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span> <span class="o">=</span> <span class="n">get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_eeprom</span> <span class="o">=</span> <span class="n">get_eeprom</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_set_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">newval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">data</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLCmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">WakeOptsSummary</span><span class="p">;</span>

	<span class="cm">/* translate to bitmasks this chip understands */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newval</span> <span class="o">&amp;</span> <span class="n">WAKE_PHY</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">WakePhy</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newval</span> <span class="o">&amp;</span> <span class="n">WAKE_UCAST</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">WakeUnicast</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newval</span> <span class="o">&amp;</span> <span class="n">WAKE_MCAST</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">WakeMulticast</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newval</span> <span class="o">&amp;</span> <span class="n">WAKE_BCAST</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">WakeBroadcast</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newval</span> <span class="o">&amp;</span> <span class="n">WAKE_ARP</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">WakeArp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newval</span> <span class="o">&amp;</span> <span class="n">WAKE_MAGIC</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">WakeMagic</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">srr</span> <span class="o">&gt;=</span> <span class="n">SRR_DP83815_D</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newval</span> <span class="o">&amp;</span> <span class="n">WAKE_MAGICSECURE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="n">WakeMagicSecure</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLCmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_get_wol</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">supported</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">cur</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">regval</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLCmd</span><span class="p">);</span>

	<span class="o">*</span><span class="n">supported</span> <span class="o">=</span> <span class="p">(</span><span class="n">WAKE_PHY</span> <span class="o">|</span> <span class="n">WAKE_UCAST</span> <span class="o">|</span> <span class="n">WAKE_MCAST</span> <span class="o">|</span> <span class="n">WAKE_BCAST</span>
			<span class="o">|</span> <span class="n">WAKE_ARP</span> <span class="o">|</span> <span class="n">WAKE_MAGIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">srr</span> <span class="o">&gt;=</span> <span class="n">SRR_DP83815_D</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* SOPASS works on revD and higher */</span>
		<span class="o">*</span><span class="n">supported</span> <span class="o">|=</span> <span class="n">WAKE_MAGICSECURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* translate from chip bitmasks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regval</span> <span class="o">&amp;</span> <span class="n">WakePhy</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cur</span> <span class="o">|=</span> <span class="n">WAKE_PHY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regval</span> <span class="o">&amp;</span> <span class="n">WakeUnicast</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cur</span> <span class="o">|=</span> <span class="n">WAKE_UCAST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regval</span> <span class="o">&amp;</span> <span class="n">WakeMulticast</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cur</span> <span class="o">|=</span> <span class="n">WAKE_MCAST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regval</span> <span class="o">&amp;</span> <span class="n">WakeBroadcast</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cur</span> <span class="o">|=</span> <span class="n">WAKE_BCAST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regval</span> <span class="o">&amp;</span> <span class="n">WakeArp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cur</span> <span class="o">|=</span> <span class="n">WAKE_ARP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regval</span> <span class="o">&amp;</span> <span class="n">WakeMagic</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cur</span> <span class="o">|=</span> <span class="n">WAKE_MAGIC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regval</span> <span class="o">&amp;</span> <span class="n">WakeMagicSecure</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this can be on in revC, but it&#39;s broken */</span>
		<span class="o">*</span><span class="n">cur</span> <span class="o">|=</span> <span class="n">WAKE_MAGICSECURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_set_sopass</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">newval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">sval</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">newval</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">srr</span> <span class="o">&lt;</span> <span class="n">SRR_DP83815_D</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* enable writing to these registers by disabling the RX filter */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RFCRAddressMask</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RxFilterEnable</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>

	<span class="cm">/* write the three words to (undocumented) RFCR vals 0xa, 0xc, 0xe */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">addr</span> <span class="o">|</span> <span class="mh">0xa</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">sval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">addr</span> <span class="o">|</span> <span class="mh">0xc</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">sval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">addr</span> <span class="o">|</span> <span class="mh">0xe</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">sval</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>

	<span class="cm">/* re-enable the RX filter */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">addr</span> <span class="o">|</span> <span class="n">RxFilterEnable</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_get_sopass</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">sval</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">srr</span> <span class="o">&lt;</span> <span class="n">SRR_DP83815_D</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sval</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* read the three words from (undocumented) RFCR vals 0xa, 0xc, 0xe */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RFCRAddressMask</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">addr</span> <span class="o">|</span> <span class="mh">0xa</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
	<span class="n">sval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">addr</span> <span class="o">|</span> <span class="mh">0xc</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
	<span class="n">sval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">addr</span> <span class="o">|</span> <span class="mh">0xe</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
	<span class="n">sval</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_get_ecmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">port</span>        <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span><span class="p">;</span>
	<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">ecmd</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">);</span>
	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">duplex</span>      <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">;</span>
	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">autoneg</span>     <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">autoneg</span><span class="p">;</span>
	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_10HALF</span><span class="p">)</span>
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_10baseT_Half</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_10FULL</span><span class="p">)</span>
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_10baseT_Full</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_100HALF</span><span class="p">)</span>
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_100baseT_Half</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_100FULL</span><span class="p">)</span>
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_100baseT_Full</span><span class="p">;</span>
	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">supported</span>   <span class="o">=</span> <span class="p">(</span><span class="n">SUPPORTED_Autoneg</span> <span class="o">|</span>
		<span class="n">SUPPORTED_10baseT_Half</span>  <span class="o">|</span> <span class="n">SUPPORTED_10baseT_Full</span>  <span class="o">|</span>
		<span class="n">SUPPORTED_100baseT_Half</span> <span class="o">|</span> <span class="n">SUPPORTED_100baseT_Full</span> <span class="o">|</span>
		<span class="n">SUPPORTED_TP</span> <span class="o">|</span> <span class="n">SUPPORTED_MII</span> <span class="o">|</span> <span class="n">SUPPORTED_FIBRE</span><span class="p">);</span>
	<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">phy_address</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We intentionally report the phy address of the external</span>
<span class="cm">	 * phy, even if the internal phy is used. This is necessary</span>
<span class="cm">	 * to work around a deficiency of the ethtool interface:</span>
<span class="cm">	 * It&#39;s only possible to query the settings of the active</span>
<span class="cm">	 * port. Therefore</span>
<span class="cm">	 * # ethtool -s ethX port mii</span>
<span class="cm">	 * actually sends an ioctl to switch to port mii with the</span>
<span class="cm">	 * settings that are used for the current active port.</span>
<span class="cm">	 * If we would report a different phy address in this</span>
<span class="cm">	 * command, then</span>
<span class="cm">	 * # ethtool -s ethX port tp;ethtool -s ethX port mii</span>
<span class="cm">	 * would unintentionally change the phy address.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Fortunately the phy address doesn&#39;t matter with the</span>
<span class="cm">	 * internal phy...</span>
<span class="cm">	 */</span>

	<span class="cm">/* set information based on active port type */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="n">PORT_TP</span>:
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_TP</span><span class="p">;</span>
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">XCVR_INTERNAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PORT_MII</span>:
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_MII</span><span class="p">;</span>
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">XCVR_EXTERNAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PORT_FIBRE</span>:
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_FIBRE</span><span class="p">;</span>
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">XCVR_EXTERNAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if autonegotiation is on, try to return the active speed/duplex */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">==</span> <span class="n">AUTONEG_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_Autoneg</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">mii_nway_result</span><span class="p">(</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MII_LPA</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">LPA_100FULL</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">==</span> <span class="n">LPA_100HALF</span><span class="p">)</span>
			<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">ecmd</span><span class="p">,</span> <span class="n">SPEED_100</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">ecmd</span><span class="p">,</span> <span class="n">SPEED_10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">LPA_100FULL</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">==</span> <span class="n">LPA_10FULL</span><span class="p">)</span>
			<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">DUPLEX_FULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">DUPLEX_HALF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ignore maxtxpkt, maxrxpkt for now */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_set_ecmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="n">PORT_TP</span> <span class="o">&amp;&amp;</span> <span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="n">PORT_MII</span> <span class="o">&amp;&amp;</span> <span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="n">PORT_FIBRE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">!=</span> <span class="n">XCVR_INTERNAL</span> <span class="o">&amp;&amp;</span> <span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">!=</span> <span class="n">XCVR_EXTERNAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">==</span> <span class="n">AUTONEG_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ADVERTISED_10baseT_Half</span> <span class="o">|</span>
					  <span class="n">ADVERTISED_10baseT_Full</span> <span class="o">|</span>
					  <span class="n">ADVERTISED_100baseT_Half</span> <span class="o">|</span>
					  <span class="n">ADVERTISED_100baseT_Full</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">==</span> <span class="n">AUTONEG_DISABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">speed</span> <span class="o">=</span> <span class="n">ethtool_cmd_speed</span><span class="p">(</span><span class="n">ecmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">SPEED_10</span> <span class="o">&amp;&amp;</span> <span class="n">speed</span> <span class="o">!=</span> <span class="n">SPEED_100</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">!=</span> <span class="n">DUPLEX_HALF</span> <span class="o">&amp;&amp;</span> <span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">!=</span> <span class="n">DUPLEX_FULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re ignoring the PHY then autoneg and the internal</span>
<span class="cm">	 * transceiver are really not going to work so don&#39;t let the</span>
<span class="cm">	 * user select them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ignore_phy</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">==</span> <span class="n">AUTONEG_ENABLE</span> <span class="o">||</span>
			       <span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">==</span> <span class="n">PORT_TP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * maxtxpkt, maxrxpkt: ignored for now.</span>
<span class="cm">	 *</span>
<span class="cm">	 * transceiver:</span>
<span class="cm">	 * PORT_TP is always XCVR_INTERNAL, PORT_MII and PORT_FIBRE are always</span>
<span class="cm">	 * XCVR_EXTERNAL. The implementation thus ignores ecmd-&gt;transceiver and</span>
<span class="cm">	 * selects based on ecmd-&gt;port.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Actually PORT_FIBRE is nearly identical to PORT_MII: it&#39;s for fibre</span>
<span class="cm">	 * phys that are connected to the mii bus. It&#39;s used to apply fibre</span>
<span class="cm">	 * specific updates.</span>
<span class="cm">	 */</span>

	<span class="cm">/* WHEW! now lets bang some bits */</span>

	<span class="cm">/* save the parms */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span>          <span class="o">=</span> <span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">autoneg</span>           <span class="o">=</span> <span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">autoneg</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span> <span class="o">=</span> <span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">phy_address</span> <span class="o">&amp;</span> <span class="n">PhyAddrMask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">==</span> <span class="n">AUTONEG_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* advertise only what has been requested */</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ADVERTISE_ALL</span> <span class="o">|</span> <span class="n">ADVERTISE_100BASE4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISED_10baseT_Half</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISE_10HALF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISED_10baseT_Full</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISE_10FULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISED_100baseT_Half</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISE_100HALF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">&amp;</span> <span class="n">ADVERTISED_100baseT_Full</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISE_100FULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">speed</span>  <span class="o">=</span> <span class="n">ethtool_cmd_speed</span><span class="p">(</span><span class="n">ecmd</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">;</span>
		<span class="cm">/* user overriding the initial full duplex parm? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">DUPLEX_HALF</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">full_duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the right phy enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">==</span> <span class="n">PORT_TP</span><span class="p">)</span>
		<span class="n">switch_port_internal</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">switch_port_external</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* set parms and see how this affected our link status */</span>
	<span class="n">init_phy_fixup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">check_link</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rfcr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">rbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* read non-mii page 0 of registers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NATSEMI_PG0_NREGS</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* read current mii registers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">NATSEMI_PG0_NREGS</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NATSEMI_PG0_NREGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>

	<span class="cm">/* read only the &#39;magic&#39; registers from page 1 */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PGSEL</span><span class="p">);</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PMDCSR</span><span class="p">);</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TSTDAT</span><span class="p">);</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DSPCFG</span><span class="p">);</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">SDCFG</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PGSEL</span><span class="p">);</span>

	<span class="cm">/* read RFCR indexed registers */</span>
	<span class="n">rfcr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NATSEMI_RFDR_NREGS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterData</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rfcr</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxFilterAddr</span><span class="p">);</span>

	<span class="cm">/* the interrupt status is clear-on-read - see if we missed any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">rbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;%s: shoot, we dropped an interrupt (%#08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">rbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define SWAP_BITS(x)	( (((x) &amp; 0x0001) &lt;&lt; 15) | (((x) &amp; 0x0002) &lt;&lt; 13) \</span>
<span class="cp">			| (((x) &amp; 0x0004) &lt;&lt; 11) | (((x) &amp; 0x0008) &lt;&lt; 9)  \</span>
<span class="cp">			| (((x) &amp; 0x0010) &lt;&lt; 7)  | (((x) &amp; 0x0020) &lt;&lt; 5)  \</span>
<span class="cp">			| (((x) &amp; 0x0040) &lt;&lt; 3)  | (((x) &amp; 0x0080) &lt;&lt; 1)  \</span>
<span class="cp">			| (((x) &amp; 0x0100) &gt;&gt; 1)  | (((x) &amp; 0x0200) &gt;&gt; 3)  \</span>
<span class="cp">			| (((x) &amp; 0x0400) &gt;&gt; 5)  | (((x) &amp; 0x0800) &gt;&gt; 7)  \</span>
<span class="cp">			| (((x) &amp; 0x1000) &gt;&gt; 9)  | (((x) &amp; 0x2000) &gt;&gt; 11) \</span>
<span class="cp">			| (((x) &amp; 0x4000) &gt;&gt; 13) | (((x) &amp; 0x8000) &gt;&gt; 15) )</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_get_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">ebuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* eeprom_read reads 16 bits, and indexes by 16 bits */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">eeprom_size</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ebuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eeprom_read</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="cm">/* The EEPROM itself stores data bit-swapped, but eeprom_read</span>
<span class="cm">		 * reads it back &quot;sanely&quot;. So we swap it back here in order to</span>
<span class="cm">		 * present it to userland as it is stored. */</span>
		<span class="n">ebuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SWAP_BITS</span><span class="p">(</span><span class="n">ebuf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mii_ioctl_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:		<span class="cm">/* Get address of MII PHY in use. */</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span><span class="p">;</span>
		<span class="cm">/* Fall Through */</span>

	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:		<span class="cm">/* Read MII PHY register. */</span>
		<span class="cm">/* The phy_id is not enough to uniquely identify</span>
<span class="cm">		 * the intended target. Therefore the command is sent to</span>
<span class="cm">		 * the given mii on the current port.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="n">PORT_TP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span><span class="p">)</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
							<span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">move_int_phy</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">miiport_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">,</span>
							<span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:		<span class="cm">/* Write MII PHY register. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="n">PORT_TP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span><span class="p">)</span> <span class="p">{</span>
 				<span class="k">if</span> <span class="p">((</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">==</span> <span class="n">MII_ADVERTISE</span><span class="p">)</span>
					<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">val_in</span><span class="p">;</span>
				<span class="n">mdio_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">,</span>
							<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_in</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">phy_addr_external</span><span class="p">)</span> <span class="p">{</span>
 				<span class="k">if</span> <span class="p">((</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">==</span> <span class="n">MII_ADVERTISE</span><span class="p">)</span>
					<span class="n">np</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">val_in</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">move_int_phy</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
			<span class="n">miiport_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">,</span>
						<span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">,</span>
						<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_in</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_wol_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable_intr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_wol</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: remaining active for wake-on-lan</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* For WOL we must restart the rx process in silent mode.</span>
<span class="cm">	 * Write NULL to the RxRingPtr. Only possible if</span>
<span class="cm">	 * rx process is stopped</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxRingPtr</span><span class="p">);</span>

	<span class="cm">/* read WoL status to clear */</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLCmd</span><span class="p">);</span>

	<span class="cm">/* PME on, clear status */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">SavedClkRun</span> <span class="o">|</span> <span class="n">PMEEnable</span> <span class="o">|</span> <span class="n">PMEStatus</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ClkRun</span><span class="p">);</span>

	<span class="cm">/* and restart the rx process */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">RxOn</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_intr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enable the WOL interrupt.</span>
<span class="cm">		 * Could be used to send a netlink message.</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">WOLPkt</span> <span class="o">|</span> <span class="n">LinkChange</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrMask</span><span class="p">);</span>
		<span class="n">natsemi_irq_enable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_ifdown</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
			<span class="s">&quot;%s: Shutting down ethercard, status was %#04x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipCmd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_pktdata</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
			<span class="s">&quot;%s: Queue pointers were Tx %d / %d,  Rx %d / %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">,</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dirty_rx</span><span class="p">);</span>

	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: what if someone tries to close a device</span>
<span class="cm">	 * that is suspended?</span>
<span class="cm">	 * Should we reenable the nic to switch to</span>
<span class="cm">	 * the final WOL settings?</span>
<span class="cm">	 */</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">natsemi_irq_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Interrupt disabled, interrupt handler released,</span>
<span class="cm">	 * queue stopped, timer deleted, rtnl_lock held</span>
<span class="cm">	 * All async codepaths that access the driver are disabled.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrMask</span><span class="p">);</span>
	<span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIntrStatus</span><span class="p">);</span>

	<span class="cm">/* Freeze Stats */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">StatsFreeze</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StatsCtrl</span><span class="p">);</span>

	<span class="cm">/* Stop the chip&#39;s Tx and Rx processes. */</span>
	<span class="n">natsemi_stop_rxtx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">__get_stats</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* clear the carrier last - an interrupt could reenable it otherwise */</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dump_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">drain_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">free_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="p">{</span>
		<span class="n">u32</span> <span class="n">wol</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLCmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">WakeOptsSummary</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wol</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* restart the NIC in WOL mode.</span>
<span class="cm">			 * The nic must be stopped for this.</span>
<span class="cm">			 */</span>
			<span class="n">enable_wol_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Restore PME enable bit unmolested */</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">SavedClkRun</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ClkRun</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">natsemi_remove1</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">NATSEMI_REMOVE_FILE</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dspcfg_workaround</span><span class="p">);</span>
	<span class="n">unregister_netdev</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_release_regions</span> <span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="n">free_netdev</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="cm">/*</span>
<span class="cm"> * The ns83815 chip doesn&#39;t have explicit RxStop bits.</span>
<span class="cm"> * Kicking the Rx or Tx process for a new packet reenables the Rx process</span>
<span class="cm"> * of the nic, thus this function must be very careful:</span>
<span class="cm"> *</span>
<span class="cm"> * suspend/resume synchronization:</span>
<span class="cm"> * entry points:</span>
<span class="cm"> *   netdev_open, netdev_close, netdev_ioctl, set_rx_mode, intr_handler,</span>
<span class="cm"> *   start_tx, ns_tx_timeout</span>
<span class="cm"> *</span>
<span class="cm"> * No function accesses the hardware without checking np-&gt;hands_off.</span>
<span class="cm"> *	the check occurs under spin_lock_irq(&amp;np-&gt;lock);</span>
<span class="cm"> * exceptions:</span>
<span class="cm"> *	* netdev_ioctl: noncritical access.</span>
<span class="cm"> *	* netdev_open: cannot happen due to the device_detach</span>
<span class="cm"> *	* netdev_close: doesn&#39;t hurt.</span>
<span class="cm"> *	* netdev_timer: timer stopped by natsemi_suspend.</span>
<span class="cm"> *	* intr_handler: doesn&#39;t acquire the spinlock. suspend calls</span>
<span class="cm"> *		disable_irq() to enforce synchronization.</span>
<span class="cm"> *      * natsemi_poll: checks before reenabling interrupts.  suspend</span>
<span class="cm"> *              sets hands_off, disables interrupts and then waits with</span>
<span class="cm"> *              napi_disable().</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupts must be disabled, otherwise hands_off can cause irq storms.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">natsemi_suspend</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span> <span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ns_ioaddr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span> <span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

		<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">natsemi_irq_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">natsemi_stop_rxtx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

		<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

		<span class="cm">/* Update the error counts. */</span>
		<span class="n">__get_stats</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* pci_power_off(pdev, -1); */</span>
		<span class="n">drain_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">{</span>
			<span class="n">u32</span> <span class="n">wol</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">WOLCmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">WakeOptsSummary</span><span class="p">;</span>
			<span class="cm">/* Restore PME enable bit */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wol</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* restart the NIC in WOL mode.</span>
<span class="cm">				 * The nic must be stopped for this.</span>
<span class="cm">				 * FIXME: use the WOL interrupt</span>
<span class="cm">				 */</span>
				<span class="n">enable_wol_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Restore PME enable bit unmolested */</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">SavedClkRun</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ClkRun</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">natsemi_resume</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span> <span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;pci_enable_device() failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="cm">/*	pci_power_on(pdev); */</span>

		<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

		<span class="n">natsemi_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">init_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">hands_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">init_registers</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">HZ</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">natsemi_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">natsemi_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">natsemi_probe1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">natsemi_remove1</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">natsemi_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">natsemi_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">natsemi_init_mod</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* when a module, this is printed whether or not devices are found in probe */</span>
<span class="cp">#ifdef MODULE</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">natsemi_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">natsemi_exit_mod</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">natsemi_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">natsemi_init_mod</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">natsemi_exit_mod</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
