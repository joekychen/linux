<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › natsemi › sonic.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>sonic.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Header file for sonic.c</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Waldorf Electronics, Germany</span>
<span class="cm"> * Written by Andreas Busse</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: most of the structure definitions here are endian dependent.</span>
<span class="cm"> * If you want to use this driver on big endian machines, the data</span>
<span class="cm"> * and pad structure members must be exchanged. Also, the structures</span>
<span class="cm"> * need to be changed accordingly to the bus size.</span>
<span class="cm"> *</span>
<span class="cm"> * 981229 MSch:	did just that for the 68k Mac port (32 bit, big endian)</span>
<span class="cm"> *</span>
<span class="cm"> * 990611 David Huggins-Daines &lt;dhd@debian.org&gt;: This machine abstraction</span>
<span class="cm"> * does not cope with 16-bit bus sizes very well.  Therefore I have</span>
<span class="cm"> * rewritten it with ugly macros and evil inlines.</span>
<span class="cm"> *</span>
<span class="cm"> * 050625 Finn Thain: introduced more 32-bit cards and dhd&#39;s support</span>
<span class="cm"> *        for 16-bit cards (from the mac68k project).</span>
<span class="cm"> */</span>

<span class="cp">#ifndef SONIC_H</span>
<span class="cp">#define SONIC_H</span>


<span class="cm">/*</span>
<span class="cm"> * SONIC register offsets</span>
<span class="cm"> */</span>

<span class="cp">#define SONIC_CMD              0x00</span>
<span class="cp">#define SONIC_DCR              0x01</span>
<span class="cp">#define SONIC_RCR              0x02</span>
<span class="cp">#define SONIC_TCR              0x03</span>
<span class="cp">#define SONIC_IMR              0x04</span>
<span class="cp">#define SONIC_ISR              0x05</span>

<span class="cp">#define SONIC_UTDA             0x06</span>
<span class="cp">#define SONIC_CTDA             0x07</span>

<span class="cp">#define SONIC_URDA             0x0d</span>
<span class="cp">#define SONIC_CRDA             0x0e</span>
<span class="cp">#define SONIC_EOBC             0x13</span>
<span class="cp">#define SONIC_URRA             0x14</span>
<span class="cp">#define SONIC_RSA              0x15</span>
<span class="cp">#define SONIC_REA              0x16</span>
<span class="cp">#define SONIC_RRP              0x17</span>
<span class="cp">#define SONIC_RWP              0x18</span>
<span class="cp">#define SONIC_RSC              0x2b</span>

<span class="cp">#define SONIC_CEP              0x21</span>
<span class="cp">#define SONIC_CAP2             0x22</span>
<span class="cp">#define SONIC_CAP1             0x23</span>
<span class="cp">#define SONIC_CAP0             0x24</span>
<span class="cp">#define SONIC_CE               0x25</span>
<span class="cp">#define SONIC_CDP              0x26</span>
<span class="cp">#define SONIC_CDC              0x27</span>

<span class="cp">#define SONIC_WT0              0x29</span>
<span class="cp">#define SONIC_WT1              0x2a</span>

<span class="cp">#define SONIC_SR               0x28</span>


<span class="cm">/* test-only registers */</span>

<span class="cp">#define SONIC_TPS		0x08</span>
<span class="cp">#define SONIC_TFC		0x09</span>
<span class="cp">#define SONIC_TSA0		0x0a</span>
<span class="cp">#define SONIC_TSA1		0x0b</span>
<span class="cp">#define SONIC_TFS		0x0c</span>

<span class="cp">#define SONIC_CRBA0		0x0f</span>
<span class="cp">#define SONIC_CRBA1		0x10</span>
<span class="cp">#define SONIC_RBWC0		0x11</span>
<span class="cp">#define SONIC_RBWC1		0x12</span>
<span class="cp">#define SONIC_TTDA		0x20</span>
<span class="cp">#define SONIC_MDT		0x2f</span>

<span class="cp">#define SONIC_TRBA0		0x19</span>
<span class="cp">#define SONIC_TRBA1		0x1a</span>
<span class="cp">#define SONIC_TBWC0		0x1b</span>
<span class="cp">#define SONIC_TBWC1		0x1c</span>
<span class="cp">#define SONIC_LLFA		0x1f</span>

<span class="cp">#define SONIC_ADDR0		0x1d</span>
<span class="cp">#define SONIC_ADDR1		0x1e</span>

<span class="cm">/*</span>
<span class="cm"> * Error counters</span>
<span class="cm"> */</span>

<span class="cp">#define SONIC_CRCT              0x2c</span>
<span class="cp">#define SONIC_FAET              0x2d</span>
<span class="cp">#define SONIC_MPT               0x2e</span>

<span class="cp">#define SONIC_DCR2              0x3f</span>

<span class="cm">/*</span>
<span class="cm"> * SONIC command bits</span>
<span class="cm"> */</span>

<span class="cp">#define SONIC_CR_LCAM           0x0200</span>
<span class="cp">#define SONIC_CR_RRRA           0x0100</span>
<span class="cp">#define SONIC_CR_RST            0x0080</span>
<span class="cp">#define SONIC_CR_ST             0x0020</span>
<span class="cp">#define SONIC_CR_STP            0x0010</span>
<span class="cp">#define SONIC_CR_RXEN           0x0008</span>
<span class="cp">#define SONIC_CR_RXDIS          0x0004</span>
<span class="cp">#define SONIC_CR_TXP            0x0002</span>
<span class="cp">#define SONIC_CR_HTX            0x0001</span>

<span class="cm">/*</span>
<span class="cm"> * SONIC data configuration bits</span>
<span class="cm"> */</span>

<span class="cp">#define SONIC_DCR_EXBUS         0x8000</span>
<span class="cp">#define SONIC_DCR_LBR           0x2000</span>
<span class="cp">#define SONIC_DCR_PO1           0x1000</span>
<span class="cp">#define SONIC_DCR_PO0           0x0800</span>
<span class="cp">#define SONIC_DCR_SBUS          0x0400</span>
<span class="cp">#define SONIC_DCR_USR1          0x0200</span>
<span class="cp">#define SONIC_DCR_USR0          0x0100</span>
<span class="cp">#define SONIC_DCR_WC1           0x0080</span>
<span class="cp">#define SONIC_DCR_WC0           0x0040</span>
<span class="cp">#define SONIC_DCR_DW            0x0020</span>
<span class="cp">#define SONIC_DCR_BMS           0x0010</span>
<span class="cp">#define SONIC_DCR_RFT1          0x0008</span>
<span class="cp">#define SONIC_DCR_RFT0          0x0004</span>
<span class="cp">#define SONIC_DCR_TFT1          0x0002</span>
<span class="cp">#define SONIC_DCR_TFT0          0x0001</span>

<span class="cm">/*</span>
<span class="cm"> * Constants for the SONIC receive control register.</span>
<span class="cm"> */</span>

<span class="cp">#define SONIC_RCR_ERR           0x8000</span>
<span class="cp">#define SONIC_RCR_RNT           0x4000</span>
<span class="cp">#define SONIC_RCR_BRD           0x2000</span>
<span class="cp">#define SONIC_RCR_PRO           0x1000</span>
<span class="cp">#define SONIC_RCR_AMC           0x0800</span>
<span class="cp">#define SONIC_RCR_LB1           0x0400</span>
<span class="cp">#define SONIC_RCR_LB0           0x0200</span>

<span class="cp">#define SONIC_RCR_MC            0x0100</span>
<span class="cp">#define SONIC_RCR_BC            0x0080</span>
<span class="cp">#define SONIC_RCR_LPKT          0x0040</span>
<span class="cp">#define SONIC_RCR_CRS           0x0020</span>
<span class="cp">#define SONIC_RCR_COL           0x0010</span>
<span class="cp">#define SONIC_RCR_CRCR          0x0008</span>
<span class="cp">#define SONIC_RCR_FAER          0x0004</span>
<span class="cp">#define SONIC_RCR_LBK           0x0002</span>
<span class="cp">#define SONIC_RCR_PRX           0x0001</span>

<span class="cp">#define SONIC_RCR_LB_OFF        0</span>
<span class="cp">#define SONIC_RCR_LB_MAC        SONIC_RCR_LB0</span>
<span class="cp">#define SONIC_RCR_LB_ENDEC      SONIC_RCR_LB1</span>
<span class="cp">#define SONIC_RCR_LB_TRANS      (SONIC_RCR_LB0 | SONIC_RCR_LB1)</span>

<span class="cm">/* default RCR setup */</span>

<span class="cp">#define SONIC_RCR_DEFAULT       (SONIC_RCR_BRD)</span>


<span class="cm">/*</span>
<span class="cm"> * SONIC Transmit Control register bits</span>
<span class="cm"> */</span>

<span class="cp">#define SONIC_TCR_PINTR         0x8000</span>
<span class="cp">#define SONIC_TCR_POWC          0x4000</span>
<span class="cp">#define SONIC_TCR_CRCI          0x2000</span>
<span class="cp">#define SONIC_TCR_EXDIS         0x1000</span>
<span class="cp">#define SONIC_TCR_EXD           0x0400</span>
<span class="cp">#define SONIC_TCR_DEF           0x0200</span>
<span class="cp">#define SONIC_TCR_NCRS          0x0100</span>
<span class="cp">#define SONIC_TCR_CRLS          0x0080</span>
<span class="cp">#define SONIC_TCR_EXC           0x0040</span>
<span class="cp">#define SONIC_TCR_PMB           0x0008</span>
<span class="cp">#define SONIC_TCR_FU            0x0004</span>
<span class="cp">#define SONIC_TCR_BCM           0x0002</span>
<span class="cp">#define SONIC_TCR_PTX           0x0001</span>

<span class="cp">#define SONIC_TCR_DEFAULT       0x0000</span>

<span class="cm">/*</span>
<span class="cm"> * Constants for the SONIC_INTERRUPT_MASK and</span>
<span class="cm"> * SONIC_INTERRUPT_STATUS registers.</span>
<span class="cm"> */</span>

<span class="cp">#define SONIC_INT_BR		0x4000</span>
<span class="cp">#define SONIC_INT_HBL		0x2000</span>
<span class="cp">#define SONIC_INT_LCD		0x1000</span>
<span class="cp">#define SONIC_INT_PINT		0x0800</span>
<span class="cp">#define SONIC_INT_PKTRX		0x0400</span>
<span class="cp">#define SONIC_INT_TXDN		0x0200</span>
<span class="cp">#define SONIC_INT_TXER		0x0100</span>
<span class="cp">#define SONIC_INT_TC		0x0080</span>
<span class="cp">#define SONIC_INT_RDE		0x0040</span>
<span class="cp">#define SONIC_INT_RBE		0x0020</span>
<span class="cp">#define SONIC_INT_RBAE		0x0010</span>
<span class="cp">#define SONIC_INT_CRC		0x0008</span>
<span class="cp">#define SONIC_INT_FAE		0x0004</span>
<span class="cp">#define SONIC_INT_MP		0x0002</span>
<span class="cp">#define SONIC_INT_RFO		0x0001</span>


<span class="cm">/*</span>
<span class="cm"> * The interrupts we allow.</span>
<span class="cm"> */</span>

<span class="cp">#define SONIC_IMR_DEFAULT     ( SONIC_INT_BR | \</span>
<span class="cp">                                SONIC_INT_LCD | \</span>
<span class="cp">                                SONIC_INT_RFO | \</span>
<span class="cp">                                SONIC_INT_PKTRX | \</span>
<span class="cp">                                SONIC_INT_TXDN | \</span>
<span class="cp">                                SONIC_INT_TXER | \</span>
<span class="cp">                                SONIC_INT_RDE | \</span>
<span class="cp">                                SONIC_INT_RBAE | \</span>
<span class="cp">                                SONIC_INT_CRC | \</span>
<span class="cp">                                SONIC_INT_FAE | \</span>
<span class="cp">                                SONIC_INT_MP)</span>


<span class="cp">#define SONIC_EOL       0x0001</span>
<span class="cp">#define CAM_DESCRIPTORS 16</span>

<span class="cm">/* Offsets in the various DMA buffers accessed by the SONIC */</span>

<span class="cp">#define SONIC_BITMODE16 0</span>
<span class="cp">#define SONIC_BITMODE32 1</span>
<span class="cp">#define SONIC_BUS_SCALE(bitmode) ((bitmode) ? 4 : 2)</span>
<span class="cm">/* Note!  These are all measured in bus-size units, so use SONIC_BUS_SCALE */</span>
<span class="cp">#define SIZEOF_SONIC_RR 4</span>
<span class="cp">#define SONIC_RR_BUFADR_L  0</span>
<span class="cp">#define SONIC_RR_BUFADR_H  1</span>
<span class="cp">#define SONIC_RR_BUFSIZE_L 2</span>
<span class="cp">#define SONIC_RR_BUFSIZE_H 3</span>

<span class="cp">#define SIZEOF_SONIC_RD 7</span>
<span class="cp">#define SONIC_RD_STATUS   0</span>
<span class="cp">#define SONIC_RD_PKTLEN   1</span>
<span class="cp">#define SONIC_RD_PKTPTR_L 2</span>
<span class="cp">#define SONIC_RD_PKTPTR_H 3</span>
<span class="cp">#define SONIC_RD_SEQNO    4</span>
<span class="cp">#define SONIC_RD_LINK     5</span>
<span class="cp">#define SONIC_RD_IN_USE   6</span>

<span class="cp">#define SIZEOF_SONIC_TD 8</span>
<span class="cp">#define SONIC_TD_STATUS       0</span>
<span class="cp">#define SONIC_TD_CONFIG       1</span>
<span class="cp">#define SONIC_TD_PKTSIZE      2</span>
<span class="cp">#define SONIC_TD_FRAG_COUNT   3</span>
<span class="cp">#define SONIC_TD_FRAG_PTR_L   4</span>
<span class="cp">#define SONIC_TD_FRAG_PTR_H   5</span>
<span class="cp">#define SONIC_TD_FRAG_SIZE    6</span>
<span class="cp">#define SONIC_TD_LINK         7</span>

<span class="cp">#define SIZEOF_SONIC_CD 4</span>
<span class="cp">#define SONIC_CD_ENTRY_POINTER 0</span>
<span class="cp">#define SONIC_CD_CAP0          1</span>
<span class="cp">#define SONIC_CD_CAP1          2</span>
<span class="cp">#define SONIC_CD_CAP2          3</span>

<span class="cp">#define SIZEOF_SONIC_CDA ((CAM_DESCRIPTORS * SIZEOF_SONIC_CD) + 1)</span>
<span class="cp">#define SONIC_CDA_CAM_ENABLE   (CAM_DESCRIPTORS * SIZEOF_SONIC_CD)</span>

<span class="cm">/*</span>
<span class="cm"> * Some tunables for the buffer areas. Power of 2 is required</span>
<span class="cm"> * the current driver uses one receive buffer for each descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * MSch: use more buffer space for the slow m68k Macs!</span>
<span class="cm"> */</span>
<span class="cp">#define SONIC_NUM_RRS   16            </span><span class="cm">/* number of receive resources */</span><span class="cp"></span>
<span class="cp">#define SONIC_NUM_RDS   SONIC_NUM_RRS </span><span class="cm">/* number of receive descriptors */</span><span class="cp"></span>
<span class="cp">#define SONIC_NUM_TDS   16            </span><span class="cm">/* number of transmit descriptors */</span><span class="cp"></span>

<span class="cp">#define SONIC_RDS_MASK  (SONIC_NUM_RDS-1)</span>
<span class="cp">#define SONIC_TDS_MASK  (SONIC_NUM_TDS-1)</span>

<span class="cp">#define SONIC_RBSIZE	1520          </span><span class="cm">/* size of one resource buffer */</span><span class="cp"></span>

<span class="cm">/* Again, measured in bus size units! */</span>
<span class="cp">#define SIZEOF_SONIC_DESC (SIZEOF_SONIC_CDA	\</span>
<span class="cp">	+ (SIZEOF_SONIC_TD * SONIC_NUM_TDS)	\</span>
<span class="cp">	+ (SIZEOF_SONIC_RD * SONIC_NUM_RDS)	\</span>
<span class="cp">	+ (SIZEOF_SONIC_RR * SONIC_NUM_RRS))</span>

<span class="cm">/* Information that need to be kept for each board. */</span>
<span class="k">struct</span> <span class="n">sonic_local</span> <span class="p">{</span>
	<span class="cm">/* Bus size.  0 == 16 bits, 1 == 32 bits. */</span>
	<span class="kt">int</span> <span class="n">dma_bitmode</span><span class="p">;</span>
	<span class="cm">/* Register offset within the longword (independent of endianness,</span>
<span class="cm">	   and varies from one type of Macintosh SONIC to another</span>
<span class="cm">	   (Aarrgh)) */</span>
	<span class="kt">int</span> <span class="n">reg_offset</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">descriptors</span><span class="p">;</span>
	<span class="cm">/* Crud.  These areas have to be within the same 64K.  Therefore</span>
<span class="cm">       we allocate a desriptors page, and point these to places within it. */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cda</span><span class="p">;</span>  <span class="cm">/* CAM descriptor area */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tda</span><span class="p">;</span>  <span class="cm">/* Transmit descriptor area */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rra</span><span class="p">;</span>  <span class="cm">/* Receive resource area */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rda</span><span class="p">;</span>  <span class="cm">/* Receive descriptor area */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="k">volatile</span> <span class="n">rx_skb</span><span class="p">[</span><span class="n">SONIC_NUM_RRS</span><span class="p">];</span>	<span class="cm">/* packets to be received */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="k">volatile</span> <span class="n">tx_skb</span><span class="p">[</span><span class="n">SONIC_NUM_TDS</span><span class="p">];</span>	<span class="cm">/* packets to be transmitted */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_len</span><span class="p">[</span><span class="n">SONIC_NUM_TDS</span><span class="p">];</span> <span class="cm">/* lengths of tx DMA mappings */</span>
	<span class="cm">/* Logical DMA addresses on MIPS, bus addresses on m68k</span>
<span class="cm">	 * (so &quot;laddr&quot; is a bit misleading) */</span>
	<span class="n">dma_addr_t</span> <span class="n">descriptors_laddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cda_laddr</span><span class="p">;</span>              <span class="cm">/* logical DMA address of CDA */</span>
	<span class="n">u32</span> <span class="n">tda_laddr</span><span class="p">;</span>              <span class="cm">/* logical DMA address of TDA */</span>
	<span class="n">u32</span> <span class="n">rra_laddr</span><span class="p">;</span>              <span class="cm">/* logical DMA address of RRA */</span>
	<span class="n">u32</span> <span class="n">rda_laddr</span><span class="p">;</span>              <span class="cm">/* logical DMA address of RDA */</span>
	<span class="n">dma_addr_t</span> <span class="n">rx_laddr</span><span class="p">[</span><span class="n">SONIC_NUM_RRS</span><span class="p">];</span> <span class="cm">/* logical DMA addresses of rx skbuffs */</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_laddr</span><span class="p">[</span><span class="n">SONIC_NUM_TDS</span><span class="p">];</span> <span class="cm">/* logical DMA addresses of tx skbuffs */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rra_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_rwp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_rx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_tx</span><span class="p">;</span>           <span class="cm">/* first unacked transmit packet */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eol_rx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eol_tx</span><span class="p">;</span>           <span class="cm">/* last unacked transmit packet */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_tx</span><span class="p">;</span>          <span class="cm">/* next free TD */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>         <span class="cm">/* generic device */</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define TX_TIMEOUT (3 * HZ)</span>

<span class="cm">/* Index to functions, as function prototypes. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sonic_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sonic_send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">sonic_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sonic_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sonic_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">sonic_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sonic_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sonic_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sonic_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* Internal inlines for reading/writing DMA buffers.  Note that bus</span>
<span class="cm">   size and endianness matter here, whereas they don&#39;t for registers,</span>
<span class="cm">   as far as we can tell. */</span>
<span class="cm">/* OpenBSD calls this &quot;SWO&quot;.  I&#39;d like to think that sonic_buf_put()</span>
<span class="cm">   is a much better name. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sonic_buf_put</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bitmode</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bitmode</span><span class="p">)</span>
<span class="cp">#ifdef __BIG_ENDIAN</span>
		<span class="p">((</span><span class="n">__u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">base</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span><span class="o">*</span><span class="mi">2</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="p">((</span><span class="n">__u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">base</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span><span class="o">*</span><span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
	 	<span class="p">((</span><span class="n">__u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">base</span><span class="p">)[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span> <span class="nf">sonic_buf_get</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bitmode</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bitmode</span><span class="p">)</span>
<span class="cp">#ifdef __BIG_ENDIAN</span>
		<span class="k">return</span> <span class="p">((</span><span class="k">volatile</span> <span class="n">__u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">base</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span><span class="o">*</span><span class="mi">2</span><span class="p">))[</span><span class="mi">1</span><span class="p">];</span>
<span class="cp">#else</span>
		<span class="k">return</span> <span class="p">((</span><span class="k">volatile</span> <span class="n">__u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">base</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span><span class="o">*</span><span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">((</span><span class="k">volatile</span> <span class="n">__u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">base</span><span class="p">)[</span><span class="n">offset</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Inlines that you should actually use for reading/writing DMA buffers */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sonic_cda_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sonic_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sonic_buf_put</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cda</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dma_bitmode</span><span class="p">,</span>
		      <span class="p">(</span><span class="n">entry</span> <span class="o">*</span> <span class="n">SIZEOF_SONIC_CD</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span> <span class="nf">sonic_cda_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sonic_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sonic_buf_get</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cda</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dma_bitmode</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">entry</span> <span class="o">*</span> <span class="n">SIZEOF_SONIC_CD</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sonic_set_cam_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sonic_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sonic_buf_put</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cda</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dma_bitmode</span><span class="p">,</span> <span class="n">SONIC_CDA_CAM_ENABLE</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span> <span class="nf">sonic_get_cam_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sonic_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sonic_buf_get</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cda</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dma_bitmode</span><span class="p">,</span> <span class="n">SONIC_CDA_CAM_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sonic_tda_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sonic_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sonic_buf_put</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tda</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dma_bitmode</span><span class="p">,</span>
		      <span class="p">(</span><span class="n">entry</span> <span class="o">*</span> <span class="n">SIZEOF_SONIC_TD</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span> <span class="nf">sonic_tda_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sonic_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sonic_buf_get</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tda</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dma_bitmode</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">entry</span> <span class="o">*</span> <span class="n">SIZEOF_SONIC_TD</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sonic_rda_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sonic_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sonic_buf_put</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rda</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dma_bitmode</span><span class="p">,</span>
		      <span class="p">(</span><span class="n">entry</span> <span class="o">*</span> <span class="n">SIZEOF_SONIC_RD</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span> <span class="nf">sonic_rda_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sonic_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sonic_buf_get</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rda</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dma_bitmode</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">entry</span> <span class="o">*</span> <span class="n">SIZEOF_SONIC_RD</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sonic_rra_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sonic_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sonic_buf_put</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rra</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dma_bitmode</span><span class="p">,</span>
		      <span class="p">(</span><span class="n">entry</span> <span class="o">*</span> <span class="n">SIZEOF_SONIC_RR</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span> <span class="nf">sonic_rra_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sonic_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sonic_buf_get</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">rra</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dma_bitmode</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">entry</span> <span class="o">*</span> <span class="n">SIZEOF_SONIC_RR</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">version</span> <span class="o">=</span>
    <span class="s">&quot;sonic.c:v0.92 20.9.98 tsbogend@alpha.franken.de</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* SONIC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
