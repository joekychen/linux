<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › natsemi › ibmlana.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ibmlana.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">net-3-driver for the IBM LAN Adapter/A</span>

<span class="cm">This is an extension to the Linux operating system, and is covered by the</span>
<span class="cm">same GNU General Public License that covers that work.</span>

<span class="cm">Copyright 1999 by Alfred Arnold (alfred@ccac.rwth-aachen.de,</span>
<span class="cm">                                 alfred.arnold@lancom.de)</span>

<span class="cm">This driver is based both on the SK_MCA driver, which is itself based on the</span>
<span class="cm">SK_G16 and 3C523 driver.</span>

<span class="cm">paper sources:</span>
<span class="cm">  &#39;PC Hardware: Aufbau, Funktionsweise, Programmierung&#39; by</span>
<span class="cm">  Hans-Peter Messmer for the basic Microchannel stuff</span>

<span class="cm">  &#39;Linux Geraetetreiber&#39; by Allesandro Rubini, Kalle Dalheimer</span>
<span class="cm">  for help on Ethernet driver programming</span>

<span class="cm">  &#39;DP83934CVUL-20/25 MHz SONIC-T Ethernet Controller Datasheet&#39; by National</span>
<span class="cm">  Semiconductor for info on the MAC chip</span>

<span class="cm">  &#39;LAN Technical Reference Ethernet Adapter Interface Version 1 Release 1.0</span>
<span class="cm">   Document Number SC30-3661-00&#39; by IBM for info on the adapter itself</span>

<span class="cm">  Also see http://www.national.com/analog </span>

<span class="cm">special acknowledgements to:</span>
<span class="cm">  - Bob Eager for helping me out with documentation from IBM</span>
<span class="cm">  - Jim Shorney for his endless patience with me while I was using</span>
<span class="cm">    him as a beta tester to trace down the address filter bug ;-)</span>

<span class="cm">  Missing things:</span>

<span class="cm">  -&gt; set debug level via ioctl instead of compile-time switches</span>
<span class="cm">  -&gt; I didn&#39;t follow the development of the 2.1.x kernels, so my</span>
<span class="cm">     assumptions about which things changed with which kernel version</span>
<span class="cm">     are probably nonsense</span>

<span class="cm">History:</span>
<span class="cm">  Nov 6th, 1999</span>
<span class="cm">  	startup from SK_MCA driver</span>
<span class="cm">  Dec 6th, 1999</span>
<span class="cm">	finally got docs about the card.  A big thank you to Bob Eager!</span>
<span class="cm">  Dec 12th, 1999</span>
<span class="cm">	first packet received</span>
<span class="cm">  Dec 13th, 1999</span>
<span class="cm">	recv queue done, tcpdump works</span>
<span class="cm">  Dec 15th, 1999</span>
<span class="cm">	transmission part works</span>
<span class="cm">  Dec 28th, 1999</span>
<span class="cm">	added usage of the isa_functions for Linux 2.3 .  Things should</span>
<span class="cm">	still work with 2.0.x....</span>
<span class="cm">  Jan 28th, 2000</span>
<span class="cm">	in Linux 2.2.13, the version.h file mysteriously didn&#39;t get</span>
<span class="cm">	included.  Added a workaround for this.  Furthermore, it now</span>
<span class="cm">	not only compiles as a modules ;-)</span>
<span class="cm">  Jan 30th, 2000</span>
<span class="cm">	newer kernels automatically probe more than one board, so the</span>
<span class="cm">	&#39;startslot&#39; as a variable is also needed here</span>
<span class="cm">  Apr 12th, 2000</span>
<span class="cm">	the interrupt mask register is not set &#39;hard&#39; instead of individually</span>
<span class="cm">	setting registers, since this seems to set bits that shouldn&#39;t be</span>
<span class="cm">	set</span>
<span class="cm">  May 21st, 2000</span>
<span class="cm">	reset interrupt status immediately after CAM load</span>
<span class="cm">	add a recovery delay after releasing the chip&#39;s reset line</span>
<span class="cm">  May 24th, 2000</span>
<span class="cm">	finally found the bug in the address filter setup - damned signed</span>
<span class="cm">        chars!</span>
<span class="cm">  June 1st, 2000</span>
<span class="cm">	corrected version codes, added support for the latest 2.3 changes</span>
<span class="cm">  Oct 28th, 2002</span>
<span class="cm">	cleaned up for the 2.5 tree &lt;alan@lxorguk.ukuu.org.uk&gt;</span>

<span class="cm"> *************************************************************************/</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/mca.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#define _IBM_LANA_DRIVER_</span>
<span class="cp">#include &quot;ibmlana.h&quot;</span>

<span class="cp">#undef DEBUG</span>

<span class="cp">#define DRV_NAME &quot;ibmlana&quot;</span>

<span class="cm">/* ------------------------------------------------------------------------</span>
<span class="cm"> * global static data - not more since we can handle multiple boards and</span>
<span class="cm"> * have to pack all state info into the device struct!</span>
<span class="cm"> * ------------------------------------------------------------------------ */</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">MediaNames</span><span class="p">[</span><span class="n">Media_Count</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;10BaseT&quot;</span><span class="p">,</span> <span class="s">&quot;10Base5&quot;</span><span class="p">,</span> <span class="s">&quot;Unknown&quot;</span><span class="p">,</span> <span class="s">&quot;10Base2&quot;</span>
<span class="p">};</span>

<span class="cm">/* ------------------------------------------------------------------------</span>
<span class="cm"> * private subfunctions</span>
<span class="cm"> * ------------------------------------------------------------------------ */</span>

<span class="cp">#ifdef DEBUG</span>
  <span class="cm">/* dump all registers */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dumpregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">z</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mi">160</span><span class="p">;</span> <span class="n">z</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">z</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;REGS: %04x:&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %04x&quot;</span><span class="p">,</span> <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">z</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">z</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">==</span> <span class="mi">14</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* dump parts of shared memory - only needed during debugging */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dumpmem</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">start</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">z</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Address %04x:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">z</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%04x:&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %02x&quot;</span><span class="p">,</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">start</span> <span class="o">+</span> <span class="n">z</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">z</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">z</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* print exact time - ditto */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">PrTime</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>

	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%9d:%06d: &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* DEBUG */</span><span class="cp"></span>

<span class="cm">/* deduce resources out of POS registers */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">getaddrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mca_device</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">memlen</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="o">*</span><span class="n">iobase</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">irq</span><span class="p">,</span> <span class="n">ibmlana_medium</span> <span class="o">*</span><span class="n">medium</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span> <span class="n">pos0</span><span class="p">,</span> <span class="n">pos1</span><span class="p">;</span>

	<span class="n">pos0</span> <span class="o">=</span> <span class="n">mca_device_read_stored_pos</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">pos1</span> <span class="o">=</span> <span class="n">mca_device_read_stored_pos</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="mh">0xc0000</span> <span class="o">+</span> <span class="p">((</span><span class="n">pos1</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="o">*</span><span class="n">memlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos1</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x8000</span> <span class="o">:</span> <span class="mh">0x4000</span><span class="p">;</span>
	<span class="o">*</span><span class="n">iobase</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos0</span> <span class="o">&amp;</span> <span class="mh">0xe0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pos0</span> <span class="o">&amp;</span> <span class="mh">0x06</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">6</span>:
		<span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">medium</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos0</span> <span class="o">&amp;</span> <span class="mh">0x18</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* wait on register value with mask and timeout */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regoffs</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mask</span><span class="p">,</span>
			<span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fin</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span><span class="n">fin</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">regoffs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* reset the whole board */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ResetBoard</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bcmval</span><span class="p">;</span>

	<span class="cm">/* read original board control value */</span>

	<span class="n">bcmval</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">BCMREG</span><span class="p">);</span>

	<span class="cm">/* set reset bit for a while */</span>

	<span class="n">bcmval</span> <span class="o">|=</span> <span class="n">BCMREG_RESET</span><span class="p">;</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bcmval</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">BCMREG</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">bcmval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BCMREG_RESET</span><span class="p">;</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bcmval</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">BCMREG</span><span class="p">);</span>

	<span class="cm">/* switch over to RAM again */</span>

	<span class="n">bcmval</span> <span class="o">|=</span> <span class="n">BCMREG_RAMEN</span> <span class="o">|</span> <span class="n">BCMREG_RAMWIN</span><span class="p">;</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bcmval</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">BCMREG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* calculate RAM layout &amp; set up descriptors in RAM */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">InitDscrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">baddr</span><span class="p">,</span> <span class="n">raddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
	<span class="n">tda_t</span> <span class="n">tda</span><span class="p">;</span>
	<span class="n">rda_t</span> <span class="n">rda</span><span class="p">;</span>
	<span class="n">rra_t</span> <span class="n">rra</span><span class="p">;</span>

	<span class="cm">/* initialize RAM */</span>

	<span class="n">memset_io</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mh">0xaa</span><span class="p">,</span>
		      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">);</span>	<span class="cm">/* XXX: typo? */</span>

	<span class="cm">/* setup n TX descriptors - independent of RAM size */</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tdastart</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">txbufstart</span> <span class="o">=</span> <span class="n">baddr</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">TXBUFCNT</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">TXBUFCNT</span><span class="p">;</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tda</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tda</span><span class="p">.</span><span class="n">config</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tda</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tda</span><span class="p">.</span><span class="n">fragcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tda</span><span class="p">.</span><span class="n">startlo</span> <span class="o">=</span> <span class="n">baddr</span><span class="p">;</span>
		<span class="n">tda</span><span class="p">.</span><span class="n">starthi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tda</span><span class="p">.</span><span class="n">fraglength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="n">TXBUFCNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">tda</span><span class="p">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tdastart</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tda</span><span class="p">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">);</span>
		<span class="n">tda</span><span class="p">.</span><span class="n">link</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tda</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">));</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">);</span>
		<span class="n">baddr</span> <span class="o">+=</span> <span class="n">PKTSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* calculate how many receive buffers fit into remaining memory */</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rxbufcnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">-</span> <span class="n">baddr</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rra_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rda_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">PKTSIZE</span><span class="p">);</span>

	<span class="cm">/* calculate receive addresses */</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rrastart</span> <span class="o">=</span> <span class="n">raddr</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">txbufstart</span> <span class="o">+</span> <span class="p">(</span><span class="n">TXBUFCNT</span> <span class="o">*</span> <span class="n">PKTSIZE</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rdastart</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rrastart</span> <span class="o">+</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rxbufcnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rra_t</span><span class="p">));</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rxbufstart</span> <span class="o">=</span> <span class="n">baddr</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rdastart</span> <span class="o">+</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rxbufcnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rda_t</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rxbufcnt</span><span class="p">;</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rra</span><span class="p">.</span><span class="n">startlo</span> <span class="o">=</span> <span class="n">baddr</span><span class="p">;</span>
		<span class="n">rra</span><span class="p">.</span><span class="n">starthi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rra</span><span class="p">.</span><span class="n">cntlo</span> <span class="o">=</span> <span class="n">PKTSIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rra</span><span class="p">.</span><span class="n">cnthi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">raddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rra</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rra_t</span><span class="p">));</span>

		<span class="n">rda</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rda</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rda</span><span class="p">.</span><span class="n">startlo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rda</span><span class="p">.</span><span class="n">starthi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rda</span><span class="p">.</span><span class="n">seqno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rxbufcnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">rda</span><span class="p">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rda_t</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">rda</span><span class="p">.</span><span class="n">link</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rda</span><span class="p">.</span><span class="n">inuse</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rda</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rda_t</span><span class="p">));</span>

		<span class="n">baddr</span> <span class="o">+=</span> <span class="n">PKTSIZE</span><span class="p">;</span>
		<span class="n">raddr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rra_t</span><span class="p">);</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rda_t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* initialize current pointers */</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">nextrxdescr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">lastrxdescr</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rxbufcnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">nexttxdescr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">currtxdescr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">txusedcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">txused</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">txused</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* set up Rx + Tx descriptors in SONIC */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">InitSONIC</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* set up start &amp; end of resource area */</span>

	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SONIC_URRA</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rrastart</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_RSA</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rrastart</span> <span class="o">+</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rxbufcnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rra_t</span><span class="p">)),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_REA</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rrastart</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_RRP</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rrastart</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_RWP</span><span class="p">);</span>

	<span class="cm">/* set EOBC so that only one packet goes into one buffer */</span>

	<span class="n">outw</span><span class="p">((</span><span class="n">PKTSIZE</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_EOBC</span><span class="p">);</span>

	<span class="cm">/* let SONIC read the first RRA descriptor */</span>

	<span class="n">outw</span><span class="p">(</span><span class="n">CMDREG_RRRA</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CMDREG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_timeout</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SONIC_CMDREG</span><span class="p">,</span> <span class="n">CMDREG_RRRA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: SONIC did not respond on RRRA command - giving up.&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* point SONIC to the first RDA */</span>

	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_URDA</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rdastart</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CRDA</span><span class="p">);</span>

	<span class="cm">/* set upper half of TDA address */</span>

	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_UTDA</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* stop SONIC so we can reinitialize it */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">StopSONIC</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* disable interrupts */</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">BCMREG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">BCMREG_IEN</span><span class="p">),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">BCMREG</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_IMREG</span><span class="p">);</span>

	<span class="cm">/* reset the SONIC */</span>

	<span class="n">outw</span><span class="p">(</span><span class="n">CMDREG_RST</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CMDREG</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">CMDREG_RST</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CMDREG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* initialize card and SONIC for proper operation */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">putcam</span><span class="p">(</span><span class="n">camentry_t</span> <span class="o">*</span> <span class="n">cams</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">camcnt</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">camentry_t</span> <span class="o">*</span><span class="n">pcam</span> <span class="o">=</span> <span class="n">cams</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">camcnt</span><span class="p">);</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">uaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">pcam</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">camcnt</span><span class="p">;</span>
	<span class="n">pcam</span><span class="o">-&gt;</span><span class="n">addr0</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span> <span class="n">uaddr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">uaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">pcam</span><span class="o">-&gt;</span><span class="n">addr1</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span> <span class="n">uaddr</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">uaddr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">pcam</span><span class="o">-&gt;</span><span class="n">addr2</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span> <span class="n">uaddr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">uaddr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="p">(</span><span class="o">*</span><span class="n">camcnt</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">InitBoard</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">camcnt</span><span class="p">;</span>
	<span class="n">camentry_t</span> <span class="n">cams</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">cammask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rcrval</span><span class="p">;</span>

	<span class="cm">/* reset the SONIC */</span>

	<span class="n">outw</span><span class="p">(</span><span class="n">CMDREG_RST</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CMDREG</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* clear all spurious interrupts */</span>

	<span class="n">outw</span><span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_ISREG</span><span class="p">),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_ISREG</span><span class="p">);</span>

	<span class="cm">/* set up the SONIC&#39;s bus interface - constant for this adapter -</span>
<span class="cm">	   must be done while the SONIC is in reset */</span>

	<span class="n">outw</span><span class="p">(</span><span class="n">DCREG_USR1</span> <span class="o">|</span> <span class="n">DCREG_USR0</span> <span class="o">|</span> <span class="n">DCREG_WC1</span> <span class="o">|</span> <span class="n">DCREG_DW32</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_DCREG</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_DCREG2</span><span class="p">);</span>

	<span class="cm">/* remove reset form the SONIC */</span>

	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CMDREG</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* data sheet requires URRA to be programmed before setting up the CAM contents */</span>

	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_URRA</span><span class="p">);</span>

	<span class="cm">/* program the CAM entry 0 to the device address */</span>

	<span class="n">camcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">putcam</span><span class="p">(</span><span class="n">cams</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">camcnt</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="cm">/* start putting the multicast addresses into the CAM list.  Stop if</span>
<span class="cm">	   it is full. */</span>

	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">putcam</span><span class="p">(</span><span class="n">cams</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">camcnt</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">camcnt</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* calculate CAM mask */</span>

	<span class="n">cammask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">camcnt</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* feed CDA into SONIC, initialize RCR value (always get broadcasts) */</span>

	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">cams</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">camentry_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">camcnt</span><span class="p">);</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">camentry_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">camcnt</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cammask</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cammask</span><span class="p">));</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CAM setup:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dumpmem</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">camentry_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">camcnt</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cammask</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CAMPTR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">camcnt</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CAMCNT</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">CMDREG_LCAM</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CMDREG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_timeout</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SONIC_CMDREG</span><span class="p">,</span> <span class="n">CMDREG_LCAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s:SONIC did not respond on LCAM command - giving up.&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* clear interrupt condition */</span>

		<span class="n">outw</span><span class="p">(</span><span class="n">ISREG_LCD</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_ISREG</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Loading CAM done, address pointers %04x:%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_URRA</span><span class="p">),</span>
		       <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CAMPTR</span><span class="p">));</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">z</span><span class="p">;</span>

			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--&gt;CAM: PTR %04x CNT %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CAMPTR</span><span class="p">),</span>
			       <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CAMCNT</span><span class="p">));</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">CMDREG_RST</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CMDREG</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">camcnt</span><span class="p">;</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">outw</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CAMEPTR</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Entry %d: %04x %04x %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span>
				       <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CAMADDR0</span><span class="p">),</span>
				       <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CAMADDR1</span><span class="p">),</span>
				       <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CAMADDR2</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CMDREG</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">rcrval</span> <span class="o">=</span> <span class="n">RCREG_BRD</span> <span class="o">|</span> <span class="n">RCREG_LB_NONE</span><span class="p">;</span>

	<span class="cm">/* if still multicast addresses left or ALLMULTI is set, set the multicast</span>
<span class="cm">	   enable bit */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="o">||</span> <span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">camcnt</span><span class="p">)</span>
		<span class="n">rcrval</span> <span class="o">|=</span> <span class="n">RCREG_AMC</span><span class="p">;</span>

	<span class="cm">/* promiscuous mode ? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
		<span class="n">rcrval</span> <span class="o">|=</span> <span class="n">RCREG_PRO</span><span class="p">;</span>

	<span class="cm">/* program receive mode */</span>

	<span class="n">outw</span><span class="p">(</span><span class="n">rcrval</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_RCREG</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">RCRVAL: %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rcrval</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* set up descriptors in shared memory + feed them into SONIC registers */</span>

	<span class="n">InitDscrs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">InitSONIC</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* reset all pending interrupts */</span>

	<span class="n">outw</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_ISREG</span><span class="p">);</span>

	<span class="cm">/* enable transmitter + receiver interrupts */</span>

	<span class="n">outw</span><span class="p">(</span><span class="n">CMDREG_RXEN</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CMDREG</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">IMREG_PRXEN</span> <span class="o">|</span> <span class="n">IMREG_RBEEN</span> <span class="o">|</span> <span class="n">IMREG_PTXEN</span> <span class="o">|</span> <span class="n">IMREG_TXEREN</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_IMREG</span><span class="p">);</span>

	<span class="cm">/* turn on card interrupts */</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">BCMREG</span><span class="p">)</span> <span class="o">|</span> <span class="n">BCMREG_IEN</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">BCMREG</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Register dump after initialization:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dumpregs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* start transmission of a descriptor */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">StartTx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">descr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tdastart</span> <span class="o">+</span> <span class="p">(</span><span class="n">descr</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">));</span>

	<span class="cm">/* put descriptor address into SONIC */</span>

	<span class="n">outw</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CTDA</span><span class="p">);</span>

	<span class="cm">/* trigger transmitter */</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">currtxdescr</span> <span class="o">=</span> <span class="n">descr</span><span class="p">;</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">CMDREG_TXP</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_CMDREG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------------------</span>
<span class="cm"> * interrupt handler(s)</span>
<span class="cm"> * ------------------------------------------------------------------------ */</span>

<span class="cm">/* receive buffer area exhausted */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irqrbe_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* point the SONIC back to the RRA start */</span>

	<span class="n">outw</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rrastart</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_RRP</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rrastart</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_RWP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* receive interrupt */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irqrx_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rda_t</span> <span class="n">rda</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rdaaddr</span><span class="p">,</span> <span class="n">lrdaaddr</span><span class="p">;</span>

	<span class="cm">/* loop until ... */</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* read descriptor that was next to be filled by SONIC */</span>

		<span class="n">rdaaddr</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rdastart</span> <span class="o">+</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">nextrxdescr</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rda_t</span><span class="p">));</span>
		<span class="n">lrdaaddr</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rdastart</span> <span class="o">+</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lastrxdescr</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rda_t</span><span class="p">));</span>
		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rda</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">rdaaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rda_t</span><span class="p">));</span>

		<span class="cm">/* iron out upper word halves of fields we use - SONIC will duplicate</span>
<span class="cm">		   bits 0..15 to 16..31 */</span>

		<span class="n">rda</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="n">rda</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="n">rda</span><span class="p">.</span><span class="n">startlo</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>

		<span class="cm">/* stop if the SONIC still owns it, i.e. there is no data for us */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rda</span><span class="p">.</span><span class="n">inuse</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* good packet? */</span>

		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rda</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RCREG_PRX</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

			<span class="cm">/* fetch buffer */</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rda</span><span class="p">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* copy out data */</span>

				<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rda</span><span class="p">.</span><span class="n">length</span><span class="p">),</span>
					       <span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span>
					       <span class="n">rda</span><span class="p">.</span><span class="n">startlo</span><span class="p">,</span> <span class="n">rda</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

				<span class="cm">/* set up skb fields */</span>

				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
				<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

				<span class="cm">/* bookkeeping */</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">rda</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>

				<span class="cm">/* pass to the upper layers */</span>
				<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* otherwise check error status bits and increase statistics */</span>

		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rda</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RCREG_FAER</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rda</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RCREG_CRCR</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* descriptor processed, will become new last descriptor in queue */</span>

		<span class="n">rda</span><span class="p">.</span><span class="n">link</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rda</span><span class="p">.</span><span class="n">inuse</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">rdaaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rda</span><span class="p">,</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="n">rda_t</span><span class="p">));</span>

		<span class="cm">/* set up link and EOL = 0 in currently last descriptor. Only write</span>
<span class="cm">		   the link field since the SONIC may currently already access the</span>
<span class="cm">		   other fields. */</span>

		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">lrdaaddr</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdaaddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

		<span class="cm">/* advance indices */</span>

		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">lastrxdescr</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">nextrxdescr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">++</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">nextrxdescr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rxbufcnt</span><span class="p">)</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">nextrxdescr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* transmit interrupt */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irqtx_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">tda_t</span> <span class="n">tda</span><span class="p">;</span>

	<span class="cm">/* fetch descriptor (we forgot the size ;-) */</span>
	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tda</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tdastart</span> <span class="o">+</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">currtxdescr</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">)),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">));</span>

	<span class="cm">/* update statistics */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">tda</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>

	<span class="cm">/* update our pointers */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">txused</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">currtxdescr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">txusedcnt</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* if there are more descriptors present in RAM, start them */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">txusedcnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">StartTx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">currtxdescr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">TXBUFCNT</span><span class="p">);</span>

	<span class="cm">/* tell the upper layer we can go on transmitting */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irqtxerr_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">tda_t</span> <span class="n">tda</span><span class="p">;</span>

	<span class="cm">/* fetch descriptor to check status */</span>
	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tda</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tdastart</span> <span class="o">+</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">currtxdescr</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">)),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">));</span>

	<span class="cm">/* update statistics */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tda</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCREG_NCRS</span> <span class="o">|</span> <span class="n">TCREG_CRSL</span><span class="p">))</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_carrier_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tda</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TCREG_EXC</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tda</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TCREG_OWC</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tda</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TCREG_FU</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* update our pointers */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">txused</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">currtxdescr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">txusedcnt</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* if there are more descriptors present in RAM, start them */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">txusedcnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">StartTx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">currtxdescr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">TXBUFCNT</span><span class="p">);</span>

	<span class="cm">/* tell the upper layer we can go on transmitting */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* general interrupt entry */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">dummy</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ival</span><span class="p">;</span>

	<span class="cm">/* in case we&#39;re not meant... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">BCMREG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BCMREG_IPEND</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* loop through the interrupt bits until everything is clear */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_ISREG</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&amp;</span> <span class="n">ISREG_RBE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irqrbe_handler</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">ISREG_RBE</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_ISREG</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&amp;</span> <span class="n">ISREG_PKTRX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irqrx_handler</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">ISREG_PKTRX</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_ISREG</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&amp;</span> <span class="n">ISREG_TXDN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irqtx_handler</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">ISREG_TXDN</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_ISREG</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&amp;</span> <span class="n">ISREG_TXER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irqtxerr_handler</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">ISREG_TXER</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">SONIC_ISREG</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------------------</span>
<span class="cm"> * driver methods</span>
<span class="cm"> * ------------------------------------------------------------------------ */</span>

<span class="cm">/* MCA info */</span>

<span class="cp">#if 0</span><span class="c"> /* info available elsewhere, but this is kept for reference */</span>
<span class="c">static int ibmlana_getinfo(char *buf, int slot, void *d)</span>
<span class="c">{</span>
<span class="c">	int len = 0, i;</span>
<span class="c">	struct net_device *dev = (struct net_device *) d;</span>
<span class="c">	ibmlana_priv *priv;</span>

<span class="c">	/* can&#39;t say anything about an uninitialized device... */</span>

<span class="c">	if (dev == NULL)</span>
<span class="c">		return len;</span>
<span class="c">	priv = netdev_priv(dev);</span>

<span class="c">	/* print info */</span>

<span class="c">	len += sprintf(buf + len, &quot;IRQ: %d\n&quot;, priv-&gt;realirq);</span>
<span class="c">	len += sprintf(buf + len, &quot;I/O: %#lx\n&quot;, dev-&gt;base_addr);</span>
<span class="c">	len += sprintf(buf + len, &quot;Memory: %#lx-%#lx\n&quot;, dev-&gt;mem_start, dev-&gt;mem_end - 1);</span>
<span class="c">	len += sprintf(buf + len, &quot;Transceiver: %s\n&quot;, MediaNames[priv-&gt;medium]);</span>
<span class="c">	len += sprintf(buf + len, &quot;Device: %s\n&quot;, dev-&gt;name);</span>
<span class="c">	len += sprintf(buf + len, &quot;MAC address:&quot;);</span>
<span class="c">	for (i = 0; i &lt; 6; i++)</span>
<span class="c">		len += sprintf(buf + len, &quot; %02x&quot;, dev-&gt;dev_addr[i]);</span>
<span class="c">	buf[len++] = &#39;\n&#39;;</span>
<span class="c">	buf[len] = 0;</span>

<span class="c">	return len;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/* open driver.  Means also initialization and start of LANCE */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ibmlana_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* register resources - only necessary for IRQ */</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">realirq</span><span class="p">,</span> <span class="n">irq_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: failed to register irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">realirq</span><span class="p">;</span>

	<span class="cm">/* set up the card and SONIC */</span>
	<span class="n">InitBoard</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* initialize operational flags */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* close driver.  Shut down board and free allocated resources */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ibmlana_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* turn off board */</span>

	<span class="cm">/* release resources */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* transmit a block. */</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">ibmlana_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">tmplen</span><span class="p">,</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">tda_t</span> <span class="n">tda</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">baddr</span><span class="p">;</span>

	<span class="cm">/* find out if there are free slots for a frame to transmit. If not,</span>
<span class="cm">	   the upper layer is in deep desperation and we simply ignore the frame. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">txusedcnt</span> <span class="o">&gt;=</span> <span class="n">TXBUFCNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">tx_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* copy the frame data into the next free transmit buffer - fillup missing */</span>
	<span class="n">tmplen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmplen</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span>
		<span class="n">tmplen</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
	<span class="n">baddr</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">txbufstart</span> <span class="o">+</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">nexttxdescr</span> <span class="o">*</span> <span class="n">PKTSIZE</span><span class="p">);</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">baddr</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* copy filler into RAM - in case we&#39;re filling up...</span>
<span class="cm">	   we&#39;re filling a bit more than necessary, but that doesn&#39;t harm</span>
<span class="cm">	   since the buffer is far larger...</span>
<span class="cm">	   Sorry Linus for the filler string but I couldn&#39;t resist ;-) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmplen</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">fill</span> <span class="o">=</span> <span class="s">&quot;NetBSD is a nice OS too! &quot;</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">destoffs</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">fill</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">destoffs</span> <span class="o">&lt;</span> <span class="n">tmplen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">baddr</span> <span class="o">+</span> <span class="n">destoffs</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
			<span class="n">destoffs</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* set up the new frame descriptor */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tdastart</span> <span class="o">+</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">nexttxdescr</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">));</span>
	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tda</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">));</span>
	<span class="n">tda</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">tda</span><span class="p">.</span><span class="n">fraglength</span> <span class="o">=</span> <span class="n">tmplen</span><span class="p">;</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tda</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tda_t</span><span class="p">));</span>

	<span class="cm">/* if there were no active descriptors, trigger the SONIC */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">txusedcnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">txused</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">nexttxdescr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* are all transmission slots used up ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">txusedcnt</span> <span class="o">&gt;=</span> <span class="n">TXBUFCNT</span><span class="p">)</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">txusedcnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">StartTx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">nexttxdescr</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">nexttxdescr</span> <span class="o">=</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">nexttxdescr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">TXBUFCNT</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">tx_done:</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* switch receiver mode. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ibmlana_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* first stop the SONIC... */</span>
	<span class="n">StopSONIC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* ...then reinit it with the new flags */</span>
	<span class="n">InitBoard</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------------------</span>
<span class="cm"> * hardware check</span>
<span class="cm"> * ------------------------------------------------------------------------ */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ibmlana_irq</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ibmlana_io</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">startslot</span><span class="p">;</span>		<span class="cm">/* counts through slots when probing multiple devices */</span>

<span class="k">static</span> <span class="kt">short</span> <span class="n">ibmlana_adapter_ids</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">IBM_LANA_ID</span><span class="p">,</span>
	<span class="mh">0x0000</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ibmlana_adapter_names</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;IBM LAN Adapter/A&quot;</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">ibmlana_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> 		<span class="o">=</span> <span class="n">ibmlana_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span> 		<span class="o">=</span> <span class="n">ibmlana_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">ibmlana_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">ibmlana_set_multicast_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">eth_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> 	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ibmlana_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">kdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mca_device</span> <span class="o">*</span><span class="n">mdev</span> <span class="o">=</span> <span class="n">to_mca_device</span><span class="p">(</span><span class="n">kdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">memlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">ibmlana_medium</span> <span class="n">medium</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ibmlana_priv</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">ibmlana_irq</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">ibmlana_io</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">;</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="cm">/* deduce card addresses */</span>
	<span class="n">getaddrs</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iobase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">medium</span><span class="p">);</span>

	<span class="cm">/* were we looking for something different ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">!=</span> <span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">!=</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* announce success */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: IBM LAN Adapter/A found in slot %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* try to obtain I/O range */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">IBM_LANA_IORANGE</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: cannot allocate I/O range at %#x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>
		<span class="n">startslot</span> <span class="o">=</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">realirq</span> <span class="o">=</span> <span class="n">mca_device_transform_irq</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">medium</span> <span class="o">=</span> <span class="n">medium</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* set base + irq for this device (irq not allocated so far) */</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">memlen</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">iobase</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">memlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: cannot remap memory!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
		<span class="n">startslot</span> <span class="o">=</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_reg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mca_device_set_name</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">ibmlana_adapter_names</span><span class="p">[</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">]);</span>
	<span class="n">mca_device_set_claim</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* set methods */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ibmlana_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IFF_MULTICAST</span><span class="p">;</span>

	<span class="cm">/* copy out MAC address */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">ETH_ALEN</span><span class="p">;</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">MACADDRPROM</span> <span class="o">+</span> <span class="n">z</span><span class="p">);</span>

	<span class="cm">/* print config */</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: IRQ %d, I/O %#lx, memory %#lx-%#lx, &quot;</span>
	       <span class="s">&quot;MAC address %pM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">realirq</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span>
	       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: %s medium</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">MediaNames</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">medium</span><span class="p">]);</span>

	<span class="cm">/* reset board */</span>

	<span class="n">ResetBoard</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* next probe will start at next slot */</span>

	<span class="n">startslot</span> <span class="o">=</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_claimed</span><span class="p">;</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">kdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_claimed:</span>
	<span class="n">mca_device_set_claim</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
<span class="nl">err_out_reg:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">IBM_LANA_IORANGE</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ibmlana_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">kdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mca_device</span> <span class="o">*</span><span class="n">mdev</span> <span class="o">=</span> <span class="n">to_mca_device</span><span class="p">(</span><span class="n">kdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">kdev</span><span class="p">);</span>
	<span class="n">ibmlana_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/*DeinitBoard(dev); */</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">IBM_LANA_IORANGE</span><span class="p">);</span>
	<span class="n">mca_device_set_claim</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------------------</span>
<span class="cm"> * modularization support</span>
<span class="cm"> * ------------------------------------------------------------------------ */</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">ibmlana_irq</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">ibmlana_io</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="s">&quot;IBM LAN/A IRQ number&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;IBM LAN/A I/O base address&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mca_driver</span> <span class="n">ibmlana_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">ibmlana_adapter_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ibmlana&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bus</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">mca_bus_type</span><span class="p">,</span>
		<span class="p">.</span><span class="n">probe</span>	<span class="o">=</span> <span class="n">ibmlana_init_one</span><span class="p">,</span>
		<span class="p">.</span><span class="n">remove</span>	<span class="o">=</span> <span class="n">ibmlana_remove_one</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ibmlana_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mca_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ibmlana_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ibmlana_cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mca_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ibmlana_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">ibmlana_init_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ibmlana_cleanup_module</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
