<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › smsc › smc9194.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>smc9194.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> . smc9194.c</span>
<span class="cm"> . This is a driver for SMC&#39;s 9000 series of Ethernet cards.</span>
<span class="cm"> .</span>
<span class="cm"> . Copyright (C) 1996 by Erik Stahlman</span>
<span class="cm"> . This software may be used and distributed according to the terms</span>
<span class="cm"> . of the GNU General Public License, incorporated herein by reference.</span>
<span class="cm"> .</span>
<span class="cm"> . &quot;Features&quot; of the SMC chip:</span>
<span class="cm"> .   4608 byte packet memory. ( for the 91C92.  Others have more )</span>
<span class="cm"> .   EEPROM for configuration</span>
<span class="cm"> .   AUI/TP selection  ( mine has 10Base2/10BaseT select )</span>
<span class="cm"> .</span>
<span class="cm"> . Arguments:</span>
<span class="cm"> . 	io		 = for the base address</span>
<span class="cm"> .	irq	 = for the IRQ</span>
<span class="cm"> .	ifport = 0 for autodetect, 1 for TP, 2 for AUI ( or 10base2 )</span>
<span class="cm"> .</span>
<span class="cm"> . author:</span>
<span class="cm"> . 	Erik Stahlman				( erik@vt.edu )</span>
<span class="cm"> . contributors:</span>
<span class="cm"> .      Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;</span>
<span class="cm"> .</span>
<span class="cm"> . Hardware multicast code from Peter Cammaert ( pc@denkart.be )</span>
<span class="cm"> .</span>
<span class="cm"> . Sources:</span>
<span class="cm"> .    o   SMC databook</span>
<span class="cm"> .    o   skeleton.c by Donald Becker ( becker@scyld.com )</span>
<span class="cm"> .    o   ( a LOT of advice from Becker as well )</span>
<span class="cm"> .</span>
<span class="cm"> . History:</span>
<span class="cm"> .	12/07/95  Erik Stahlman  written, got receive/xmit handled</span>
<span class="cm"> . 	01/03/96  Erik Stahlman  worked out some bugs, actually usable!!! :-)</span>
<span class="cm"> .	01/06/96  Erik Stahlman	 cleaned up some, better testing, etc</span>
<span class="cm"> .	01/29/96  Erik Stahlman	 fixed autoirq, added multicast</span>
<span class="cm"> . 	02/01/96  Erik Stahlman	 1. disabled all interrupts in smc_reset</span>
<span class="cm"> .		   		 2. got rid of post-decrementing bug -- UGH.</span>
<span class="cm"> .	02/13/96  Erik Stahlman  Tried to fix autoirq failure.  Added more</span>
<span class="cm"> .				 descriptive error messages.</span>
<span class="cm"> .	02/15/96  Erik Stahlman  Fixed typo that caused detection failure</span>
<span class="cm"> . 	02/23/96  Erik Stahlman	 Modified it to fit into kernel tree</span>
<span class="cm"> .				 Added support to change hardware address</span>
<span class="cm"> .				 Cleared stats on opens</span>
<span class="cm"> .	02/26/96  Erik Stahlman	 Trial support for Kernel 1.2.13</span>
<span class="cm"> .				 Kludge for automatic IRQ detection</span>
<span class="cm"> .	03/04/96  Erik Stahlman	 Fixed kernel 1.3.70 +</span>
<span class="cm"> .				 Fixed bug reported by Gardner Buchanan in</span>
<span class="cm"> .				   smc_enable, with outw instead of outb</span>
<span class="cm"> .	03/06/96  Erik Stahlman  Added hardware multicast from Peter Cammaert</span>
<span class="cm"> .	04/14/00  Heiko Pruessing (SMA Regelsysteme)  Fixed bug in chip memory</span>
<span class="cm"> .				 allocation</span>
<span class="cm"> .      08/20/00  Arnaldo Melo   fix kfree(skb) in smc_hardware_send_packet</span>
<span class="cm"> .      12/15/00  Christian Jullien fix &quot;Warning: kfree_skb on hard IRQ&quot;</span>
<span class="cm"> .      11/08/01 Matt Domsch     Use common crc32 function</span>
<span class="cm"> ----------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="o">=</span>
	<span class="s">&quot;smc9194.c:v0.14 12/15/00 by Erik Stahlman (erik@vt.edu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#include &quot;smc9194.h&quot;</span>

<span class="cp">#define DRV_NAME &quot;smc9194&quot;</span>

<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> .</span>
<span class="cm"> . Configuration options, for the experienced user to change.</span>
<span class="cm"> .</span>
<span class="cm"> -------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> . Do you want to use 32 bit xfers?  This should work on all chips, as</span>
<span class="cm"> . the chipset is designed to accommodate them.</span>
<span class="cm">*/</span>
<span class="cp">#ifdef __sh__</span>
<span class="cp">#undef USE_32_BIT</span>
<span class="cp">#else</span>
<span class="cp">#define USE_32_BIT 1</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(__H8300H__) || defined(__H8300S__)</span>
<span class="cp">#define NO_AUTOPROBE</span>
<span class="cp">#undef insl</span>
<span class="cp">#undef outsl</span>
<span class="cp">#define insl(a,b,l)  io_insl_noswap(a,b,l)</span>
<span class="cp">#define outsl(a,b,l) io_outsl_noswap(a,b,l)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> .the SMC9194 can be at any of the following port addresses.  To change,</span>
<span class="cm"> .for a slightly different card, you can add it to the array.  Keep in</span>
<span class="cm"> .mind that the array must end in zero.</span>
<span class="cm">*/</span>

<span class="k">struct</span> <span class="n">devlist</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#if defined(CONFIG_H8S_EDOSK2674)</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">devlist</span> <span class="n">smc_devlist</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0xf80000</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">16</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>        <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">},</span>
<span class="p">};</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">devlist</span> <span class="n">smc_devlist</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x220</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x240</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x260</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x280</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x2A0</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x2C0</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x2E0</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x300</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x320</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x340</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x360</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x380</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x3A0</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x3C0</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0x3E0</span><span class="p">,</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>     <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm"> . Wait time for memory to be free.  This probably shouldn&#39;t be</span>
<span class="cm"> . tuned that much, as waiting for this means nothing else happens</span>
<span class="cm"> . in the system</span>
<span class="cm">*/</span>
<span class="cp">#define MEMORY_WAIT_TIME 16</span>

<span class="cm">/*</span>
<span class="cm"> . DEBUGGING LEVELS</span>
<span class="cm"> .</span>
<span class="cm"> . 0 for normal operation</span>
<span class="cm"> . 1 for slightly more details</span>
<span class="cm"> . &gt;2 for various levels of increasingly useless information</span>
<span class="cm"> .    2 for interrupt tracking, status flags</span>
<span class="cm"> .    3 for packet dumps, etc.</span>
<span class="cm">*/</span>
<span class="cp">#define SMC_DEBUG 0</span>

<span class="cp">#if (SMC_DEBUG &gt; 2 )</span>
<span class="cp">#define PRINTK3(x) printk x</span>
<span class="cp">#else</span>
<span class="cp">#define PRINTK3(x)</span>
<span class="cp">#endif</span>

<span class="cp">#if SMC_DEBUG &gt; 1</span>
<span class="cp">#define PRINTK2(x) printk x</span>
<span class="cp">#else</span>
<span class="cp">#define PRINTK2(x)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef SMC_DEBUG</span>
<span class="cp">#define PRINTK(x) printk x</span>
<span class="cp">#else</span>
<span class="cp">#define PRINTK(x)</span>
<span class="cp">#endif</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> .</span>
<span class="cm"> . The internal workings of the driver.  If you are changing anything</span>
<span class="cm"> . here with the SMC stuff, you should have the datasheet and known</span>
<span class="cm"> . what you are doing.</span>
<span class="cm"> .</span>
<span class="cm"> -------------------------------------------------------------------------*/</span>
<span class="cp">#define CARDNAME &quot;SMC9194&quot;</span>


<span class="cm">/* store this information for the driver.. */</span>
<span class="k">struct</span> <span class="n">smc_local</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	   If I have to wait until memory is available to send</span>
<span class="cm">	   a packet, I will store the skbuff here, until I get the</span>
<span class="cm">	   desired memory.  Then, I&#39;ll send it out and free it.</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">saved_skb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm"> 	 . This keeps track of how many packets that I have</span>
<span class="cm"> 	 . sent out.  When an TX_EMPTY interrupt comes, I know</span>
<span class="cm">	 . that all of these have been sent.</span>
<span class="cm">	*/</span>
	<span class="kt">int</span>	<span class="n">packets_waiting</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> .</span>
<span class="cm"> .  The driver can be entered at any of the following entry points.</span>
<span class="cm"> .</span>
<span class="cm"> .------------------------------------------------------------------  */</span>

<span class="cm">/*</span>
<span class="cm"> . This is called by  register_netdev().  It is responsible for</span>
<span class="cm"> . checking the portlist for the SMC9000 series chipset.  If it finds</span>
<span class="cm"> . one, then it will initialize the device, find the hardware information,</span>
<span class="cm"> . and sets up the appropriate device parameters.</span>
<span class="cm"> . NOTE: Interrupts are *OFF* when this procedure is called.</span>
<span class="cm"> .</span>
<span class="cm"> . NB:This shouldn&#39;t be static since it is referred to externally.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">smc_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> . The kernel calls this function when someone wants to use the device,</span>
<span class="cm"> . typically &#39;ifconfig ethX up&#39;.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">smc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> . Our watchdog timed out. Called by the networking layer</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smc_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> . This is called by the kernel in response to &#39;ifconfig ethX down&#39;.  It</span>
<span class="cm"> . is responsible for cleaning up everything that the open routine</span>
<span class="cm"> . does, and maybe putting the card into a powerdown state.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">smc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> . Finally, a call to set promiscuous mode ( for TCPDUMP and related</span>
<span class="cm"> . programs ) and multicast modes.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smc_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>


<span class="cm">/*---------------------------------------------------------------</span>
<span class="cm"> .</span>
<span class="cm"> . Interrupt level calls..</span>
<span class="cm"> .</span>
<span class="cm"> ----------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> . Handles the actual interrupt</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">smc_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> . This is a separate procedure to handle the receipt of a packet, to</span>
<span class="cm"> . leave the interrupt code looking slightly cleaner</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">smc_rcv</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> . This handles a TX interrupt, which is only called when an error</span>
<span class="cm"> . relating to a packet is sent.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">smc_tx</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span> <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> ------------------------------------------------------------</span>
<span class="cm"> .</span>
<span class="cm"> . Internal routines</span>
<span class="cm"> .</span>
<span class="cm"> ------------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm"> . Test if a given location contains a chip, trying to cause as</span>
<span class="cm"> . little damage as possible if it&#39;s not a SMC chip.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">smc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioaddr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> . A rather simple routine to print out a packet for debugging purposes.</span>
<span class="cm">*/</span>
<span class="cp">#if SMC_DEBUG &gt; 2</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">print_packet</span><span class="p">(</span> <span class="n">byte</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#define tx_done(dev) 1</span>

<span class="cm">/* this is called to actually send the packet to the chip */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smc_hardware_send_packet</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span> <span class="p">);</span>

<span class="cm">/* Since I am not sure if I will have enough room in the chip&#39;s ram</span>
<span class="cm"> . to store the packet, I call this routine, which either sends it</span>
<span class="cm"> . now, or generates an interrupt when the card is ready for the</span>
<span class="cm"> . packet */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span>  <span class="n">smc_wait_to_send_packet</span><span class="p">(</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="p">);</span>

<span class="cm">/* this does a soft reset on the device */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smc_reset</span><span class="p">(</span> <span class="kt">int</span> <span class="n">ioaddr</span> <span class="p">);</span>

<span class="cm">/* Enable Interrupts, Receive, and Transmit */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smc_enable</span><span class="p">(</span> <span class="kt">int</span> <span class="n">ioaddr</span> <span class="p">);</span>

<span class="cm">/* this puts the device in an inactive state */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smc_shutdown</span><span class="p">(</span> <span class="kt">int</span> <span class="n">ioaddr</span> <span class="p">);</span>

<span class="cm">/* This routine will find the IRQ of the driver if one is not</span>
<span class="cm"> . specified in the input to the device.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">smc_findirq</span><span class="p">(</span> <span class="kt">int</span> <span class="n">ioaddr</span> <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> . Function: smc_reset( int ioaddr )</span>
<span class="cm"> . Purpose:</span>
<span class="cm"> .  	This sets the SMC91xx chip to its normal state, hopefully from whatever</span>
<span class="cm"> . 	mess that any other DOS driver has put it in.</span>
<span class="cm"> .</span>
<span class="cm"> . Maybe I should reset more registers to defaults in here?  SOFTRESET  should</span>
<span class="cm"> . do that for me.</span>
<span class="cm"> .</span>
<span class="cm"> . Method:</span>
<span class="cm"> .	1.  send a SOFT RESET</span>
<span class="cm"> .	2.  wait for it to finish</span>
<span class="cm"> .	3.  enable autorelease mode</span>
<span class="cm"> .	4.  reset the memory management unit</span>
<span class="cm"> .	5.  clear all interrupts</span>
<span class="cm"> .</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smc_reset</span><span class="p">(</span> <span class="kt">int</span> <span class="n">ioaddr</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This resets the registers mostly to defaults, but doesn&#39;t</span>
<span class="cm">	   affect EEPROM.  That seems unnecessary */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">RCR_SOFTRESET</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">);</span>

	<span class="cm">/* this should pause enough for the chip to be happy */</span>
	<span class="n">SMC_DELAY</span><span class="p">(</span> <span class="p">);</span>

	<span class="cm">/* Set the transmit and receive configuration registers to</span>
<span class="cm">	   default values */</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">RCR_CLEAR</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">TCR_CLEAR</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TCR</span> <span class="p">);</span>

	<span class="cm">/* set the control register to automatically</span>
<span class="cm">	   release successfully transmitted packets, to make the best</span>
<span class="cm">	   use out of our limited memory */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CONTROL</span> <span class="p">)</span> <span class="o">|</span> <span class="n">CTL_AUTO_RELEASE</span> <span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CONTROL</span> <span class="p">);</span>

	<span class="cm">/* Reset the MMU */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">MC_RESET</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MMU_CMD</span> <span class="p">);</span>

	<span class="cm">/* Note:  It doesn&#39;t seem that waiting for the MMU busy is needed here,</span>
<span class="cm">	   but this is a place where future chipsets _COULD_ break.  Be wary</span>
<span class="cm"> 	   of issuing another MMU command right after this */</span>

	<span class="n">outb</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INT_MASK</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> . Function: smc_enable</span>
<span class="cm"> . Purpose: let the chip talk to the outside work</span>
<span class="cm"> . Method:</span>
<span class="cm"> .	1.  Enable the transmitter</span>
<span class="cm"> .	2.  Enable the receiver</span>
<span class="cm"> .	3.  Enable interrupts</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smc_enable</span><span class="p">(</span> <span class="kt">int</span> <span class="n">ioaddr</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="cm">/* see the header file for options in TCR/RCR NORMAL*/</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">TCR_NORMAL</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TCR</span> <span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">RCR_NORMAL</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">);</span>

	<span class="cm">/* now, enable interrupts */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span> <span class="n">SMC_INTERRUPT_MASK</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INT_MASK</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> . Function: smc_shutdown</span>
<span class="cm"> . Purpose:  closes down the SMC91xxx chip.</span>
<span class="cm"> . Method:</span>
<span class="cm"> .	1. zero the interrupt mask</span>
<span class="cm"> .	2. clear the enable receive flag</span>
<span class="cm"> .	3. clear the enable xmit flags</span>
<span class="cm"> .</span>
<span class="cm"> . TODO:</span>
<span class="cm"> .   (1) maybe utilize power down mode.</span>
<span class="cm"> .	Why not yet?  Because while the chip will go into power down mode,</span>
<span class="cm"> .	the manual says that it will wake up in response to any I/O requests</span>
<span class="cm"> .	in the register space.   Empirical results do not show this working.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smc_shutdown</span><span class="p">(</span> <span class="kt">int</span> <span class="n">ioaddr</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* no more interrupts for me */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INT_MASK</span> <span class="p">);</span>

	<span class="cm">/* and tell the card to stay away from that nasty outside world */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span> <span class="n">RCR_CLEAR</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span> <span class="n">TCR_CLEAR</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TCR</span> <span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* finally, shut the chip down */</span>
<span class="c">	SMC_SELECT_BANK( 1 );</span>
<span class="c">	outw( inw( ioaddr + CONTROL ), CTL_POWERDOWN, ioaddr + CONTROL  );</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> . Function: smc_setmulticast( int ioaddr, struct net_device *dev )</span>
<span class="cm"> . Purpose:</span>
<span class="cm"> .    This sets the internal hardware table to filter out unwanted multicast</span>
<span class="cm"> .    packets before they take up memory.</span>
<span class="cm"> .</span>
<span class="cm"> .    The SMC chip uses a hash table where the high 6 bits of the CRC of</span>
<span class="cm"> .    address are the offset into the table.  If that bit is 1, then the</span>
<span class="cm"> .    multicast packet is accepted.  Otherwise, it&#39;s dropped silently.</span>
<span class="cm"> .</span>
<span class="cm"> .    To use the 6 bits as an offset into the table, the high 3 bits are the</span>
<span class="cm"> .    number of the 8 bit register, while the low 3 bits are the bit within</span>
<span class="cm"> .    that register.</span>
<span class="cm"> .</span>
<span class="cm"> . This routine is based very heavily on the one provided by Peter Cammaert.</span>
<span class="cm">*/</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">smc_setmulticast</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioaddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">multicast_table</span><span class="p">[</span> <span class="mi">8</span> <span class="p">];</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="cm">/* table for flipping the order of 3 bits */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">invert3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span> <span class="p">};</span>

	<span class="cm">/* start with a table of all zeros: reject all */</span>
	<span class="n">memset</span><span class="p">(</span> <span class="n">multicast_table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">multicast_table</span> <span class="p">)</span> <span class="p">);</span>

	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">position</span><span class="p">;</span>

		<span class="cm">/* only use the low order bits */</span>
		<span class="n">position</span> <span class="o">=</span> <span class="n">ether_crc_le</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>

		<span class="cm">/* do some messy swapping to put the bit in the right spot */</span>
		<span class="n">multicast_table</span><span class="p">[</span><span class="n">invert3</span><span class="p">[</span><span class="n">position</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">]]</span> <span class="o">|=</span>
					<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">invert3</span><span class="p">[(</span><span class="n">position</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">]);</span>

	<span class="p">}</span>
	<span class="cm">/* now, the table can be loaded into the chipset */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">outb</span><span class="p">(</span> <span class="n">multicast_table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MULTICAST1</span> <span class="o">+</span> <span class="n">i</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> . Function: smc_wait_to_send_packet( struct sk_buff * skb, struct net_device * )</span>
<span class="cm"> . Purpose:</span>
<span class="cm"> .    Attempt to allocate memory for a packet, if chip-memory is not</span>
<span class="cm"> .    available, then tell the card to generate an interrupt when it</span>
<span class="cm"> .    is available.</span>
<span class="cm"> .</span>
<span class="cm"> . Algorithm:</span>
<span class="cm"> .</span>
<span class="cm"> . o	if the saved_skb is not currently null, then drop this packet</span>
<span class="cm"> .	on the floor.  This should never happen, because of TBUSY.</span>
<span class="cm"> . o	if the saved_skb is null, then replace it with the current packet,</span>
<span class="cm"> . o	See if I can sending it now.</span>
<span class="cm"> . o 	(NO): Enable interrupts and let the interrupt handler deal with it.</span>
<span class="cm"> . o	(YES):Send it now.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">smc_wait_to_send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smc_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioaddr</span> 	<span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">word</span> 			<span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> 		<span class="n">numPages</span><span class="p">;</span>
	<span class="n">word</span>			<span class="n">time_out</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* Well, I want to send the packet.. but I don&#39;t know</span>
<span class="cm">	   if I can send it right now...  */</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">saved_skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* THIS SHOULD NEVER HAPPEN. */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">CARDNAME</span><span class="s">&quot;: Bad Craziness - sent packet while busy.</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">saved_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">ETH_ZLEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_padto</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_ZLEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">ETH_ZLEN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	** The MMU wants the number of pages to be the number of 256 bytes</span>
<span class="cm">	** &#39;pages&#39;, minus 1 ( since a packet can&#39;t ever have 0 pages :) )</span>
<span class="cm">	**</span>
<span class="cm">	** Pkt size for allocating is data length +6 (for additional status words,</span>
<span class="cm">	** length and ctl!) If odd size last byte is included in this header.</span>
<span class="cm">	*/</span>
	<span class="n">numPages</span> <span class="o">=</span>  <span class="p">((</span><span class="n">length</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="o">/</span> <span class="mi">256</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">numPages</span> <span class="o">&gt;</span> <span class="mi">7</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">CARDNAME</span><span class="s">&quot;: Far too big packet error.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* freeing the packet is a good thing here... but should</span>
<span class="cm">		 . any packets of this size get down here?   */</span>
		<span class="n">dev_kfree_skb</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">saved_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* this IS an error, but, i don&#39;t want the skb saved */</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* either way, a packet is waiting now */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">packets_waiting</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* now, try to allocate the memory */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">MC_ALLOC</span> <span class="o">|</span> <span class="n">numPages</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MMU_CMD</span> <span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm"> 	. Performance Hack</span>
<span class="cm">	.</span>
<span class="cm"> 	. wait a short amount of time.. if I can send a packet now, I send</span>
<span class="cm">	. it now.  Otherwise, I enable an interrupt and wait for one to be</span>
<span class="cm">	. available.</span>
<span class="cm">	.</span>
<span class="cm">	. I could have handled this a slightly different way, by checking to</span>
<span class="cm">	. see if any memory was available in the FREE MEMORY register.  However,</span>
<span class="cm">	. either way, I need to generate an allocation, and the allocation works</span>
<span class="cm">	. no matter what, so I saw no point in checking free memory.</span>
<span class="cm">	*/</span>
	<span class="n">time_out</span> <span class="o">=</span> <span class="n">MEMORY_WAIT_TIME</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">word</span>	<span class="n">status</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INTERRUPT</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">IM_ALLOC_INT</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* acknowledge the interrupt */</span>
			<span class="n">outb</span><span class="p">(</span> <span class="n">IM_ALLOC_INT</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INTERRUPT</span> <span class="p">);</span>
  			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
   	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="o">--</span> <span class="n">time_out</span> <span class="p">);</span>

   	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">time_out</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* oh well, wait until the chip finds memory later */</span>
		<span class="n">SMC_ENABLE_INT</span><span class="p">(</span> <span class="n">IM_ALLOC_INT</span> <span class="p">);</span>
		<span class="n">PRINTK2</span><span class="p">((</span><span class="n">CARDNAME</span><span class="s">&quot;: memory allocation deferred.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="cm">/* it&#39;s deferred, but I&#39;ll handle it later */</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
   	<span class="p">}</span>
	<span class="cm">/* or YES! I can send the packet now.. */</span>
	<span class="n">smc_hardware_send_packet</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> . Function:  smc_hardware_send_packet(struct net_device * )</span>
<span class="cm"> . Purpose:</span>
<span class="cm"> .	This sends the actual packet to the SMC9xxx chip.</span>
<span class="cm"> .</span>
<span class="cm"> . Algorithm:</span>
<span class="cm"> . 	First, see if a saved_skb is available.</span>
<span class="cm"> .		( this should NOT be called if there is no &#39;saved_skb&#39;</span>
<span class="cm"> .	Now, find the packet number that the chip allocated</span>
<span class="cm"> .	Point the data pointers at it in memory</span>
<span class="cm"> .	Set the length word in the chip&#39;s memory</span>
<span class="cm"> .	Dump the packet to chip memory</span>
<span class="cm"> .	Check if a last byte is needed ( odd length packet )</span>
<span class="cm"> .		if so, set the control flag right</span>
<span class="cm"> . 	Tell the card to send it</span>
<span class="cm"> .	Enable the transmit interrupt, so I know if it failed</span>
<span class="cm"> . 	Free the kernel data if I actually sent it.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smc_hardware_send_packet</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smc_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">byte</span>	 		<span class="n">packet_no</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> 	<span class="n">skb</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">saved_skb</span><span class="p">;</span>
	<span class="n">word</span>			<span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">byte</span>			<span class="o">*</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">skb</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">PRINTK</span><span class="p">((</span><span class="n">CARDNAME</span><span class="s">&quot;: In XMIT with no packet to send</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">ETH_ZLEN</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">?</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">:</span> <span class="n">ETH_ZLEN</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* If I get here, I _know_ there is a packet slot waiting for me */</span>
	<span class="n">packet_no</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PNR_ARR</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">packet_no</span> <span class="o">&amp;</span> <span class="mh">0x80</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* or isn&#39;t there?  BAD CHIP! */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">CARDNAME</span><span class="s">&quot;: Memory allocation failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">saved_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we have a packet address, so tell the card to use it */</span>
	<span class="n">outb</span><span class="p">(</span> <span class="n">packet_no</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PNR_ARR</span> <span class="p">);</span>

	<span class="cm">/* point to the beginning of the packet */</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">PTR_AUTOINC</span> <span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">POINTER</span> <span class="p">);</span>

   	<span class="n">PRINTK3</span><span class="p">((</span><span class="n">CARDNAME</span><span class="s">&quot;: Trying to xmit packet of length %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">length</span> <span class="p">));</span>
<span class="cp">#if SMC_DEBUG &gt; 2</span>
	<span class="n">print_packet</span><span class="p">(</span> <span class="n">buf</span><span class="p">,</span> <span class="n">length</span> <span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* send the packet length ( +6 for status, length and ctl byte )</span>
<span class="cm"> 	   and the status word ( set to zeros ) */</span>
<span class="cp">#ifdef USE_32_BIT</span>
	<span class="n">outl</span><span class="p">(</span>  <span class="p">(</span><span class="n">length</span> <span class="o">+</span><span class="mi">6</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">outw</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">);</span>
	<span class="cm">/* send the packet length ( +6 for status words, length, and ctl*/</span>
	<span class="n">outb</span><span class="p">(</span> <span class="p">(</span><span class="n">length</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span> <span class="p">(</span><span class="n">length</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* send the actual data</span>
<span class="cm">	 . I _think_ it&#39;s faster to send the longs first, and then</span>
<span class="cm">	 . mop up by sending the last word.  It depends heavily</span>
<span class="cm"> 	 . on alignment, at least on the 486.  Maybe it would be</span>
<span class="cm"> 	 . a good idea to check which is optimal?  But that could take</span>
<span class="cm">	 . almost as much time as is saved?</span>
<span class="cm">	*/</span>
<span class="cp">#ifdef USE_32_BIT</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">length</span> <span class="o">&amp;</span> <span class="mh">0x2</span>  <span class="p">)</span> <span class="p">{</span>
		<span class="n">outsl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>  <span class="n">length</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span> <span class="p">);</span>
<span class="cp">#if !defined(__H8300H__) &amp;&amp; !defined(__H8300S__)</span>
		<span class="n">outw</span><span class="p">(</span> <span class="o">*</span><span class="p">((</span><span class="n">word</span> <span class="o">*</span><span class="p">)(</span><span class="n">buf</span> <span class="o">+</span> <span class="p">(</span><span class="n">length</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFC</span><span class="p">))),</span><span class="n">ioaddr</span> <span class="o">+</span><span class="n">DATA_1</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">ctrl_outw</span><span class="p">(</span> <span class="o">*</span><span class="p">((</span><span class="n">word</span> <span class="o">*</span><span class="p">)(</span><span class="n">buf</span> <span class="o">+</span> <span class="p">(</span><span class="n">length</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFC</span><span class="p">))),</span><span class="n">ioaddr</span> <span class="o">+</span><span class="n">DATA_1</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">outsl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>  <span class="n">length</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span> <span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">outsw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="n">length</span> <span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/* Send the last byte, if there is one.   */</span>

	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">length</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">outw</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">outb</span><span class="p">(</span> <span class="n">buf</span><span class="p">[</span><span class="n">length</span> <span class="o">-</span><span class="mi">1</span> <span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span> <span class="mh">0x20</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* enable the interrupts */</span>
	<span class="n">SMC_ENABLE_INT</span><span class="p">(</span> <span class="p">(</span><span class="n">IM_TX_INT</span> <span class="o">|</span> <span class="n">IM_TX_EMPTY_INT</span><span class="p">)</span> <span class="p">);</span>

	<span class="cm">/* and let the chipset deal with it */</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">MC_ENQUEUE</span> <span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MMU_CMD</span> <span class="p">);</span>

	<span class="n">PRINTK2</span><span class="p">((</span><span class="n">CARDNAME</span><span class="s">&quot;: Sent packet of length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">length</span><span class="p">));</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">saved_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev_kfree_skb_any</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* we can send another packet */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------</span>
<span class="cm"> |</span>
<span class="cm"> | smc_init(int unit)</span>
<span class="cm"> |   Input parameters:</span>
<span class="cm"> |	dev-&gt;base_addr == 0, try to find all possible locations</span>
<span class="cm"> |	dev-&gt;base_addr == 1, return failure code</span>
<span class="cm"> |	dev-&gt;base_addr == 2, always allocate space,  and return success</span>
<span class="cm"> |	dev-&gt;base_addr == &lt;anything else&gt;   this is the address to check</span>
<span class="cm"> |</span>
<span class="cm"> |   Output:</span>
<span class="cm"> |	pointer to net_device or ERR_PTR(error)</span>
<span class="cm"> |</span>
<span class="cm"> ---------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">io</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ifport</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">smc_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smc_local</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">devlist</span> <span class="o">*</span><span class="n">smcdev</span> <span class="o">=</span> <span class="n">smc_devlist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unit</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;eth%d&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
		<span class="n">netdev_boot_setup_check</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">io</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">io</span> <span class="o">&gt;</span> <span class="mh">0x1ff</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Check a single specified location. */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">smc_probe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">io</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">io</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Don&#39;t probe at all. */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(;</span><span class="n">smcdev</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span> <span class="n">smcdev</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">smc_probe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smcdev</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smcdev</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="nl">out1:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">SMC_IO_EXTENT</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------------</span>
<span class="cm"> . smc_findirq</span>
<span class="cm"> .</span>
<span class="cm"> . This routine has a simple purpose -- make the SMC chip generate an</span>
<span class="cm"> . interrupt, so an auto-detect routine can detect it, and find the IRQ,</span>
<span class="cm"> ------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smc_findirq</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioaddr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef NO_AUTOPROBE</span>
	<span class="kt">int</span>	<span class="n">timeout</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cookie</span><span class="p">;</span>


	<span class="n">cookie</span> <span class="o">=</span> <span class="n">probe_irq_on</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * What I try to do here is trigger an ALLOC_INT. This is done</span>
<span class="cm">	 * by allocating a small chunk of memory, which will give an interrupt</span>
<span class="cm">	 * when done.</span>
<span class="cm">	 */</span>


	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="cm">/* enable ALLOCation interrupts ONLY */</span>
	<span class="n">outb</span><span class="p">(</span> <span class="n">IM_ALLOC_INT</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INT_MASK</span> <span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm"> 	 . Allocate 512 bytes of memory.  Note that the chip was just</span>
<span class="cm">	 . reset so all the memory is available</span>
<span class="cm">	*/</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">MC_ALLOC</span> <span class="o">|</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MMU_CMD</span> <span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 . Wait until positive that the interrupt has been generated</span>
<span class="cm">	*/</span>
	<span class="k">while</span> <span class="p">(</span> <span class="n">timeout</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">byte</span>	<span class="n">int_status</span><span class="p">;</span>

		<span class="n">int_status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INTERRUPT</span> <span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">int_status</span> <span class="o">&amp;</span> <span class="n">IM_ALLOC_INT</span> <span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>		<span class="cm">/* got the interrupt */</span>
		<span class="n">timeout</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* there is really nothing that I can do here if timeout fails,</span>
<span class="cm">	   as probe_irq_off will return a 0 anyway, which is what I</span>
<span class="cm">	   want in this case.   Plus, the clean up is needed in both</span>
<span class="cm">	   cases.  */</span>

	<span class="cm">/* DELAY HERE!</span>
<span class="cm">	   On a fast machine, the status might change before the interrupt</span>
<span class="cm">	   is given to the processor.  This means that the interrupt was</span>
<span class="cm">	   never detected, and probe_irq_off fails to report anything.</span>
<span class="cm">	   This should fix probe_irq_* problems.</span>
<span class="cm">	*/</span>
	<span class="n">SMC_DELAY</span><span class="p">();</span>
	<span class="n">SMC_DELAY</span><span class="p">();</span>

	<span class="cm">/* and disable all interrupts again */</span>
	<span class="n">outb</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INT_MASK</span> <span class="p">);</span>

	<span class="cm">/* and return what I found */</span>
	<span class="k">return</span> <span class="n">probe_irq_off</span><span class="p">(</span><span class="n">cookie</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* NO_AUTOPROBE */</span><span class="cp"></span>
	<span class="k">struct</span> <span class="n">devlist</span> <span class="o">*</span><span class="n">smcdev</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">smcdev</span> <span class="o">=</span> <span class="n">smc_devlist</span><span class="p">;</span> <span class="n">smcdev</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span> <span class="n">smcdev</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smcdev</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">==</span> <span class="n">ioaddr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">smcdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">smc_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		 <span class="o">=</span> <span class="n">smc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">smc_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>    	<span class="o">=</span> <span class="n">smc_wait_to_send_packet</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>	    	<span class="o">=</span> <span class="n">smc_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">smc_set_multicast_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">eth_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> 	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*----------------------------------------------------------------------</span>
<span class="cm"> . Function: smc_probe( int ioaddr )</span>
<span class="cm"> .</span>
<span class="cm"> . Purpose:</span>
<span class="cm"> .	Tests to see if a given ioaddr points to an SMC9xxx chip.</span>
<span class="cm"> .	Returns a 0 on success</span>
<span class="cm"> .</span>
<span class="cm"> . Algorithm:</span>
<span class="cm"> .	(1) see if the high byte of BANK_SELECT is 0x33</span>
<span class="cm"> . 	(2) compare the ioaddr with the base register&#39;s address</span>
<span class="cm"> .	(3) see if I recognize the chip ID in the appropriate register</span>
<span class="cm"> .</span>
<span class="cm"> .---------------------------------------------------------------------</span>
<span class="cm"> */</span>

<span class="cm">/*---------------------------------------------------------------</span>
<span class="cm"> . Here I do typical initialization tasks.</span>
<span class="cm"> .</span>
<span class="cm"> . o  Initialize the structure if needed</span>
<span class="cm"> . o  print out my vanity message if not done so already</span>
<span class="cm"> . o  print out what type of hardware is detected</span>
<span class="cm"> . o  print out the ethernet address</span>
<span class="cm"> . o  find the IRQ</span>
<span class="cm"> . o  set up my private data</span>
<span class="cm"> . o  configure the dev structure with my subroutines</span>
<span class="cm"> . o  actually GRAB the irq.</span>
<span class="cm"> . o  GRAB the region</span>
<span class="cm"> .-----------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">version_printed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bank</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">version_string</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">if_string</span><span class="p">;</span>

	<span class="cm">/* registers */</span>
	<span class="n">word</span> <span class="n">revision_register</span><span class="p">;</span>
	<span class="n">word</span> <span class="n">base_address_register</span><span class="p">;</span>
	<span class="n">word</span> <span class="n">configuration_register</span><span class="p">;</span>
	<span class="n">word</span> <span class="n">memory_info_register</span><span class="p">;</span>
	<span class="n">word</span> <span class="n">memory_cfg_register</span><span class="p">;</span>

	<span class="cm">/* Grab the region so that no one else tries to probe our ioports. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">SMC_IO_EXTENT</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">=</span> <span class="n">ifport</span><span class="p">;</span>

	<span class="cm">/* First, see if the high byte is 0x33 */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">BANK_SELECT</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bank</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x3300</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* The above MIGHT indicate a device, but I need to write to further</span>
<span class="cm"> 	 	test this.  */</span>
	<span class="n">outw</span><span class="p">(</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">BANK_SELECT</span> <span class="p">);</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">BANK_SELECT</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bank</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span> <span class="p">)</span> <span class="o">!=</span> <span class="mh">0x3300</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if !defined(CONFIG_H8S_EDOSK2674)</span>
	<span class="cm">/* well, we&#39;ve already written once, so hopefully another time won&#39;t</span>
<span class="cm"> 	   hurt.  This time, I need to switch the bank register to bank 1,</span>
<span class="cm">	   so I can access the base address register */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">base_address_register</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">BASE</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">ioaddr</span> <span class="o">!=</span> <span class="p">(</span> <span class="n">base_address_register</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">&amp;</span> <span class="mh">0x3E0</span> <span class="p">)</span> <span class="p">)</span>  <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">CARDNAME</span> <span class="s">&quot;: IOADDR %x doesn&#39;t match configuration (%x). &quot;</span>
			<span class="s">&quot;Probably not a SMC chip</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ioaddr</span><span class="p">,</span> <span class="n">base_address_register</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">&amp;</span> <span class="mh">0x3E0</span> <span class="p">);</span>
		<span class="cm">/* well, the base address register didn&#39;t match.  Must not have</span>
<span class="cm">		   been a SMC chip after all. */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">base_address_register</span><span class="p">;</span> <span class="cm">/* Warning suppression */</span>
<span class="cp">#endif</span>


	<span class="cm">/*  check if the revision register is something that I recognize.</span>
<span class="cm">	    These might need to be added to later, as future revisions</span>
<span class="cm">	    could be added.  */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">revision_register</span>  <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">REVISION</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">chip_ids</span><span class="p">[</span> <span class="p">(</span> <span class="n">revision_register</span>  <span class="o">&gt;&gt;</span> <span class="mi">4</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span>  <span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* I don&#39;t recognize this chip, so... */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">CARDNAME</span> <span class="s">&quot;: IO %x: Unrecognized revision register:&quot;</span>
			<span class="s">&quot; %x, Contact author.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">,</span> <span class="n">revision_register</span><span class="p">);</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* at this point I&#39;ll assume that the chip is an SMC9xxx.</span>
<span class="cm">	   It might be prudent to check a listing of MAC addresses</span>
<span class="cm">	   against the hardware address, or do some other tests. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">version_printed</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

	<span class="cm">/* fill in some of the fields */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm"> 	 . Get the MAC address ( bank 1, regs 4 - 9 )</span>
<span class="cm">	*/</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span>	<span class="n">address</span><span class="p">;</span>

		<span class="n">address</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ADDR0</span> <span class="o">+</span> <span class="n">i</span>  <span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span> <span class="n">i</span> <span class="p">]</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the memory information */</span>

	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="n">memory_info_register</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MIR</span> <span class="p">);</span>
	<span class="n">memory_cfg_register</span>  <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MCR</span> <span class="p">);</span>
	<span class="n">memory</span> <span class="o">=</span> <span class="p">(</span> <span class="n">memory_cfg_register</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span> <span class="p">)</span>  <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>  <span class="cm">/* multiplier */</span>
	<span class="n">memory</span> <span class="o">*=</span> <span class="mi">256</span> <span class="o">*</span> <span class="p">(</span> <span class="n">memory_info_register</span> <span class="o">&amp;</span> <span class="mh">0xFF</span> <span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 Now, I want to find out more about the chip.  This is sort of</span>
<span class="cm"> 	 redundant, but it&#39;s cleaner to have it in both, rather than having</span>
<span class="cm"> 	 one VERY long probe procedure.</span>
<span class="cm">	*/</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">revision_register</span>  <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">REVISION</span> <span class="p">);</span>
	<span class="n">version_string</span> <span class="o">=</span> <span class="n">chip_ids</span><span class="p">[</span> <span class="p">(</span> <span class="n">revision_register</span>  <span class="o">&gt;&gt;</span> <span class="mi">4</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span>  <span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">version_string</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* I shouldn&#39;t get here because this call was done before.... */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* is it using AUI or 10BaseT ? */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">SMC_SELECT_BANK</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">configuration_register</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CONFIG</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">configuration_register</span> <span class="o">&amp;</span> <span class="n">CFG_AUI_SELECT</span> <span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">if_string</span> <span class="o">=</span> <span class="n">interfaces</span><span class="p">[</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">];</span>

	<span class="cm">/* now, reset the chip, and put it into a known state */</span>
	<span class="n">smc_reset</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 . If dev-&gt;irq is 0, then the device has to be banged on to see</span>
<span class="cm">	 . what the IRQ is.</span>
<span class="cm"> 	 .</span>
<span class="cm">	 . This banging doesn&#39;t always detect the IRQ, for unknown reasons.</span>
<span class="cm">	 . a workaround is to reset the chip and try again.</span>
<span class="cm">	 .</span>
<span class="cm">	 . Interestingly, the DOS packet driver *SETS* the IRQ on the card to</span>
<span class="cm">	 . be what is requested on the command line.   I don&#39;t do that, mostly</span>
<span class="cm">	 . because the card that I have uses a non-standard method of accessing</span>
<span class="cm">	 . the IRQs, and because this _should_ work in most configurations.</span>
<span class="cm">	 .</span>
<span class="cm">	 . Specifying an IRQ is done with the assumption that the user knows</span>
<span class="cm">	 . what (s)he is doing.  No checking is done!!!!</span>
<span class="cm"> 	 .</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">trials</span><span class="p">;</span>

		<span class="n">trials</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span> <span class="n">trials</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">smc_findirq</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* kick the card and try again */</span>
			<span class="n">smc_reset</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">CARDNAME</span><span class="s">&quot;: Couldn&#39;t autodetect your IRQ. Use irq=xx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* now, print out the card info, in a short format.. */</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: %s(r:%d) at %#3x IRQ:%d INTF:%s MEM:%db &quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">version_string</span><span class="p">,</span> <span class="n">revision_register</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
		<span class="n">if_string</span><span class="p">,</span> <span class="n">memory</span> <span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 . Print the Ethernet address</span>
<span class="cm">	*/</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ADDR: %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="cm">/* Grab the IRQ */</span>
      	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">smc_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
      	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: unable to get IRQ %d (irqval=%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
  	  	<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
      	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">smc_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span>		<span class="o">=</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">20</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">SMC_IO_EXTENT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if SMC_DEBUG &gt; 2</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_packet</span><span class="p">(</span> <span class="n">byte</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span> <span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	int i;</span>
<span class="c">	int remainder;</span>
<span class="c">	int lines;</span>

<span class="c">	printk(&quot;Packet of length %d\n&quot;, length);</span>
<span class="c">	lines = length / 16;</span>
<span class="c">	remainder = length % 16;</span>

<span class="c">	for ( i = 0; i &lt; lines ; i ++ ) {</span>
<span class="c">		int cur;</span>

<span class="c">		for ( cur = 0; cur &lt; 8; cur ++ ) {</span>
<span class="c">			byte a, b;</span>

<span class="c">			a = *(buf ++ );</span>
<span class="c">			b = *(buf ++ );</span>
<span class="c">			printk(&quot;%02x%02x &quot;, a, b );</span>
<span class="c">		}</span>
<span class="c">		printk(&quot;\n&quot;);</span>
<span class="c">	}</span>
<span class="c">	for ( i = 0; i &lt; remainder/2 ; i++ ) {</span>
<span class="c">		byte a, b;</span>

<span class="c">		a = *(buf ++ );</span>
<span class="c">		b = *(buf ++ );</span>
<span class="c">		printk(&quot;%02x%02x &quot;, a, b );</span>
<span class="c">	}</span>
<span class="c">	printk(&quot;\n&quot;);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * Open and Initialize the board</span>
<span class="cm"> *</span>
<span class="cm"> * Set up everything, reset the card, etc ..</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>	<span class="cm">/* used to set hw ethernet address */</span>

	<span class="cm">/* clear out all the junk that was put here before... */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smc_local</span><span class="p">));</span>

	<span class="cm">/* reset the hardware */</span>

	<span class="n">smc_reset</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="p">);</span>
	<span class="n">smc_enable</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="p">);</span>

	<span class="cm">/* Select which interface to use */</span>

	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">outw</span><span class="p">(</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CONFIG</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CFG_AUI_SELECT</span><span class="p">,</span>
			<span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CONFIG</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">outw</span><span class="p">(</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CONFIG</span> <span class="p">)</span> <span class="o">|</span> <span class="n">CFG_AUI_SELECT</span><span class="p">,</span>
			<span class="n">ioaddr</span> <span class="o">+</span> <span class="n">CONFIG</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">  		According to Becker, I have to set the hardware address</span>
<span class="cm">		at this point, because the (l)user can set it with an</span>
<span class="cm">		ioctl.  Easily done...</span>
<span class="cm">	*/</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span>	<span class="n">address</span><span class="p">;</span>

		<span class="n">address</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="p">;</span>
		<span class="n">address</span>  <span class="o">|=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span> <span class="n">i</span> <span class="p">];</span>
		<span class="n">outw</span><span class="p">(</span> <span class="n">address</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ADDR0</span> <span class="o">+</span> <span class="n">i</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*--------------------------------------------------------</span>
<span class="cm"> . Called by the kernel to send a packet out into the void</span>
<span class="cm"> . of the net.  This routine is largely based on</span>
<span class="cm"> . skeleton.c, from Becker.</span>
<span class="cm"> .--------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smc_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If we get here, some higher level has decided we are broken.</span>
<span class="cm">	   There should really be a &quot;kick me&quot; function call instead. */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">CARDNAME</span><span class="s">&quot;: transmit timed out, %s?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">tx_done</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;IRQ conflict&quot;</span> <span class="o">:</span>
		<span class="s">&quot;network cable problem&quot;</span><span class="p">);</span>
	<span class="cm">/* &quot;kick&quot; the adaptor */</span>
	<span class="n">smc_reset</span><span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="p">);</span>
	<span class="n">smc_enable</span><span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
	<span class="cm">/* clear anything saved */</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">smc_local</span> <span class="o">*</span><span class="p">)</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">saved_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------</span>
<span class="cm"> .</span>
<span class="cm"> . smc_rcv -  receive a packet from the card</span>
<span class="cm"> .</span>
<span class="cm"> . There is ( at least ) a packet waiting to be read from</span>
<span class="cm"> . chip-memory.</span>
<span class="cm"> .</span>
<span class="cm"> . o Read the status</span>
<span class="cm"> . o If an error, record it</span>
<span class="cm"> . o otherwise, read in the packet</span>
<span class="cm"> --------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smc_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> 	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">int</span> 	<span class="n">packet_number</span><span class="p">;</span>
	<span class="n">word</span>	<span class="n">status</span><span class="p">;</span>
	<span class="n">word</span>	<span class="n">packet_length</span><span class="p">;</span>

	<span class="cm">/* assume bank 2 */</span>

	<span class="n">packet_number</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">FIFO_PORTS</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">packet_number</span> <span class="o">&amp;</span> <span class="n">FP_RXEMPTY</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we got called , but nothing was on the FIFO */</span>
		<span class="n">PRINTK</span><span class="p">((</span><span class="n">CARDNAME</span> <span class="s">&quot;: WARNING: smc_rcv with nothing on FIFO.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="cm">/* don&#39;t need to restore anything */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*  start reading from the start of the packet */</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">PTR_READ</span> <span class="o">|</span> <span class="n">PTR_RCV</span> <span class="o">|</span> <span class="n">PTR_AUTOINC</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">POINTER</span> <span class="p">);</span>

	<span class="cm">/* First two words are status and packet_length */</span>
	<span class="n">status</span> 		<span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">);</span>
	<span class="n">packet_length</span> 	<span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">);</span>

	<span class="n">packet_length</span> <span class="o">&amp;=</span> <span class="mh">0x07ff</span><span class="p">;</span>  <span class="cm">/* mask off top bits */</span>

	<span class="n">PRINTK2</span><span class="p">((</span><span class="s">&quot;RCV: STATUS %4x LENGTH %4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">packet_length</span> <span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 . the packet length contains 3 extra words :</span>
<span class="cm">	 . status, length, and an extra word with an odd byte .</span>
<span class="cm">	*/</span>
	<span class="n">packet_length</span> <span class="o">-=</span> <span class="mi">6</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_ERRORS</span> <span class="p">)</span> <span class="p">){</span>
		<span class="cm">/* do stuff to make a new packet */</span>
		<span class="k">struct</span> <span class="n">sk_buff</span>  <span class="o">*</span> <span class="n">skb</span><span class="p">;</span>
		<span class="n">byte</span>		<span class="o">*</span> <span class="n">data</span><span class="p">;</span>

		<span class="cm">/* read one extra byte */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_ODDFRAME</span> <span class="p">)</span>
			<span class="n">packet_length</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* set multicast stats */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_MULTICAST</span> <span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">multicast</span><span class="o">++</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">packet_length</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="n">CARDNAME</span> <span class="s">&quot;: Low memory, packet dropped.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 ! This should work without alignment, but it could be</span>
<span class="cm">		 ! in the worse case</span>
<span class="cm">		*/</span>

		<span class="n">skb_reserve</span><span class="p">(</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>   <span class="cm">/* 16 bit alignment */</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span> <span class="n">skb</span><span class="p">,</span> <span class="n">packet_length</span><span class="p">);</span>

<span class="cp">#ifdef USE_32_BIT</span>
		<span class="cm">/* QUESTION:  Like in the TX routine, do I want</span>
<span class="cm">		   to send the DWORDs or the bytes first, or some</span>
<span class="cm">		   mixture.  A mixture might improve already slow PIO</span>
<span class="cm">		   performance  */</span>
		<span class="n">PRINTK3</span><span class="p">((</span><span class="s">&quot; Reading %d dwords (and %d bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">packet_length</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">packet_length</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="p">));</span>
		<span class="n">insl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">packet_length</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span> <span class="p">);</span>
		<span class="cm">/* read the left over bytes */</span>
		<span class="n">insb</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="p">(</span><span class="n">packet_length</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFC</span><span class="p">),</span>
			<span class="n">packet_length</span> <span class="o">&amp;</span> <span class="mh">0x3</span>  <span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">PRINTK3</span><span class="p">((</span><span class="s">&quot; Reading %d words and %d byte(s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">packet_length</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="p">),</span> <span class="n">packet_length</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="p">));</span>
		<span class="n">insw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">packet_length</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">packet_length</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">+=</span> <span class="n">packet_length</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>
			<span class="o">*</span><span class="p">(</span><span class="n">data</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#if	SMC_DEBUG &gt; 2</span>
			<span class="n">print_packet</span><span class="p">(</span> <span class="n">data</span><span class="p">,</span> <span class="n">packet_length</span> <span class="p">);</span>
<span class="cp">#endif</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span> <span class="p">);</span>
		<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">packet_length</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* error ... */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_ALGNERR</span> <span class="p">)</span>  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RS_TOOSHORT</span> <span class="o">|</span> <span class="n">RS_TOOLONG</span> <span class="p">)</span> <span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_BADCRC</span><span class="p">)</span>	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="cm">/*  error or good, tell the card to get rid of this packet */</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">MC_RELEASE</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MMU_CMD</span> <span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*************************************************************************</span>
<span class="cm"> . smc_tx</span>
<span class="cm"> .</span>
<span class="cm"> . Purpose:  Handle a transmit error message.   This will only be called</span>
<span class="cm"> .   when an error, because of the AUTO_RELEASE mode.</span>
<span class="cm"> .</span>
<span class="cm"> . Algorithm:</span>
<span class="cm"> .	Save pointer and packet no</span>
<span class="cm"> .	Get the packet no from the top of the queue</span>
<span class="cm"> .	check if it&#39;s valid ( if not, is this an error??? )</span>
<span class="cm"> .	read the status word</span>
<span class="cm"> .	record the error</span>
<span class="cm"> .	( resend?  Not really, since we don&#39;t want old packets around )</span>
<span class="cm"> .	Restore saved values</span>
<span class="cm"> ************************************************************************/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smc_tx</span><span class="p">(</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smc_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">byte</span> <span class="n">saved_packet</span><span class="p">;</span>
	<span class="n">byte</span> <span class="n">packet_no</span><span class="p">;</span>
	<span class="n">word</span> <span class="n">tx_status</span><span class="p">;</span>


	<span class="cm">/* assume bank 2  */</span>

	<span class="n">saved_packet</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PNR_ARR</span> <span class="p">);</span>
	<span class="n">packet_no</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">FIFO_PORTS</span> <span class="p">);</span>
	<span class="n">packet_no</span> <span class="o">&amp;=</span> <span class="mh">0x7F</span><span class="p">;</span>

	<span class="cm">/* select this as the packet to read from */</span>
	<span class="n">outb</span><span class="p">(</span> <span class="n">packet_no</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PNR_ARR</span> <span class="p">);</span>

	<span class="cm">/* read the first word from this packet */</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">PTR_AUTOINC</span> <span class="o">|</span> <span class="n">PTR_READ</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">POINTER</span> <span class="p">);</span>

	<span class="n">tx_status</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">DATA_1</span> <span class="p">);</span>
	<span class="n">PRINTK3</span><span class="p">((</span><span class="n">CARDNAME</span><span class="s">&quot;: TX DONE STATUS: %4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tx_status</span><span class="p">));</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">TS_LOSTCAR</span> <span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_carrier_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">TS_LATCOL</span>  <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">CARDNAME</span>
			<span class="s">&quot;: Late collision occurred on last xmit.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		if ( tx_status &amp; TS_16COL ) { ... }</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">tx_status</span> <span class="o">&amp;</span> <span class="n">TS_SUCCESS</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">CARDNAME</span><span class="s">&quot;: Successful packet caused interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* re-enable transmit */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TCR</span> <span class="p">)</span> <span class="o">|</span> <span class="n">TCR_ENABLE</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TCR</span> <span class="p">);</span>

	<span class="cm">/* kill the packet */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">MC_FREEPKT</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MMU_CMD</span> <span class="p">);</span>

	<span class="cm">/* one less packet waiting for me */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">packets_waiting</span><span class="o">--</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span> <span class="n">saved_packet</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PNR_ARR</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*--------------------------------------------------------------------</span>
<span class="cm"> .</span>
<span class="cm"> . This is the main routine of the driver, to handle the device when</span>
<span class="cm"> . it needs some attention.</span>
<span class="cm"> .</span>
<span class="cm"> . So:</span>
<span class="cm"> .   first, save state of the chipset</span>
<span class="cm"> .   branch off into routines to handle each case, and acknowledge</span>
<span class="cm"> .	    each to the interrupt register</span>
<span class="cm"> .   and finally restore state.</span>
<span class="cm"> .</span>
<span class="cm"> ---------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">smc_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> 	<span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ioaddr</span> 		<span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smc_local</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">byte</span>	<span class="n">status</span><span class="p">;</span>
	<span class="n">word</span>	<span class="n">card_stats</span><span class="p">;</span>
	<span class="n">byte</span>	<span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">timeout</span><span class="p">;</span>
	<span class="cm">/* state registers */</span>
	<span class="n">word</span>	<span class="n">saved_bank</span><span class="p">;</span>
	<span class="n">word</span>	<span class="n">saved_pointer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="n">PRINTK3</span><span class="p">((</span><span class="n">CARDNAME</span><span class="s">&quot;: SMC interrupt started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="n">saved_bank</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">BANK_SELECT</span> <span class="p">);</span>

	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">saved_pointer</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">POINTER</span> <span class="p">);</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INT_MASK</span> <span class="p">);</span>
	<span class="cm">/* clear all interrupts */</span>
	<span class="n">outb</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INT_MASK</span> <span class="p">);</span>


	<span class="cm">/* set a timeout value, so I don&#39;t stay here forever */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">PRINTK2</span><span class="p">((</span><span class="n">KERN_WARNING</span> <span class="n">CARDNAME</span> <span class="s">&quot;: MASK IS %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mask</span><span class="p">));</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* read the status flag, and mask it */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INTERRUPT</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">PRINTK3</span><span class="p">((</span><span class="n">KERN_WARNING</span> <span class="n">CARDNAME</span>
			<span class="s">&quot;: Handling interrupt status %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IM_RCV_INT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Got a packet(s). */</span>
			<span class="n">PRINTK2</span><span class="p">((</span><span class="n">KERN_WARNING</span> <span class="n">CARDNAME</span>
				<span class="s">&quot;: Receive Interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="n">smc_rcv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IM_TX_INT</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">PRINTK2</span><span class="p">((</span><span class="n">KERN_WARNING</span> <span class="n">CARDNAME</span>
				<span class="s">&quot;: TX ERROR handled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="n">smc_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">IM_TX_INT</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INTERRUPT</span> <span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IM_TX_EMPTY_INT</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* update stats */</span>
			<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
			<span class="n">card_stats</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">COUNTER</span> <span class="p">);</span>
			<span class="cm">/* single collisions */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span> <span class="o">+=</span> <span class="n">card_stats</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
			<span class="n">card_stats</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="cm">/* multiple collisions */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span> <span class="o">+=</span> <span class="n">card_stats</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>

			<span class="cm">/* these are for when linux supports these statistics */</span>

			<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
			<span class="n">PRINTK2</span><span class="p">((</span><span class="n">KERN_WARNING</span> <span class="n">CARDNAME</span>
				<span class="s">&quot;: TX_BUFFER_EMPTY handled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="n">outb</span><span class="p">(</span> <span class="n">IM_TX_EMPTY_INT</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INTERRUPT</span> <span class="p">);</span>
			<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IM_TX_EMPTY_INT</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span> <span class="o">+=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">packets_waiting</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">packets_waiting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IM_ALLOC_INT</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">PRINTK2</span><span class="p">((</span><span class="n">KERN_DEBUG</span> <span class="n">CARDNAME</span>
				<span class="s">&quot;: Allocation interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="cm">/* clear this interrupt so it doesn&#39;t happen again */</span>
			<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IM_ALLOC_INT</span><span class="p">;</span>

			<span class="n">smc_hardware_send_packet</span><span class="p">(</span> <span class="n">dev</span> <span class="p">);</span>

			<span class="cm">/* enable xmit interrupts based on this */</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="p">(</span> <span class="n">IM_TX_EMPTY_INT</span> <span class="o">|</span> <span class="n">IM_TX_INT</span> <span class="p">);</span>

			<span class="cm">/* and let the card send more packets to me */</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

			<span class="n">PRINTK2</span><span class="p">((</span><span class="n">CARDNAME</span><span class="s">&quot;: Handoff done successfully.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IM_RX_OVRN_INT</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">outb</span><span class="p">(</span> <span class="n">IM_RX_OVRN_INT</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INTERRUPT</span> <span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IM_EPH_INT</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">PRINTK</span><span class="p">((</span><span class="n">CARDNAME</span> <span class="s">&quot;: UNSUPPORTED: EPH INTERRUPT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IM_ERCV_INT</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">PRINTK</span><span class="p">((</span><span class="n">CARDNAME</span> <span class="s">&quot;: UNSUPPORTED: ERCV INTERRUPT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="n">outb</span><span class="p">(</span> <span class="n">IM_ERCV_INT</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INTERRUPT</span> <span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="n">timeout</span> <span class="o">--</span> <span class="p">);</span>


	<span class="cm">/* restore state register */</span>
	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">INT_MASK</span> <span class="p">);</span>

	<span class="n">PRINTK3</span><span class="p">((</span><span class="n">KERN_WARNING</span> <span class="n">CARDNAME</span> <span class="s">&quot;: MASK is now %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mask</span><span class="p">));</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">saved_pointer</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">POINTER</span> <span class="p">);</span>

	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="n">saved_bank</span> <span class="p">);</span>

	<span class="n">PRINTK3</span><span class="p">((</span><span class="n">CARDNAME</span> <span class="s">&quot;: Interrupt done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*----------------------------------------------------</span>
<span class="cm"> . smc_close</span>
<span class="cm"> .</span>
<span class="cm"> . this makes the board clean up everything that it can</span>
<span class="cm"> . and not talk to the outside world.   Caused by</span>
<span class="cm"> . an &#39;ifconfig ethX down&#39;</span>
<span class="cm"> .</span>
<span class="cm"> -----------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* clear everything */</span>
	<span class="n">smc_shutdown</span><span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="p">);</span>

	<span class="cm">/* Update the statistics here. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------</span>
<span class="cm"> . smc_set_multicast_list</span>
<span class="cm"> .</span>
<span class="cm"> . This routine will, depending on the values passed to it,</span>
<span class="cm"> . either make it accept multicast packets, go into</span>
<span class="cm"> . promiscuous mode ( for TCPDUMP and cousins ) or accept</span>
<span class="cm"> . a select set of multicast packets</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smc_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">ioaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="n">SMC_SELECT_BANK</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span> <span class="p">)</span>
		<span class="n">outw</span><span class="p">(</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">)</span> <span class="o">|</span> <span class="n">RCR_PROMISC</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">);</span>

<span class="cm">/* BUG?  I never disable promiscuous mode if multicasting was turned on.</span>
<span class="cm">   Now, I turn off promiscuous mode, but I don&#39;t do anything to multicasting</span>
<span class="cm">   when promiscuous mode is turned on.</span>
<span class="cm">*/</span>

	<span class="cm">/* Here, I am setting this to accept all multicast packets.</span>
<span class="cm">	   I don&#39;t need to zero the multicast table, because the flag is</span>
<span class="cm">	   checked before the table is</span>
<span class="cm">	*/</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span>
		<span class="n">outw</span><span class="p">(</span> <span class="n">inw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">)</span> <span class="o">|</span> <span class="n">RCR_ALMUL</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">);</span>

	<span class="cm">/* We just get all multicast packets even if we only want them</span>
<span class="cm">	 . from one source.  This will be changed at some future</span>
<span class="cm">	 . point. */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev_mc_empty</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* support hardware multicasting */</span>

		<span class="cm">/* be sure I get rid of flags I might have set */</span>
		<span class="n">outw</span><span class="p">(</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">RCR_PROMISC</span> <span class="o">|</span> <span class="n">RCR_ALMUL</span><span class="p">),</span>
			<span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">);</span>
		<span class="cm">/* NOTE: this has to set the bank, so make sure it is the</span>
<span class="cm">		   last thing called.  The bank is set to zero at the top */</span>
		<span class="n">smc_setmulticast</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>  <span class="p">{</span>
		<span class="n">outw</span><span class="p">(</span> <span class="n">inw</span><span class="p">(</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">RCR_PROMISC</span> <span class="o">|</span> <span class="n">RCR_ALMUL</span><span class="p">),</span>
			<span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RCR</span> <span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		  since I&#39;m disabling all multicast entirely, I need to</span>
<span class="cm">		  clear the multicast list</span>
<span class="cm">		*/</span>
		<span class="n">SMC_SELECT_BANK</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MULTICAST1</span> <span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MULTICAST2</span> <span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MULTICAST3</span> <span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MULTICAST4</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef MODULE</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">devSMC9194</span><span class="p">;</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ifport</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;SMC 99194 I/O base address&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="s">&quot;SMC 99194 IRQ number&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ifport</span><span class="p">,</span> <span class="s">&quot;SMC 99194 interface port (0-default, 1-TP, 2-AUI)&quot;</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="n">CARDNAME</span><span class="s">&quot;: You shouldn&#39;t use auto-probing with insmod!</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>

	<span class="cm">/* copy the parameters from insmod into the device structure */</span>
	<span class="n">devSMC9194</span> <span class="o">=</span> <span class="n">smc_init</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">devSMC9194</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">devSMC9194</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">devSMC9194</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">devSMC9194</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">devSMC9194</span><span class="p">);</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">devSMC9194</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">SMC_IO_EXTENT</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">devSMC9194</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* MODULE */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
