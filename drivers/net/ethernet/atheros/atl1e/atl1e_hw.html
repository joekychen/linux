<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › atheros › atl1e › atl1e_hw.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>atl1e_hw.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright(c) 2007 Atheros Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Derived from Intel e1000 driver</span>
<span class="cm"> * Copyright(c) 1999 - 2005 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the Free</span>
<span class="cm"> * Software Foundation; either version 2 of the License, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 59</span>
<span class="cm"> * Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>

<span class="cp">#include &quot;atl1e.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * check_eeprom_exist</span>
<span class="cm"> * return 0 if eeprom exist</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">atl1e_check_eeprom_exist</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_SPI_FLASH_CTRL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">SPI_FLASH_CTRL_EN_VPD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SPI_FLASH_CTRL_EN_VPD</span><span class="p">;</span>
		<span class="n">AT_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_SPI_FLASH_CTRL</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">AT_READ_REGW</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_PCIE_CAP_LIST</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x6C00</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">atl1e_hw_set_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * 00-0B-6A-F6-00-DC</span>
<span class="cm">	 * 0:  6AF600DC 1: 000B</span>
<span class="cm">	 * low dword</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>  <span class="o">|</span>
		<span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span> <span class="p">;</span>
	<span class="n">AT_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_MAC_STA_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="cm">/* hight dword */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">;</span>
	<span class="n">AT_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_MAC_STA_ADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * atl1e_get_permanent_address</span>
<span class="cm"> * return 0 if get valid mac address,</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atl1e_get_permanent_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">twsi_ctrl_data</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">eth_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">perm_mac_addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* init */</span>
	<span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atl1e_check_eeprom_exist</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* eeprom exist */</span>
		<span class="n">twsi_ctrl_data</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_TWSI_CTRL</span><span class="p">);</span>
		<span class="n">twsi_ctrl_data</span> <span class="o">|=</span> <span class="n">TWSI_CTRL_SW_LDSTART</span><span class="p">;</span>
		<span class="n">AT_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_TWSI_CTRL</span><span class="p">,</span> <span class="n">twsi_ctrl_data</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AT_TWSI_EEPROM_TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">twsi_ctrl_data</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_TWSI_CTRL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">twsi_ctrl_data</span> <span class="o">&amp;</span> <span class="n">TWSI_CTRL_SW_LDSTART</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">AT_TWSI_EEPROM_TIMEOUT</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">AT_ERR_TIMEOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* maybe MAC-address is from BIOS */</span>
	<span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_MAC_STA_ADDR</span><span class="p">);</span>
	<span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_MAC_STA_ADDR</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">eth_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">swab32</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">eth_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">swab16</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">eth_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">perm_mac_addr</span><span class="p">,</span> <span class="n">eth_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">AT_ERR_EEPROM</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">atl1e_write_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">atl1e_read_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">p_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">control</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* address do not align */</span>

	<span class="n">AT_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_VPD_DATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">control</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">VPD_CAP_VPD_ADDR_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">VPD_CAP_VPD_ADDR_SHIFT</span><span class="p">;</span>
	<span class="n">AT_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_VPD_CAP</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="n">control</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_VPD_CAP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">VPD_CAP_VPD_FLAG</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">VPD_CAP_VPD_FLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p_value</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_VPD_DATA</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* timeout */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">atl1e_force_ps</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AT_WRITE_REGW</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_GPHY_CTRL</span><span class="p">,</span>
			<span class="n">GPHY_CTRL_PW_WOL_DIS</span> <span class="o">|</span> <span class="n">GPHY_CTRL_EXT_RESET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reads the adapter&#39;s MAC address from the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">atl1e_read_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">atl1e_get_permanent_address</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AT_ERR_EEPROM</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">perm_mac_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">perm_mac_addr</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * atl1e_hash_mc_addr</span>
<span class="cm"> *  purpose</span>
<span class="cm"> *      set hash value for a multicast address</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">atl1e_hash_mc_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mc_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">crc32</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">crc32</span> <span class="o">=</span> <span class="n">ether_crc_le</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">mc_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="p">(((</span><span class="n">crc32</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">31</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sets the bit in the multicast table corresponding to the hash value.</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> * hash_value - Multicast address hash value</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">atl1e_hash_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hash_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hash_bit</span><span class="p">,</span> <span class="n">hash_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mta</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The HASH Table  is a register array of 2 32-bit registers.</span>
<span class="cm">	 * It is treated like an array of 64 bits.  We want to set</span>
<span class="cm">	 * bit BitArray[hash_value]. So we figure out what register</span>
<span class="cm">	 * the bit is in, read it, OR in the new bit, then write</span>
<span class="cm">	 * back the new value.  The register is determined by the</span>
<span class="cm">	 * upper 7 bits of the hash value and the bit within that</span>
<span class="cm">	 * register are determined by the lower 5 bits of the value.</span>
<span class="cm">	 */</span>
	<span class="n">hash_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">hash_bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">;</span>

	<span class="n">mta</span> <span class="o">=</span> <span class="n">AT_READ_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_RX_HASH_TABLE</span><span class="p">,</span> <span class="n">hash_reg</span><span class="p">);</span>

	<span class="n">mta</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hash_bit</span><span class="p">);</span>

	<span class="n">AT_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_RX_HASH_TABLE</span><span class="p">,</span> <span class="n">hash_reg</span><span class="p">,</span> <span class="n">mta</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Reads the value from a PHY register</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> * reg_addr - address of the PHY register to read</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">atl1e_read_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg_addr</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">phy_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">reg_addr</span> <span class="o">&amp;</span> <span class="n">MDIO_REG_ADDR_MASK</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">MDIO_REG_ADDR_SHIFT</span> <span class="o">|</span>
		<span class="n">MDIO_START</span> <span class="o">|</span> <span class="n">MDIO_SUP_PREAMBLE</span> <span class="o">|</span> <span class="n">MDIO_RW</span> <span class="o">|</span>
		<span class="n">MDIO_CLK_25_4</span> <span class="o">&lt;&lt;</span> <span class="n">MDIO_CLK_SEL_SHIFT</span><span class="p">;</span>

	<span class="n">AT_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_MDIO_CTRL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">wmb</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MDIO_WAIT_TIMES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_MDIO_CTRL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDIO_START</span> <span class="o">|</span> <span class="n">MDIO_BUSY</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDIO_START</span> <span class="o">|</span> <span class="n">MDIO_BUSY</span><span class="p">)))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">phy_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">val</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">AT_ERR_PHY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Writes a value to a PHY register</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> * reg_addr - address of the PHY register to write</span>
<span class="cm"> * data - data to write to the PHY</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">atl1e_write_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg_addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">phy_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">MDIO_DATA_MASK</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">MDIO_DATA_SHIFT</span> <span class="o">|</span>
	       <span class="p">(</span><span class="n">reg_addr</span><span class="o">&amp;</span><span class="n">MDIO_REG_ADDR_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">MDIO_REG_ADDR_SHIFT</span> <span class="o">|</span>
	       <span class="n">MDIO_SUP_PREAMBLE</span> <span class="o">|</span>
	       <span class="n">MDIO_START</span> <span class="o">|</span>
	       <span class="n">MDIO_CLK_25_4</span> <span class="o">&lt;&lt;</span> <span class="n">MDIO_CLK_SEL_SHIFT</span><span class="p">;</span>

	<span class="n">AT_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_MDIO_CTRL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MDIO_WAIT_TIMES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_MDIO_CTRL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDIO_START</span> <span class="o">|</span> <span class="n">MDIO_BUSY</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDIO_START</span> <span class="o">|</span> <span class="n">MDIO_BUSY</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">AT_ERR_PHY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * atl1e_init_pcie - init PCIE module</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">atl1e_init_pcie</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
	<span class="cm">/* comment 2lines below to save more power when sususpend</span>
<span class="cm">	   value = LTSSM_TEST_MODE_DEF;</span>
<span class="cm">	   AT_WRITE_REG(hw, REG_LTSSM_TEST_MODE, value);</span>
<span class="cm">	 */</span>

	<span class="cm">/* pcie flow control mode change */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1008</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">|=</span> <span class="mh">0x8000</span><span class="p">;</span>
	<span class="n">AT_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1008</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Configures PHY autoneg and flow control advertisement settings</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atl1e_phy_setup_autoneg_adv</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_autoneg_adv_reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_1000t_ctrl_reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mii_autoneg_adv_reg</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Read the MII Auto-Neg Advertisement Register (Address 4/9). */</span>
	<span class="n">mii_autoneg_adv_reg</span> <span class="o">=</span> <span class="n">MII_AR_DEFAULT_CAP_MASK</span><span class="p">;</span>
	<span class="n">mii_1000t_ctrl_reg</span>  <span class="o">=</span> <span class="n">MII_AT001_CR_1000T_DEFAULT_CAP_MASK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to parse autoneg_advertised  and set up</span>
<span class="cm">	 * the appropriate PHY registers.  First we will parse for</span>
<span class="cm">	 * autoneg_advertised software override.  Since we can advertise</span>
<span class="cm">	 * a plethora of combinations, we need to check each bit</span>
<span class="cm">	 * individually.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * First we clear all the 10/100 mb speed bits in the Auto-Neg</span>
<span class="cm">	 * Advertisement Register (Address 4) and the 1000 mb speed bits in</span>
<span class="cm">	 * the  1000Base-T control Register (Address 9).</span>
<span class="cm">	 */</span>
	<span class="n">mii_autoneg_adv_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ADVERTISE_ALL</span><span class="p">;</span>
	<span class="n">mii_1000t_ctrl_reg</span>  <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MII_AT001_CR_1000T_SPEED_MASK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to parse MediaType and setup the</span>
<span class="cm">	 * appropriate PHY registers.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEDIA_TYPE_AUTO_SENSOR</span>:
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="n">ADVERTISE_ALL</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="n">ADVERTISE_ALL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nic_type</span> <span class="o">==</span> <span class="n">athr_l1e</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mii_1000t_ctrl_reg</span> <span class="o">|=</span> <span class="n">ADVERTISE_1000FULL</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">|=</span> <span class="n">ADVERTISE_1000_FULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MEDIA_TYPE_100M_FULL</span>:
		<span class="n">mii_autoneg_adv_reg</span>   <span class="o">|=</span> <span class="n">ADVERTISE_100FULL</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="n">ADVERTISE_100_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MEDIA_TYPE_100M_HALF</span>:
		<span class="n">mii_autoneg_adv_reg</span>   <span class="o">|=</span> <span class="n">ADVERTISE_100_HALF</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="n">ADVERTISE_100_HALF</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MEDIA_TYPE_10M_FULL</span>:
		<span class="n">mii_autoneg_adv_reg</span>   <span class="o">|=</span> <span class="n">ADVERTISE_10_FULL</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="n">ADVERTISE_10_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">mii_autoneg_adv_reg</span>   <span class="o">|=</span> <span class="n">ADVERTISE_10_HALF</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="n">ADVERTISE_10_HALF</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* flow control fixed to enable all */</span>
	<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ADVERTISE_PAUSE_ASYM</span> <span class="o">|</span> <span class="n">ADVERTISE_PAUSE_CAP</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mii_autoneg_adv_reg</span> <span class="o">=</span> <span class="n">mii_autoneg_adv_reg</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mii_1000t_ctrl_reg</span>  <span class="o">=</span> <span class="n">mii_1000t_ctrl_reg</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_ADVERTISE</span><span class="p">,</span> <span class="n">mii_autoneg_adv_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nic_type</span> <span class="o">==</span> <span class="n">athr_l1e</span> <span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">nic_type</span> <span class="o">==</span> <span class="n">athr_l2e_revA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_CTRL1000</span><span class="p">,</span>
					   <span class="n">mii_1000t_ctrl_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Resets the PHY and make all config validate</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Sets bit 15 and 12 of the MII control regiser (for F001 bug)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">atl1e_phy_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atl1e_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">phy_data</span> <span class="o">=</span> <span class="n">BMCR_RESET</span> <span class="o">|</span> <span class="n">BMCR_ANENABLE</span> <span class="o">|</span> <span class="n">BMCR_ANRESTART</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/**************************************</span>
<span class="cm">		 * pcie serdes link may be down !</span>
<span class="cm">		 **************************************/</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_MDIO_CTRL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDIO_START</span> <span class="o">|</span> <span class="n">MDIO_BUSY</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDIO_START</span> <span class="o">|</span> <span class="n">MDIO_BUSY</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
				   <span class="s">&quot;pcie linkdown at least for 25ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">netdev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;pcie linkup after %d ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">atl1e_phy_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atl1e_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_configured</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">re_autoneg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">re_autoneg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">atl1e_restart_autoneg</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* RESET GPHY Core */</span>
	<span class="n">AT_WRITE_REGW</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_GPHY_CTRL</span><span class="p">,</span> <span class="n">GPHY_CTRL_DEFAULT</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">AT_WRITE_REGW</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_GPHY_CTRL</span><span class="p">,</span> <span class="n">GPHY_CTRL_DEFAULT</span> <span class="o">|</span>
		      <span class="n">GPHY_CTRL_EXT_RESET</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* patches */</span>
	<span class="cm">/* p1. eable hibernation mode */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_DBG_ADDR</span><span class="p">,</span> <span class="mh">0xB</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_DBG_DATA</span><span class="p">,</span> <span class="mh">0xBC00</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="cm">/* p2. set Class A/B for all modes */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_DBG_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">phy_val</span> <span class="o">=</span> <span class="mh">0x02ef</span><span class="p">;</span>
	<span class="cm">/* remove Class AB */</span>
	<span class="cm">/* phy_val = hw-&gt;emi_ca ? 0x02ef : 0x02df; */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_DBG_DATA</span><span class="p">,</span> <span class="n">phy_val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="cm">/* p3. 10B ??? */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_DBG_ADDR</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_DBG_DATA</span><span class="p">,</span> <span class="mh">0x4C04</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="cm">/* p4. 1000T power */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_DBG_ADDR</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_DBG_DATA</span><span class="p">,</span> <span class="mh">0x8BBB</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_DBG_ADDR</span><span class="p">,</span> <span class="mh">0x5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_DBG_DATA</span><span class="p">,</span> <span class="mh">0x2C46</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*Enable PHY LinkChange Interrupt */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_INT_CTRL</span><span class="p">,</span> <span class="mh">0xC00</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
			   <span class="s">&quot;Error enable PHY linkChange Interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* setup AutoNeg parameters */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_phy_setup_autoneg_adv</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
			   <span class="s">&quot;Error Setting up Auto-Negotiation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* SW.Reset &amp; En-Auto-Neg to restart Auto-Neg*/</span>
	<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Restarting Auto-Negotiation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_phy_commit</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;Error resetting the phy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_configured</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset the transmit and receive units; mask and clear all interrupts.</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> * return : 0  or  idle status (if error)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">atl1e_reset_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atl1e_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">idle_status_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pci_cfg_cmd_word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Workaround for PCI problem when BIOS sets MMRBC incorrectly. */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_REG_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_cfg_cmd_word</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pci_cfg_cmd_word</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CMD_IO_SPACE</span> <span class="o">|</span>
				<span class="n">CMD_MEMORY_SPACE</span> <span class="o">|</span> <span class="n">CMD_BUS_MASTER</span><span class="p">))</span>
			<span class="o">!=</span> <span class="p">(</span><span class="n">CMD_IO_SPACE</span> <span class="o">|</span> <span class="n">CMD_MEMORY_SPACE</span> <span class="o">|</span> <span class="n">CMD_BUS_MASTER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pci_cfg_cmd_word</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CMD_IO_SPACE</span> <span class="o">|</span>
				     <span class="n">CMD_MEMORY_SPACE</span> <span class="o">|</span> <span class="n">CMD_BUS_MASTER</span><span class="p">);</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_REG_COMMAND</span><span class="p">,</span> <span class="n">pci_cfg_cmd_word</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Issue Soft Reset to the MAC.  This will reset the chip&#39;s</span>
<span class="cm">	 * transmit, receive, DMA.  It will not effect</span>
<span class="cm">	 * the current PCI configuration.  The global reset bit is self-</span>
<span class="cm">	 * clearing, and should clear within a microsecond.</span>
<span class="cm">	 */</span>
	<span class="n">AT_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_MASTER_CTRL</span><span class="p">,</span>
			<span class="n">MASTER_CTRL_LED_MODE</span> <span class="o">|</span> <span class="n">MASTER_CTRL_SOFT_RST</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Wait at least 10ms for All module to be Idle */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="n">AT_HW_MAX_IDLE_DELAY</span><span class="p">;</span> <span class="n">timeout</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idle_status_data</span> <span class="o">=</span> <span class="n">AT_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_IDLE_STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idle_status_data</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;=</span> <span class="n">AT_HW_MAX_IDLE_DELAY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
			   <span class="s">&quot;MAC state machine can&#39;t be idle since disabled for 10ms second</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">AT_ERR_TIMEOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Performs basic configuration of the adapter.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> * Assumes that the controller has previously been reset and is in a</span>
<span class="cm"> * post-reset uninitialized state. Initializes multicast table,</span>
<span class="cm"> * and  Calls routines to setup link</span>
<span class="cm"> * Leaves the transmit and receive units disabled and uninitialized.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">atl1e_init_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">atl1e_init_pcie</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Zero out the Multicast HASH table */</span>
	<span class="cm">/* clear the old settings from the multicast hash table */</span>
	<span class="n">AT_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_RX_HASH_TABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">AT_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">REG_RX_HASH_TABLE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">atl1e_phy_init</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Detects the current speed and duplex settings of the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> * speed - Speed of the connection</span>
<span class="cm"> * duplex - Duplex setting of the connection</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">atl1e_get_speed_and_duplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">speed</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">duplex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="cm">/* Read   PHY Specific Status Register (17) */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">atl1e_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_AT001_PSSR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">MII_AT001_PSSR_SPD_DPLX_RESOLVED</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">AT_ERR_PHY_RES</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">MII_AT001_PSSR_SPEED</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MII_AT001_PSSR_1000MBS</span>:
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">SPEED_1000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MII_AT001_PSSR_100MBS</span>:
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">SPEED_100</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MII_AT001_PSSR_10MBS</span>:
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">SPEED_10</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">AT_ERR_PHY_SPEED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">MII_AT001_PSSR_DPLX</span><span class="p">)</span>
		<span class="o">*</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">FULL_DUPLEX</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">HALF_DUPLEX</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">atl1e_restart_autoneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">atl1e_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_ADVERTISE</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mii_autoneg_adv_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nic_type</span> <span class="o">==</span> <span class="n">athr_l1e</span> <span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">nic_type</span> <span class="o">==</span> <span class="n">athr_l2e_revA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_CTRL1000</span><span class="p">,</span>
				       <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mii_1000t_ctrl_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">atl1e_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span>
			<span class="n">BMCR_RESET</span> <span class="o">|</span> <span class="n">BMCR_ANENABLE</span> <span class="o">|</span> <span class="n">BMCR_ANRESTART</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
