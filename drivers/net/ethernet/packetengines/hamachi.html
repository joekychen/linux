<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › packetengines › hamachi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>hamachi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* hamachi.c: A Packet Engines GNIC-II Gigabit Ethernet driver for Linux. */</span>
<span class="cm">/*</span>
<span class="cm">	Written 1998-2000 by Donald Becker.</span>
<span class="cm">	Updates 2000 by Keith Underwood.</span>

<span class="cm">	This software may be used and distributed according to the terms of</span>
<span class="cm">	the GNU General Public License (GPL), incorporated herein by reference.</span>
<span class="cm">	Drivers based on or derived from this code fall under the GPL and must</span>
<span class="cm">	retain the authorship, copyright and license notice.  This file is not</span>
<span class="cm">	a complete program and may only be used when the entire operating</span>
<span class="cm">	system is licensed under the GPL.</span>

<span class="cm">	The author may be reached as becker@scyld.com, or C/O</span>
<span class="cm">	Scyld Computing Corporation</span>
<span class="cm">	410 Severn Ave., Suite 210</span>
<span class="cm">	Annapolis MD 21403</span>

<span class="cm">	This driver is for the Packet Engines GNIC-II PCI Gigabit Ethernet</span>
<span class="cm">	adapter.</span>

<span class="cm">	Support and updates available at</span>
<span class="cm">	http://www.scyld.com/network/hamachi.html</span>
<span class="cm">	[link no longer provides useful info -jgarzik]</span>
<span class="cm">	or</span>
<span class="cm">	http://www.parl.clemson.edu/~keithu/hamachi.html</span>

<span class="cm">*/</span>

<span class="cp">#define DRV_NAME	&quot;hamachi&quot;</span>
<span class="cp">#define DRV_VERSION	&quot;2.1&quot;</span>
<span class="cp">#define DRV_RELDATE	&quot;Sept 11, 2006&quot;</span>


<span class="cm">/* A few user-configurable values. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* 1 normal messages, 0 quiet .. 7 verbose.  */</span>
<span class="cp">#define final_version</span>
<span class="cp">#define hamachi_debug debug</span>
<span class="cm">/* Maximum events (Rx packets, etc.) to handle at each interrupt. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_interrupt_work</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mtu</span><span class="p">;</span>
<span class="cm">/* Default values selected by testing on a dual processor PIII-450 */</span>
<span class="cm">/* These six interrupt control parameters may be set directly when loading the</span>
<span class="cm"> * module, or through the rx_params and tx_params variables</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_rx_latency</span> <span class="o">=</span> <span class="mh">0x11</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_rx_gap</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">min_rx_pkt</span> <span class="o">=</span> <span class="mh">0x18</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_tx_latency</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_tx_gap</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">min_tx_pkt</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>

<span class="cm">/* Set the copy breakpoint for the copy-only-tiny-frames scheme.</span>
<span class="cm">   -Setting to &gt; 1518 causes all frames to be copied</span>
<span class="cm">	-Setting to 0 disables copies</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rx_copybreak</span><span class="p">;</span>

<span class="cm">/* An override for the hardware detection of bus width.</span>
<span class="cm">	Set to 1 to force 32 bit PCI bus detection.  Set to 4 to force 64 bit.</span>
<span class="cm">	Add 2 to disable parity detection.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">force32</span><span class="p">;</span>


<span class="cm">/* Used to pass the media type, etc.</span>
<span class="cm">   These exist for driver interoperability.</span>
<span class="cm">   No media types are currently defined.</span>
<span class="cm">		- The lower 4 bits are reserved for the media type.</span>
<span class="cm">		- The next three bits may be set to one of the following:</span>
<span class="cm">			0x00000000 : Autodetect PCI bus</span>
<span class="cm">			0x00000010 : Force 32 bit PCI bus</span>
<span class="cm">			0x00000020 : Disable parity detection</span>
<span class="cm">			0x00000040 : Force 64 bit PCI bus</span>
<span class="cm">			Default is autodetect</span>
<span class="cm">		- The next bit can be used to force half-duplex.  This is a bad</span>
<span class="cm">		  idea since no known implementations implement half-duplex, and,</span>
<span class="cm">		  in general, half-duplex for gigabit ethernet is a bad idea.</span>
<span class="cm">			0x00000080 : Force half-duplex</span>
<span class="cm">			Default is full-duplex.</span>
<span class="cm">		- In the original driver, the ninth bit could be used to force</span>
<span class="cm">		  full-duplex.  Maintain that for compatibility</span>
<span class="cm">		   0x00000200 : Force full-duplex</span>
<span class="cm">*/</span>
<span class="cp">#define MAX_UNITS 8				</span><span class="cm">/* More are supported, limit only on options */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">options</span><span class="p">[</span><span class="n">MAX_UNITS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">full_duplex</span><span class="p">[</span><span class="n">MAX_UNITS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="cm">/* The Hamachi chipset supports 3 parameters each for Rx and Tx</span>
<span class="cm"> * interruput management.  Parameters will be loaded as specified into</span>
<span class="cm"> * the TxIntControl and RxIntControl registers.</span>
<span class="cm"> *</span>
<span class="cm"> * The registers are arranged as follows:</span>
<span class="cm"> *     23 - 16   15 -  8   7    -    0</span>
<span class="cm"> *    _________________________________</span>
<span class="cm"> *   | min_pkt | max_gap | max_latency |</span>
<span class="cm"> *    ---------------------------------</span>
<span class="cm"> *   min_pkt      : The minimum number of packets processed between</span>
<span class="cm"> *                  interrupts.</span>
<span class="cm"> *   max_gap      : The maximum inter-packet gap in units of 8.192 us</span>
<span class="cm"> *   max_latency  : The absolute time between interrupts in units of 8.192 us</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rx_params</span><span class="p">[</span><span class="n">MAX_UNITS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tx_params</span><span class="p">[</span><span class="n">MAX_UNITS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>

<span class="cm">/* Operational parameters that are set at compile time. */</span>

<span class="cm">/* Keep the ring sizes a power of two for compile efficiency.</span>
<span class="cm">	The compiler will convert &lt;unsigned&gt;&#39;%&#39;&lt;2^N&gt; into a bit mask.</span>
<span class="cm">   Making the Tx ring too large decreases the effectiveness of channel</span>
<span class="cm">   bonding and packet priority.</span>
<span class="cm">   There are no ill effects from too-large receive rings, except for</span>
<span class="cm">	excessive memory usage */</span>
<span class="cm">/* Empirically it appears that the Tx ring needs to be a little bigger</span>
<span class="cm">   for these Gbit adapters or you get into an overrun condition really</span>
<span class="cm">   easily.  Also, things appear to work a bit better in back-to-back</span>
<span class="cm">   configurations if the Rx ring is 8 times the size of the Tx ring</span>
<span class="cm">*/</span>
<span class="cp">#define TX_RING_SIZE	64</span>
<span class="cp">#define RX_RING_SIZE	512</span>
<span class="cp">#define TX_TOTAL_SIZE	TX_RING_SIZE*sizeof(struct hamachi_desc)</span>
<span class="cp">#define RX_TOTAL_SIZE	RX_RING_SIZE*sizeof(struct hamachi_desc)</span>

<span class="cm">/*</span>
<span class="cm"> * Enable netdev_ioctl.  Added interrupt coalescing parameter adjustment.</span>
<span class="cm"> * 2/19/99 Pete Wyckoff &lt;wyckoff@ca.sandia.gov&gt;</span>
<span class="cm"> */</span>

<span class="cm">/* play with 64-bit addrlen; seems to be a teensy bit slower  --pw */</span>
<span class="cm">/* #define ADDRLEN 64 */</span>

<span class="cm">/*</span>
<span class="cm"> * RX_CHECKSUM turns on card-generated receive checksum generation for</span>
<span class="cm"> *   TCP and UDP packets.  Otherwise the upper layers do the calculation.</span>
<span class="cm"> * 3/10/1999 Pete Wyckoff &lt;wyckoff@ca.sandia.gov&gt;</span>
<span class="cm"> */</span>
<span class="cp">#define RX_CHECKSUM</span>

<span class="cm">/* Operational parameters that usually are not changed. */</span>
<span class="cm">/* Time in jiffies before concluding the transmitter is hung. */</span>
<span class="cp">#define TX_TIMEOUT  (5*HZ)</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;	</span><span class="cm">/* Processor type for cache alignment. */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;asm/cache.h&gt;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="n">__devinitconst</span> <span class="o">=</span>
<span class="n">KERN_INFO</span> <span class="n">DRV_NAME</span> <span class="s">&quot;.c:v&quot;</span> <span class="n">DRV_VERSION</span> <span class="s">&quot; &quot;</span> <span class="n">DRV_RELDATE</span> <span class="s">&quot;  Written by Donald Becker</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;   Some modifications by Eric kasten &lt;kasten@nscl.msu.edu&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;   Further modifications by Keith Underwood &lt;keithu@parl.clemson.edu&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>


<span class="cm">/* IP_MF appears to be only defined in &lt;netinet/ip.h&gt;, however,</span>
<span class="cm">   we need it for hardware checksumming support.  FYI... some of</span>
<span class="cm">   the definitions in &lt;netinet/ip.h&gt; conflict/duplicate those in</span>
<span class="cm">   other linux headers causing many compiler warnings.</span>
<span class="cm">*/</span>
<span class="cp">#ifndef IP_MF</span>
  <span class="cp">#define IP_MF 0x2000   </span><span class="cm">/* IP more frags from &lt;netinet/ip.h&gt; */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/* Define IP_OFFSET to be IPOPT_OFFSET */</span>
<span class="cp">#ifndef IP_OFFSET</span>
  <span class="cp">#ifdef IPOPT_OFFSET</span>
    <span class="cp">#define IP_OFFSET IPOPT_OFFSET</span>
  <span class="cp">#else</span>
    <span class="cp">#define IP_OFFSET 2</span>
  <span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#define RUN_AT(x) (jiffies + (x))</span>

<span class="cp">#ifndef ADDRLEN</span>
<span class="cp">#define ADDRLEN 32</span>
<span class="cp">#endif</span>

<span class="cm">/* Condensed bus+endian portability operations. */</span>
<span class="cp">#if ADDRLEN == 64</span>
<span class="cp">#define cpu_to_leXX(addr)	cpu_to_le64(addr)</span>
<span class="cp">#define leXX_to_cpu(addr)	le64_to_cpu(addr)</span>
<span class="cp">#else</span>
<span class="cp">#define cpu_to_leXX(addr)	cpu_to_le32(addr)</span>
<span class="cp">#define leXX_to_cpu(addr)	le32_to_cpu(addr)</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm">				Theory of Operation</span>

<span class="cm">I. Board Compatibility</span>

<span class="cm">This device driver is designed for the Packet Engines &quot;Hamachi&quot;</span>
<span class="cm">Gigabit Ethernet chip.  The only PCA currently supported is the GNIC-II 64-bit</span>
<span class="cm">66Mhz PCI card.</span>

<span class="cm">II. Board-specific settings</span>

<span class="cm">No jumpers exist on the board.  The chip supports software correction of</span>
<span class="cm">various motherboard wiring errors, however this driver does not support</span>
<span class="cm">that feature.</span>

<span class="cm">III. Driver operation</span>

<span class="cm">IIIa. Ring buffers</span>

<span class="cm">The Hamachi uses a typical descriptor based bus-master architecture.</span>
<span class="cm">The descriptor list is similar to that used by the Digital Tulip.</span>
<span class="cm">This driver uses two statically allocated fixed-size descriptor lists</span>
<span class="cm">formed into rings by a branch from the final descriptor to the beginning of</span>
<span class="cm">the list.  The ring sizes are set at compile time by RX/TX_RING_SIZE.</span>

<span class="cm">This driver uses a zero-copy receive and transmit scheme similar my other</span>
<span class="cm">network drivers.</span>
<span class="cm">The driver allocates full frame size skbuffs for the Rx ring buffers at</span>
<span class="cm">open() time and passes the skb-&gt;data field to the Hamachi as receive data</span>
<span class="cm">buffers.  When an incoming frame is less than RX_COPYBREAK bytes long,</span>
<span class="cm">a fresh skbuff is allocated and the frame is copied to the new skbuff.</span>
<span class="cm">When the incoming frame is larger, the skbuff is passed directly up the</span>
<span class="cm">protocol stack and replaced by a newly allocated skbuff.</span>

<span class="cm">The RX_COPYBREAK value is chosen to trade-off the memory wasted by</span>
<span class="cm">using a full-sized skbuff for small frames vs. the copying costs of larger</span>
<span class="cm">frames.  Gigabit cards are typically used on generously configured machines</span>
<span class="cm">and the underfilled buffers have negligible impact compared to the benefit of</span>
<span class="cm">a single allocation size, so the default value of zero results in never</span>
<span class="cm">copying packets.</span>

<span class="cm">IIIb/c. Transmit/Receive Structure</span>

<span class="cm">The Rx and Tx descriptor structure are straight-forward, with no historical</span>
<span class="cm">baggage that must be explained.  Unlike the awkward DBDMA structure, there</span>
<span class="cm">are no unused fields or option bits that had only one allowable setting.</span>

<span class="cm">Two details should be noted about the descriptors: The chip supports both 32</span>
<span class="cm">bit and 64 bit address structures, and the length field is overwritten on</span>
<span class="cm">the receive descriptors.  The descriptor length is set in the control word</span>
<span class="cm">for each channel. The development driver uses 32 bit addresses only, however</span>
<span class="cm">64 bit addresses may be enabled for 64 bit architectures e.g. the Alpha.</span>

<span class="cm">IIId. Synchronization</span>

<span class="cm">This driver is very similar to my other network drivers.</span>
<span class="cm">The driver runs as two independent, single-threaded flows of control.  One</span>
<span class="cm">is the send-packet routine, which enforces single-threaded use by the</span>
<span class="cm">dev-&gt;tbusy flag.  The other thread is the interrupt handler, which is single</span>
<span class="cm">threaded by the hardware and other software.</span>

<span class="cm">The send packet thread has partial control over the Tx ring and &#39;dev-&gt;tbusy&#39;</span>
<span class="cm">flag.  It sets the tbusy flag whenever it&#39;s queuing a Tx packet. If the next</span>
<span class="cm">queue slot is empty, it clears the tbusy flag when finished otherwise it sets</span>
<span class="cm">the &#39;hmp-&gt;tx_full&#39; flag.</span>

<span class="cm">The interrupt handler has exclusive control over the Rx ring and records stats</span>
<span class="cm">from the Tx ring.  After reaping the stats, it marks the Tx queue entry as</span>
<span class="cm">empty by incrementing the dirty_tx mark. Iff the &#39;hmp-&gt;tx_full&#39; flag is set, it</span>
<span class="cm">clears both the tx_full and tbusy flags.</span>

<span class="cm">IV. Notes</span>

<span class="cm">Thanks to Kim Stearns of Packet Engines for providing a pair of GNIC-II boards.</span>

<span class="cm">IVb. References</span>

<span class="cm">Hamachi Engineering Design Specification, 5/15/97</span>
<span class="cm">(Note: This version was marked &quot;Confidential&quot;.)</span>

<span class="cm">IVc. Errata</span>

<span class="cm">None noted.</span>

<span class="cm">V.  Recent Changes</span>

<span class="cm">01/15/1999 EPK  Enlargement of the TX and RX ring sizes.  This appears</span>
<span class="cm">    to help avoid some stall conditions -- this needs further research.</span>

<span class="cm">01/15/1999 EPK  Creation of the hamachi_tx function.  This function cleans</span>
<span class="cm">    the Tx ring and is called from hamachi_start_xmit (this used to be</span>
<span class="cm">    called from hamachi_interrupt but it tends to delay execution of the</span>
<span class="cm">    interrupt handler and thus reduce bandwidth by reducing the latency</span>
<span class="cm">    between hamachi_rx()&#39;s).  Notably, some modification has been made so</span>
<span class="cm">    that the cleaning loop checks only to make sure that the DescOwn bit</span>
<span class="cm">    isn&#39;t set in the status flag since the card is not required</span>
<span class="cm">    to set the entire flag to zero after processing.</span>

<span class="cm">01/15/1999 EPK In the hamachi_start_tx function, the Tx ring full flag is</span>
<span class="cm">    checked before attempting to add a buffer to the ring.  If the ring is full</span>
<span class="cm">    an attempt is made to free any dirty buffers and thus find space for</span>
<span class="cm">    the new buffer or the function returns non-zero which should case the</span>
<span class="cm">    scheduler to reschedule the buffer later.</span>

<span class="cm">01/15/1999 EPK Some adjustments were made to the chip initialization.</span>
<span class="cm">    End-to-end flow control should now be fully active and the interrupt</span>
<span class="cm">    algorithm vars have been changed.  These could probably use further tuning.</span>

<span class="cm">01/15/1999 EPK Added the max_{rx,tx}_latency options.  These are used to</span>
<span class="cm">    set the rx and tx latencies for the Hamachi interrupts. If you&#39;re having</span>
<span class="cm">    problems with network stalls, try setting these to higher values.</span>
<span class="cm">    Valid values are 0x00 through 0xff.</span>

<span class="cm">01/15/1999 EPK In general, the overall bandwidth has increased and</span>
<span class="cm">    latencies are better (sometimes by a factor of 2).  Stalls are rare at</span>
<span class="cm">    this point, however there still appears to be a bug somewhere between the</span>
<span class="cm">    hardware and driver.  TCP checksum errors under load also appear to be</span>
<span class="cm">    eliminated at this point.</span>

<span class="cm">01/18/1999 EPK Ensured that the DescEndRing bit was being set on both the</span>
<span class="cm">    Rx and Tx rings.  This appears to have been affecting whether a particular</span>
<span class="cm">    peer-to-peer connection would hang under high load.  I believe the Rx</span>
<span class="cm">    rings was typically getting set correctly, but the Tx ring wasn&#39;t getting</span>
<span class="cm">    the DescEndRing bit set during initialization. ??? Does this mean the</span>
<span class="cm">    hamachi card is using the DescEndRing in processing even if a particular</span>
<span class="cm">    slot isn&#39;t in use -- hypothetically, the card might be searching the</span>
<span class="cm">    entire Tx ring for slots with the DescOwn bit set and then processing</span>
<span class="cm">    them.  If the DescEndRing bit isn&#39;t set, then it might just wander off</span>
<span class="cm">    through memory until it hits a chunk of data with that bit set</span>
<span class="cm">    and then looping back.</span>

<span class="cm">02/09/1999 EPK Added Michel Mueller&#39;s TxDMA Interrupt and Tx-timeout</span>
<span class="cm">    problem (TxCmd and RxCmd need only to be set when idle or stopped.</span>

<span class="cm">02/09/1999 EPK Added code to check/reset dev-&gt;tbusy in hamachi_interrupt.</span>
<span class="cm">    (Michel Mueller pointed out the ``permanently busy&#39;&#39; potential</span>
<span class="cm">    problem here).</span>

<span class="cm">02/22/1999 EPK Added Pete Wyckoff&#39;s ioctl to control the Tx/Rx latencies.</span>

<span class="cm">02/23/1999 EPK Verified that the interrupt status field bits for Tx were</span>
<span class="cm">    incorrectly defined and corrected (as per Michel Mueller).</span>

<span class="cm">02/23/1999 EPK Corrected the Tx full check to check that at least 4 slots</span>
<span class="cm">    were available before reseting the tbusy and tx_full flags</span>
<span class="cm">    (as per Michel Mueller).</span>

<span class="cm">03/11/1999 EPK Added Pete Wyckoff&#39;s hardware checksumming support.</span>

<span class="cm">12/31/1999 KDU Cleaned up assorted things and added Don&#39;s code to force</span>
<span class="cm">32 bit.</span>

<span class="cm">02/20/2000 KDU Some of the control was just plain odd.  Cleaned up the</span>
<span class="cm">hamachi_start_xmit() and hamachi_interrupt() code.  There is still some</span>
<span class="cm">re-structuring I would like to do.</span>

<span class="cm">03/01/2000 KDU Experimenting with a WIDE range of interrupt mitigation</span>
<span class="cm">parameters on a dual P3-450 setup yielded the new default interrupt</span>
<span class="cm">mitigation parameters.  Tx should interrupt VERY infrequently due to</span>
<span class="cm">Eric&#39;s scheme.  Rx should be more often...</span>

<span class="cm">03/13/2000 KDU Added a patch to make the Rx Checksum code interact</span>
<span class="cm">nicely with non-linux machines.</span>

<span class="cm">03/13/2000 KDU Experimented with some of the configuration values:</span>

<span class="cm">	-It seems that enabling PCI performance commands for descriptors</span>
<span class="cm">	(changing RxDMACtrl and TxDMACtrl lower nibble from 5 to D) has minimal</span>
<span class="cm">	performance impact for any of my tests. (ttcp, netpipe, netperf)  I will</span>
<span class="cm">	leave them that way until I hear further feedback.</span>

<span class="cm">	-Increasing the PCI_LATENCY_TIMER to 130</span>
<span class="cm">	(2 + (burst size of 128 * (0 wait states + 1))) seems to slightly</span>
<span class="cm">	degrade performance.  Leaving default at 64 pending further information.</span>

<span class="cm">03/14/2000 KDU Further tuning:</span>

<span class="cm">	-adjusted boguscnt in hamachi_rx() to depend on interrupt</span>
<span class="cm">	mitigation parameters chosen.</span>

<span class="cm">	-Selected a set of interrupt parameters based on some extensive testing.</span>
<span class="cm">	These may change with more testing.</span>

<span class="cm">TO DO:</span>

<span class="cm">-Consider borrowing from the acenic driver code to check PCI_COMMAND for</span>
<span class="cm">PCI_COMMAND_INVALIDATE.  Set maximum burst size to cache line size in</span>
<span class="cm">that case.</span>

<span class="cm">-fix the reset procedure.  It doesn&#39;t quite work.</span>
<span class="cm">*/</span>

<span class="cm">/* A few values that may be tweaked. */</span>
<span class="cm">/* Size of each temporary Rx buffer, calculated as:</span>
<span class="cm"> * 1518 bytes (ethernet packet) + 2 bytes (to get 8 byte alignment for</span>
<span class="cm"> * the card) + 8 bytes of status info + 8 bytes for the Rx Checksum</span>
<span class="cm"> */</span>
<span class="cp">#define PKT_BUF_SZ		1536</span>

<span class="cm">/* For now, this is going to be set to the maximum size of an ethernet</span>
<span class="cm"> * packet.  Eventually, we may want to make it a variable that is</span>
<span class="cm"> * related to the MTU</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_FRAME_SIZE  1518</span>

<span class="cm">/* The rest of these values should never change. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hamachi_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">capability_flags</span> <span class="p">{</span><span class="n">CanHaveMII</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">chip_info</span> <span class="p">{</span>
	<span class="n">u16</span>	<span class="n">vendor_id</span><span class="p">,</span> <span class="n">device_id</span><span class="p">,</span> <span class="n">device_id_mask</span><span class="p">,</span> <span class="n">pad</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">media_timer</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">chip_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="mh">0x1318</span><span class="p">,</span> <span class="mh">0x0911</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Hamachi GNIC-II&quot;</span><span class="p">,</span> <span class="n">hamachi_timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,},</span>
<span class="p">};</span>

<span class="cm">/* Offsets to the Hamachi registers.  Various sizes. */</span>
<span class="k">enum</span> <span class="n">hamachi_offsets</span> <span class="p">{</span>
	<span class="n">TxDMACtrl</span><span class="o">=</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">TxCmd</span><span class="o">=</span><span class="mh">0x04</span><span class="p">,</span> <span class="n">TxStatus</span><span class="o">=</span><span class="mh">0x06</span><span class="p">,</span> <span class="n">TxPtr</span><span class="o">=</span><span class="mh">0x08</span><span class="p">,</span> <span class="n">TxCurPtr</span><span class="o">=</span><span class="mh">0x10</span><span class="p">,</span>
	<span class="n">RxDMACtrl</span><span class="o">=</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">RxCmd</span><span class="o">=</span><span class="mh">0x24</span><span class="p">,</span> <span class="n">RxStatus</span><span class="o">=</span><span class="mh">0x26</span><span class="p">,</span> <span class="n">RxPtr</span><span class="o">=</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">RxCurPtr</span><span class="o">=</span><span class="mh">0x30</span><span class="p">,</span>
	<span class="n">PCIClkMeas</span><span class="o">=</span><span class="mh">0x060</span><span class="p">,</span> <span class="n">MiscStatus</span><span class="o">=</span><span class="mh">0x066</span><span class="p">,</span> <span class="n">ChipRev</span><span class="o">=</span><span class="mh">0x68</span><span class="p">,</span> <span class="n">ChipReset</span><span class="o">=</span><span class="mh">0x06B</span><span class="p">,</span>
	<span class="n">LEDCtrl</span><span class="o">=</span><span class="mh">0x06C</span><span class="p">,</span> <span class="n">VirtualJumpers</span><span class="o">=</span><span class="mh">0x06D</span><span class="p">,</span> <span class="n">GPIO</span><span class="o">=</span><span class="mh">0x6E</span><span class="p">,</span>
	<span class="n">TxChecksum</span><span class="o">=</span><span class="mh">0x074</span><span class="p">,</span> <span class="n">RxChecksum</span><span class="o">=</span><span class="mh">0x076</span><span class="p">,</span>
	<span class="n">TxIntrCtrl</span><span class="o">=</span><span class="mh">0x078</span><span class="p">,</span> <span class="n">RxIntrCtrl</span><span class="o">=</span><span class="mh">0x07C</span><span class="p">,</span>
	<span class="n">InterruptEnable</span><span class="o">=</span><span class="mh">0x080</span><span class="p">,</span> <span class="n">InterruptClear</span><span class="o">=</span><span class="mh">0x084</span><span class="p">,</span> <span class="n">IntrStatus</span><span class="o">=</span><span class="mh">0x088</span><span class="p">,</span>
	<span class="n">EventStatus</span><span class="o">=</span><span class="mh">0x08C</span><span class="p">,</span>
	<span class="n">MACCnfg</span><span class="o">=</span><span class="mh">0x0A0</span><span class="p">,</span> <span class="n">FrameGap0</span><span class="o">=</span><span class="mh">0x0A2</span><span class="p">,</span> <span class="n">FrameGap1</span><span class="o">=</span><span class="mh">0x0A4</span><span class="p">,</span>
	<span class="cm">/* See enum MII_offsets below. */</span>
	<span class="n">MACCnfg2</span><span class="o">=</span><span class="mh">0x0B0</span><span class="p">,</span> <span class="n">RxDepth</span><span class="o">=</span><span class="mh">0x0B8</span><span class="p">,</span> <span class="n">FlowCtrl</span><span class="o">=</span><span class="mh">0x0BC</span><span class="p">,</span> <span class="n">MaxFrameSize</span><span class="o">=</span><span class="mh">0x0CE</span><span class="p">,</span>
	<span class="n">AddrMode</span><span class="o">=</span><span class="mh">0x0D0</span><span class="p">,</span> <span class="n">StationAddr</span><span class="o">=</span><span class="mh">0x0D2</span><span class="p">,</span>
	<span class="cm">/* Gigabit AutoNegotiation. */</span>
	<span class="n">ANCtrl</span><span class="o">=</span><span class="mh">0x0E0</span><span class="p">,</span> <span class="n">ANStatus</span><span class="o">=</span><span class="mh">0x0E2</span><span class="p">,</span> <span class="n">ANXchngCtrl</span><span class="o">=</span><span class="mh">0x0E4</span><span class="p">,</span> <span class="n">ANAdvertise</span><span class="o">=</span><span class="mh">0x0E8</span><span class="p">,</span>
	<span class="n">ANLinkPartnerAbility</span><span class="o">=</span><span class="mh">0x0EA</span><span class="p">,</span>
	<span class="n">EECmdStatus</span><span class="o">=</span><span class="mh">0x0F0</span><span class="p">,</span> <span class="n">EEData</span><span class="o">=</span><span class="mh">0x0F1</span><span class="p">,</span> <span class="n">EEAddr</span><span class="o">=</span><span class="mh">0x0F2</span><span class="p">,</span>
	<span class="n">FIFOcfg</span><span class="o">=</span><span class="mh">0x0F8</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Offsets to the MII-mode registers. */</span>
<span class="k">enum</span> <span class="n">MII_offsets</span> <span class="p">{</span>
	<span class="n">MII_Cmd</span><span class="o">=</span><span class="mh">0xA6</span><span class="p">,</span> <span class="n">MII_Addr</span><span class="o">=</span><span class="mh">0xA8</span><span class="p">,</span> <span class="n">MII_Wr_Data</span><span class="o">=</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">MII_Rd_Data</span><span class="o">=</span><span class="mh">0xAC</span><span class="p">,</span>
	<span class="n">MII_Status</span><span class="o">=</span><span class="mh">0xAE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Bits in the interrupt status/mask registers. */</span>
<span class="k">enum</span> <span class="n">intr_status_bits</span> <span class="p">{</span>
	<span class="n">IntrRxDone</span><span class="o">=</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">IntrRxPCIFault</span><span class="o">=</span><span class="mh">0x02</span><span class="p">,</span> <span class="n">IntrRxPCIErr</span><span class="o">=</span><span class="mh">0x04</span><span class="p">,</span>
	<span class="n">IntrTxDone</span><span class="o">=</span><span class="mh">0x100</span><span class="p">,</span> <span class="n">IntrTxPCIFault</span><span class="o">=</span><span class="mh">0x200</span><span class="p">,</span> <span class="n">IntrTxPCIErr</span><span class="o">=</span><span class="mh">0x400</span><span class="p">,</span>
	<span class="n">LinkChange</span><span class="o">=</span><span class="mh">0x10000</span><span class="p">,</span> <span class="n">NegotiationChange</span><span class="o">=</span><span class="mh">0x20000</span><span class="p">,</span> <span class="n">StatsMax</span><span class="o">=</span><span class="mh">0x40000</span><span class="p">,</span> <span class="p">};</span>

<span class="cm">/* The Hamachi Rx and Tx buffer descriptors. */</span>
<span class="k">struct</span> <span class="n">hamachi_desc</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">status_n_length</span><span class="p">;</span>
<span class="cp">#if ADDRLEN == 64</span>
	<span class="n">u32</span> <span class="n">pad</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">addr</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">__le32</span> <span class="n">addr</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Bits in hamachi_desc.status_n_length */</span>
<span class="k">enum</span> <span class="n">desc_status_bits</span> <span class="p">{</span>
	<span class="n">DescOwn</span><span class="o">=</span><span class="mh">0x80000000</span><span class="p">,</span> <span class="n">DescEndPacket</span><span class="o">=</span><span class="mh">0x40000000</span><span class="p">,</span> <span class="n">DescEndRing</span><span class="o">=</span><span class="mh">0x20000000</span><span class="p">,</span>
	<span class="n">DescIntr</span><span class="o">=</span><span class="mh">0x10000000</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define PRIV_ALIGN	15  			</span><span class="cm">/* Required alignment mask */</span><span class="cp"></span>
<span class="cp">#define MII_CNT		4</span>
<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="p">{</span>
	<span class="cm">/* Descriptor rings first for alignment.  Tx requires a second descriptor</span>
<span class="cm">	   for status. */</span>
	<span class="k">struct</span> <span class="n">hamachi_desc</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hamachi_desc</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">rx_skbuff</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">tx_skbuff</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_ring_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rx_ring_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>		<span class="cm">/* Media selection timer. */</span>
	<span class="cm">/* Frequently used and paired value: keep adjacent for cache effect. */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_rx</span><span class="p">,</span> <span class="n">dirty_rx</span><span class="p">;</span>		<span class="cm">/* Producer/consumer ring indices */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_tx</span><span class="p">,</span> <span class="n">dirty_tx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_buf_sz</span><span class="p">;</span>			<span class="cm">/* Based on MTU+slack. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_full</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>			<span class="cm">/* The Tx queue is full. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">duplex_lock</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">default_port</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>		<span class="cm">/* Last dev-&gt;if_port value. */</span>
	<span class="cm">/* MII transceiver section. */</span>
	<span class="kt">int</span> <span class="n">mii_cnt</span><span class="p">;</span>								<span class="cm">/* MII device addresses. */</span>
	<span class="k">struct</span> <span class="n">mii_if_info</span> <span class="n">mii_if</span><span class="p">;</span>		<span class="cm">/* MII lib hooks/info */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">phys</span><span class="p">[</span><span class="n">MII_CNT</span><span class="p">];</span>		<span class="cm">/* MII device addresses, only first one used. */</span>
	<span class="n">u32</span> <span class="n">rx_int_var</span><span class="p">,</span> <span class="n">tx_int_var</span><span class="p">;</span>	<span class="cm">/* interrupt control variables */</span>
	<span class="n">u32</span> <span class="n">option</span><span class="p">;</span>							<span class="cm">/* Hold on to a copy of the options */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Donald Becker &lt;becker@scyld.com&gt;, Eric Kasten &lt;kasten@nscl.msu.edu&gt;, Keith Underwood &lt;keithu@parl.clemson.edu&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Packet Engines &#39;Hamachi&#39; GNIC-II Gigabit Ethernet driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">max_interrupt_work</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">mtu</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">min_rx_pkt</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_rx_gap</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_rx_latency</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">min_tx_pkt</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_tx_gap</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_tx_latency</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">rx_copybreak</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">rx_params</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">tx_params</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">full_duplex</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">force32</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_interrupt_work</span><span class="p">,</span> <span class="s">&quot;GNIC-II maximum events handled per interrupt&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">mtu</span><span class="p">,</span> <span class="s">&quot;GNIC-II MTU (all boards)&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;GNIC-II debug level (0-7)&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">min_rx_pkt</span><span class="p">,</span> <span class="s">&quot;GNIC-II minimum Rx packets processed between interrupts&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_rx_gap</span><span class="p">,</span> <span class="s">&quot;GNIC-II maximum Rx inter-packet gap in 8.192 microsecond units&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_rx_latency</span><span class="p">,</span> <span class="s">&quot;GNIC-II time between Rx interrupts in 8.192 microsecond units&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">min_tx_pkt</span><span class="p">,</span> <span class="s">&quot;GNIC-II minimum Tx packets processed between interrupts&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_tx_gap</span><span class="p">,</span> <span class="s">&quot;GNIC-II maximum Tx inter-packet gap in 8.192 microsecond units&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_tx_latency</span><span class="p">,</span> <span class="s">&quot;GNIC-II time between Tx interrupts in 8.192 microsecond units&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">rx_copybreak</span><span class="p">,</span> <span class="s">&quot;GNIC-II copy breakpoint for copy-only-tiny-frames&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">rx_params</span><span class="p">,</span> <span class="s">&quot;GNIC-II min_rx_pkt+max_rx_gap+max_rx_latency&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">tx_params</span><span class="p">,</span> <span class="s">&quot;GNIC-II min_tx_pkt+max_tx_gap+max_tx_latency&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="s">&quot;GNIC-II Bits 0-3: media type, bits 4-6: as force32, bit 7: half duplex, bit 9 full duplex&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">full_duplex</span><span class="p">,</span> <span class="s">&quot;GNIC-II full duplex setting(s) (1)&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">force32</span><span class="p">,</span> <span class="s">&quot;GNIC-II: Bit 0: 32 bit PCI, bit 1: disable parity, bit 2: 64 bit PCI (all boards)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">read_eeprom</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hamachi_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">netdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hamachi_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hamachi_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hamachi_init_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">hamachi_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">hamachi_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hamachi_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">hamachi_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hamachi_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">intr_status</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hamachi_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">hamachi_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">ethtool_ops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">ethtool_ops_no_mii</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">hamachi_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">hamachi_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">hamachi_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">hamachi_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">hamachi_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">eth_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> 	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">hamachi_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">netdev_ioctl</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hamachi_init_one</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">option</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rx_int_var</span><span class="p">,</span> <span class="n">tx_int_var</span><span class="p">,</span> <span class="n">boguscnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip_id</span> <span class="o">=</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">card_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ring_space</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">ring_dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="cm">/* when built into the kernel, we only print version if device is found */</span>
<span class="cp">#ifndef MODULE</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">printed_version</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printed_version</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef __alpha__				</span><span class="cm">/* Really &quot;64 bit addrs&quot; */</span><span class="cp"></span>
	<span class="n">base</span> <span class="o">|=</span> <span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mh">0x400</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioaddr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_release</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hamachi_private</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_iounmap</span><span class="p">;</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">read_eeprom</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
			<span class="o">:</span> <span class="n">readb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StationAddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

<span class="cp">#if ! defined(final_version)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%2.2x%s&quot;</span><span class="p">,</span>
				   <span class="n">read_eeprom</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">16</span> <span class="o">!=</span> <span class="mi">15</span> <span class="o">?</span> <span class="s">&quot; &quot;</span> <span class="o">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">mdio_read</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">mdio_write</span> <span class="o">=</span> <span class="n">mdio_write</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">reg_num_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>

	<span class="n">ring_space</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">TX_TOTAL_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_space</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_cleardev</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">ring_space</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span> <span class="o">=</span> <span class="n">ring_dma</span><span class="p">;</span>

	<span class="n">ring_space</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">RX_TOTAL_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_space</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_unmap_tx</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">ring_space</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span> <span class="o">=</span> <span class="n">ring_dma</span><span class="p">;</span>

	<span class="cm">/* Check for options being passed in */</span>
	<span class="n">option</span> <span class="o">=</span> <span class="n">card_idx</span> <span class="o">&lt;</span> <span class="n">MAX_UNITS</span> <span class="o">?</span> <span class="n">options</span><span class="p">[</span><span class="n">card_idx</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">)</span>
		<span class="n">option</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">;</span>

	<span class="cm">/* If the bus size is misidentified, do the following. */</span>
	<span class="n">force32</span> <span class="o">=</span> <span class="n">force32</span> <span class="o">?</span> <span class="n">force32</span> <span class="o">:</span>
		<span class="p">((</span><span class="n">option</span>  <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="p">((</span><span class="n">option</span> <span class="o">&amp;</span> <span class="mh">0x00000070</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force32</span><span class="p">)</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">force32</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VirtualJumpers</span><span class="p">);</span>

	<span class="cm">/* Hmmm, do we really need to reset the chip???. */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipReset</span><span class="p">);</span>

	<span class="cm">/* After a reset, the clock speed measurement of the PCI bus will not</span>
<span class="cm">	 * be valid for a moment.  Wait for a little while until it is.  If</span>
<span class="cm">	 * it takes more than 10ms, forget it.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PCIClkMeas</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">boguscnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x080</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">boguscnt</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">boguscnt</span><span class="o">++</span><span class="p">){</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PCIClkMeas</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">chip_id</span> <span class="o">=</span> <span class="n">chip_id</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* The lower four bits are the media type. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">option</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">option</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">option</span> <span class="o">&amp;</span> <span class="mh">0x200</span><span class="p">)</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">full_duplex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">option</span> <span class="o">&amp;</span> <span class="mh">0x080</span><span class="p">)</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">full_duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">default_port</span> <span class="o">=</span> <span class="n">option</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">default_port</span><span class="p">)</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">force_media</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">card_idx</span> <span class="o">&lt;</span> <span class="n">MAX_UNITS</span>  <span class="o">&amp;&amp;</span>  <span class="n">full_duplex</span><span class="p">[</span><span class="n">card_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">full_duplex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* lock the duplex mode if someone specified a value */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">full_duplex</span> <span class="o">||</span> <span class="p">(</span><span class="n">option</span> <span class="o">&amp;</span> <span class="mh">0x080</span><span class="p">))</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">duplex_lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Set interrupt tuning parameters */</span>
	<span class="n">max_rx_latency</span> <span class="o">=</span> <span class="n">max_rx_latency</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">;</span>
	<span class="n">max_rx_gap</span> <span class="o">=</span> <span class="n">max_rx_gap</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">;</span>
	<span class="n">min_rx_pkt</span> <span class="o">=</span> <span class="n">min_rx_pkt</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">;</span>
	<span class="n">max_tx_latency</span> <span class="o">=</span> <span class="n">max_tx_latency</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">;</span>
	<span class="n">max_tx_gap</span> <span class="o">=</span> <span class="n">max_tx_gap</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">;</span>
	<span class="n">min_tx_pkt</span> <span class="o">=</span> <span class="n">min_tx_pkt</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">;</span>

	<span class="n">rx_int_var</span> <span class="o">=</span> <span class="n">card_idx</span> <span class="o">&lt;</span> <span class="n">MAX_UNITS</span> <span class="o">?</span> <span class="n">rx_params</span><span class="p">[</span><span class="n">card_idx</span><span class="p">]</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">tx_int_var</span> <span class="o">=</span> <span class="n">card_idx</span> <span class="o">&lt;</span> <span class="n">MAX_UNITS</span> <span class="o">?</span> <span class="n">tx_params</span><span class="p">[</span><span class="n">card_idx</span><span class="p">]</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_int_var</span> <span class="o">=</span> <span class="n">rx_int_var</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">rx_int_var</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">min_rx_pkt</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">max_rx_gap</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">max_rx_latency</span><span class="p">);</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_int_var</span> <span class="o">=</span> <span class="n">tx_int_var</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">tx_int_var</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">min_tx_pkt</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">max_tx_gap</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">max_tx_latency</span><span class="p">);</span>


	<span class="cm">/* The Hamachi-specific entries in the device structure. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hamachi_netdev_ops</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip_tbl</span><span class="p">[</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">chip_id</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CanHaveMII</span><span class="p">)</span>
		<span class="n">SET_ETHTOOL_OPS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ethtool_ops</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">SET_ETHTOOL_OPS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ethtool_ops_no_mii</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">TX_TIMEOUT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtu</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">mtu</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_unmap_rx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: %s type %x at %p, %pM, IRQ %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">chip_tbl</span><span class="p">[</span><span class="n">chip_id</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipRev</span><span class="p">),</span>
		   <span class="n">ioaddr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">PCIClkMeas</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s:  %d-bit %d Mhz PCI bus (%d), Virtual Jumpers &quot;</span>
		   <span class="s">&quot;%2.2x, LPA %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MiscStatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">64</span> <span class="o">:</span> <span class="mi">32</span><span class="p">,</span>
		   <span class="n">i</span> <span class="o">?</span> <span class="mi">2000</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x7f</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">&amp;</span><span class="mh">0x7f</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">readb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VirtualJumpers</span><span class="p">),</span>
		   <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ANLinkPartnerAbility</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip_tbl</span><span class="p">[</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">chip_id</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CanHaveMII</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="n">phy_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">phy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">phy</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="n">phy_idx</span> <span class="o">&lt;</span> <span class="n">MII_CNT</span><span class="p">;</span> <span class="n">phy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">mii_status</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">phy</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mii_status</span> <span class="o">!=</span> <span class="mh">0xffff</span>  <span class="o">&amp;&amp;</span>
				<span class="n">mii_status</span> <span class="o">!=</span> <span class="mh">0x0000</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">phy_idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">phy</span><span class="p">;</span>
				<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">advertising</span> <span class="o">=</span> <span class="n">mdio_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">phy</span><span class="p">,</span> <span class="n">MII_ADVERTISE</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: MII PHY found at address %d, status &quot;</span>
					   <span class="s">&quot;0x%4.4x advertising %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">phy</span><span class="p">,</span> <span class="n">mii_status</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">advertising</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_cnt</span> <span class="o">=</span> <span class="n">phy_idx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/* Configure gigabit autonegotiation. */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0400</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ANXchngCtrl</span><span class="p">);</span>	<span class="cm">/* Enable legacy links. */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x08e0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ANAdvertise</span><span class="p">);</span>	<span class="cm">/* Set our advertise word. */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ANCtrl</span><span class="p">);</span>			<span class="cm">/* Enable negotiation */</span>

	<span class="n">card_idx</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_unmap_rx:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">RX_TOTAL_SIZE</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">,</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">);</span>
<span class="nl">err_out_unmap_tx:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">TX_TOTAL_SIZE</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">,</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">);</span>
<span class="nl">err_out_cleardev:</span>
	<span class="n">free_netdev</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">err_out_iounmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">);</span>
<span class="nl">err_out_release:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">read_eeprom</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bogus_cnt</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="cm">/* We should check busy first - per docs -KDU */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">readb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EECmdStatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span>  <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">bogus_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EEAddr</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0x02</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EECmdStatus</span><span class="p">);</span>
	<span class="n">bogus_cnt</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">readb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EECmdStatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span>  <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">bogus_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;   EEPROM status is %2.2x after %d ticks.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">readb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EECmdStatus</span><span class="p">),</span> <span class="mi">1000</span><span class="o">-</span> <span class="n">bogus_cnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EEData</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* MII Managemen Data I/O accesses.</span>
<span class="cm">   These routines assume the MDIO controller is idle, and do not exit until</span>
<span class="cm">   the command is finished. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* We should check busy first - per docs -KDU */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MII_Status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">((</span><span class="n">phy_id</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">location</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MII_Addr</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MII_Cmd</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MII_Status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MII_Rd_Data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* We should check busy first - per docs -KDU */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MII_Status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">((</span><span class="n">phy_id</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">location</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MII_Addr</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MII_Wr_Data</span><span class="p">);</span>

	<span class="cm">/* Wait for the command to finish. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MII_Status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">hamachi_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_int_var</span><span class="p">,</span> <span class="n">tx_int_var</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fifo_info</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">hamachi_interrupt</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">hamachi_init_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#if ADDRLEN == 64</span>
	<span class="cm">/* writellll anyone ? */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxPtr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxPtr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxPtr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxPtr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxPtr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxPtr</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* TODO:  It would make sense to organize this as words since the card</span>
<span class="cm">	 * documentation does. -KDU</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">StationAddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/* Initialize other registers: with so many this eventually this will</span>
<span class="cm">	   converted to an offset/value list. */</span>

	<span class="cm">/* Configure the FIFO */</span>
	<span class="n">fifo_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">GPIO</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00C0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fifo_info</span><span class="p">){</span>
		<span class="k">case</span> <span class="mi">0</span> :
			<span class="cm">/* No FIFO */</span>
			<span class="n">writew</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">FIFOcfg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span> :
			<span class="cm">/* Configure the FIFO for 512K external, 16K used for Tx. */</span>
			<span class="n">writew</span><span class="p">(</span><span class="mh">0x0028</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">FIFOcfg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span> :
			<span class="cm">/* Configure the FIFO for 1024 external, 32K used for Tx. */</span>
			<span class="n">writew</span><span class="p">(</span><span class="mh">0x004C</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">FIFOcfg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span> :
			<span class="cm">/* Configure the FIFO for 2048 external, 32K used for Tx. */</span>
			<span class="n">writew</span><span class="p">(</span><span class="mh">0x006C</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">FIFOcfg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">default</span> <span class="o">:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s:  Unsupported external memory config!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="cm">/* Default to no FIFO */</span>
			<span class="n">writew</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">FIFOcfg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">default_port</span><span class="p">;</span>


	<span class="cm">/* Setting the Rx mode will start the Rx process. */</span>
	<span class="cm">/* If someone didn&#39;t choose a duplex, default to full-duplex */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">duplex_lock</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">.</span><span class="n">full_duplex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* always 1, takes no more time to do it */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxChecksum</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxChecksum</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MACCnfg</span><span class="p">);</span> <span class="cm">/* Soft reset the MAC */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x215F</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MACCnfg</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x000C</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">FrameGap0</span><span class="p">);</span>
	<span class="cm">/* WHAT?!?!?  Why isn&#39;t this documented somewhere? -KDU */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x1018</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">FrameGap1</span><span class="p">);</span>
	<span class="cm">/* Why do we enable receives/transmits here? -KDU */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0780</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MACCnfg2</span><span class="p">);</span> <span class="cm">/* Upper 16 bits control LEDs. */</span>
	<span class="cm">/* Enable automatic generation of flow control frames, period 0xffff. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0030FFFF</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">FlowCtrl</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">MAX_FRAME_SIZE</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">MaxFrameSize</span><span class="p">);</span> 	<span class="cm">/* dev-&gt;mtu+14 ??? */</span>

	<span class="cm">/* Enable legacy links. */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0400</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ANXchngCtrl</span><span class="p">);</span>	<span class="cm">/* Enable legacy links. */</span>
	<span class="cm">/* Initial Link LED to blinking red. */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0x03</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">LEDCtrl</span><span class="p">);</span>

	<span class="cm">/* Configure interrupt mitigation.  This has a great effect on</span>
<span class="cm">	   performance, so systems tuning should start here!. */</span>

	<span class="n">rx_int_var</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_int_var</span><span class="p">;</span>
	<span class="n">tx_int_var</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_int_var</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;max_tx_latency: %d, max_tx_gap: %d, min_tx_pkt: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tx_int_var</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">,</span> <span class="p">(</span><span class="n">tx_int_var</span> <span class="o">&amp;</span> <span class="mh">0x00ff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tx_int_var</span> <span class="o">&amp;</span> <span class="mh">0x00ff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;max_rx_latency: %d, max_rx_gap: %d, min_rx_pkt: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rx_int_var</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">,</span> <span class="p">(</span><span class="n">rx_int_var</span> <span class="o">&amp;</span> <span class="mh">0x00ff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
			<span class="p">(</span><span class="n">rx_int_var</span> <span class="o">&amp;</span> <span class="mh">0x00ff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;rx_int_var: %x, tx_int_var: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rx_int_var</span><span class="p">,</span> <span class="n">tx_int_var</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">tx_int_var</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxIntrCtrl</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rx_int_var</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxIntrCtrl</span><span class="p">);</span>

	<span class="n">set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Enable interrupts by setting the interrupt mask. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x80878787</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">InterruptEnable</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EventStatus</span><span class="p">);</span>	<span class="cm">/* Clear non-interrupting events */</span>

	<span class="cm">/* Configure and start the DMA channels. */</span>
	<span class="cm">/* Burst sizes are in the low three bits: size = 4&lt;&lt;(val&amp;7) */</span>
<span class="cp">#if ADDRLEN == 64</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x005D</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxDMACtrl</span><span class="p">);</span> 		<span class="cm">/* 128 dword bursts */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x005D</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxDMACtrl</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x001D</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxDMACtrl</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x001D</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxDMACtrl</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxCmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Done hamachi_open(), status: Rx %x Tx %x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxStatus</span><span class="p">),</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxStatus</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/* Set the timer to check for link beat. */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">RUN_AT</span><span class="p">((</span><span class="mi">24</span><span class="o">*</span><span class="n">HZ</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>			<span class="cm">/* 2.4 sec. */</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">hamachi_timer</span><span class="p">;</span>				<span class="cm">/* timer handler */</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hamachi_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Update the dirty pointer until we find an entry that is</span>
<span class="cm">		still owned by the card */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">%</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Free the original skb. */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="n">leXX_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">addr</span><span class="p">),</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&gt;=</span> <span class="n">TX_RING_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">|=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescEndRing</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hamachi_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_tick</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Hamachi Autonegotiation status %4.4x, LPA &quot;</span>
			   <span class="s">&quot;%4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ANStatus</span><span class="p">),</span>
			   <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ANLinkPartnerAbility</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Autonegotiation regs %4.4x %4.4x %4.4x &quot;</span>
		       <span class="s">&quot;%4.4x %4.4x %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		       <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x0e0</span><span class="p">),</span>
		       <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x0e2</span><span class="p">),</span>
		       <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x0e4</span><span class="p">),</span>
		       <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x0e6</span><span class="p">),</span>
		       <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x0e8</span><span class="p">),</span>
		       <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x0eA</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/* We could do something here... nah. */</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">RUN_AT</span><span class="p">(</span><span class="n">next_tick</span><span class="p">);</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hamachi_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Hamachi transmit timed out, status %8.8x,&quot;</span>
		   <span class="s">&quot; resetting...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxStatus</span><span class="p">));</span>

	<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  Rx ring %p: &quot;</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; %8.8x&quot;</span><span class="p">,</span>
			       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;  Tx ring %p: &quot;</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; %4.4x&quot;</span><span class="p">,</span>
			       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Reinit the hardware and make sure the Rx and Tx processes</span>
<span class="cm">		are up and running.</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* The right way to do Reset. -KDU</span>
<span class="cm">	 *		-Clear OWN bit in all Rx/Tx descriptors</span>
<span class="cm">	 *		-Wait 50 uS for channels to go idle</span>
<span class="cm">	 *		-Turn off MAC receiver</span>
<span class="cm">	 *		-Issue Reset</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">DescOwn</span><span class="p">);</span>

	<span class="cm">/* Presume that all packets in the Tx queue are gone if we have to</span>
<span class="cm">	 * re-init the hardware.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">TX_RING_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescEndRing</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">&amp;</span>
				 <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x0000ffff</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x0000ffff</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">){</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">leXX_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">),</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">60</span><span class="p">);</span> <span class="cm">/* Sleep 60 us just for safety sake */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxCmd</span><span class="p">);</span> <span class="cm">/* STOP Rx */</span>

	<span class="n">writeb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ChipReset</span><span class="p">);</span>  <span class="cm">/* Reinit the hardware */</span>

	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Rx packets are also presumed lost; however, we need to make sure a</span>
<span class="cm">	 * ring of buffers is in tact. -KDU</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">){</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="n">leXX_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">),</span>
				<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Fill in the Rx buffers.  Handle allocation failure gracefully. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">);</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

                <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_leXX</span><span class="p">(</span><span class="n">pci_map_single</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">));</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span> <span class="o">|</span>
			<span class="n">DescEndPacket</span> <span class="o">|</span> <span class="n">DescIntr</span> <span class="o">|</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">i</span> <span class="o">-</span> <span class="n">RX_RING_SIZE</span><span class="p">);</span>
	<span class="cm">/* Mark the last entry as wrapping the ring. */</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescEndRing</span><span class="p">);</span>

	<span class="cm">/* Trigger an immediate transmit demand. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Restart the chip&#39;s Tx/Rx processes . */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxCmd</span><span class="p">);</span> <span class="cm">/* STOP Tx */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxCmd</span><span class="p">);</span> <span class="cm">/* START Tx */</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxCmd</span><span class="p">);</span> <span class="cm">/* START Rx */</span>

	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Initialize the Rx and Tx rings, along with various &#39;dev&#39; bits. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hamachi_init_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* +26 gets the maximum ethernet encapsulation, +7 &amp; ~7 because the</span>
<span class="cm">	 * card needs room to do 8 byte alignment, +2 so we can reserve</span>
<span class="cm">	 * the first 2 bytes, and +16 gets room for the status word from the</span>
<span class="cm">	 * card.  -KDU</span>
<span class="cm">	 */</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&lt;=</span> <span class="mi">1492</span> <span class="o">?</span> <span class="n">PKT_BUF_SZ</span> <span class="o">:</span>
		<span class="p">(((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="o">+</span><span class="mi">26</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">));</span>

	<span class="cm">/* Initialize all Rx descriptors. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Fill in the Rx buffers.  Handle allocation failure gracefully. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="cm">/* 16 byte align the IP header. */</span>
                <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_leXX</span><span class="p">(</span><span class="n">pci_map_single</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">));</span>
		<span class="cm">/* -2 because it doesn&#39;t REALLY have that first 2 bytes -KDU */</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span> <span class="o">|</span>
			<span class="n">DescEndPacket</span> <span class="o">|</span> <span class="n">DescIntr</span> <span class="o">|</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span> <span class="o">-</span><span class="mi">2</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">i</span> <span class="o">-</span> <span class="n">RX_RING_SIZE</span><span class="p">);</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">RX_RING_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescEndRing</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Mark the last entry of the ring */</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescEndRing</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">hamachi_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Ok, now make sure that the queue has space before trying to</span>
<span class="cm">		add another skbuff.  if we return non-zero the scheduler</span>
<span class="cm">		should interpret this as a queue full and requeue the buffer</span>
<span class="cm">		for later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_full</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We should NEVER reach this point -KDU */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Hamachi transmit queue full at slot %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">);</span>

		<span class="cm">/* Wake the potentially-idle transmit channel. */</span>
		<span class="cm">/* If we don&#39;t need to read status, DON&#39;T -KDU */</span>
		<span class="n">status</span><span class="o">=</span><span class="n">readw</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">TxStatus</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x0001</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x0002</span><span class="p">))</span>
			<span class="n">writew</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">TxCmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Caution: the write order is important here, set the field</span>
<span class="cm">	   with the &quot;ownership&quot; bits last. */</span>

	<span class="cm">/* Calculate the next Tx descriptor entry. */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">%</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>

	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

        <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_leXX</span><span class="p">(</span><span class="n">pci_map_single</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">));</span>

	<span class="cm">/* Hmmmm, could probably put a DescIntr on these, but the way</span>
<span class="cm">		the driver is currently coded makes Tx interrupts unnecessary</span>
<span class="cm">		since the clearing of the Tx ring is handled by the start_xmit</span>
<span class="cm">		routine.  This organization helps mitigate the interrupts a</span>
<span class="cm">		bit and probably renders the max_tx_latency param useless.</span>

<span class="cm">		Update: Putting a DescIntr bit on all of the descriptors and</span>
<span class="cm">		mitigating interrupt frequency with the tx_min_pkt parameter. -KDU</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&gt;=</span> <span class="n">TX_RING_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>		 <span class="cm">/* Wrap ring */</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span> <span class="o">|</span>
			<span class="n">DescEndPacket</span> <span class="o">|</span> <span class="n">DescEndRing</span> <span class="o">|</span> <span class="n">DescIntr</span> <span class="o">|</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span> <span class="o">|</span>
			<span class="n">DescEndPacket</span> <span class="o">|</span> <span class="n">DescIntr</span> <span class="o">|</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Non-x86 Todo: explicitly flush cache lines here. */</span>

	<span class="cm">/* Wake the potentially-idle transmit channel. */</span>
	<span class="cm">/* If we don&#39;t need to read status, DON&#39;T -KDU */</span>
	<span class="n">status</span><span class="o">=</span><span class="n">readw</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">TxStatus</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x0001</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x0002</span><span class="p">))</span>
		<span class="n">writew</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">TxCmd</span><span class="p">);</span>

	<span class="cm">/* Immediately before returning, let&#39;s clear as many entries as we can. */</span>
	<span class="n">hamachi_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* We should kick the bottom half here, since we are not accepting</span>
<span class="cm">	 * interrupts with every packet.  i.e. realize that Gigabit ethernet</span>
<span class="cm">	 * can transmit faster than ordinary machines can load packets;</span>
<span class="cm">	 * hence, any packet that got put off because we were in the transmit</span>
<span class="cm">	 * routine should IMMEDIATELY get a chance to be re-queued. -KDU</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">TX_RING_SIZE</span> <span class="o">-</span> <span class="mi">4</span><span class="p">))</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>  <span class="cm">/* Typical path */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Hamachi transmit frame #%d queued in slot %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The interrupt handler does all of the Rx thread work and cleans up</span>
<span class="cm">   after the Tx thread. */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">hamachi_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">boguscnt</span> <span class="o">=</span> <span class="n">max_interrupt_work</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifndef final_version			</span><span class="cm">/* Can never occur. */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hamachi_interrupt(): irq %d for unknown device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">intr_status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">InterruptClear</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Hamachi interrupt, status %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">intr_status</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">IntrRxDone</span><span class="p">)</span>
			<span class="n">hamachi_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">IntrTxDone</span><span class="p">){</span>
			<span class="cm">/* This code should RARELY need to execute. After all, this is</span>
<span class="cm">			 * a gigabit link, it should consume packets as fast as we put</span>
<span class="cm">			 * them in AND we clear the Tx ring in hamachi_start_xmit().</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_full</span><span class="p">){</span>
				<span class="k">for</span> <span class="p">(;</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="o">++</span><span class="p">){</span>
					<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">%</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span><span class="p">))</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="n">skb</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
					<span class="cm">/* Free the original skb. */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">){</span>
						<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
							<span class="n">leXX_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">addr</span><span class="p">),</span>
							<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
							<span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
						<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
						<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&gt;=</span> <span class="n">TX_RING_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
						<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">TX_RING_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">|=</span>
							<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescEndRing</span><span class="p">);</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_tx</span> <span class="o">-</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span> <span class="o">-</span> <span class="mi">4</span><span class="p">){</span>
					<span class="cm">/* The ring is no longer full */</span>
					<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>


		<span class="cm">/* Abnormal error summary/uncommon events handlers. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span>
			<span class="p">(</span><span class="n">IntrTxPCIFault</span> <span class="o">|</span> <span class="n">IntrTxPCIErr</span> <span class="o">|</span> <span class="n">IntrRxPCIFault</span> <span class="o">|</span> <span class="n">IntrRxPCIErr</span> <span class="o">|</span>
			 <span class="n">LinkChange</span> <span class="o">|</span> <span class="n">NegotiationChange</span> <span class="o">|</span> <span class="n">StatsMax</span><span class="p">))</span>
			<span class="n">hamachi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">intr_status</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">boguscnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Too much work at interrupt, status=0x%4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">intr_status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: exiting interrupt, status=%#4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus</span><span class="p">));</span>

<span class="cp">#ifndef final_version</span>
	<span class="cm">/* Code that should never be run!  Perhaps remove after testing.. */</span>
	<span class="p">{</span>
		<span class="k">static</span> <span class="kt">int</span> <span class="n">stopit</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">==</span> <span class="mi">0</span>  <span class="o">&amp;&amp;</span>  <span class="o">--</span><span class="n">stopit</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Emergency stop, looping startup interrupt.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This routine is logically part of the interrupt handler, but separated</span>
<span class="cm">   for clarity and better register allocation. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hamachi_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">boguscnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">+</span> <span class="n">RX_RING_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; In hamachi_rx(), entry %d status %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">entry</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">status_n_length</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If EOP is set on the next entry, it&#39;s a new packet. Send it up. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hamachi_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
		<span class="n">u32</span> <span class="n">desc_status</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">status_n_length</span><span class="p">);</span>
		<span class="n">u16</span> <span class="n">data_size</span> <span class="o">=</span> <span class="n">desc_status</span><span class="p">;</span>	<span class="cm">/* Implicit truncate */</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">buf_addr</span><span class="p">;</span>
		<span class="n">s32</span> <span class="n">frame_status</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="n">DescOwn</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					    <span class="n">leXX_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">),</span>
					    <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span>
					    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">buf_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">frame_status</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">12</span><span class="p">]));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  hamachi_rx() status was %8.8x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">frame_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">boguscnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="p">(</span><span class="n">desc_status</span> <span class="o">&amp;</span> <span class="n">DescEndPacket</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Oversized Ethernet frame spanned &quot;</span>
				   <span class="s">&quot;multiple buffers, entry %#x length %d status %4.4x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span> <span class="n">desc_status</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Oversized Ethernet frame %p vs %p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">]);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Oversized Ethernet frame -- next status %x/%x last status %x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				   <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">].</span><span class="n">status_n_length</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">,</span>
				   <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">].</span><span class="n">status_n_length</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0000ffff</span><span class="p">,</span>
				   <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">].</span><span class="n">status_n_length</span><span class="p">));</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="cm">/* else  Omit for prototype errata??? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frame_status</span> <span class="o">&amp;</span> <span class="mh">0x00380000</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* There was an error. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  hamachi_rx() Rx error was %8.8x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">frame_status</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frame_status</span> <span class="o">&amp;</span> <span class="mh">0x00600000</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frame_status</span> <span class="o">&amp;</span> <span class="mh">0x00080000</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frame_status</span> <span class="o">&amp;</span> <span class="mh">0x00100000</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frame_status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
			<span class="cm">/* Omit CRC */</span>
			<span class="n">u16</span> <span class="n">pkt_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame_status</span> <span class="o">&amp;</span> <span class="mh">0x07ff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
<span class="cp">#ifdef RX_CHECKSUM</span>
			<span class="n">u32</span> <span class="n">pfck</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">8</span><span class="p">];</span>
<span class="cp">#endif</span>


<span class="cp">#ifndef final_version</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  hamachi_rx() normal Rx pkt length %d&quot;</span>
					   <span class="s">&quot; of %d, bogus_cnt %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">pkt_len</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span> <span class="n">boguscnt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;%s:  rx status %8.8x %8.8x %8.8x %8.8x %8.8x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					   <span class="o">*</span><span class="p">(</span><span class="n">s32</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">20</span><span class="p">]),</span>
					   <span class="o">*</span><span class="p">(</span><span class="n">s32</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">16</span><span class="p">]),</span>
					   <span class="o">*</span><span class="p">(</span><span class="n">s32</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">12</span><span class="p">]),</span>
					   <span class="o">*</span><span class="p">(</span><span class="n">s32</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">8</span><span class="p">]),</span>
					   <span class="o">*</span><span class="p">(</span><span class="n">s32</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">4</span><span class="p">]));</span>
<span class="cp">#endif</span>
			<span class="cm">/* Check if the packet is long enough to accept without copying</span>
<span class="cm">			   to a minimally-sized skbuff. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&lt;</span> <span class="n">rx_copybreak</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pkt_len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef RX_CHECKSUM</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: rx_copybreak non-zero &quot;</span>
				  <span class="s">&quot;not good with RX_CHECKSUM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* 16 byte align the IP header */</span>
				<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
							    <span class="n">leXX_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">addr</span><span class="p">),</span>
							    <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span>
							    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
				<span class="cm">/* Call copy + cksum if available. */</span>
<span class="cp">#if 1 || USE_IP_COPYSUM</span>
				<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
					<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>
<span class="cp">#else</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">),</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span>
					<span class="o">+</span> <span class="n">entry</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">),</span> <span class="n">pkt_len</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
							       <span class="n">leXX_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">addr</span><span class="p">),</span>
							       <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span>
							       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
						 <span class="n">leXX_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">addr</span><span class="p">),</span>
						 <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span> <span class="n">pkt_len</span><span class="p">);</span>
				<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>


<span class="cp">#ifdef RX_CHECKSUM</span>
			<span class="cm">/* TCP or UDP on ipv4, DIX encoding */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pfck</span><span class="o">&gt;&gt;</span><span class="mi">24</span> <span class="o">==</span> <span class="mh">0x91</span> <span class="o">||</span> <span class="n">pfck</span><span class="o">&gt;&gt;</span><span class="mi">24</span> <span class="o">==</span> <span class="mh">0x51</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ih</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
				<span class="cm">/* Check that IP packet is at least 46 bytes, otherwise,</span>
<span class="cm">				 * there may be pad bytes included in the hardware checksum.</span>
<span class="cm">				 * This wouldn&#39;t happen if everyone padded with 0.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">tot_len</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">46</span><span class="p">){</span>
					<span class="cm">/* don&#39;t worry about frags */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">frag_off</span> <span class="o">&amp;</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">IP_MF</span><span class="o">|</span><span class="n">IP_OFFSET</span><span class="p">)))</span> <span class="p">{</span>
						<span class="n">u32</span> <span class="n">inv</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">16</span><span class="p">];</span>
						<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">buf_addr</span><span class="p">[</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">20</span><span class="p">];</span>
						<span class="k">register</span> <span class="n">u32</span> <span class="n">crc</span><span class="p">,</span> <span class="n">p_r</span><span class="p">,</span> <span class="n">p_r1</span><span class="p">;</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">inv</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">inv</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">4</span><span class="p">;</span>
							<span class="o">--</span><span class="n">p</span><span class="p">;</span>
						<span class="p">}</span>
						<span class="n">p_r</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
						<span class="n">p_r1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
						<span class="k">switch</span> <span class="p">(</span><span class="n">inv</span><span class="p">)</span> <span class="p">{</span>
							<span class="k">case</span> <span class="mi">0</span>:
								<span class="n">crc</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_r</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">p_r</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
								<span class="k">break</span><span class="p">;</span>
							<span class="k">case</span> <span class="mi">1</span>:
								<span class="n">crc</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_r</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">p_r</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span>
									<span class="o">+</span> <span class="p">(</span><span class="n">p_r1</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">);</span>
								<span class="k">break</span><span class="p">;</span>
							<span class="k">case</span> <span class="mi">2</span>:
								<span class="n">crc</span> <span class="o">=</span> <span class="n">p_r</span> <span class="o">+</span> <span class="p">(</span><span class="n">p_r1</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
								<span class="k">break</span><span class="p">;</span>
							<span class="k">case</span> <span class="mi">3</span>:
								<span class="n">crc</span> <span class="o">=</span> <span class="n">p_r</span> <span class="o">+</span> <span class="p">(</span><span class="n">p_r1</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">p_r1</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
								<span class="k">break</span><span class="p">;</span>
							<span class="nl">default:</span>	<span class="cm">/*NOTREACHED*/</span> <span class="n">crc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="p">}</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">crc</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">crc</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
							<span class="o">++</span><span class="n">crc</span><span class="p">;</span>
						<span class="p">}</span>
						<span class="cm">/* tcp/udp will add in pseudo */</span>
						<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">pfck</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">&gt;</span> <span class="n">crc</span><span class="p">)</span>
							<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">-=</span> <span class="n">crc</span><span class="p">;</span>
						<span class="k">else</span>
							<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">+=</span> <span class="p">(</span><span class="o">~</span><span class="n">crc</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
						<span class="cm">/*</span>
<span class="cm">						* could do the pseudo myself and return</span>
<span class="cm">						* CHECKSUM_UNNECESSARY</span>
<span class="cm">						*/</span>
						<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_COMPLETE</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
<span class="cp">#endif  </span><span class="cm">/* RX_CHECKSUM */</span><span class="cp"></span>

			<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">)</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Refill the Rx ring buffers. */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span> <span class="o">-</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hamachi_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

		<span class="n">entry</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span> <span class="o">%</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">entry</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>		<span class="cm">/* Better luck next round. */</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* Align IP on 16 byte boundaries */</span>
                	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_leXX</span><span class="p">(</span><span class="n">pci_map_single</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status_n_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&gt;=</span> <span class="n">RX_RING_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status_n_length</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span> <span class="o">|</span>
				<span class="n">DescEndPacket</span> <span class="o">|</span> <span class="n">DescEndRing</span> <span class="o">|</span> <span class="n">DescIntr</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status_n_length</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DescOwn</span> <span class="o">|</span>
				<span class="n">DescEndPacket</span> <span class="o">|</span> <span class="n">DescIntr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Restart Rx engine if stopped. */</span>
	<span class="cm">/* If we don&#39;t need to check status, don&#39;t. -KDU */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readw</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">RxStatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0002</span><span class="p">)</span>
		<span class="n">writew</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">RxCmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is more properly named &quot;uncommon interrupt events&quot;, as it covers more</span>
<span class="cm">   than just errors. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hamachi_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">intr_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LinkChange</span><span class="o">|</span><span class="n">NegotiationChange</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Link changed: AutoNegotiation Ctrl&quot;</span>
				   <span class="s">&quot; %4.4x, Status %4.4x %4.4x Intr status %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x0E0</span><span class="p">),</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x0E2</span><span class="p">),</span>
				   <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ANLinkPartnerAbility</span><span class="p">),</span>
				   <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">ANStatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span>
			<span class="n">writeb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">LEDCtrl</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">writeb</span><span class="p">(</span><span class="mh">0x03</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">LEDCtrl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">StatsMax</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hamachi_get_stats</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="cm">/* Read the overflow bits to clear. */</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x370</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x3F0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">LinkChange</span><span class="o">|</span><span class="n">StatsMax</span><span class="o">|</span><span class="n">NegotiationChange</span><span class="o">|</span><span class="n">IntrRxDone</span><span class="o">|</span><span class="n">IntrTxDone</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">hamachi_debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Something Wicked happened! %4.4x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">intr_status</span><span class="p">);</span>
	<span class="cm">/* Hmmmmm, it&#39;s not clear how to recover from PCI faults. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IntrTxPCIErr</span> <span class="o">|</span> <span class="n">IntrTxPCIFault</span><span class="p">))</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IntrRxPCIErr</span> <span class="o">|</span> <span class="n">IntrRxPCIFault</span><span class="p">))</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hamachi_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Shutting down ethercard, status was Tx %4.4x Rx %4.4x Int %2.2x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxStatus</span><span class="p">),</span>
			   <span class="n">readw</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxStatus</span><span class="p">),</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">IntrStatus</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Queue pointers were Tx %d / %d,  Rx %d / %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_tx</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_tx</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">cur_rx</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">dirty_rx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Disable interrupts by clearing the interrupt mask. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">InterruptEnable</span><span class="p">);</span>

	<span class="cm">/* Stop the chip&#39;s Tx and Rx processes. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxCmd</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxCmd</span><span class="p">);</span>

<span class="cp">#ifdef __i386__</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  Tx ring at %8.8x:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; %c #%d desc. %8.8x %8.8x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxCurPtr</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="sc">&#39;&gt;&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
				   <span class="n">i</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  Rx ring %8.8x:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; %c #%d desc. %4.4x %8.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">RxCurPtr</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="sc">&#39;&gt;&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
				   <span class="n">i</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hamachi_debug</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="mh">0x69</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">u16</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span>
						<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
					<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Addr: &quot;</span><span class="p">);</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mh">0x50</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %4.4x&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __i386__ debugging only */</span><span class="cp"></span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="cm">/* Free all the skbuffs in the Rx queue. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status_n_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="n">leXX_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">),</span>
				<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_buf_sz</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_leXX</span><span class="p">(</span><span class="mh">0xBADF00D0</span><span class="p">);</span> <span class="cm">/* An invalid address. */</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_RING_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="n">leXX_to_cpu</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">),</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_skbuff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">writeb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">LEDCtrl</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">hamachi_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="cm">/* We should lock this segment of code for SMP eventually, although</span>
<span class="cm">	   the vulnerability window is very small and statistics are</span>
<span class="cm">	   non-critical. */</span>
        <span class="cm">/* Ok, what goes here?  This appears to be stuck at 21 packets</span>
<span class="cm">           according to ifconfig.  It does get incremented in hamachi_tx(),</span>
<span class="cm">           so I think I&#39;ll comment it out here and see if better things</span>
<span class="cm">           happen.</span>
<span class="cm">        */</span>
	<span class="cm">/* dev-&gt;stats.tx_packets	= readl(ioaddr + 0x000); */</span>

	<span class="cm">/* Total Uni+Brd+Multi */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x330</span><span class="p">);</span>
	<span class="cm">/* Total Uni+Brd+Multi */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x3B0</span><span class="p">);</span>
	<span class="cm">/* Multicast Rx */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">multicast</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x320</span><span class="p">);</span>

	<span class="cm">/* Over+Undersized */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x368</span><span class="p">);</span>
	<span class="cm">/* Jabber */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x35C</span><span class="p">);</span>
	<span class="cm">/* Jabber */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x360</span><span class="p">);</span>
	<span class="cm">/* Symbol Errs */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x364</span><span class="p">);</span>
	<span class="cm">/* Dropped */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_missed_errors</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x36C</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* Set promiscuous. */</span>
		<span class="n">writew</span><span class="p">(</span><span class="mh">0x000F</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">AddrMode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">63</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Too many to match, or accept all multicasts. */</span>
		<span class="n">writew</span><span class="p">(</span><span class="mh">0x000B</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">AddrMode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev_mc_empty</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* Must use the CAM filter. */</span>
		<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">),</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x100</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x20000</span> <span class="o">|</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span>
				   <span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x104</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Clear remaining entries. */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="mh">0x104</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
		<span class="n">writew</span><span class="p">(</span><span class="mh">0x0003</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">AddrMode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>					<span class="cm">/* Normal, unicast/broadcast-only mode. */</span>
		<span class="n">writew</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">AddrMode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_if_running</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hamachi_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hamachi_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mii_ethtool_gset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">ecmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hamachi_set_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">mii_ethtool_sset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">ecmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hamachi_nway_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mii_nway_restart</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">hamachi_get_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mii_link_ok</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">begin</span> <span class="o">=</span> <span class="n">check_if_running</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_drvinfo</span> <span class="o">=</span> <span class="n">hamachi_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_settings</span> <span class="o">=</span> <span class="n">hamachi_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span> <span class="o">=</span> <span class="n">hamachi_set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nway_reset</span> <span class="o">=</span> <span class="n">hamachi_nway_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span> <span class="o">=</span> <span class="n">hamachi_get_link</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">ethtool_ops_no_mii</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">begin</span> <span class="o">=</span> <span class="n">check_if_running</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_drvinfo</span> <span class="o">=</span> <span class="n">hamachi_get_drvinfo</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mii_ioctl_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="p">(</span><span class="n">SIOCDEVPRIVATE</span><span class="o">+</span><span class="mi">3</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* set rx,tx intr params */</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">ifr_ifru</span><span class="p">;</span>
		<span class="cm">/* Should add this check here or an ordinary user can do nasty</span>
<span class="cm">		 * things. -KDU</span>
<span class="cm">		 *</span>
<span class="cm">		 * TODO: Shut down the Rx and Tx engines while doing this.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">TxIntrCtrl</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">RxIntrCtrl</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: tx %08x, rx %08x intr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">readl</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">TxIntrCtrl</span><span class="p">),</span>
		  <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">readl</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">RxIntrCtrl</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">generic_mii_ioctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">mii_if</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">hamachi_remove_one</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hamachi_private</span> <span class="o">*</span><span class="n">hmp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">RX_TOTAL_SIZE</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">,</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">rx_ring_dma</span><span class="p">);</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">TX_TOTAL_SIZE</span><span class="p">,</span> <span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">,</span>
			<span class="n">hmp</span><span class="o">-&gt;</span><span class="n">tx_ring_dma</span><span class="p">);</span>
		<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">hmp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">hamachi_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x1318</span><span class="p">,</span> <span class="mh">0x0911</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">hamachi_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">hamachi_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">hamachi_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">hamachi_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">hamachi_remove_one</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hamachi_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* when a module, this is printed whether or not devices are found in probe */</span>
<span class="cp">#ifdef MODULE</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hamachi_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">hamachi_exit</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hamachi_driver</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">module_init</span><span class="p">(</span><span class="n">hamachi_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">hamachi_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
