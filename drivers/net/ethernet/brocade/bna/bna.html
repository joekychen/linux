<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › brocade › bna › bna.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>bna.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux network driver for Brocade Converged Network Adapter.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License (GPL) Version 2 as</span>
<span class="cm"> * published by the Free Software Foundation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2005-2011 Brocade Communications Systems, Inc.</span>
<span class="cm"> * All rights reserved</span>
<span class="cm"> * www.brocade.com</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __BNA_H__</span>
<span class="cp">#define __BNA_H__</span>

<span class="cp">#include &quot;bfa_defs.h&quot;</span>
<span class="cp">#include &quot;bfa_ioc.h&quot;</span>
<span class="cp">#include &quot;bfi_enet.h&quot;</span>
<span class="cp">#include &quot;bna_types.h&quot;</span>

<span class="k">extern</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">bna_napi_dim_vector</span><span class="p">[][</span><span class="n">BNA_BIAS_T_MAX</span><span class="p">];</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *  Macros and constants</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define BNA_IOC_TIMER_FREQ		200</span>

<span class="cm">/* Log string size */</span>
<span class="cp">#define BNA_MESSAGE_SIZE		256</span>

<span class="cp">#define bna_is_small_rxq(_id) ((_id) &amp; 0x1)</span>

<span class="cp">#define BNA_MAC_IS_EQUAL(_mac1, _mac2)					\</span>
<span class="cp">	(!memcmp((_mac1), (_mac2), sizeof(mac_t)))</span>

<span class="cp">#define BNA_POWER_OF_2(x) (((x) &amp; ((x) - 1)) == 0)</span>

<span class="cp">#define BNA_TO_POWER_OF_2(x)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	int _shift = 0;							\</span>
<span class="cp">	while ((x) &amp;&amp; (x) != 1) {					\</span>
<span class="cp">		(x) &gt;&gt;= 1;						\</span>
<span class="cp">		_shift++;						\</span>
<span class="cp">	}								\</span>
<span class="cp">	(x) &lt;&lt;= _shift;							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define BNA_TO_POWER_OF_2_HIGH(x)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	int n = 1;							\</span>
<span class="cp">	while (n &lt; (x))							\</span>
<span class="cp">		n &lt;&lt;= 1;						\</span>
<span class="cp">	(x) = n;							\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * input : _addr-&gt; os dma addr in host endian format,</span>
<span class="cm"> * output : _bna_dma_addr-&gt; pointer to hw dma addr</span>
<span class="cm"> */</span>
<span class="cp">#define BNA_SET_DMA_ADDR(_addr, _bna_dma_addr)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	u64 tmp_addr =						\</span>
<span class="cp">	cpu_to_be64((u64)(_addr));				\</span>
<span class="cp">	(_bna_dma_addr)-&gt;msb = ((struct bna_dma_addr *)&amp;tmp_addr)-&gt;msb; \</span>
<span class="cp">	(_bna_dma_addr)-&gt;lsb = ((struct bna_dma_addr *)&amp;tmp_addr)-&gt;lsb; \</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * input : _bna_dma_addr-&gt; pointer to hw dma addr</span>
<span class="cm"> * output : _addr-&gt; os dma addr in host endian format</span>
<span class="cm"> */</span>
<span class="cp">#define BNA_GET_DMA_ADDR(_bna_dma_addr, _addr)			\</span>
<span class="cp">do {								\</span>
<span class="cp">	(_addr) = ((((u64)ntohl((_bna_dma_addr)-&gt;msb))) &lt;&lt; 32)		\</span>
<span class="cp">	| ((ntohl((_bna_dma_addr)-&gt;lsb) &amp; 0xffffffff));	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	containing_rec(addr, type, field)				\</span>
<span class="cp">	((type *)((unsigned char *)(addr) -				\</span>
<span class="cp">	(unsigned char *)(&amp;((type *)0)-&gt;field)))</span>

<span class="cp">#define BNA_TXQ_WI_NEEDED(_vectors)	(((_vectors) + 3) &gt;&gt; 2)</span>

<span class="cm">/* TxQ element is 64 bytes */</span>
<span class="cp">#define BNA_TXQ_PAGE_INDEX_MAX		(PAGE_SIZE &gt;&gt; 6)</span>
<span class="cp">#define BNA_TXQ_PAGE_INDEX_MAX_SHIFT	(PAGE_SHIFT - 6)</span>

<span class="cp">#define BNA_TXQ_QPGE_PTR_GET(_qe_idx, _qpt_ptr, _qe_ptr, _qe_ptr_range) \</span>
<span class="cp">{									\</span>
<span class="cp">	unsigned int page_index;	</span><span class="cm">/* index within a page */</span><span class="cp">	\</span>
<span class="cp">	void *page_addr;						\</span>
<span class="cp">	page_index = (_qe_idx) &amp; (BNA_TXQ_PAGE_INDEX_MAX - 1);		\</span>
<span class="cp">	(_qe_ptr_range) = (BNA_TXQ_PAGE_INDEX_MAX - page_index);	\</span>
<span class="cp">	page_addr = (_qpt_ptr)[((_qe_idx) &gt;&gt;  BNA_TXQ_PAGE_INDEX_MAX_SHIFT)];\</span>
<span class="cp">	(_qe_ptr) = &amp;((struct bna_txq_entry *)(page_addr))[page_index]; \</span>
<span class="cp">}</span>

<span class="cm">/* RxQ element is 8 bytes */</span>
<span class="cp">#define BNA_RXQ_PAGE_INDEX_MAX		(PAGE_SIZE &gt;&gt; 3)</span>
<span class="cp">#define BNA_RXQ_PAGE_INDEX_MAX_SHIFT	(PAGE_SHIFT - 3)</span>

<span class="cp">#define BNA_RXQ_QPGE_PTR_GET(_qe_idx, _qpt_ptr, _qe_ptr, _qe_ptr_range) \</span>
<span class="cp">{									\</span>
<span class="cp">	unsigned int page_index;	</span><span class="cm">/* index within a page */</span><span class="cp">	\</span>
<span class="cp">	void *page_addr;						\</span>
<span class="cp">	page_index = (_qe_idx) &amp; (BNA_RXQ_PAGE_INDEX_MAX - 1);		\</span>
<span class="cp">	(_qe_ptr_range) = (BNA_RXQ_PAGE_INDEX_MAX - page_index);	\</span>
<span class="cp">	page_addr = (_qpt_ptr)[((_qe_idx) &gt;&gt;				\</span>
<span class="cp">				BNA_RXQ_PAGE_INDEX_MAX_SHIFT)];		\</span>
<span class="cp">	(_qe_ptr) = &amp;((struct bna_rxq_entry *)(page_addr))[page_index]; \</span>
<span class="cp">}</span>

<span class="cm">/* CQ element is 16 bytes */</span>
<span class="cp">#define BNA_CQ_PAGE_INDEX_MAX		(PAGE_SIZE &gt;&gt; 4)</span>
<span class="cp">#define BNA_CQ_PAGE_INDEX_MAX_SHIFT	(PAGE_SHIFT - 4)</span>

<span class="cp">#define BNA_CQ_QPGE_PTR_GET(_qe_idx, _qpt_ptr, _qe_ptr, _qe_ptr_range)	\</span>
<span class="cp">{									\</span>
<span class="cp">	unsigned int page_index;	  </span><span class="cm">/* index within a page */</span><span class="cp">	\</span>
<span class="cp">	void *page_addr;						\</span>
<span class="cp">									\</span>
<span class="cp">	page_index = (_qe_idx) &amp; (BNA_CQ_PAGE_INDEX_MAX - 1);		\</span>
<span class="cp">	(_qe_ptr_range) = (BNA_CQ_PAGE_INDEX_MAX - page_index);		\</span>
<span class="cp">	page_addr = (_qpt_ptr)[((_qe_idx) &gt;&gt;				\</span>
<span class="cp">				    BNA_CQ_PAGE_INDEX_MAX_SHIFT)];	\</span>
<span class="cp">	(_qe_ptr) = &amp;((struct bna_cq_entry *)(page_addr))[page_index];\</span>
<span class="cp">}</span>

<span class="cp">#define BNA_QE_INDX_2_PTR(_cast, _qe_idx, _q_base)			\</span>
<span class="cp">	(&amp;((_cast *)(_q_base))[(_qe_idx)])</span>

<span class="cp">#define BNA_QE_INDX_RANGE(_qe_idx, _q_depth) ((_q_depth) - (_qe_idx))</span>

<span class="cp">#define BNA_QE_INDX_ADD(_qe_idx, _qe_num, _q_depth)			\</span>
<span class="cp">	((_qe_idx) = ((_qe_idx) + (_qe_num)) &amp; ((_q_depth) - 1))</span>

<span class="cp">#define BNA_Q_INDEX_CHANGE(_old_idx, _updated_idx, _q_depth)		\</span>
<span class="cp">	(((_updated_idx) - (_old_idx)) &amp; ((_q_depth) - 1))</span>

<span class="cp">#define BNA_QE_FREE_CNT(_q_ptr, _q_depth)				\</span>
<span class="cp">	(((_q_ptr)-&gt;consumer_index - (_q_ptr)-&gt;producer_index - 1) &amp;	\</span>
<span class="cp">	 ((_q_depth) - 1))</span>

<span class="cp">#define BNA_QE_IN_USE_CNT(_q_ptr, _q_depth)				\</span>
<span class="cp">	((((_q_ptr)-&gt;producer_index - (_q_ptr)-&gt;consumer_index)) &amp;	\</span>
<span class="cp">	 (_q_depth - 1))</span>

<span class="cp">#define BNA_Q_GET_CI(_q_ptr)		((_q_ptr)-&gt;q.consumer_index)</span>

<span class="cp">#define BNA_Q_GET_PI(_q_ptr)		((_q_ptr)-&gt;q.producer_index)</span>

<span class="cp">#define BNA_Q_PI_ADD(_q_ptr, _num)					\</span>
<span class="cp">	(_q_ptr)-&gt;q.producer_index =					\</span>
<span class="cp">		(((_q_ptr)-&gt;q.producer_index + (_num)) &amp;		\</span>
<span class="cp">		((_q_ptr)-&gt;q.q_depth - 1))</span>

<span class="cp">#define BNA_Q_CI_ADD(_q_ptr, _num)					\</span>
<span class="cp">	(_q_ptr)-&gt;q.consumer_index =					\</span>
<span class="cp">		(((_q_ptr)-&gt;q.consumer_index + (_num))			\</span>
<span class="cp">		&amp; ((_q_ptr)-&gt;q.q_depth - 1))</span>

<span class="cp">#define BNA_Q_FREE_COUNT(_q_ptr)					\</span>
<span class="cp">	(BNA_QE_FREE_CNT(&amp;((_q_ptr)-&gt;q), (_q_ptr)-&gt;q.q_depth))</span>

<span class="cp">#define BNA_Q_IN_USE_COUNT(_q_ptr)					\</span>
<span class="cp">	(BNA_QE_IN_USE_CNT(&amp;(_q_ptr)-&gt;q, (_q_ptr)-&gt;q.q_depth))</span>

<span class="cp">#define BNA_LARGE_PKT_SIZE		1000</span>

<span class="cp">#define BNA_UPDATE_PKT_CNT(_pkt, _len)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	if ((_len) &gt; BNA_LARGE_PKT_SIZE) {				\</span>
<span class="cp">		(_pkt)-&gt;large_pkt_cnt++;				\</span>
<span class="cp">	} else {							\</span>
<span class="cp">		(_pkt)-&gt;small_pkt_cnt++;				\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	call_rxf_stop_cbfn(rxf)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	if ((rxf)-&gt;stop_cbfn) {						\</span>
<span class="cp">		void (*cbfn)(struct bna_rx *);			\</span>
<span class="cp">		struct bna_rx *cbarg;					\</span>
<span class="cp">		cbfn = (rxf)-&gt;stop_cbfn;				\</span>
<span class="cp">		cbarg = (rxf)-&gt;stop_cbarg;				\</span>
<span class="cp">		(rxf)-&gt;stop_cbfn = NULL;				\</span>
<span class="cp">		(rxf)-&gt;stop_cbarg = NULL;				\</span>
<span class="cp">		cbfn(cbarg);						\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	call_rxf_start_cbfn(rxf)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	if ((rxf)-&gt;start_cbfn) {					\</span>
<span class="cp">		void (*cbfn)(struct bna_rx *);			\</span>
<span class="cp">		struct bna_rx *cbarg;					\</span>
<span class="cp">		cbfn = (rxf)-&gt;start_cbfn;				\</span>
<span class="cp">		cbarg = (rxf)-&gt;start_cbarg;				\</span>
<span class="cp">		(rxf)-&gt;start_cbfn = NULL;				\</span>
<span class="cp">		(rxf)-&gt;start_cbarg = NULL;				\</span>
<span class="cp">		cbfn(cbarg);						\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	call_rxf_cam_fltr_cbfn(rxf)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	if ((rxf)-&gt;cam_fltr_cbfn) {					\</span>
<span class="cp">		void (*cbfn)(struct bnad *, struct bna_rx *);	\</span>
<span class="cp">		struct bnad *cbarg;					\</span>
<span class="cp">		cbfn = (rxf)-&gt;cam_fltr_cbfn;				\</span>
<span class="cp">		cbarg = (rxf)-&gt;cam_fltr_cbarg;				\</span>
<span class="cp">		(rxf)-&gt;cam_fltr_cbfn = NULL;				\</span>
<span class="cp">		(rxf)-&gt;cam_fltr_cbarg = NULL;				\</span>
<span class="cp">		cbfn(cbarg, rxf-&gt;rx);					\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	call_rxf_pause_cbfn(rxf)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	if ((rxf)-&gt;oper_state_cbfn) {					\</span>
<span class="cp">		void (*cbfn)(struct bnad *, struct bna_rx *);	\</span>
<span class="cp">		struct bnad *cbarg;					\</span>
<span class="cp">		cbfn = (rxf)-&gt;oper_state_cbfn;				\</span>
<span class="cp">		cbarg = (rxf)-&gt;oper_state_cbarg;			\</span>
<span class="cp">		(rxf)-&gt;oper_state_cbfn = NULL;				\</span>
<span class="cp">		(rxf)-&gt;oper_state_cbarg = NULL;				\</span>
<span class="cp">		cbfn(cbarg, rxf-&gt;rx);					\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	call_rxf_resume_cbfn(rxf) call_rxf_pause_cbfn(rxf)</span>

<span class="cp">#define is_xxx_enable(mode, bitmask, xxx) ((bitmask &amp; xxx) &amp;&amp; (mode &amp; xxx))</span>

<span class="cp">#define is_xxx_disable(mode, bitmask, xxx) ((bitmask &amp; xxx) &amp;&amp; !(mode &amp; xxx))</span>

<span class="cp">#define xxx_enable(mode, bitmask, xxx)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	bitmask |= xxx;							\</span>
<span class="cp">	mode |= xxx;							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define xxx_disable(mode, bitmask, xxx)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	bitmask |= xxx;							\</span>
<span class="cp">	mode &amp;= ~xxx;							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define xxx_inactive(mode, bitmask, xxx)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	bitmask &amp;= ~xxx;						\</span>
<span class="cp">	mode &amp;= ~xxx;							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define is_promisc_enable(mode, bitmask)				\</span>
<span class="cp">	is_xxx_enable(mode, bitmask, BNA_RXMODE_PROMISC)</span>

<span class="cp">#define is_promisc_disable(mode, bitmask)				\</span>
<span class="cp">	is_xxx_disable(mode, bitmask, BNA_RXMODE_PROMISC)</span>

<span class="cp">#define promisc_enable(mode, bitmask)					\</span>
<span class="cp">	xxx_enable(mode, bitmask, BNA_RXMODE_PROMISC)</span>

<span class="cp">#define promisc_disable(mode, bitmask)					\</span>
<span class="cp">	xxx_disable(mode, bitmask, BNA_RXMODE_PROMISC)</span>

<span class="cp">#define promisc_inactive(mode, bitmask)					\</span>
<span class="cp">	xxx_inactive(mode, bitmask, BNA_RXMODE_PROMISC)</span>

<span class="cp">#define is_default_enable(mode, bitmask)				\</span>
<span class="cp">	is_xxx_enable(mode, bitmask, BNA_RXMODE_DEFAULT)</span>

<span class="cp">#define is_default_disable(mode, bitmask)				\</span>
<span class="cp">	is_xxx_disable(mode, bitmask, BNA_RXMODE_DEFAULT)</span>

<span class="cp">#define default_enable(mode, bitmask)					\</span>
<span class="cp">	xxx_enable(mode, bitmask, BNA_RXMODE_DEFAULT)</span>

<span class="cp">#define default_disable(mode, bitmask)					\</span>
<span class="cp">	xxx_disable(mode, bitmask, BNA_RXMODE_DEFAULT)</span>

<span class="cp">#define default_inactive(mode, bitmask)					\</span>
<span class="cp">	xxx_inactive(mode, bitmask, BNA_RXMODE_DEFAULT)</span>

<span class="cp">#define is_allmulti_enable(mode, bitmask)				\</span>
<span class="cp">	is_xxx_enable(mode, bitmask, BNA_RXMODE_ALLMULTI)</span>

<span class="cp">#define is_allmulti_disable(mode, bitmask)				\</span>
<span class="cp">	is_xxx_disable(mode, bitmask, BNA_RXMODE_ALLMULTI)</span>

<span class="cp">#define allmulti_enable(mode, bitmask)					\</span>
<span class="cp">	xxx_enable(mode, bitmask, BNA_RXMODE_ALLMULTI)</span>

<span class="cp">#define allmulti_disable(mode, bitmask)					\</span>
<span class="cp">	xxx_disable(mode, bitmask, BNA_RXMODE_ALLMULTI)</span>

<span class="cp">#define allmulti_inactive(mode, bitmask)				\</span>
<span class="cp">	xxx_inactive(mode, bitmask, BNA_RXMODE_ALLMULTI)</span>

<span class="cp">#define	GET_RXQS(rxp, q0, q1)	do {					\</span>
<span class="cp">	switch ((rxp)-&gt;type) {						\</span>
<span class="cp">	case BNA_RXP_SINGLE:						\</span>
<span class="cp">		(q0) = rxp-&gt;rxq.single.only;				\</span>
<span class="cp">		(q1) = NULL;						\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case BNA_RXP_SLR:						\</span>
<span class="cp">		(q0) = rxp-&gt;rxq.slr.large;				\</span>
<span class="cp">		(q1) = rxp-&gt;rxq.slr.small;				\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case BNA_RXP_HDS:						\</span>
<span class="cp">		(q0) = rxp-&gt;rxq.hds.data;				\</span>
<span class="cp">		(q1) = rxp-&gt;rxq.hds.hdr;				\</span>
<span class="cp">		break;							\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define bna_tx_rid_mask(_bna) ((_bna)-&gt;tx_mod.rid_mask)</span>

<span class="cp">#define bna_rx_rid_mask(_bna) ((_bna)-&gt;rx_mod.rid_mask)</span>

<span class="cp">#define bna_tx_from_rid(_bna, _rid, _tx)				\</span>
<span class="cp">do {								    \</span>
<span class="cp">	struct bna_tx_mod *__tx_mod = &amp;(_bna)-&gt;tx_mod;	  \</span>
<span class="cp">	struct bna_tx *__tx;					    \</span>
<span class="cp">	struct list_head *qe;					   \</span>
<span class="cp">	_tx = NULL;						     \</span>
<span class="cp">	list_for_each(qe, &amp;__tx_mod-&gt;tx_active_q) {		     \</span>
<span class="cp">		__tx = (struct bna_tx *)qe;			     \</span>
<span class="cp">		if (__tx-&gt;rid == (_rid)) {			      \</span>
<span class="cp">			(_tx) = __tx;				   \</span>
<span class="cp">			break;					  \</span>
<span class="cp">		}						       \</span>
<span class="cp">	}							       \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define bna_rx_from_rid(_bna, _rid, _rx)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	struct bna_rx_mod *__rx_mod = &amp;(_bna)-&gt;rx_mod;			\</span>
<span class="cp">	struct bna_rx *__rx;						\</span>
<span class="cp">	struct list_head *qe;						\</span>
<span class="cp">	_rx = NULL;							\</span>
<span class="cp">	list_for_each(qe, &amp;__rx_mod-&gt;rx_active_q) {			\</span>
<span class="cp">		__rx = (struct bna_rx *)qe;				\</span>
<span class="cp">		if (__rx-&gt;rid == (_rid)) {				\</span>
<span class="cp">			(_rx) = __rx;					\</span>
<span class="cp">			break;						\</span>
<span class="cp">		}							\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *  Inline functions</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">bna_mac</span> <span class="o">*</span><span class="nf">bna_mac_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bna_mac</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">qe</span><span class="p">;</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">qe</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BNA_MAC_IS_EQUAL</span><span class="p">(((</span><span class="k">struct</span> <span class="n">bna_mac</span> <span class="o">*</span><span class="p">)</span><span class="n">qe</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mac</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bna_mac</span> <span class="o">*</span><span class="p">)</span><span class="n">qe</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mac</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define bna_attr(_bna) (&amp;(_bna)-&gt;ioceth.attr)</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * Function prototypes</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * BNA</span>
<span class="cm"> */</span>

<span class="cm">/* FW response handlers */</span>
<span class="kt">void</span> <span class="n">bna_bfi_stats_clr_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bfi_msgq_mhdr</span> <span class="o">*</span><span class="n">msghdr</span><span class="p">);</span>

<span class="cm">/* APIs for BNAD */</span>
<span class="kt">void</span> <span class="n">bna_res_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_res_info</span> <span class="o">*</span><span class="n">res_info</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_mod_res_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna_res_info</span> <span class="o">*</span><span class="n">res_info</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="n">bnad</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bfa_pcidev</span> <span class="o">*</span><span class="n">pcidev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bna_res_info</span> <span class="o">*</span><span class="n">res_info</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_mod_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna_res_info</span> <span class="o">*</span><span class="n">res_info</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bna_num_txq_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_txq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bna_num_rxp_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_rxp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_hw_stats_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">);</span>

<span class="cm">/* APIs for RxF */</span>
<span class="k">struct</span> <span class="n">bna_mac</span> <span class="o">*</span><span class="n">bna_ucam_mod_mac_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_ucam_mod</span> <span class="o">*</span><span class="n">ucam_mod</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_ucam_mod_mac_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_ucam_mod</span> <span class="o">*</span><span class="n">ucam_mod</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">bna_mac</span> <span class="o">*</span><span class="n">mac</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">bna_mac</span> <span class="o">*</span><span class="n">bna_mcam_mod_mac_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_mcam_mod</span> <span class="o">*</span><span class="n">mcam_mod</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_mcam_mod_mac_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_mcam_mod</span> <span class="o">*</span><span class="n">mcam_mod</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">bna_mac</span> <span class="o">*</span><span class="n">mac</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">bna_mcam_handle</span> <span class="o">*</span><span class="n">bna_mcam_mod_handle_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_mcam_mod</span> <span class="o">*</span><span class="n">mod</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_mcam_mod_handle_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_mcam_mod</span> <span class="o">*</span><span class="n">mcam_mod</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">bna_mcam_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * MBOX</span>
<span class="cm"> */</span>

<span class="cm">/* API for BNAD */</span>
<span class="kt">void</span> <span class="n">bna_mbox_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span> <span class="n">u32</span> <span class="n">intr_status</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ETHPORT</span>
<span class="cm"> */</span>

<span class="cm">/* Callbacks for RX */</span>
<span class="kt">void</span> <span class="n">bna_ethport_cb_rx_started</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_ethport</span> <span class="o">*</span><span class="n">ethport</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_ethport_cb_rx_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_ethport</span> <span class="o">*</span><span class="n">ethport</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * TX MODULE AND TX</span>
<span class="cm"> */</span>
<span class="cm">/* FW response handelrs */</span>
<span class="kt">void</span> <span class="n">bna_bfi_tx_enet_start_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bfi_msgq_mhdr</span> <span class="o">*</span><span class="n">msghdr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_bfi_tx_enet_stop_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">bfi_msgq_mhdr</span> <span class="o">*</span><span class="n">msghdr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_bfi_bw_update_aen</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx_mod</span> <span class="o">*</span><span class="n">tx_mod</span><span class="p">);</span>

<span class="cm">/* APIs for BNA */</span>
<span class="kt">void</span> <span class="n">bna_tx_mod_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx_mod</span> <span class="o">*</span><span class="n">tx_mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">bna_res_info</span> <span class="o">*</span><span class="n">res_info</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_tx_mod_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx_mod</span> <span class="o">*</span><span class="n">tx_mod</span><span class="p">);</span>

<span class="cm">/* APIs for ENET */</span>
<span class="kt">void</span> <span class="n">bna_tx_mod_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx_mod</span> <span class="o">*</span><span class="n">tx_mod</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bna_tx_type</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_tx_mod_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx_mod</span> <span class="o">*</span><span class="n">tx_mod</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bna_tx_type</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_tx_mod_fail</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx_mod</span> <span class="o">*</span><span class="n">tx_mod</span><span class="p">);</span>

<span class="cm">/* APIs for BNAD */</span>
<span class="kt">void</span> <span class="n">bna_tx_res_req</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_txq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txq_depth</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">bna_res_info</span> <span class="o">*</span><span class="n">res_info</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">bna_tx</span> <span class="o">*</span><span class="n">bna_tx_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="n">bnad</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bna_tx_config</span> <span class="o">*</span><span class="n">tx_cfg</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">bna_tx_event_cbfn</span> <span class="o">*</span><span class="n">tx_cbfn</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bna_res_info</span> <span class="o">*</span><span class="n">res_info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_tx_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx</span> <span class="o">*</span><span class="n">tx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_tx_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx</span> <span class="o">*</span><span class="n">tx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_tx_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bna_cleanup_type</span> <span class="n">type</span><span class="p">,</span>
		    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cbfn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna_tx</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">bna_tx_cleanup_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx</span> <span class="o">*</span><span class="n">tx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_tx_coalescing_timeo_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_tx</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">coalescing_timeo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * RX MODULE, RX, RXF</span>
<span class="cm"> */</span>

<span class="cm">/* FW response handlers */</span>
<span class="kt">void</span> <span class="n">bna_bfi_rx_enet_start_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bfi_msgq_mhdr</span> <span class="o">*</span><span class="n">msghdr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_bfi_rx_enet_stop_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">bfi_msgq_mhdr</span> <span class="o">*</span><span class="n">msghdr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_bfi_rxf_cfg_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rxf</span> <span class="o">*</span><span class="n">rxf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bfi_msgq_mhdr</span> <span class="o">*</span><span class="n">msghdr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_bfi_rxf_mcast_add_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rxf</span> <span class="o">*</span><span class="n">rxf</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bfi_msgq_mhdr</span> <span class="o">*</span><span class="n">msghdr</span><span class="p">);</span>

<span class="cm">/* APIs for BNA */</span>
<span class="kt">void</span> <span class="n">bna_rx_mod_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx_mod</span> <span class="o">*</span><span class="n">rx_mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">bna_res_info</span> <span class="o">*</span><span class="n">res_info</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_rx_mod_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx_mod</span> <span class="o">*</span><span class="n">rx_mod</span><span class="p">);</span>

<span class="cm">/* APIs for ENET */</span>
<span class="kt">void</span> <span class="n">bna_rx_mod_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx_mod</span> <span class="o">*</span><span class="n">rx_mod</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bna_rx_type</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_rx_mod_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx_mod</span> <span class="o">*</span><span class="n">rx_mod</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bna_rx_type</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_rx_mod_fail</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx_mod</span> <span class="o">*</span><span class="n">rx_mod</span><span class="p">);</span>

<span class="cm">/* APIs for BNAD */</span>
<span class="kt">void</span> <span class="n">bna_rx_res_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx_config</span> <span class="o">*</span><span class="n">rx_config</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">bna_res_info</span> <span class="o">*</span><span class="n">res_info</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">bna_rx_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="n">bnad</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bna_rx_config</span> <span class="o">*</span><span class="n">rx_cfg</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">bna_rx_event_cbfn</span> <span class="o">*</span><span class="n">rx_cbfn</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bna_res_info</span> <span class="o">*</span><span class="n">res_info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_rx_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_rx_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_rx_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bna_cleanup_type</span> <span class="n">type</span><span class="p">,</span>
		    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cbfn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">bna_rx_cleanup_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_rx_coalescing_timeo_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">coalescing_timeo</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_rx_dim_reconfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna</span> <span class="o">*</span><span class="n">bna</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">vector</span><span class="p">[][</span><span class="n">BNA_BIAS_T_MAX</span><span class="p">]);</span>
<span class="kt">void</span> <span class="n">bna_rx_dim_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_ccb</span> <span class="o">*</span><span class="n">ccb</span><span class="p">);</span>
<span class="k">enum</span> <span class="n">bna_cb_status</span>
<span class="n">bna_rx_ucast_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ucmac</span><span class="p">,</span>
		 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cbfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="p">));</span>
<span class="k">enum</span> <span class="n">bna_cb_status</span>
<span class="n">bna_rx_ucast_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="n">u8</span><span class="o">*</span> <span class="n">ucmac</span><span class="p">,</span>
		 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cbfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="p">));</span>
<span class="k">enum</span> <span class="n">bna_cb_status</span>
<span class="n">bna_rx_ucast_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ucmac</span><span class="p">,</span>
		 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cbfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="p">));</span>
<span class="k">enum</span> <span class="n">bna_cb_status</span>
<span class="n">bna_rx_mcast_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mcmac</span><span class="p">,</span>
		 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cbfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="p">));</span>
<span class="k">enum</span> <span class="n">bna_cb_status</span>
<span class="n">bna_rx_mcast_listset</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mcmac</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cbfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="p">));</span>
<span class="k">enum</span> <span class="n">bna_cb_status</span>
<span class="n">bna_rx_mode_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bna_rxmode</span> <span class="n">rxmode</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">bna_rxmode</span> <span class="n">bitmask</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cbfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">bna_rx_vlan_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vlan_id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_rx_vlan_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vlan_id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_rx_vlanfilter_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_rx</span> <span class="o">*</span><span class="n">rx</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * ENET</span>
<span class="cm"> */</span>

<span class="cm">/* API for RX */</span>
<span class="kt">int</span> <span class="n">bna_enet_mtu_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_enet</span> <span class="o">*</span><span class="n">enet</span><span class="p">);</span>

<span class="cm">/* Callbacks for TX, RX */</span>
<span class="kt">void</span> <span class="n">bna_enet_cb_tx_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_enet</span> <span class="o">*</span><span class="n">enet</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_enet_cb_rx_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_enet</span> <span class="o">*</span><span class="n">enet</span><span class="p">);</span>

<span class="cm">/* API for BNAD */</span>
<span class="kt">void</span> <span class="n">bna_enet_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_enet</span> <span class="o">*</span><span class="n">enet</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_enet_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_enet</span> <span class="o">*</span><span class="n">enet</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bna_cleanup_type</span> <span class="n">type</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cbfn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">bna_enet_pause_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_enet</span> <span class="o">*</span><span class="n">enet</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">bna_pause_config</span> <span class="o">*</span><span class="n">pause_config</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cbfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">bna_enet_mtu_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_enet</span> <span class="o">*</span><span class="n">enet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mtu</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cbfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">bna_enet_perm_mac_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_enet</span> <span class="o">*</span><span class="n">enet</span><span class="p">,</span> <span class="n">mac_t</span> <span class="o">*</span><span class="n">mac</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * IOCETH</span>
<span class="cm"> */</span>

<span class="cm">/* APIs for BNAD */</span>
<span class="kt">void</span> <span class="n">bna_ioceth_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_ioceth</span> <span class="o">*</span><span class="n">ioceth</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bna_ioceth_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bna_ioceth</span> <span class="o">*</span><span class="n">ioceth</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">bna_cleanup_type</span> <span class="n">type</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * BNAD</span>
<span class="cm"> */</span>

<span class="cm">/* Callbacks for ENET */</span>
<span class="kt">void</span> <span class="n">bnad_cb_ethport_link_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="n">bnad</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">bna_link_status</span> <span class="n">status</span><span class="p">);</span>

<span class="cm">/* Callbacks for IOCETH */</span>
<span class="kt">void</span> <span class="n">bnad_cb_ioceth_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="n">bnad</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bnad_cb_ioceth_failed</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="n">bnad</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bnad_cb_ioceth_disabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="n">bnad</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bnad_cb_mbox_intr_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="n">bnad</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bnad_cb_mbox_intr_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="n">bnad</span><span class="p">);</span>

<span class="cm">/* Callbacks for BNA */</span>
<span class="kt">void</span> <span class="n">bnad_cb_stats_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnad</span> <span class="o">*</span><span class="n">bnad</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bna_cb_status</span> <span class="n">status</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">bna_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>

<span class="cp">#endif  </span><span class="cm">/* __BNA_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
