<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › brocade › bna › bna_hw_defs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>bna_hw_defs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux network driver for Brocade Converged Network Adapter.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License (GPL) Version 2 as</span>
<span class="cm"> * published by the Free Software Foundation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2005-2011 Brocade Communications Systems, Inc.</span>
<span class="cm"> * All rights reserved</span>
<span class="cm"> * www.brocade.com</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * File for interrupt macros and functions</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __BNA_HW_DEFS_H__</span>
<span class="cp">#define __BNA_HW_DEFS_H__</span>

<span class="cp">#include &quot;bfi_reg.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * SW imposed limits</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define BFI_ENET_DEF_TXQ		1</span>
<span class="cp">#define BFI_ENET_DEF_RXP		1</span>
<span class="cp">#define BFI_ENET_DEF_UCAM		1</span>
<span class="cp">#define BFI_ENET_DEF_RITSZ		1</span>

<span class="cp">#define BFI_ENET_MAX_MCAM		256</span>

<span class="cp">#define BFI_INVALID_RID			-1</span>

<span class="cp">#define BFI_IBIDX_SIZE			4</span>

<span class="cp">#define BFI_VLAN_WORD_SHIFT		5	</span><span class="cm">/* 32 bits */</span><span class="cp"></span>
<span class="cp">#define BFI_VLAN_WORD_MASK		0x1F</span>
<span class="cp">#define BFI_VLAN_BLOCK_SHIFT		9	</span><span class="cm">/* 512 bits */</span><span class="cp"></span>
<span class="cp">#define BFI_VLAN_BMASK_ALL		0xFF</span>

<span class="cp">#define BFI_COALESCING_TIMER_UNIT	5	</span><span class="cm">/* 5us */</span><span class="cp"></span>
<span class="cp">#define BFI_MAX_COALESCING_TIMEO	0xFF	</span><span class="cm">/* in 5us units */</span><span class="cp"></span>
<span class="cp">#define BFI_MAX_INTERPKT_COUNT		0xFF</span>
<span class="cp">#define BFI_MAX_INTERPKT_TIMEO		0xF	</span><span class="cm">/* in 0.5us units */</span><span class="cp"></span>
<span class="cp">#define BFI_TX_COALESCING_TIMEO		20	</span><span class="cm">/* 20 * 5 = 100us */</span><span class="cp"></span>
<span class="cp">#define BFI_TX_INTERPKT_COUNT		32</span>
<span class="cp">#define	BFI_RX_COALESCING_TIMEO		12	</span><span class="cm">/* 12 * 5 = 60us */</span><span class="cp"></span>
<span class="cp">#define	BFI_RX_INTERPKT_COUNT		6	</span><span class="cm">/* Pkt Cnt = 6 */</span><span class="cp"></span>
<span class="cp">#define	BFI_RX_INTERPKT_TIMEO		3	</span><span class="cm">/* 3 * 0.5 = 1.5us */</span><span class="cp"></span>

<span class="cp">#define BFI_TXQ_WI_SIZE			64	</span><span class="cm">/* bytes */</span><span class="cp"></span>
<span class="cp">#define BFI_RXQ_WI_SIZE			8	</span><span class="cm">/* bytes */</span><span class="cp"></span>
<span class="cp">#define BFI_CQ_WI_SIZE			16	</span><span class="cm">/* bytes */</span><span class="cp"></span>
<span class="cp">#define BFI_TX_MAX_WRR_QUOTA		0xFFF</span>

<span class="cp">#define BFI_TX_MAX_VECTORS_PER_WI	4</span>
<span class="cp">#define BFI_TX_MAX_VECTORS_PER_PKT	0xFF</span>
<span class="cp">#define BFI_TX_MAX_DATA_PER_VECTOR	0xFFFF</span>
<span class="cp">#define BFI_TX_MAX_DATA_PER_PKT		0xFFFFFF</span>

<span class="cm">/* Small Q buffer size */</span>
<span class="cp">#define BFI_SMALL_RXBUF_SIZE		128</span>

<span class="cp">#define BFI_TX_MAX_PRIO			8</span>
<span class="cp">#define BFI_TX_PRIO_MAP_ALL		0xFF</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Register definitions and macros</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define BNA_PCI_REG_CT_ADDRSZ		(0x40000)</span>

<span class="cp">#define ct_reg_addr_init(_bna, _pcidev)					\</span>
<span class="cp">{									\</span>
<span class="cp">	struct bna_reg_offset reg_offset[] =				\</span>
<span class="cp">	{{HOSTFN0_INT_STATUS, HOSTFN0_INT_MSK},				\</span>
<span class="cp">	 {HOSTFN1_INT_STATUS, HOSTFN1_INT_MSK},				\</span>
<span class="cp">	 {HOSTFN2_INT_STATUS, HOSTFN2_INT_MSK},				\</span>
<span class="cp">	 {HOSTFN3_INT_STATUS, HOSTFN3_INT_MSK} };			\</span>
<span class="cp">									\</span>
<span class="cp">	(_bna)-&gt;regs.fn_int_status = (_pcidev)-&gt;pci_bar_kva +		\</span>
<span class="cp">				reg_offset[(_pcidev)-&gt;pci_func].fn_int_status;\</span>
<span class="cp">	(_bna)-&gt;regs.fn_int_mask = (_pcidev)-&gt;pci_bar_kva +		\</span>
<span class="cp">				reg_offset[(_pcidev)-&gt;pci_func].fn_int_mask;\</span>
<span class="cp">}</span>

<span class="cp">#define ct_bit_defn_init(_bna, _pcidev)					\</span>
<span class="cp">{									\</span>
<span class="cp">	(_bna)-&gt;bits.mbox_status_bits = (__HFN_INT_MBOX_LPU0 |		\</span>
<span class="cp">					__HFN_INT_MBOX_LPU1);		\</span>
<span class="cp">	(_bna)-&gt;bits.mbox_mask_bits = (__HFN_INT_MBOX_LPU0 |		\</span>
<span class="cp">					__HFN_INT_MBOX_LPU1);		\</span>
<span class="cp">	(_bna)-&gt;bits.error_status_bits = (__HFN_INT_ERR_MASK);		\</span>
<span class="cp">	(_bna)-&gt;bits.error_mask_bits = (__HFN_INT_ERR_MASK);		\</span>
<span class="cp">	(_bna)-&gt;bits.halt_status_bits = __HFN_INT_LL_HALT;		\</span>
<span class="cp">	(_bna)-&gt;bits.halt_mask_bits = __HFN_INT_LL_HALT;		\</span>
<span class="cp">}</span>

<span class="cp">#define ct2_reg_addr_init(_bna, _pcidev)				\</span>
<span class="cp">{									\</span>
<span class="cp">	(_bna)-&gt;regs.fn_int_status = (_pcidev)-&gt;pci_bar_kva +		\</span>
<span class="cp">				CT2_HOSTFN_INT_STATUS;			\</span>
<span class="cp">	(_bna)-&gt;regs.fn_int_mask = (_pcidev)-&gt;pci_bar_kva +		\</span>
<span class="cp">				CT2_HOSTFN_INTR_MASK;			\</span>
<span class="cp">}</span>

<span class="cp">#define ct2_bit_defn_init(_bna, _pcidev)				\</span>
<span class="cp">{									\</span>
<span class="cp">	(_bna)-&gt;bits.mbox_status_bits = (__HFN_INT_MBOX_LPU0_CT2 |	\</span>
<span class="cp">					__HFN_INT_MBOX_LPU1_CT2);	\</span>
<span class="cp">	(_bna)-&gt;bits.mbox_mask_bits = (__HFN_INT_MBOX_LPU0_CT2 |	\</span>
<span class="cp">					__HFN_INT_MBOX_LPU1_CT2);	\</span>
<span class="cp">	(_bna)-&gt;bits.error_status_bits = (__HFN_INT_ERR_MASK_CT2);	\</span>
<span class="cp">	(_bna)-&gt;bits.error_mask_bits = (__HFN_INT_ERR_MASK_CT2);	\</span>
<span class="cp">	(_bna)-&gt;bits.halt_status_bits = __HFN_INT_CPQ_HALT_CT2;		\</span>
<span class="cp">	(_bna)-&gt;bits.halt_mask_bits = __HFN_INT_CPQ_HALT_CT2;		\</span>
<span class="cp">}</span>

<span class="cp">#define bna_reg_addr_init(_bna, _pcidev)				\</span>
<span class="cp">{									\</span>
<span class="cp">	switch ((_pcidev)-&gt;device_id) {					\</span>
<span class="cp">	case PCI_DEVICE_ID_BROCADE_CT:					\</span>
<span class="cp">		ct_reg_addr_init((_bna), (_pcidev));			\</span>
<span class="cp">		ct_bit_defn_init((_bna), (_pcidev));			\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case BFA_PCI_DEVICE_ID_CT2:					\</span>
<span class="cp">		ct2_reg_addr_init((_bna), (_pcidev));			\</span>
<span class="cp">		ct2_bit_defn_init((_bna), (_pcidev));			\</span>
<span class="cp">		break;							\</span>
<span class="cp">	}								\</span>
<span class="cp">}</span>

<span class="cp">#define bna_port_id_get(_bna) ((_bna)-&gt;ioceth.ioc.port_id)</span>
<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *  Interrupt related bits, flags and macros</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define IB_STATUS_BITS		0x0000ffff</span>

<span class="cp">#define BNA_IS_MBOX_INTR(_bna, _intr_status)				\</span>
<span class="cp">	((_intr_status) &amp; (_bna)-&gt;bits.mbox_status_bits)</span>

<span class="cp">#define BNA_IS_HALT_INTR(_bna, _intr_status)				\</span>
<span class="cp">	((_intr_status) &amp; (_bna)-&gt;bits.halt_status_bits)</span>

<span class="cp">#define BNA_IS_ERR_INTR(_bna, _intr_status)	\</span>
<span class="cp">	((_intr_status) &amp; (_bna)-&gt;bits.error_status_bits)</span>

<span class="cp">#define BNA_IS_MBOX_ERR_INTR(_bna, _intr_status)	\</span>
<span class="cp">	(BNA_IS_MBOX_INTR(_bna, _intr_status) |		\</span>
<span class="cp">	BNA_IS_ERR_INTR(_bna, _intr_status))</span>

<span class="cp">#define BNA_IS_INTX_DATA_INTR(_intr_status)		\</span>
<span class="cp">		((_intr_status) &amp; IB_STATUS_BITS)</span>

<span class="cp">#define bna_halt_clear(_bna)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	u32 init_halt;						\</span>
<span class="cp">	init_halt = readl((_bna)-&gt;ioceth.ioc.ioc_regs.ll_halt);	\</span>
<span class="cp">	init_halt &amp;= ~__FW_INIT_HALT_P;					\</span>
<span class="cp">	writel(init_halt, (_bna)-&gt;ioceth.ioc.ioc_regs.ll_halt);	\</span>
<span class="cp">	init_halt = readl((_bna)-&gt;ioceth.ioc.ioc_regs.ll_halt);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define bna_intx_disable(_bna, _cur_mask)				\</span>
<span class="cp">{									\</span>
<span class="cp">	(_cur_mask) = readl((_bna)-&gt;regs.fn_int_mask);		\</span>
<span class="cp">	writel(0xffffffff, (_bna)-&gt;regs.fn_int_mask);		\</span>
<span class="cp">}</span>

<span class="cp">#define bna_intx_enable(bna, new_mask)					\</span>
<span class="cp">	writel((new_mask), (bna)-&gt;regs.fn_int_mask)</span>
<span class="cp">#define bna_mbox_intr_disable(bna)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	u32 mask;							\</span>
<span class="cp">	mask = readl((bna)-&gt;regs.fn_int_mask);				\</span>
<span class="cp">	writel((mask | (bna)-&gt;bits.mbox_mask_bits |			\</span>
<span class="cp">		(bna)-&gt;bits.error_mask_bits), (bna)-&gt;regs.fn_int_mask); \</span>
<span class="cp">	mask = readl((bna)-&gt;regs.fn_int_mask);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define bna_mbox_intr_enable(bna)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	u32 mask;							\</span>
<span class="cp">	mask = readl((bna)-&gt;regs.fn_int_mask);				\</span>
<span class="cp">	writel((mask &amp; ~((bna)-&gt;bits.mbox_mask_bits |			\</span>
<span class="cp">		(bna)-&gt;bits.error_mask_bits)), (bna)-&gt;regs.fn_int_mask);\</span>
<span class="cp">	mask = readl((bna)-&gt;regs.fn_int_mask);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define bna_intr_status_get(_bna, _status)				\</span>
<span class="cp">{									\</span>
<span class="cp">	(_status) = readl((_bna)-&gt;regs.fn_int_status);			\</span>
<span class="cp">	if (_status) {							\</span>
<span class="cp">		writel(((_status) &amp; ~(_bna)-&gt;bits.mbox_status_bits),	\</span>
<span class="cp">			(_bna)-&gt;regs.fn_int_status);			\</span>
<span class="cp">	}								\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * MAX ACK EVENTS : No. of acks that can be accumulated in driver,</span>
<span class="cm"> * before acking to h/w. The no. of bits is 16 in the doorbell register,</span>
<span class="cm"> * however we keep this limited to 15 bits.</span>
<span class="cm"> * This is because around the edge of 64K boundary (16 bits), one</span>
<span class="cm"> * single poll can make the accumulated ACK counter cross the 64K boundary,</span>
<span class="cm"> * causing problems, when we try to ack with a value greater than 64K.</span>
<span class="cm"> * 15 bits (32K) should  be large enough to accumulate, anyways, and the max.</span>
<span class="cm"> * acked events to h/w can be (32K + max poll weight) (currently 64).</span>
<span class="cm"> */</span>
<span class="cp">#define	BNA_IB_MAX_ACK_EVENTS		(1 &lt;&lt; 15)</span>

<span class="cm">/* These macros build the data portion of the TxQ/RxQ doorbell */</span>
<span class="cp">#define BNA_DOORBELL_Q_PRD_IDX(_pi)	(0x80000000 | (_pi))</span>
<span class="cp">#define BNA_DOORBELL_Q_STOP		(0x40000000)</span>

<span class="cm">/* These macros build the data portion of the IB doorbell */</span>
<span class="cp">#define BNA_DOORBELL_IB_INT_ACK(_timeout, _events)			\</span>
<span class="cp">	(0x80000000 | ((_timeout) &lt;&lt; 16) | (_events))</span>
<span class="cp">#define BNA_DOORBELL_IB_INT_DISABLE	(0x40000000)</span>

<span class="cm">/* Set the coalescing timer for the given ib */</span>
<span class="cp">#define bna_ib_coalescing_timer_set(_i_dbell, _cls_timer)		\</span>
<span class="cp">	((_i_dbell)-&gt;doorbell_ack = BNA_DOORBELL_IB_INT_ACK((_cls_timer), 0));</span>

<span class="cm">/* Acks &#39;events&#39; # of events for a given ib while disabling interrupts */</span>
<span class="cp">#define bna_ib_ack_disable_irq(_i_dbell, _events)			\</span>
<span class="cp">	(writel(BNA_DOORBELL_IB_INT_ACK(0, (_events)), \</span>
<span class="cp">		(_i_dbell)-&gt;doorbell_addr));</span>

<span class="cm">/* Acks &#39;events&#39; # of events for a given ib */</span>
<span class="cp">#define bna_ib_ack(_i_dbell, _events)					\</span>
<span class="cp">	(writel(((_i_dbell)-&gt;doorbell_ack | (_events)), \</span>
<span class="cp">		(_i_dbell)-&gt;doorbell_addr));</span>

<span class="cp">#define bna_ib_start(_bna, _ib, _is_regular)				\</span>
<span class="cp">{									\</span>
<span class="cp">	u32 intx_mask;						\</span>
<span class="cp">	struct bna_ib *ib = _ib;					\</span>
<span class="cp">	if ((ib-&gt;intr_type == BNA_INTR_T_INTX)) {			\</span>
<span class="cp">		bna_intx_disable((_bna), intx_mask);			\</span>
<span class="cp">		intx_mask &amp;= ~(ib-&gt;intr_vector);			\</span>
<span class="cp">		bna_intx_enable((_bna), intx_mask);			\</span>
<span class="cp">	}								\</span>
<span class="cp">	bna_ib_coalescing_timer_set(&amp;ib-&gt;door_bell,			\</span>
<span class="cp">			ib-&gt;coalescing_timeo);				\</span>
<span class="cp">	if (_is_regular)						\</span>
<span class="cp">		bna_ib_ack(&amp;ib-&gt;door_bell, 0);				\</span>
<span class="cp">}</span>

<span class="cp">#define bna_ib_stop(_bna, _ib)						\</span>
<span class="cp">{									\</span>
<span class="cp">	u32 intx_mask;						\</span>
<span class="cp">	struct bna_ib *ib = _ib;					\</span>
<span class="cp">	writel(BNA_DOORBELL_IB_INT_DISABLE,				\</span>
<span class="cp">		ib-&gt;door_bell.doorbell_addr);				\</span>
<span class="cp">	if (ib-&gt;intr_type == BNA_INTR_T_INTX) {				\</span>
<span class="cp">		bna_intx_disable((_bna), intx_mask);			\</span>
<span class="cp">		intx_mask |= ib-&gt;intr_vector;				\</span>
<span class="cp">		bna_intx_enable((_bna), intx_mask);			\</span>
<span class="cp">	}								\</span>
<span class="cp">}</span>

<span class="cp">#define bna_txq_prod_indx_doorbell(_tcb)				\</span>
<span class="cp">	(writel(BNA_DOORBELL_Q_PRD_IDX((_tcb)-&gt;producer_index), \</span>
<span class="cp">		(_tcb)-&gt;q_dbell));</span>

<span class="cp">#define bna_rxq_prod_indx_doorbell(_rcb)				\</span>
<span class="cp">	(writel(BNA_DOORBELL_Q_PRD_IDX((_rcb)-&gt;producer_index), \</span>
<span class="cp">		(_rcb)-&gt;q_dbell));</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * TxQ, RxQ, CQ related bits, offsets, macros</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/* TxQ Entry Opcodes */</span>
<span class="cp">#define BNA_TXQ_WI_SEND			(0x402)	</span><span class="cm">/* Single Frame Transmission */</span><span class="cp"></span>
<span class="cp">#define BNA_TXQ_WI_SEND_LSO		(0x403)	</span><span class="cm">/* Multi-Frame Transmission */</span><span class="cp"></span>
<span class="cp">#define BNA_TXQ_WI_EXTENSION		(0x104)	</span><span class="cm">/* Extension WI */</span><span class="cp"></span>

<span class="cm">/* TxQ Entry Control Flags */</span>
<span class="cp">#define BNA_TXQ_WI_CF_FCOE_CRC		(1 &lt;&lt; 8)</span>
<span class="cp">#define BNA_TXQ_WI_CF_IPID_MODE		(1 &lt;&lt; 5)</span>
<span class="cp">#define BNA_TXQ_WI_CF_INS_PRIO		(1 &lt;&lt; 4)</span>
<span class="cp">#define BNA_TXQ_WI_CF_INS_VLAN		(1 &lt;&lt; 3)</span>
<span class="cp">#define BNA_TXQ_WI_CF_UDP_CKSUM		(1 &lt;&lt; 2)</span>
<span class="cp">#define BNA_TXQ_WI_CF_TCP_CKSUM		(1 &lt;&lt; 1)</span>
<span class="cp">#define BNA_TXQ_WI_CF_IP_CKSUM		(1 &lt;&lt; 0)</span>

<span class="cp">#define BNA_TXQ_WI_L4_HDR_N_OFFSET(_hdr_size, _offset) \</span>
<span class="cp">		(((_hdr_size) &lt;&lt; 10) | ((_offset) &amp; 0x3FF))</span>

<span class="cm">/*</span>
<span class="cm"> * Completion Q defines</span>
<span class="cm"> */</span>
<span class="cm">/* CQ Entry Flags */</span>
<span class="cp">#define	BNA_CQ_EF_MAC_ERROR	(1 &lt;&lt;  0)</span>
<span class="cp">#define	BNA_CQ_EF_FCS_ERROR	(1 &lt;&lt;  1)</span>
<span class="cp">#define	BNA_CQ_EF_TOO_LONG	(1 &lt;&lt;  2)</span>
<span class="cp">#define	BNA_CQ_EF_FC_CRC_OK	(1 &lt;&lt;  3)</span>

<span class="cp">#define	BNA_CQ_EF_RSVD1		(1 &lt;&lt;  4)</span>
<span class="cp">#define	BNA_CQ_EF_L4_CKSUM_OK	(1 &lt;&lt;  5)</span>
<span class="cp">#define	BNA_CQ_EF_L3_CKSUM_OK	(1 &lt;&lt;  6)</span>
<span class="cp">#define	BNA_CQ_EF_HDS_HEADER	(1 &lt;&lt;  7)</span>

<span class="cp">#define	BNA_CQ_EF_UDP		(1 &lt;&lt;  8)</span>
<span class="cp">#define	BNA_CQ_EF_TCP		(1 &lt;&lt;  9)</span>
<span class="cp">#define	BNA_CQ_EF_IP_OPTIONS	(1 &lt;&lt; 10)</span>
<span class="cp">#define	BNA_CQ_EF_IPV6		(1 &lt;&lt; 11)</span>

<span class="cp">#define	BNA_CQ_EF_IPV4		(1 &lt;&lt; 12)</span>
<span class="cp">#define	BNA_CQ_EF_VLAN		(1 &lt;&lt; 13)</span>
<span class="cp">#define	BNA_CQ_EF_RSS		(1 &lt;&lt; 14)</span>
<span class="cp">#define	BNA_CQ_EF_RSVD2		(1 &lt;&lt; 15)</span>

<span class="cp">#define	BNA_CQ_EF_MCAST_MATCH   (1 &lt;&lt; 16)</span>
<span class="cp">#define	BNA_CQ_EF_MCAST		(1 &lt;&lt; 17)</span>
<span class="cp">#define BNA_CQ_EF_BCAST		(1 &lt;&lt; 18)</span>
<span class="cp">#define	BNA_CQ_EF_REMOTE	(1 &lt;&lt; 19)</span>

<span class="cp">#define	BNA_CQ_EF_LOCAL		(1 &lt;&lt; 20)</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * Data structures</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">bna_reg_offset</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">fn_int_status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fn_int_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bna_bit_defn</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">mbox_status_bits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mbox_mask_bits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">error_status_bits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">error_mask_bits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">halt_status_bits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">halt_mask_bits</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bna_reg</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">fn_int_status</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">fn_int_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* TxQ Vector (a.k.a. Tx-Buffer Descriptor) */</span>
<span class="k">struct</span> <span class="n">bna_dma_addr</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">msb</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">lsb</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bna_txq_wi_vector</span> <span class="p">{</span>
	<span class="n">u16</span>		<span class="n">reserved</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">length</span><span class="p">;</span>		<span class="cm">/* Only 14 LSB are valid */</span>
	<span class="k">struct</span> <span class="n">bna_dma_addr</span> <span class="n">host_addr</span><span class="p">;</span> <span class="cm">/* Tx-Buf DMA addr */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *  TxQ Entry Structure</span>
<span class="cm"> *</span>
<span class="cm"> *  BEWARE:  Load values into this structure with correct endianess.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bna_txq_entry</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">num_vectors</span><span class="p">;</span>	<span class="cm">/* number of vectors present */</span>
			<span class="n">u16</span> <span class="n">opcode</span><span class="p">;</span> <span class="cm">/* Either */</span>
						    <span class="cm">/* BNA_TXQ_WI_SEND or */</span>
						    <span class="cm">/* BNA_TXQ_WI_SEND_LSO */</span>
			<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* OR of all the flags */</span>
			<span class="n">u16</span> <span class="n">l4_hdr_size_n_offset</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">vlan_tag</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">lso_mss</span><span class="p">;</span>	<span class="cm">/* Only 14 LSB are valid */</span>
			<span class="n">u32</span> <span class="n">frame_length</span><span class="p">;</span>	<span class="cm">/* Only 24 LSB are valid */</span>
		<span class="p">}</span> <span class="n">wi</span><span class="p">;</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">reserved</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">opcode</span><span class="p">;</span> <span class="cm">/* Must be */</span>
						    <span class="cm">/* BNA_TXQ_WI_EXTENSION */</span>
			<span class="n">u32</span> <span class="n">reserved2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* Place holder for */</span>
						<span class="cm">/* removed vector (12 bytes) */</span>
		<span class="p">}</span> <span class="n">wi_ext</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bna_txq_wi_vector</span> <span class="n">vector</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* RxQ Entry Structure */</span>
<span class="k">struct</span> <span class="n">bna_rxq_entry</span> <span class="p">{</span>		<span class="cm">/* Rx-Buffer */</span>
	<span class="k">struct</span> <span class="n">bna_dma_addr</span> <span class="n">host_addr</span><span class="p">;</span> <span class="cm">/* Rx-Buffer DMA address */</span>
<span class="p">};</span>

<span class="cm">/* CQ Entry Structure */</span>
<span class="k">struct</span> <span class="n">bna_cq_entry</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vlan_tag</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rss_hash</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">valid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rxq_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* __BNA_HW_DEFS_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
