<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › marvell › pxa168_eth.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pxa168_eth.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PXA168 ethernet driver.</span>
<span class="cm"> * Most of the code is derived from mv643xx ethernet driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010 Marvell International Ltd.</span>
<span class="cm"> *		Sachin Sanap &lt;ssanap@marvell.com&gt;</span>
<span class="cm"> *		Zhangfei Gao &lt;zgao6@marvell.com&gt;</span>
<span class="cm"> *		Philip Rakity &lt;prakity@marvell.com&gt;</span>
<span class="cm"> *		Mark Brown &lt;markb@marvell.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version 2</span>
<span class="cm"> * of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/udp.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/phy.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;linux/pxa168_eth.h&gt;</span>

<span class="cp">#define DRIVER_NAME	&quot;pxa168-eth&quot;</span>
<span class="cp">#define DRIVER_VERSION	&quot;0.3&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Registers</span>
<span class="cm"> */</span>

<span class="cp">#define PHY_ADDRESS		0x0000</span>
<span class="cp">#define SMI			0x0010</span>
<span class="cp">#define PORT_CONFIG		0x0400</span>
<span class="cp">#define PORT_CONFIG_EXT		0x0408</span>
<span class="cp">#define PORT_COMMAND		0x0410</span>
<span class="cp">#define PORT_STATUS		0x0418</span>
<span class="cp">#define HTPR			0x0428</span>
<span class="cp">#define SDMA_CONFIG		0x0440</span>
<span class="cp">#define SDMA_CMD		0x0448</span>
<span class="cp">#define INT_CAUSE		0x0450</span>
<span class="cp">#define INT_W_CLEAR		0x0454</span>
<span class="cp">#define INT_MASK		0x0458</span>
<span class="cp">#define ETH_F_RX_DESC_0		0x0480</span>
<span class="cp">#define ETH_C_RX_DESC_0		0x04A0</span>
<span class="cp">#define ETH_C_TX_DESC_1		0x04E4</span>

<span class="cm">/* smi register */</span>
<span class="cp">#define SMI_BUSY		(1 &lt;&lt; 28)	</span><span class="cm">/* 0 - Write, 1 - Read  */</span><span class="cp"></span>
<span class="cp">#define SMI_R_VALID		(1 &lt;&lt; 27)	</span><span class="cm">/* 0 - Write, 1 - Read  */</span><span class="cp"></span>
<span class="cp">#define SMI_OP_W		(0 &lt;&lt; 26)	</span><span class="cm">/* Write operation      */</span><span class="cp"></span>
<span class="cp">#define SMI_OP_R		(1 &lt;&lt; 26)	</span><span class="cm">/* Read operation */</span><span class="cp"></span>

<span class="cp">#define PHY_WAIT_ITERATIONS	10</span>

<span class="cp">#define PXA168_ETH_PHY_ADDR_DEFAULT	0</span>
<span class="cm">/* RX &amp; TX descriptor command */</span>
<span class="cp">#define BUF_OWNED_BY_DMA	(1 &lt;&lt; 31)</span>

<span class="cm">/* RX descriptor status */</span>
<span class="cp">#define RX_EN_INT		(1 &lt;&lt; 23)</span>
<span class="cp">#define RX_FIRST_DESC		(1 &lt;&lt; 17)</span>
<span class="cp">#define RX_LAST_DESC		(1 &lt;&lt; 16)</span>
<span class="cp">#define RX_ERROR		(1 &lt;&lt; 15)</span>

<span class="cm">/* TX descriptor command */</span>
<span class="cp">#define TX_EN_INT		(1 &lt;&lt; 23)</span>
<span class="cp">#define TX_GEN_CRC		(1 &lt;&lt; 22)</span>
<span class="cp">#define TX_ZERO_PADDING		(1 &lt;&lt; 18)</span>
<span class="cp">#define TX_FIRST_DESC		(1 &lt;&lt; 17)</span>
<span class="cp">#define TX_LAST_DESC		(1 &lt;&lt; 16)</span>
<span class="cp">#define TX_ERROR		(1 &lt;&lt; 15)</span>

<span class="cm">/* SDMA_CMD */</span>
<span class="cp">#define SDMA_CMD_AT		(1 &lt;&lt; 31)</span>
<span class="cp">#define SDMA_CMD_TXDL		(1 &lt;&lt; 24)</span>
<span class="cp">#define SDMA_CMD_TXDH		(1 &lt;&lt; 23)</span>
<span class="cp">#define SDMA_CMD_AR		(1 &lt;&lt; 15)</span>
<span class="cp">#define SDMA_CMD_ERD		(1 &lt;&lt; 7)</span>

<span class="cm">/* Bit definitions of the Port Config Reg */</span>
<span class="cp">#define PCR_HS			(1 &lt;&lt; 12)</span>
<span class="cp">#define PCR_EN			(1 &lt;&lt; 7)</span>
<span class="cp">#define PCR_PM			(1 &lt;&lt; 0)</span>

<span class="cm">/* Bit definitions of the Port Config Extend Reg */</span>
<span class="cp">#define PCXR_2BSM		(1 &lt;&lt; 28)</span>
<span class="cp">#define PCXR_DSCP_EN		(1 &lt;&lt; 21)</span>
<span class="cp">#define PCXR_MFL_1518		(0 &lt;&lt; 14)</span>
<span class="cp">#define PCXR_MFL_1536		(1 &lt;&lt; 14)</span>
<span class="cp">#define PCXR_MFL_2048		(2 &lt;&lt; 14)</span>
<span class="cp">#define PCXR_MFL_64K		(3 &lt;&lt; 14)</span>
<span class="cp">#define PCXR_FLP		(1 &lt;&lt; 11)</span>
<span class="cp">#define PCXR_PRIO_TX_OFF	3</span>
<span class="cp">#define PCXR_TX_HIGH_PRI	(7 &lt;&lt; PCXR_PRIO_TX_OFF)</span>

<span class="cm">/* Bit definitions of the SDMA Config Reg */</span>
<span class="cp">#define SDCR_BSZ_OFF		12</span>
<span class="cp">#define SDCR_BSZ8		(3 &lt;&lt; SDCR_BSZ_OFF)</span>
<span class="cp">#define SDCR_BSZ4		(2 &lt;&lt; SDCR_BSZ_OFF)</span>
<span class="cp">#define SDCR_BSZ2		(1 &lt;&lt; SDCR_BSZ_OFF)</span>
<span class="cp">#define SDCR_BSZ1		(0 &lt;&lt; SDCR_BSZ_OFF)</span>
<span class="cp">#define SDCR_BLMR		(1 &lt;&lt; 6)</span>
<span class="cp">#define SDCR_BLMT		(1 &lt;&lt; 7)</span>
<span class="cp">#define SDCR_RIFB		(1 &lt;&lt; 9)</span>
<span class="cp">#define SDCR_RC_OFF		2</span>
<span class="cp">#define SDCR_RC_MAX_RETRANS	(0xf &lt;&lt; SDCR_RC_OFF)</span>

<span class="cm">/*</span>
<span class="cm"> * Bit definitions of the Interrupt Cause Reg</span>
<span class="cm"> * and Interrupt MASK Reg is the same</span>
<span class="cm"> */</span>
<span class="cp">#define ICR_RXBUF		(1 &lt;&lt; 0)</span>
<span class="cp">#define ICR_TXBUF_H		(1 &lt;&lt; 2)</span>
<span class="cp">#define ICR_TXBUF_L		(1 &lt;&lt; 3)</span>
<span class="cp">#define ICR_TXEND_H		(1 &lt;&lt; 6)</span>
<span class="cp">#define ICR_TXEND_L		(1 &lt;&lt; 7)</span>
<span class="cp">#define ICR_RXERR		(1 &lt;&lt; 8)</span>
<span class="cp">#define ICR_TXERR_H		(1 &lt;&lt; 10)</span>
<span class="cp">#define ICR_TXERR_L		(1 &lt;&lt; 11)</span>
<span class="cp">#define ICR_TX_UDR		(1 &lt;&lt; 13)</span>
<span class="cp">#define ICR_MII_CH		(1 &lt;&lt; 28)</span>

<span class="cp">#define ALL_INTS (ICR_TXBUF_H  | ICR_TXBUF_L  | ICR_TX_UDR |\</span>
<span class="cp">				ICR_TXERR_H  | ICR_TXERR_L |\</span>
<span class="cp">				ICR_TXEND_H  | ICR_TXEND_L |\</span>
<span class="cp">				ICR_RXBUF | ICR_RXERR  | ICR_MII_CH)</span>

<span class="cp">#define ETH_HW_IP_ALIGN		2	</span><span class="cm">/* hw aligns IP header */</span><span class="cp"></span>

<span class="cp">#define NUM_RX_DESCS		64</span>
<span class="cp">#define NUM_TX_DESCS		64</span>

<span class="cp">#define HASH_ADD		0</span>
<span class="cp">#define HASH_DELETE		1</span>
<span class="cp">#define HASH_ADDR_TABLE_SIZE	0x4000	</span><span class="cm">/* 16K (1/2K address - PCR_HS == 1) */</span><span class="cp"></span>
<span class="cp">#define HOP_NUMBER		12</span>

<span class="cm">/* Bit definitions for Port status */</span>
<span class="cp">#define PORT_SPEED_100		(1 &lt;&lt; 0)</span>
<span class="cp">#define FULL_DUPLEX		(1 &lt;&lt; 1)</span>
<span class="cp">#define FLOW_CONTROL_ENABLED	(1 &lt;&lt; 2)</span>
<span class="cp">#define LINK_UP			(1 &lt;&lt; 3)</span>

<span class="cm">/* Bit definitions for work to be done */</span>
<span class="cp">#define WORK_LINK		(1 &lt;&lt; 0)</span>
<span class="cp">#define WORK_TX_DONE		(1 &lt;&lt; 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Misc definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define SKB_DMA_REALIGN		((PAGE_SIZE - NET_SKB_PAD) % SMP_CACHE_BYTES)</span>

<span class="k">struct</span> <span class="n">rx_desc</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">cmd_sts</span><span class="p">;</span>		<span class="cm">/* Descriptor command status            */</span>
	<span class="n">u16</span> <span class="n">byte_cnt</span><span class="p">;</span>		<span class="cm">/* Descriptor buffer byte count         */</span>
	<span class="n">u16</span> <span class="n">buf_size</span><span class="p">;</span>		<span class="cm">/* Buffer size                          */</span>
	<span class="n">u32</span> <span class="n">buf_ptr</span><span class="p">;</span>		<span class="cm">/* Descriptor buffer pointer            */</span>
	<span class="n">u32</span> <span class="n">next_desc_ptr</span><span class="p">;</span>	<span class="cm">/* Next descriptor pointer              */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tx_desc</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">cmd_sts</span><span class="p">;</span>		<span class="cm">/* Command/status field                 */</span>
	<span class="n">u16</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">byte_cnt</span><span class="p">;</span>		<span class="cm">/* buffer byte count                    */</span>
	<span class="n">u32</span> <span class="n">buf_ptr</span><span class="p">;</span>		<span class="cm">/* pointer to buffer for this descriptor */</span>
	<span class="n">u32</span> <span class="n">next_desc_ptr</span><span class="p">;</span>	<span class="cm">/* Pointer to next descriptor           */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">port_num</span><span class="p">;</span>		<span class="cm">/* User Ethernet port number    */</span>

	<span class="kt">int</span> <span class="n">rx_resource_err</span><span class="p">;</span>	<span class="cm">/* Rx ring resource error flag */</span>

	<span class="cm">/* Next available and first returning Rx resource */</span>
	<span class="kt">int</span> <span class="n">rx_curr_desc_q</span><span class="p">,</span> <span class="n">rx_used_desc_q</span><span class="p">;</span>

	<span class="cm">/* Next available and first returning Tx resource */</span>
	<span class="kt">int</span> <span class="n">tx_curr_desc_q</span><span class="p">,</span> <span class="n">tx_used_desc_q</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">p_rx_desc_area</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rx_desc_dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_desc_area_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">rx_skb</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">p_tx_desc_area</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_desc_dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_desc_area_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">tx_skb</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">tx_timeout_task</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">work_todo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skb_size</span><span class="p">;</span>

	<span class="cm">/* Size of Tx Ring per queue */</span>
	<span class="kt">int</span> <span class="n">tx_ring_size</span><span class="p">;</span>
	<span class="cm">/* Number of tx descriptors in use */</span>
	<span class="kt">int</span> <span class="n">tx_desc_count</span><span class="p">;</span>
	<span class="cm">/* Size of Rx Ring per queue */</span>
	<span class="kt">int</span> <span class="n">rx_ring_size</span><span class="p">;</span>
	<span class="cm">/* Number of rx descriptors in use */</span>
	<span class="kt">int</span> <span class="n">rx_desc_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Used in case RX Ring is empty, which can occur when</span>
<span class="cm">	 * system does not have resources (skb&#39;s)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">smi_bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phy</span><span class="p">;</span>

	<span class="cm">/* clock */</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_platform_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ethernet controller base address.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="cm">/* Pointer to the hardware address filter table */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">htpr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">htpr_dma</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">addr_table_entry</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">lo</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">hi</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Bit fields of a Hash Table Entry */</span>
<span class="k">enum</span> <span class="n">hash_table_entry</span> <span class="p">{</span>
	<span class="n">HASH_ENTRY_VALID</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SKIP</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">HASH_ENTRY_RECEIVE_DISCARD</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">HASH_ENTRY_RECEIVE_DISCARD_BIT</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pxa168_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pxa168_set_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pxa168_init_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">eth_port_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">eth_port_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pxa168_eth_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pxa168_eth_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ethernet_phy_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">rdl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">abort_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">delay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_retries</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">SDMA_CMD</span><span class="p">,</span> <span class="n">SDMA_CMD_AR</span> <span class="o">|</span> <span class="n">SDMA_CMD_AT</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

		<span class="n">delay</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">SDMA_CMD</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SDMA_CMD_AR</span> <span class="o">|</span> <span class="n">SDMA_CMD_AT</span><span class="p">))</span>
		       <span class="o">&amp;&amp;</span> <span class="n">delay</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">max_retries</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">delay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_retries</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s : DMA Stuck</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ethernet_phy_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg_data</span><span class="p">;</span>

	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">PHY_ADDRESS</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">reg_data</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">port_num</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ethernet_phy_set_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr_shift</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">port_num</span><span class="p">;</span>

	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">PHY_ADDRESS</span><span class="p">);</span>
	<span class="n">reg_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1f</span> <span class="o">&lt;&lt;</span> <span class="n">addr_shift</span><span class="p">);</span>
	<span class="n">reg_data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">phy_addr</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">addr_shift</span><span class="p">;</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">PHY_ADDRESS</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ethernet_phy_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">phy_read</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">|=</span> <span class="n">BMCR_RESET</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy_write</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">phy_read</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="n">BMCR_RESET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rxq_refill</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">p_used_rx_desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used_rx_desc</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_count</span> <span class="o">&lt;</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">skb_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SKB_DMA_REALIGN</span><span class="p">)</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">SKB_DMA_REALIGN</span><span class="p">);</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_count</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Get &#39;used&#39; Rx descriptor */</span>
		<span class="n">used_rx_desc</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_used_desc_q</span><span class="p">;</span>
		<span class="n">p_used_rx_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_rx_desc_area</span><span class="p">[</span><span class="n">used_rx_desc</span><span class="p">];</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">p_used_rx_desc</span><span class="o">-&gt;</span><span class="n">buf_ptr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
							 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
							 <span class="n">size</span><span class="p">,</span>
							 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">p_used_rx_desc</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">[</span><span class="n">used_rx_desc</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

		<span class="cm">/* Return the descriptor to DMA ownership */</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">p_used_rx_desc</span><span class="o">-&gt;</span><span class="n">cmd_sts</span> <span class="o">=</span> <span class="n">BUF_OWNED_BY_DMA</span> <span class="o">|</span> <span class="n">RX_EN_INT</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>

		<span class="cm">/* Move the used descriptor pointer to the next descriptor */</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_used_desc_q</span> <span class="o">=</span> <span class="p">(</span><span class="n">used_rx_desc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span>

		<span class="cm">/* Any Rx return cancels the Rx resource error status */</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_resource_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HW_IP_ALIGN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If RX ring is empty of SKB, set a timer to try allocating</span>
<span class="cm">	 * again at a later time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rxq_refill_timer_wrapper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">flip_8_bits</span><span class="p">(</span><span class="n">u8</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nibble_swap_every_byte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ETH_ALEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">((</span><span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inverse_every_nibble</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ETH_ALEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">flip_8_bits</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ----------------------------------------------------------------------------</span>
<span class="cm"> * This function will calculate the hash function of the address.</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * mac_addr_orig    - MAC address.</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * return the calculated entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">hash_function</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mac_addr_orig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hash_result</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mac_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="cm">/* Make a copy of MAC address since we are going to performe bit</span>
<span class="cm">	 * operations on it</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">mac_addr_orig</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">nibble_swap_every_byte</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">);</span>
	<span class="n">inverse_every_nibble</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">);</span>

	<span class="n">addr0</span> <span class="o">=</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
	<span class="n">addr1</span> <span class="o">=</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">addr2</span> <span class="o">=</span> <span class="p">((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">|</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">addr3</span> <span class="o">=</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">hash_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr0</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">addr1</span> <span class="o">^</span> <span class="n">addr2</span> <span class="o">^</span> <span class="n">addr3</span><span class="p">);</span>
	<span class="n">hash_result</span> <span class="o">=</span> <span class="n">hash_result</span> <span class="o">&amp;</span> <span class="mh">0x07ff</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hash_result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ----------------------------------------------------------------------------</span>
<span class="cm"> * This function will add/del an entry to the address table.</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * pep - ETHERNET .</span>
<span class="cm"> * mac_addr - MAC address.</span>
<span class="cm"> * skip - if 1, skip this address.Used in case of deleting an entry which is a</span>
<span class="cm"> *	  part of chain in the hash table.We can&#39;t just delete the entry since</span>
<span class="cm"> *	  that will break the chain.We need to defragment the tables time to</span>
<span class="cm"> *	  time.</span>
<span class="cm"> * rd   - 0 Discard packet upon match.</span>
<span class="cm"> *	- 1 Receive packet upon match.</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * address table entry is added/deleted.</span>
<span class="cm"> * 0 if success.</span>
<span class="cm"> * -ENOSPC if table full</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_del_hash_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">rd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">skip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">del</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">addr_table_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_high</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_low</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">new_low</span> <span class="o">=</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(</span><span class="n">skip</span> <span class="o">&lt;&lt;</span> <span class="n">SKIP</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">rd</span> <span class="o">&lt;&lt;</span> <span class="n">HASH_ENTRY_RECEIVE_DISCARD_BIT</span><span class="p">)</span>
	    <span class="o">|</span> <span class="n">HASH_ENTRY_VALID</span><span class="p">;</span>

	<span class="n">new_high</span> <span class="o">=</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
	    <span class="o">|</span> <span class="p">(((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pick the appropriate table, start scanning for free/reusable</span>
<span class="cm">	 * entries at the index obtained by hashing the specified MAC address</span>
<span class="cm">	 */</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">hash_function</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HOP_NUMBER</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">lo</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HASH_ENTRY_VALID</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* if same address put in same position */</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">lo</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffffff8</span><span class="p">)</span> <span class="o">==</span>
				<span class="p">(</span><span class="n">new_low</span> <span class="o">&amp;</span> <span class="mh">0xfffffff8</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hi</span><span class="p">)</span> <span class="o">==</span> <span class="n">new_high</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="n">start</span> <span class="o">+</span> <span class="mh">0x7ff</span><span class="p">)</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">entry</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">lo</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffffff8</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">new_low</span> <span class="o">&amp;</span> <span class="mh">0xfffffff8</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hi</span><span class="p">)</span> <span class="o">!=</span> <span class="n">new_high</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">del</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">HOP_NUMBER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">del</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: table section is full, need to &quot;</span>
					<span class="s">&quot;move to 16kB implementation?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">__FILE__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the selected entry</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">del</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_high</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_low</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ----------------------------------------------------------------------------</span>
<span class="cm"> *  Create an addressTable entry from MAC address info</span>
<span class="cm"> *  found in the specifed net_device struct</span>
<span class="cm"> *</span>
<span class="cm"> *  Input : pointer to ethernet interface network device structure</span>
<span class="cm"> *  Output : N/A</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_hash_table_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oaddr</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Delete old entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oaddr</span><span class="p">)</span>
		<span class="n">add_del_hash_entry</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">oaddr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HASH_DELETE</span><span class="p">);</span>
	<span class="cm">/* Add new entry */</span>
	<span class="n">add_del_hash_entry</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HASH_ADD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_hash_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hardware expects CPU to build a hash table based on a predefined</span>
<span class="cm">	 * hash function and populate it based on hardware address. The</span>
<span class="cm">	 * location of the hash table is identified by 32-bit pointer stored</span>
<span class="cm">	 * in HTPR internal register. Two possible sizes exists for the hash</span>
<span class="cm">	 * table 8kB (256kB of DRAM required (4 x 64 kB banks)) and 1/2kB</span>
<span class="cm">	 * (16kB of DRAM required (4 x 4 kB banks)).We currently only support</span>
<span class="cm">	 * 1/2kB.</span>
<span class="cm">	 */</span>
	<span class="cm">/* TODO: Add support for 8kB hash table and alternative hash</span>
<span class="cm">	 * function.Driver can dynamically switch to them if the 1/2kB hash</span>
<span class="cm">	 * table is full.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
					      <span class="n">HASH_ADDR_TABLE_SIZE</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HASH_ADDR_TABLE_SIZE</span><span class="p">);</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">HTPR</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr_dma</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa168_eth_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">PORT_CONFIG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">PCR_PM</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCR_PM</span><span class="p">;</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">PORT_CONFIG</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove the old list of MAC address and add dev-&gt;addr</span>
<span class="cm">	 * and multicast address.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HASH_ADDR_TABLE_SIZE</span><span class="p">);</span>
	<span class="n">update_hash_table_mac_address</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
		<span class="n">update_hash_table_mac_address</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_eth_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">oldMac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">oldMac</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_assign_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NET_ADDR_RANDOM</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">netif_addr_lock_bh</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">update_hash_table_mac_address</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">oldMac</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="n">netif_addr_unlock_bh</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">eth_port_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">tx_curr_desc</span><span class="p">,</span> <span class="n">rx_curr_desc</span><span class="p">;</span>

	<span class="cm">/* Perform PHY reset, if there is a PHY. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="n">cmd</span><span class="p">;</span>

		<span class="n">pxa168_get_settings</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">ethernet_phy_reset</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>
		<span class="n">pxa168_set_settings</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Assignment of Tx CTRP of given queue */</span>
	<span class="n">tx_curr_desc</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_curr_desc_q</span><span class="p">;</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">ETH_C_TX_DESC_1</span><span class="p">,</span>
	    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_dma</span> <span class="o">+</span> <span class="n">tx_curr_desc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">)));</span>

	<span class="cm">/* Assignment of Rx CRDP of given queue */</span>
	<span class="n">rx_curr_desc</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_curr_desc_q</span><span class="p">;</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">ETH_C_RX_DESC_0</span><span class="p">,</span>
	    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_dma</span> <span class="o">+</span> <span class="n">rx_curr_desc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">)));</span>

	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">ETH_F_RX_DESC_0</span><span class="p">,</span>
	    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_dma</span> <span class="o">+</span> <span class="n">rx_curr_desc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">)));</span>

	<span class="cm">/* Clear all interrupts */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_CAUSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Enable all interrupts for receive, transmit and error. */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_MASK</span><span class="p">,</span> <span class="n">ALL_INTS</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">PORT_CONFIG</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">PCR_EN</span><span class="p">;</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">PORT_CONFIG</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* Start RX DMA engine */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">SDMA_CMD</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">SDMA_CMD_ERD</span><span class="p">;</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">SDMA_CMD</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">eth_port_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Stop all interrupts for receive, transmit and error. */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Clear all interrupts */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_CAUSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Stop RX DMA */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">SDMA_CMD</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SDMA_CMD_ERD</span><span class="p">;</span>	<span class="cm">/* abort dma command */</span>

	<span class="cm">/* Abort any transmit and receive operations and put DMA</span>
<span class="cm">	 * in idle state.</span>
<span class="cm">	 */</span>
	<span class="n">abort_dma</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>

	<span class="cm">/* Disable port */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">PORT_CONFIG</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCR_EN</span><span class="p">;</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">PORT_CONFIG</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * txq_reclaim - Free the tx desc data for completed descriptors</span>
<span class="cm"> * If force is non-zero, frees uncompleted descriptors as well</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">txq_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd_sts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_index</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">released</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netif_tx_lock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">work_todo</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">WORK_TX_DONE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_index</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_used_desc_q</span><span class="p">;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_tx_desc_area</span><span class="p">[</span><span class="n">tx_index</span><span class="p">];</span>
		<span class="n">cmd_sts</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">cmd_sts</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">force</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd_sts</span> <span class="o">&amp;</span> <span class="n">BUF_OWNED_BY_DMA</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">released</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">txq_reclaim_end</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">released</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">txq_reclaim_end</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_used_desc_q</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">buf_ptr</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">byte_cnt</span><span class="p">;</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">[</span><span class="n">tx_index</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">[</span><span class="n">tx_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_sts</span> <span class="o">&amp;</span> <span class="n">TX_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Error in TX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">released</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">txq_reclaim_end:</span>
	<span class="n">netif_tx_unlock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">released</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa168_eth_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: TX timeout  desc_count %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_count</span><span class="p">);</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_timeout_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa168_eth_tx_timeout_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">pxa168_eth_private</span><span class="p">,</span>
						 <span class="n">tx_timeout_task</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">pxa168_eth_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pxa168_eth_open</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rxq_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">received_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">budget</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rx_next_curr_desc</span><span class="p">,</span> <span class="n">rx_curr_desc</span><span class="p">,</span> <span class="n">rx_used_desc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_sts</span><span class="p">;</span>

		<span class="cm">/* Do not process Rx ring in case of Rx ring resource error */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_resource_err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">rx_curr_desc</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_curr_desc_q</span><span class="p">;</span>
		<span class="n">rx_used_desc</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_used_desc_q</span><span class="p">;</span>
		<span class="n">rx_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_rx_desc_area</span><span class="p">[</span><span class="n">rx_curr_desc</span><span class="p">];</span>
		<span class="n">cmd_sts</span> <span class="o">=</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">cmd_sts</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_sts</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BUF_OWNED_BY_DMA</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">[</span><span class="n">rx_curr_desc</span><span class="p">];</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">[</span><span class="n">rx_curr_desc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">rx_next_curr_desc</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx_curr_desc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_curr_desc_q</span> <span class="o">=</span> <span class="n">rx_next_curr_desc</span><span class="p">;</span>

		<span class="cm">/* Rx descriptors exhausted. */</span>
		<span class="cm">/* Set the Rx ring resource error flag */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_next_curr_desc</span> <span class="o">==</span> <span class="n">rx_used_desc</span><span class="p">)</span>
			<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_resource_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">buf_ptr</span><span class="p">,</span>
				 <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">,</span>
				 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">received_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update statistics.</span>
<span class="cm">		 * Note byte count includes 4 byte CRC count</span>
<span class="cm">		 */</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">byte_cnt</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * In case received a packet without first / last bits on OR</span>
<span class="cm">		 * the error summary bit is on, the packets needs to be droped.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">cmd_sts</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RX_FIRST_DESC</span> <span class="o">|</span> <span class="n">RX_LAST_DESC</span><span class="p">))</span> <span class="o">!=</span>
		     <span class="p">(</span><span class="n">RX_FIRST_DESC</span> <span class="o">|</span> <span class="n">RX_LAST_DESC</span><span class="p">))</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">cmd_sts</span> <span class="o">&amp;</span> <span class="n">RX_ERROR</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cmd_sts</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RX_FIRST_DESC</span> <span class="o">|</span> <span class="n">RX_LAST_DESC</span><span class="p">))</span> <span class="o">!=</span>
			    <span class="p">(</span><span class="n">RX_FIRST_DESC</span> <span class="o">|</span> <span class="n">RX_LAST_DESC</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
					       <span class="s">&quot;%s: Rx pkt on multiple desc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd_sts</span> <span class="o">&amp;</span> <span class="n">RX_ERROR</span><span class="p">)</span>
				<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The -4 is for the CRC in the trailer of the</span>
<span class="cm">			 * received packet</span>
<span class="cm">			 */</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">byte_cnt</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Fill RX ring with skb&#39;s */</span>
	<span class="n">rxq_refill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">received_packets</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_eth_collect_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">icr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">icr</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_CAUSE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_CAUSE</span><span class="p">,</span> <span class="o">~</span><span class="n">icr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ICR_TXBUF_H</span> <span class="o">|</span> <span class="n">ICR_TXBUF_L</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">work_todo</span> <span class="o">|=</span> <span class="n">WORK_TX_DONE</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">ICR_RXBUF</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">ICR_MII_CH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">work_todo</span> <span class="o">|=</span> <span class="n">WORK_LINK</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_link_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">port_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">speed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">duplex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fc</span><span class="p">;</span>

	<span class="n">port_status</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">PORT_STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port_status</span> <span class="o">&amp;</span> <span class="n">LINK_UP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: link down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">txq_reclaim</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port_status</span> <span class="o">&amp;</span> <span class="n">PORT_SPEED_100</span><span class="p">)</span>
		<span class="n">speed</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">speed</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">duplex</span> <span class="o">=</span> <span class="p">(</span><span class="n">port_status</span> <span class="o">&amp;</span> <span class="n">FULL_DUPLEX</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fc</span> <span class="o">=</span> <span class="p">(</span><span class="n">port_status</span> <span class="o">&amp;</span> <span class="n">FLOW_CONTROL_ENABLED</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: link up, %d Mb/s, %s duplex, &quot;</span>
	       <span class="s">&quot;flow control %sabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	       <span class="n">speed</span><span class="p">,</span> <span class="n">duplex</span> <span class="o">?</span> <span class="s">&quot;full&quot;</span> <span class="o">:</span> <span class="s">&quot;half&quot;</span><span class="p">,</span> <span class="n">fc</span> <span class="o">?</span> <span class="s">&quot;en&quot;</span> <span class="o">:</span> <span class="s">&quot;dis&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">pxa168_eth_int_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pxa168_eth_collect_events</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">dev</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="cm">/* Disable interrupts */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa168_eth_recalc_skb_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">skb_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reserve 2+14 bytes for an ethernet header (the hardware</span>
<span class="cm">	 * automatically prepends 2 bytes of dummy data to each</span>
<span class="cm">	 * received packet), 16 bytes for up to four VLAN tags, and</span>
<span class="cm">	 * 4 bytes for the trailing FCS -- 36 bytes total.</span>
<span class="cm">	 */</span>
	<span class="n">skb_size</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="mi">36</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that the skb size is a multiple of 8 bytes, as</span>
<span class="cm">	 * the lower three bits of the receive descriptor&#39;s buffer</span>
<span class="cm">	 * size field are ignored by the hardware.</span>
<span class="cm">	 */</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">skb_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb_size</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If NET_SKB_PAD is smaller than a cache line,</span>
<span class="cm">	 * netdev_alloc_skb() will cause skb-&gt;data to be misaligned</span>
<span class="cm">	 * to a cache line boundary.  If this is the case, include</span>
<span class="cm">	 * some extra space to allow re-aligning the data area.</span>
<span class="cm">	 */</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">skb_size</span> <span class="o">+=</span> <span class="n">SKB_DMA_REALIGN</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_port_config_ext</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">skb_size</span><span class="p">;</span>

	<span class="n">pxa168_eth_recalc_skb_size</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>
	<span class="k">if</span>  <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">skb_size</span> <span class="o">&lt;=</span> <span class="mi">1518</span><span class="p">)</span>
		<span class="n">skb_size</span> <span class="o">=</span> <span class="n">PCXR_MFL_1518</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">skb_size</span> <span class="o">&lt;=</span> <span class="mi">1536</span><span class="p">)</span>
		<span class="n">skb_size</span> <span class="o">=</span> <span class="n">PCXR_MFL_1536</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">skb_size</span> <span class="o">&lt;=</span> <span class="mi">2048</span><span class="p">)</span>
		<span class="n">skb_size</span> <span class="o">=</span> <span class="n">PCXR_MFL_2048</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">skb_size</span> <span class="o">=</span> <span class="n">PCXR_MFL_64K</span><span class="p">;</span>

	<span class="cm">/* Extended Port Configuration */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span>
	    <span class="n">PORT_CONFIG_EXT</span><span class="p">,</span> <span class="n">PCXR_2BSM</span> <span class="o">|</span> <span class="cm">/* Two byte prefix aligns IP hdr */</span>
	    <span class="n">PCXR_DSCP_EN</span> <span class="o">|</span>		 <span class="cm">/* Enable DSCP in IP */</span>
	    <span class="n">skb_size</span> <span class="o">|</span> <span class="n">PCXR_FLP</span> <span class="o">|</span>	 <span class="cm">/* do not force link pass */</span>
	    <span class="n">PCXR_TX_HIGH_PRI</span><span class="p">);</span>		 <span class="cm">/* Transmit - high priority queue */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_init_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Disable interrupts */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_CAUSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Write to ICR to clear interrupts. */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_W_CLEAR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Abort any transmit and receive operations and put DMA</span>
<span class="cm">	 * in idle state.</span>
<span class="cm">	 */</span>
	<span class="n">abort_dma</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>
	<span class="cm">/* Initialize address hash table */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">init_hash_table</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/* SDMA configuration */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">SDMA_CONFIG</span><span class="p">,</span> <span class="n">SDCR_BSZ8</span> <span class="o">|</span>	<span class="cm">/* Burst size = 32 bytes */</span>
	    <span class="n">SDCR_RIFB</span> <span class="o">|</span>				<span class="cm">/* Rx interrupt on frame */</span>
	    <span class="n">SDCR_BLMT</span> <span class="o">|</span>				<span class="cm">/* Little endian transmit */</span>
	    <span class="n">SDCR_BLMR</span> <span class="o">|</span>				<span class="cm">/* Little endian receive */</span>
	    <span class="n">SDCR_RC_MAX_RETRANS</span><span class="p">);</span>		<span class="cm">/* Max retransmit count */</span>
	<span class="cm">/* Port Configuration */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">PORT_CONFIG</span><span class="p">,</span> <span class="n">PCR_HS</span><span class="p">);</span>		<span class="cm">/* Hash size is 1/2kb */</span>
	<span class="n">set_port_config_ext</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rxq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="n">p_rx_desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_desc_num</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span>

	<span class="cm">/* Allocate RX skb rings */</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_skb</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">)</span> <span class="o">*</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">,</span>
			     <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Allocate RX ring */</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">);</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_area_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_rx_desc_area</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_rx_desc_area</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Cannot alloc RX ring (size %d bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_rx_desc_area</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="cm">/* initialize the next_desc_ptr links in the Rx descriptors ring */</span>
	<span class="n">p_rx_desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_rx_desc_area</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_desc_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p_rx_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_desc_ptr</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_dma</span> <span class="o">+</span>
		    <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">rx_desc_num</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Save Rx desc pointer to driver struct. */</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_curr_desc_q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_used_desc_q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_area_size</span> <span class="o">=</span> <span class="n">rx_desc_num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_desc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rxq_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">curr</span><span class="p">;</span>

	<span class="cm">/* Free preallocated skb&#39;s on RX rings */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">curr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_count</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span> <span class="o">&lt;</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">;</span> <span class="n">curr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">[</span><span class="n">curr</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">[</span><span class="n">curr</span><span class="p">]);</span>
			<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_count</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_count</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;Error in freeing Rx Ring. %d skb&#39;s still</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_count</span><span class="p">);</span>
	<span class="cm">/* Free RX ring */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_rx_desc_area</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_area_size</span><span class="p">,</span>
				  <span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_rx_desc_area</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_desc_dma</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">txq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">p_tx_desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_desc_num</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span>

	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">)</span> <span class="o">*</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">,</span>
			     <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Allocate TX ring */</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">);</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_area_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_tx_desc_area</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_tx_desc_area</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Cannot allocate Tx Ring (size %d bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_tx_desc_area</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_area_size</span><span class="p">);</span>
	<span class="cm">/* Initialize the next_desc_ptr links in the Tx descriptors ring */</span>
	<span class="n">p_tx_desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_tx_desc_area</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_desc_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p_tx_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_desc_ptr</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_dma</span> <span class="o">+</span>
		    <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">tx_desc_num</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_curr_desc_q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_used_desc_q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_area_size</span> <span class="o">=</span> <span class="n">tx_desc_num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">txq_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Free outstanding skb&#39;s on TX ring */</span>
	<span class="n">txq_reclaim</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_used_desc_q</span> <span class="o">!=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_curr_desc_q</span><span class="p">);</span>
	<span class="cm">/* Free TX ring */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_tx_desc_area</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_area_size</span><span class="p">,</span>
				  <span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_tx_desc_area</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_dma</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_eth_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pxa168_eth_int_handler</span><span class="p">,</span>
			  <span class="n">IRQF_DISABLED</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t assign irq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_resource_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">rxq_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_irq</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">txq_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_rx_skb</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_used_desc_q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_curr_desc_q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Fill RX ring with skb&#39;s */</span>
	<span class="n">rxq_refill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_used_desc_q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_curr_desc_q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">eth_port_start</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_free_rx_skb:</span>
	<span class="n">rxq_deinit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">out_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_eth_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">eth_port_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Disable interrupts */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_CAUSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Write to ICR to clear interrupts. */</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_W_CLEAR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">rxq_deinit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">txq_deinit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_eth_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="mi">9500</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">mtu</span> <span class="o">&lt;</span> <span class="mi">68</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">mtu</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">set_port_config_ext</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stop and then re-open the interface. This will allocate RX</span>
<span class="cm">	 * skbs of the new MTU.</span>
<span class="cm">	 * There is a possible danger that the open will not succeed,</span>
<span class="cm">	 * due to memory being full.</span>
<span class="cm">	 */</span>
	<span class="n">pxa168_eth_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pxa168_eth_open</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			   <span class="s">&quot;fatal error on re-opening device after &quot;</span>
			   <span class="s">&quot;MTU change</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">eth_alloc_tx_desc_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tx_desc_curr</span><span class="p">;</span>

	<span class="n">tx_desc_curr</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_curr_desc_q</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_curr_desc_q</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx_desc_curr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_curr_desc_q</span> <span class="o">==</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_used_desc_q</span><span class="p">);</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_count</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tx_desc_curr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_rx_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span>
	    <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa168_eth_private</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">work_todo</span> <span class="o">&amp;</span> <span class="n">WORK_LINK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">work_todo</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">WORK_LINK</span><span class="p">);</span>
		<span class="n">handle_link_event</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We call txq_reclaim every time since in NAPI interupts are disabled</span>
<span class="cm">	 * and due to this we miss the TX_DONE interrupt,which is not updated in</span>
<span class="cm">	 * interrupt status register.</span>
<span class="cm">	 */</span>
	<span class="n">txq_reclaim</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span> <span class="o">-</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">work_done</span> <span class="o">=</span> <span class="n">rxq_process</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">INT_MASK</span><span class="p">,</span> <span class="n">ALL_INTS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_eth_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">tx_index</span> <span class="o">=</span> <span class="n">eth_alloc_tx_desc_index</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">p_tx_desc_area</span><span class="p">[</span><span class="n">tx_index</span><span class="p">];</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">[</span><span class="n">tx_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">byte_cnt</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">buf_ptr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="n">skb_tx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">cmd_sts</span> <span class="o">=</span> <span class="n">BUF_OWNED_BY_DMA</span> <span class="o">|</span> <span class="n">TX_GEN_CRC</span> <span class="o">|</span> <span class="n">TX_FIRST_DESC</span> <span class="o">|</span>
			<span class="n">TX_ZERO_PADDING</span> <span class="o">|</span> <span class="n">TX_LAST_DESC</span> <span class="o">|</span> <span class="n">TX_EN_INT</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">SDMA_CMD</span><span class="p">,</span> <span class="n">SDMA_CMD_TXDH</span> <span class="o">|</span> <span class="n">SDMA_CMD_ERD</span><span class="p">);</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span> <span class="o">-</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_desc_count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We handled the current skb, but now we are out of space.*/</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smi_wait_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* wait for the SMI register to become available */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">SMI</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SMI_BUSY</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">PHY_WAIT_ITERATIONS</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_smi_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smi_wait_ready</span><span class="p">(</span><span class="n">pep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;pxa168_eth: SMI bus busy timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">SMI</span><span class="p">,</span> <span class="p">(</span><span class="n">phy_addr</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">regnum</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">)</span> <span class="o">|</span> <span class="n">SMI_OP_R</span><span class="p">);</span>
	<span class="cm">/* now wait for the data to be valid */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="p">((</span><span class="n">val</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">SMI</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">SMI_R_VALID</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">PHY_WAIT_ITERATIONS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;pxa168_eth: SMI bus read not valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_smi_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regnum</span><span class="p">,</span>
			    <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smi_wait_ready</span><span class="p">(</span><span class="n">pep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;pxa168_eth: SMI bus busy timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wrl</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">SMI</span><span class="p">,</span> <span class="p">(</span><span class="n">phy_addr</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">regnum</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">)</span> <span class="o">|</span>
	    <span class="n">SMI_OP_W</span> <span class="o">|</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smi_wait_ready</span><span class="p">(</span><span class="n">pep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;pxa168_eth: SMI bus busy timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_eth_do_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">phy_mii_ioctl</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="nf">phy_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy_addr</span> <span class="o">==</span> <span class="n">PXA168_ETH_PHY_ADDR_DEFAULT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Scan entire range */</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">ethernet_phy_get</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>
		<span class="n">num</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Use phy addr specific to platform */</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">phy_addr</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
		<span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phydev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">phy_map</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">mdiobus_scan</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phydev</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">phy_map</span><span class="p">[</span><span class="n">addr</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">ethernet_phy_set_addr</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">phydev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">phy_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">,</span> <span class="kt">int</span> <span class="n">duplex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">ethernet_phy_reset</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>

	<span class="n">phy_attach</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PHY_INTERFACE_MODE_MII</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="n">AUTONEG_ENABLE</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">&amp;=</span> <span class="n">PHY_BASIC_FEATURES</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">|</span> <span class="n">ADVERTISED_Autoneg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="n">AUTONEG_DISABLE</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">duplex</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phy_start_aneg</span><span class="p">(</span><span class="n">phy</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ethernet_phy_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">();</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span> <span class="o">=</span> <span class="n">phy_scan</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">phy_init</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">);</span>
	<span class="n">update_hash_table_mac_address</span><span class="p">(</span><span class="n">pep</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">phy_read_status</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">phy_ethtool_gset</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_set_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">phy_ethtool_sset</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa168_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRIVER_NAME</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRIVER_VERSION</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="s">&quot;N/A&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="s">&quot;N/A&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">pxa168_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_settings</span> <span class="o">=</span> <span class="n">pxa168_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span> <span class="o">=</span> <span class="n">pxa168_set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_drvinfo</span> <span class="o">=</span> <span class="n">pxa168_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span> <span class="o">=</span> <span class="n">ethtool_op_get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ts_info</span> <span class="o">=</span> <span class="n">ethtool_op_get_ts_info</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">pxa168_eth_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> <span class="o">=</span> <span class="n">pxa168_eth_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span> <span class="o">=</span> <span class="n">pxa168_eth_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">pxa168_eth_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span> <span class="o">=</span> <span class="n">pxa168_eth_set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span> <span class="o">=</span> <span class="n">pxa168_eth_set_mac_address</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span> <span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span> <span class="o">=</span> <span class="n">pxa168_eth_do_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span> <span class="o">=</span> <span class="n">pxa168_eth_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span> <span class="o">=</span> <span class="n">pxa168_eth_tx_timeout</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_eth_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;PXA168 10/100 Ethernet Driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MFUCLK&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Fast Ethernet failed to get clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">DRIVER_NAME</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa168_eth_private</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_netdev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_netdev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_IRQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pxa168_eth_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">SET_ETHTOOL_OPS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pxa168_ethtool_ops</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_timeout_task</span><span class="p">,</span> <span class="n">pxa168_eth_tx_timeout_task</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s:Using random mac address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DRIVER_NAME</span><span class="p">);</span>
	<span class="n">eth_hw_addr_random</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">pd</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">=</span> <span class="n">NUM_RX_DESCS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">rx_queue_size</span><span class="p">)</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">rx_queue_size</span><span class="p">;</span>

	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span> <span class="o">=</span> <span class="n">NUM_TX_DESCS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">tx_queue_size</span><span class="p">)</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_ring_size</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">tx_queue_size</span><span class="p">;</span>

	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">port_num</span> <span class="o">=</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_number</span><span class="p">;</span>
	<span class="cm">/* Hardware supports only 3 ports */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">port_num</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">pxa168_rx_poll</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">rx_ring_size</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span><span class="p">));</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">rxq_refill_timer_wrapper</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pep</span><span class="p">;</span>

	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span> <span class="o">=</span> <span class="n">mdiobus_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_base</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">pep</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pxa168_eth smi&quot;</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">pxa168_smi_read</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">pxa168_smi_write</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">MII_BUS_ID_SIZE</span><span class="p">,</span> <span class="s">&quot;%s-%d&quot;</span><span class="p">,</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="o">-&gt;</span><span class="n">phy_mask</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">mdiobus_register</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_mdio</span><span class="p">;</span>

	<span class="n">pxa168_init_hw</span><span class="p">(</span><span class="n">pep</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ethernet_phy_setup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_mdiobus</span><span class="p">;</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_mdiobus</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_mdiobus:</span>
	<span class="n">mdiobus_unregister</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="p">);</span>
<span class="nl">err_free_mdio:</span>
	<span class="n">mdiobus_free</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="p">);</span>
<span class="nl">err_base:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
<span class="nl">err_netdev:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">err_clk:</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_eth_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa168_eth_private</span> <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">HASH_ADDR_TABLE_SIZE</span><span class="p">,</span>
				  <span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr</span><span class="p">,</span> <span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr_dma</span><span class="p">);</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">htpr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="n">pep</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">phy_detach</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">pep</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mdiobus_unregister</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="p">);</span>
	<span class="n">mdiobus_free</span><span class="p">(</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">smi_bus</span><span class="p">);</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pep</span><span class="o">-&gt;</span><span class="n">tx_timeout_task</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa168_eth_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">eth_port_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_eth_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa168_eth_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define pxa168_eth_resume NULL</span>
<span class="cp">#define pxa168_eth_suspend NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">pxa168_eth_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">pxa168_eth_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">pxa168_eth_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">pxa168_eth_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">pxa168_eth_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">pxa168_eth_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		   <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
		   <span class="p">},</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">pxa168_eth_driver</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Ethernet driver for Marvell PXA168&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:pxa168_eth&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
