<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › chelsio › cxgb › sge.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>sge.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*****************************************************************************</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> * File: sge.c                                                               *</span>
<span class="cm"> * $Revision: 1.26 $                                                         *</span>
<span class="cm"> * $Date: 2005/06/21 18:29:48 $                                              *</span>
<span class="cm"> * Description:                                                              *</span>
<span class="cm"> *  DMA engine.                                                              *</span>
<span class="cm"> *  part of the Chelsio 10Gb Ethernet Driver.                                *</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify      *</span>
<span class="cm"> * it under the terms of the GNU General Public License, version 2, as       *</span>
<span class="cm"> * published by the Free Software Foundation.                                *</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along   *</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,   *</span>
<span class="cm"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.                 *</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR IMPLIED    *</span>
<span class="cm"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF      *</span>
<span class="cm"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.                     *</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> * http://www.chelsio.com                                                    *</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> * Copyright (c) 2003 - 2005 Chelsio Communications, Inc.                    *</span>
<span class="cm"> * All rights reserved.                                                      *</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> * Maintainers: maintainers@chelsio.com                                      *</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> * Authors: Dimitrios Michailidis   &lt;dm@chelsio.com&gt;                         *</span>
<span class="cm"> *          Tina Yang               &lt;tainay@chelsio.com&gt;                     *</span>
<span class="cm"> *          Felix Marti             &lt;felix@chelsio.com&gt;                      *</span>
<span class="cm"> *          Scott Bardone           &lt;sbardone@chelsio.com&gt;                   *</span>
<span class="cm"> *          Kurt Ottaway            &lt;kottaway@chelsio.com&gt;                   *</span>
<span class="cm"> *          Frank DiMambro          &lt;frank@chelsio.com&gt;                      *</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> * History:                                                                  *</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> ****************************************************************************/</span>

<span class="cp">#include &quot;common.h&quot;</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/ktime.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cp">#include &quot;cpl5_cmd.h&quot;</span>
<span class="cp">#include &quot;sge.h&quot;</span>
<span class="cp">#include &quot;regs.h&quot;</span>
<span class="cp">#include &quot;espi.h&quot;</span>

<span class="cm">/* This belongs in if_ether.h */</span>
<span class="cp">#define ETH_P_CPL5 0xf</span>

<span class="cp">#define SGE_CMDQ_N		2</span>
<span class="cp">#define SGE_FREELQ_N		2</span>
<span class="cp">#define SGE_CMDQ0_E_N		1024</span>
<span class="cp">#define SGE_CMDQ1_E_N		128</span>
<span class="cp">#define SGE_FREEL_SIZE		4096</span>
<span class="cp">#define SGE_JUMBO_FREEL_SIZE	512</span>
<span class="cp">#define SGE_FREEL_REFILL_THRESH	16</span>
<span class="cp">#define SGE_RESPQ_E_N		1024</span>
<span class="cp">#define SGE_INTRTIMER_NRES	1000</span>
<span class="cp">#define SGE_RX_SM_BUF_SIZE	1536</span>
<span class="cp">#define SGE_TX_DESC_MAX_PLEN	16384</span>

<span class="cp">#define SGE_RESPQ_REPLENISH_THRES (SGE_RESPQ_E_N / 4)</span>

<span class="cm">/*</span>
<span class="cm"> * Period of the TX buffer reclaim timer.  This timer does not need to run</span>
<span class="cm"> * frequently as TX buffers are usually reclaimed by new TX packets.</span>
<span class="cm"> */</span>
<span class="cp">#define TX_RECLAIM_PERIOD (HZ / 4)</span>

<span class="cp">#define M_CMD_LEN       0x7fffffff</span>
<span class="cp">#define V_CMD_LEN(v)    (v)</span>
<span class="cp">#define G_CMD_LEN(v)    ((v) &amp; M_CMD_LEN)</span>
<span class="cp">#define V_CMD_GEN1(v)   ((v) &lt;&lt; 31)</span>
<span class="cp">#define V_CMD_GEN2(v)   (v)</span>
<span class="cp">#define F_CMD_DATAVALID (1 &lt;&lt; 1)</span>
<span class="cp">#define F_CMD_SOP       (1 &lt;&lt; 2)</span>
<span class="cp">#define V_CMD_EOP(v)    ((v) &lt;&lt; 3)</span>

<span class="cm">/*</span>
<span class="cm"> * Command queue, receive buffer list, and response queue descriptors.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(__BIG_ENDIAN_BITFIELD)</span>
<span class="k">struct</span> <span class="n">cmdQ_e</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr_lo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len_gen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_hi</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">freelQ_e</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr_lo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len_gen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gen2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_hi</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">respQ_e</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">Qsleeping</span>		<span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Cmdq1CreditReturn</span>	<span class="o">:</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Cmdq1DmaComplete</span>	<span class="o">:</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Cmdq0CreditReturn</span>	<span class="o">:</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Cmdq0DmaComplete</span>	<span class="o">:</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">FreelistQid</span>		<span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">CreditValid</span>		<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">DataValid</span>		<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Offload</span>		<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Eop</span>			<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Sop</span>			<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">GenerationBit</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">BufferLength</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#elif defined(__LITTLE_ENDIAN_BITFIELD)</span>
<span class="k">struct</span> <span class="n">cmdQ_e</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">len_gen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_lo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_hi</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">freelQ_e</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">len_gen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_lo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_hi</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gen2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">respQ_e</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">BufferLength</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">GenerationBit</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Sop</span>			<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Eop</span>			<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Offload</span>		<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">DataValid</span>		<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">CreditValid</span>		<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">FreelistQid</span>		<span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Cmdq0DmaComplete</span>	<span class="o">:</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Cmdq0CreditReturn</span>	<span class="o">:</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Cmdq1DmaComplete</span>	<span class="o">:</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Cmdq1CreditReturn</span>	<span class="o">:</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">Qsleeping</span>		<span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * SW Context Command and Freelist Queue Descriptors</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cmdQ_ce</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">DEFINE_DMA_UNMAP_ADDR</span><span class="p">(</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="n">DEFINE_DMA_UNMAP_LEN</span><span class="p">(</span><span class="n">dma_len</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">freelQ_ce</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">DEFINE_DMA_UNMAP_ADDR</span><span class="p">(</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="n">DEFINE_DMA_UNMAP_LEN</span><span class="p">(</span><span class="n">dma_len</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * SW command, freelist and response rings</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cmdQ</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">status</span><span class="p">;</span>         <span class="cm">/* HW DMA fetch status */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">in_use</span><span class="p">;</span>         <span class="cm">/* # of in-use command descriptors */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">size</span><span class="p">;</span>	        <span class="cm">/* # of descriptors */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">processed</span><span class="p">;</span>      <span class="cm">/* total # of descs HW has processed */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">cleaned</span><span class="p">;</span>        <span class="cm">/* total # of descs SW has reclaimed */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">stop_thres</span><span class="p">;</span>     <span class="cm">/* SW TX queue suspend threshold */</span>
	<span class="n">u16</span>		<span class="n">pidx</span><span class="p">;</span>           <span class="cm">/* producer index (SW) */</span>
	<span class="n">u16</span>		<span class="n">cidx</span><span class="p">;</span>           <span class="cm">/* consumer index (HW) */</span>
	<span class="n">u8</span>		<span class="n">genbit</span><span class="p">;</span>         <span class="cm">/* current generation (=valid) bit */</span>
	<span class="n">u8</span>              <span class="n">sop</span><span class="p">;</span>            <span class="cm">/* is next entry start of packet? */</span>
	<span class="k">struct</span> <span class="n">cmdQ_e</span>  <span class="o">*</span><span class="n">entries</span><span class="p">;</span>        <span class="cm">/* HW command descriptor Q */</span>
	<span class="k">struct</span> <span class="n">cmdQ_ce</span> <span class="o">*</span><span class="n">centries</span><span class="p">;</span>       <span class="cm">/* SW command context descriptor Q */</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma_addr</span><span class="p">;</span>       <span class="cm">/* DMA addr HW command descriptor Q */</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>           <span class="cm">/* Lock to protect cmdQ enqueuing */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">freelQ</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">credits</span><span class="p">;</span>        <span class="cm">/* # of available RX buffers */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">size</span><span class="p">;</span>	        <span class="cm">/* free list capacity */</span>
	<span class="n">u16</span>		<span class="n">pidx</span><span class="p">;</span>           <span class="cm">/* producer index (SW) */</span>
	<span class="n">u16</span>		<span class="n">cidx</span><span class="p">;</span>           <span class="cm">/* consumer index (HW) */</span>
	<span class="n">u16</span>		<span class="n">rx_buffer_size</span><span class="p">;</span> <span class="cm">/* Buffer size on this free list */</span>
	<span class="n">u16</span>             <span class="n">dma_offset</span><span class="p">;</span>     <span class="cm">/* DMA offset to align IP headers */</span>
	<span class="n">u16</span>             <span class="n">recycleq_idx</span><span class="p">;</span>   <span class="cm">/* skb recycle q to use */</span>
	<span class="n">u8</span>		<span class="n">genbit</span><span class="p">;</span>	        <span class="cm">/* current generation (=valid) bit */</span>
	<span class="k">struct</span> <span class="n">freelQ_e</span>	<span class="o">*</span><span class="n">entries</span><span class="p">;</span>       <span class="cm">/* HW freelist descriptor Q */</span>
	<span class="k">struct</span> <span class="n">freelQ_ce</span> <span class="o">*</span><span class="n">centries</span><span class="p">;</span>     <span class="cm">/* SW freelist context descriptor Q */</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma_addr</span><span class="p">;</span>       <span class="cm">/* DMA addr HW freelist descriptor Q */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">respQ</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">credits</span><span class="p">;</span>        <span class="cm">/* credits to be returned to SGE */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">size</span><span class="p">;</span>	        <span class="cm">/* # of response Q descriptors */</span>
	<span class="n">u16</span>		<span class="n">cidx</span><span class="p">;</span>	        <span class="cm">/* consumer index (SW) */</span>
	<span class="n">u8</span>		<span class="n">genbit</span><span class="p">;</span>	        <span class="cm">/* current generation(=valid) bit */</span>
	<span class="k">struct</span> <span class="n">respQ_e</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>        <span class="cm">/* HW response descriptor Q */</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma_addr</span><span class="p">;</span>       <span class="cm">/* DMA addr HW response descriptor Q */</span>
<span class="p">};</span>

<span class="cm">/* Bit flags for cmdQ.status */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CMDQ_STAT_RUNNING</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>          <span class="cm">/* fetch engine is running */</span>
	<span class="n">CMDQ_STAT_LAST_PKT_DB</span> <span class="o">=</span> <span class="mi">2</span>       <span class="cm">/* last packet rung the doorbell */</span>
<span class="p">};</span>

<span class="cm">/* T204 TX SW scheduler */</span>

<span class="cm">/* Per T204 TX port */</span>
<span class="k">struct</span> <span class="n">sched_port</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">avail</span><span class="p">;</span>		<span class="cm">/* available bits - quota */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">drain_bits_per_1024ns</span><span class="p">;</span> <span class="cm">/* drain rate */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">speed</span><span class="p">;</span>		<span class="cm">/* drain rate, mbps */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">mtu</span><span class="p">;</span>		<span class="cm">/* mtu size */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">skbq</span><span class="p">;</span>	<span class="cm">/* pending skbs */</span>
<span class="p">};</span>

<span class="cm">/* Per T204 device */</span>
<span class="k">struct</span> <span class="n">sched</span> <span class="p">{</span>
	<span class="n">ktime_t</span>         <span class="n">last_updated</span><span class="p">;</span>   <span class="cm">/* last time quotas were computed */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">max_avail</span><span class="p">;</span>	<span class="cm">/* max bits to be sent to any port */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">port</span><span class="p">;</span>		<span class="cm">/* port index (round robin ports) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">num</span><span class="p">;</span>		<span class="cm">/* num skbs in per port queues */</span>
	<span class="k">struct</span> <span class="n">sched_port</span> <span class="n">p</span><span class="p">[</span><span class="n">MAX_NPORTS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">sched_tsk</span><span class="p">;</span><span class="cm">/* tasklet used to run scheduler */</span>
<span class="p">};</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">restart_sched</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Main SGE data structure</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupts are handled by a single CPU and it is likely that on a MP system</span>
<span class="cm"> * the application is migrated to another CPU. In that scenario, we try to</span>
<span class="cm"> * separate the RX(in irq context) and TX state in order to decrease memory</span>
<span class="cm"> * contention.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sge</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>	<span class="cm">/* adapter backpointer */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>      <span class="cm">/* netdevice backpointer */</span>
	<span class="k">struct</span> <span class="n">freelQ</span>	<span class="n">freelQ</span><span class="p">[</span><span class="n">SGE_FREELQ_N</span><span class="p">];</span> <span class="cm">/* buffer free lists */</span>
	<span class="k">struct</span> <span class="n">respQ</span>	<span class="n">respQ</span><span class="p">;</span>		<span class="cm">/* response Q */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">stopped_tx_queues</span><span class="p">;</span> <span class="cm">/* bitmap of suspended Tx queues */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rx_pkt_pad</span><span class="p">;</span>     <span class="cm">/* RX padding for L2 packets */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">jumbo_fl</span><span class="p">;</span>       <span class="cm">/* jumbo freelist Q index */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">intrtimer_nres</span><span class="p">;</span>	<span class="cm">/* no-resource interrupt timer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">fixed_intrtimer</span><span class="p">;</span><span class="cm">/* non-adaptive interrupt timer */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">tx_reclaim_timer</span><span class="p">;</span> <span class="cm">/* reclaims TX buffers */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">espibug_timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">espibug_timeout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">espibug_skb</span><span class="p">[</span><span class="n">MAX_NPORTS</span><span class="p">];</span>
	<span class="n">u32</span>		<span class="n">sge_control</span><span class="p">;</span>	<span class="cm">/* shadow value of sge control reg */</span>
	<span class="k">struct</span> <span class="n">sge_intr_counts</span> <span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_port_stats</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">port_stats</span><span class="p">[</span><span class="n">MAX_NPORTS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sched</span>	<span class="o">*</span><span class="n">tx_sched</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmdQ</span> <span class="n">cmdQ</span><span class="p">[</span><span class="n">SGE_CMDQ_N</span><span class="p">]</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">ch_mac_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x7</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * stop tasklet and free all pending skb&#39;s</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tx_sched_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_sched</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sched_tsk</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NPORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">].</span><span class="n">skbq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * t1_sched_update_parms() is called when the MTU or link speed changes. It</span>
<span class="cm"> * re-computes scheduler parameters to scope with the change.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">t1_sched_update_parms</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mtu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_sched</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_port</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_avail_segs</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;t1_sched_update_params mtu=%d speed=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mtu</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtu</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">mtu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">||</span> <span class="n">mtu</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">drain</span> <span class="o">=</span> <span class="mi">1024ULL</span> <span class="o">*</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">-</span> <span class="mi">40</span><span class="p">);</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">drain</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="mi">50</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">drain_bits_per_1024ns</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">drain</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">drain_bits_per_1024ns</span> <span class="o">=</span>
				<span class="mi">90</span> <span class="o">*</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">drain_bits_per_1024ns</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">board_info</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">board</span> <span class="o">==</span> <span class="n">CHBT_BOARD_CHT204</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">drain_bits_per_1024ns</span> <span class="o">-=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">max_avail</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">4096U</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">+</span> <span class="mi">14</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">max_avail_segs</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">1U</span><span class="p">,</span> <span class="mi">4096</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">-</span> <span class="mi">40</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">max_avail</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
		<span class="n">max_avail_segs</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">1U</span><span class="p">,</span> <span class="mi">9000</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">-</span> <span class="mi">40</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;t1_sched_update_parms: mtu %u speed %u max_avail %u &quot;</span>
		 <span class="s">&quot;max_avail_segs %u drain_bits_per_1024ns %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span>
		 <span class="n">p</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">max_avail</span><span class="p">,</span> <span class="n">max_avail_segs</span><span class="p">,</span>
		 <span class="n">p</span><span class="o">-&gt;</span><span class="n">drain_bits_per_1024ns</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">max_avail_segs</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">-</span> <span class="mi">40</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>

<span class="c">/*</span>
<span class="c"> * t1_sched_max_avail_bytes() tells the scheduler the maximum amount of</span>
<span class="c"> * data that can be pushed per port.</span>
<span class="c"> */</span>
<span class="c">void t1_sched_set_max_avail_bytes(struct sge *sge, unsigned int val)</span>
<span class="c">{</span>
<span class="c">	struct sched *s = sge-&gt;tx_sched;</span>
<span class="c">	unsigned int i;</span>

<span class="c">	s-&gt;max_avail = val;</span>
<span class="c">	for (i = 0; i &lt; MAX_NPORTS; i++)</span>
<span class="c">		t1_sched_update_parms(sge, i, 0, 0);</span>
<span class="c">}</span>

<span class="c">/*</span>
<span class="c"> * t1_sched_set_drain_bits_per_us() tells the scheduler at which rate a port</span>
<span class="c"> * is draining.</span>
<span class="c"> */</span>
<span class="c">void t1_sched_set_drain_bits_per_us(struct sge *sge, unsigned int port,</span>
<span class="c">					 unsigned int val)</span>
<span class="c">{</span>
<span class="c">	struct sched *s = sge-&gt;tx_sched;</span>
<span class="c">	struct sched_port *p = &amp;s-&gt;p[port];</span>
<span class="c">	p-&gt;drain_bits_per_1024ns = val * 1024 / 1000;</span>
<span class="c">	t1_sched_update_parms(sge, port, 0, 0);</span>
<span class="c">}</span>

<span class="cp">#endif  /*  0  */</span>


<span class="cm">/*</span>
<span class="cm"> * get_clock() implements a ns clock (see ktime_get)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">get_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>

	<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">ts</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * tx_sched_init() allocates resources and does basic initialization.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tx_sched_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sched</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;tx_sched_init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sched_tsk</span><span class="p">,</span> <span class="n">restart_sched</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">sge</span><span class="p">);</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_sched</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NPORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">skbq</span><span class="p">);</span>
		<span class="n">t1_sched_update_parms</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sched_update_avail() computes the delta since the last time it was called</span>
<span class="cm"> * and updates the per port quota (number of bits that can be sent to the any</span>
<span class="cm"> * port).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sched_update_avail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_sched</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">delta_time_ns</span><span class="p">;</span>

	<span class="n">delta_time_ns</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_updated</span><span class="p">));</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sched_update_avail delta=%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">delta_time_ns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta_time_ns</span> <span class="o">&lt;</span> <span class="mi">15000</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NPORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sched_port</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delta_avail</span><span class="p">;</span>

		<span class="n">delta_avail</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drain_bits_per_1024ns</span> <span class="o">*</span> <span class="n">delta_time_ns</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">+</span> <span class="n">delta_avail</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">max_avail</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">last_updated</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sched_skb() is called from two different places. In the tx path, any</span>
<span class="cm"> * packet generating load on an output port will call sched_skb()</span>
<span class="cm"> * (skb != NULL). In addition, sched_skb() is called from the irq/soft irq</span>
<span class="cm"> * context (skb == NULL).</span>
<span class="cm"> * The scheduler only returns a skb (which will then be sent) if the</span>
<span class="cm"> * length of the skb is &lt;= the current quota of the output port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">sched_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">credits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_sched</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">skbq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">update</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sched_skb %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skbq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span><span class="p">].</span><span class="n">skbq</span><span class="p">;</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="n">skbq</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">num</span><span class="o">++</span><span class="p">;</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">credits</span> <span class="o">&lt;</span> <span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NPORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MAX_NPORTS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">skbq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">].</span><span class="n">skbq</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="n">skbq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">].</span><span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">].</span><span class="n">avail</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">num</span><span class="o">--</span><span class="p">;</span>
			<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skbq</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">update</span><span class="o">--</span> <span class="o">&amp;&amp;</span> <span class="n">sched_update_avail</span><span class="p">(</span><span class="n">sge</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="cm">/* If there are more pending skbs, we use the hardware to schedule us</span>
<span class="cm">	 * again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">F_CMDQ0_ENABLE</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_DOORBELL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sched_skb ret %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PIO to indicate that memory mapped Q contains valid descriptor(s).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">doorbell_pio</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_DOORBELL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Frees all RX buffers on the freelist Q. The caller must make sure that</span>
<span class="cm"> * the SGE is turned off before calling this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_freelQ_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">freelQ</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cidx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">freelQ_ce</span> <span class="o">*</span><span class="n">ce</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">[</span><span class="n">cidx</span><span class="p">];</span>

		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">),</span>
				 <span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">),</span>
				 <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
			<span class="n">cidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free RX free list and response queue resources.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">respQ_e</span><span class="p">)</span> <span class="o">*</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">entries</span><span class="p">,</span>
				    <span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_FREELQ_N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">freelQ</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_freelQ_buffers</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">freelQ_e</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span>
					    <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocates basic RX resources, consisting of memory mapped freelist Qs and a</span>
<span class="cm"> * response queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_params</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_FREELQ_N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">freelQ</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">freelQ_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_offset</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">rx_pkt_pad</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">NET_IP_ALIGN</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">freelQ_e</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_no_mem</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">freelQ_ce</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_no_mem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the buffer sizes for the two free lists.  FL0 accommodates</span>
<span class="cm">	 * regular sized Ethernet frames, FL1 is sized not to exceed 16K,</span>
<span class="cm">	 * including all the sk_buff overhead.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: For T2 FL0 and FL1 are reversed.</span>
<span class="cm">	 */</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="o">!</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">jumbo_fl</span><span class="p">].</span><span class="n">rx_buffer_size</span> <span class="o">=</span> <span class="n">SGE_RX_SM_BUF_SIZE</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpl_rx_data</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="o">!</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">jumbo_fl</span><span class="p">].</span><span class="n">dma_offset</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">-</span>
		    <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span><span class="p">));</span>

	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">jumbo_fl</span><span class="p">].</span><span class="n">rx_buffer_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup which skb recycle Q should be used when recycling buffers from</span>
<span class="cm">	 * each free list.</span>
<span class="cm">	 */</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="o">!</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">jumbo_fl</span><span class="p">].</span><span class="n">recycleq_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">jumbo_fl</span><span class="p">].</span><span class="n">recycleq_idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">genbit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">SGE_RESPQ_E_N</span><span class="p">;</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">credits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">respQ_e</span><span class="p">)</span> <span class="o">*</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span>
		<span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">entries</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_no_mem</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_no_mem:</span>
	<span class="n">free_rx_resources</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reclaims n TX descriptors and frees the buffers associated with them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_cmdQ_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmdQ_ce</span> <span class="o">*</span><span class="n">ce</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cidx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">ce</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">[</span><span class="n">cidx</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">),</span>
					 <span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">),</span>
					 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sop</span><span class="p">)</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">sop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">sop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ce</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ce</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">=</span> <span class="n">cidx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free TX resources.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumes that SGE is stopped and all interrupts are disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_CMDQ_N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">)</span>
				<span class="n">free_cmdQ_buffers</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmdQ_e</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span>
					    <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocates basic TX resources, consisting of memory mapped command Qs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_params</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_CMDQ_N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">sop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">cmdQ_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cleaned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">stop_thres</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmdQ_e</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_no_mem</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmdQ_ce</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_no_mem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * CommandQ 0 handles Ethernet and TOE packets, while queue 1 is TOE</span>
<span class="cm">	 * only.  For queue 0 set the stop threshold so we can handle one more</span>
<span class="cm">	 * packet from each port, plus reserve an additional 24 entries for</span>
<span class="cm">	 * Ethernet packets only.  Queue 1 never suspends nor do we reserve</span>
<span class="cm">	 * space for Ethernet packets.</span>
<span class="cm">	 */</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">stop_thres</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">*</span>
		<span class="p">(</span><span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_no_mem:</span>
	<span class="n">free_tx_resources</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_ring_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base_reg_lo</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">base_reg_hi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size_reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">base_reg_lo</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">base_reg_hi</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">size_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable/disable VLAN acceleration.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t1_vlan_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">sge_control</span> <span class="o">|=</span> <span class="n">F_VLAN_XTRACT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">sge_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">F_VLAN_XTRACT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">open_device_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">sge_control</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_CONTROL</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_CONTROL</span><span class="p">);</span>   <span class="cm">/* flush */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Programs the various SGE registers. However, the engine is not yet enabled,</span>
<span class="cm"> * but sge-&gt;sge_control is setup and ready to go.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">configure_sge</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_params</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_CONTROL</span><span class="p">);</span>
	<span class="n">setup_ring_params</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
			  <span class="n">A_SG_CMD0BASELWR</span><span class="p">,</span> <span class="n">A_SG_CMD0BASEUPR</span><span class="p">,</span> <span class="n">A_SG_CMD0SIZE</span><span class="p">);</span>
	<span class="n">setup_ring_params</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
			  <span class="n">A_SG_CMD1BASELWR</span><span class="p">,</span> <span class="n">A_SG_CMD1BASEUPR</span><span class="p">,</span> <span class="n">A_SG_CMD1SIZE</span><span class="p">);</span>
	<span class="n">setup_ring_params</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">,</span>
			  <span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">,</span> <span class="n">A_SG_FL0BASELWR</span><span class="p">,</span>
			  <span class="n">A_SG_FL0BASEUPR</span><span class="p">,</span> <span class="n">A_SG_FL0SIZE</span><span class="p">);</span>
	<span class="n">setup_ring_params</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">,</span>
			  <span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">,</span> <span class="n">A_SG_FL1BASELWR</span><span class="p">,</span>
			  <span class="n">A_SG_FL1BASEUPR</span><span class="p">,</span> <span class="n">A_SG_FL1SIZE</span><span class="p">);</span>

	<span class="cm">/* The threshold comparison uses &lt;. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">SGE_RX_SM_BUF_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_FLTHRESHOLD</span><span class="p">);</span>

	<span class="n">setup_ring_params</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
			  <span class="n">A_SG_RSPBASELWR</span><span class="p">,</span> <span class="n">A_SG_RSPBASEUPR</span><span class="p">,</span> <span class="n">A_SG_RSPSIZE</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_RSPQUEUECREDIT</span><span class="p">);</span>

	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">sge_control</span> <span class="o">=</span> <span class="n">F_CMDQ0_ENABLE</span> <span class="o">|</span> <span class="n">F_CMDQ1_ENABLE</span> <span class="o">|</span> <span class="n">F_FL0_ENABLE</span> <span class="o">|</span>
		<span class="n">F_FL1_ENABLE</span> <span class="o">|</span> <span class="n">F_CPL_ENABLE</span> <span class="o">|</span> <span class="n">F_RESPONSE_QUEUE_ENABLE</span> <span class="o">|</span>
		<span class="n">V_CMDQ_PRIORITY</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">F_DISABLE_CMDQ1_GTS</span> <span class="o">|</span> <span class="n">F_ISCSI_COALESCE</span> <span class="o">|</span>
		<span class="n">V_RX_PKT_OFFSET</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">rx_pkt_pad</span><span class="p">);</span>

<span class="cp">#if defined(__BIG_ENDIAN_BITFIELD)</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">sge_control</span> <span class="o">|=</span> <span class="n">F_ENABLE_BIG_ENDIAN</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Initialize no-resource timer */</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">intrtimer_nres</span> <span class="o">=</span> <span class="n">SGE_INTRTIMER_NRES</span> <span class="o">*</span> <span class="n">core_ticks_per_usec</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">t1_sge_set_coalesce_params</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the payload capacity of the jumbo free-list buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">jumbo_payload_capacity</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">jumbo_fl</span><span class="p">].</span><span class="n">rx_buffer_size</span> <span class="o">-</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">jumbo_fl</span><span class="p">].</span><span class="n">dma_offset</span> <span class="o">-</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpl_rx_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Frees all SGE related resources and the sge structure itself</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t1_sge_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_port</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">free_percpu</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_sched</span><span class="p">);</span>
	<span class="n">free_tx_resources</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>
	<span class="n">free_rx_resources</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocates new RX buffers on the freelist Q (and tracks them on the freelist</span>
<span class="cm"> * context Q) until the Q is full or alloc_skb fails.</span>
<span class="cm"> *</span>
<span class="cm"> * It is possible that the generation bits already match, indicating that the</span>
<span class="cm"> * buffer is already valid and nothing needs to be done. This happens when we</span>
<span class="cm"> * copied a received buffer into a new sk_buff during the interrupt processing.</span>
<span class="cm"> *</span>
<span class="cm"> * If the SGE doesn&#39;t automatically align packets properly (!sge-&gt;rx_pkt_pad),</span>
<span class="cm"> * we specify a RX_OFFSET in order to make sure that the IP header is 4B</span>
<span class="cm"> * aligned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">refill_free_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="k">struct</span> <span class="n">freelQ</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">freelQ_ce</span> <span class="o">*</span><span class="n">ce</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">freelQ_e</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dma_len</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_offset</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rx_buffer_size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_offset</span><span class="p">);</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">,</span>
					 <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">rx_pkt_pad</span><span class="p">);</span>

		<span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
		<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">);</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">mapping</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">mapping</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">len_gen</span> <span class="o">=</span> <span class="n">V_CMD_LEN</span><span class="p">(</span><span class="n">dma_len</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_CMD_GEN1</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span><span class="p">);</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">gen2</span> <span class="o">=</span> <span class="n">V_CMD_GEN2</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span><span class="p">);</span>

		<span class="n">e</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ce</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ce</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">;</span>
			<span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calls refill_free_list for both free lists. If we cannot fill at least 1/4</span>
<span class="cm"> * of both rings, we go into &#39;few interrupt mode&#39; in order to give the system</span>
<span class="cm"> * time to free up resources.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">freelQs_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irq_reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_INT_ENABLE</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">irqholdoff_reg</span><span class="p">;</span>

	<span class="n">refill_free_list</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">refill_free_list</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">credits</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">credits</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">irq_reg</span> <span class="o">|=</span> <span class="n">F_FL_EXHAUSTED</span><span class="p">;</span>
		<span class="n">irqholdoff_reg</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">fixed_intrtimer</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Clear the F_FL_EXHAUSTED interrupts for now */</span>
		<span class="n">irq_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">F_FL_EXHAUSTED</span><span class="p">;</span>
		<span class="n">irqholdoff_reg</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">intrtimer_nres</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">irqholdoff_reg</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_INTRTIMER</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">irq_reg</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_INT_ENABLE</span><span class="p">);</span>

	<span class="cm">/* We reenable the Qs to force a freelist GTS interrupt later */</span>
	<span class="n">doorbell_pio</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">F_FL0_ENABLE</span> <span class="o">|</span> <span class="n">F_FL1_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define SGE_PL_INTR_MASK (F_PL_INTR_SGE_ERR | F_PL_INTR_SGE_DATA)</span>
<span class="cp">#define SGE_INT_FATAL (F_RESPQ_OVERFLOW | F_PACKET_TOO_BIG | F_PACKET_MISMATCH)</span>
<span class="cp">#define SGE_INT_ENABLE (F_RESPQ_EXHAUSTED | F_RESPQ_OVERFLOW | \</span>
<span class="cp">			F_FL_EXHAUSTED | F_PACKET_TOO_BIG | F_PACKET_MISMATCH)</span>

<span class="cm">/*</span>
<span class="cm"> * Disable SGE Interrupts</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t1_sge_intr_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_PL_ENABLE</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SGE_PL_INTR_MASK</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_PL_ENABLE</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_INT_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable SGE interrupts.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t1_sge_intr_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">en</span> <span class="o">=</span> <span class="n">SGE_INT_ENABLE</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_PL_ENABLE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_TSO</span><span class="p">)</span>
		<span class="n">en</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">F_PACKET_TOO_BIG</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">en</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_INT_ENABLE</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span> <span class="o">|</span> <span class="n">SGE_PL_INTR_MASK</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_PL_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear SGE interrupts.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t1_sge_intr_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">SGE_PL_INTR_MASK</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_PL_CAUSE</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_INT_CAUSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SGE &#39;Error&#39; interrupt handler</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">t1_sge_intr_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cause</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_INT_CAUSE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_TSO</span><span class="p">)</span>
		<span class="n">cause</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">F_PACKET_TOO_BIG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">&amp;</span> <span class="n">F_RESPQ_EXHAUSTED</span><span class="p">)</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">respQ_empty</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">&amp;</span> <span class="n">F_RESPQ_OVERFLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">respQ_overflow</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;%s: SGE response queue overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">&amp;</span> <span class="n">F_FL_EXHAUSTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">freelistQ_empty</span><span class="o">++</span><span class="p">;</span>
		<span class="n">freelQs_empty</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">&amp;</span> <span class="n">F_PACKET_TOO_BIG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">pkt_too_big</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;%s: SGE max packet size exceeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">&amp;</span> <span class="n">F_PACKET_MISMATCH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">pkt_mismatch</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;%s: SGE packet mismatch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">&amp;</span> <span class="n">SGE_INT_FATAL</span><span class="p">)</span>
		<span class="n">t1_fatal_err</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">cause</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_INT_CAUSE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">sge_intr_counts</span> <span class="o">*</span><span class="nf">t1_sge_get_intr_counts</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">t1_sge_get_port_stats</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">sge_port_stats</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="p">));</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sge_port_stats</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">port</span><span class="p">],</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">rx_cso_good</span> <span class="o">+=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">rx_cso_good</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx_cso</span> <span class="o">+=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">tx_cso</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx_tso</span> <span class="o">+=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">tx_tso</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">tx_need_hdrroom</span> <span class="o">+=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">tx_need_hdrroom</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">vlan_xtract</span> <span class="o">+=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">vlan_xtract</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">vlan_insert</span> <span class="o">+=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">vlan_insert</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	recycle_fl_buf - recycle a free list buffer</span>
<span class="cm"> *	@fl: the free list</span>
<span class="cm"> *	@idx: index of buffer to recycle</span>
<span class="cm"> *</span>
<span class="cm"> *	Recycles the specified buffer on the given free list by adding it at</span>
<span class="cm"> *	the next available slot on the list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">recycle_fl_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">freelQ</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">freelQ_e</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">freelQ_e</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">];</span>

	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">[</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">addr_lo</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">addr_hi</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">len_gen</span> <span class="o">=</span> <span class="n">G_CMD_LEN</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">len_gen</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_CMD_GEN1</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">genbit</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">gen2</span> <span class="o">=</span> <span class="n">V_CMD_GEN2</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">genbit</span><span class="p">);</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">credits</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">==</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">genbit</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">copybreak</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">copybreak</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">copybreak</span><span class="p">,</span> <span class="s">&quot;Receive copy threshold&quot;</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	get_packet - return the next ingress packet buffer</span>
<span class="cm"> *	@pdev: the PCI device that received the packet</span>
<span class="cm"> *	@fl: the SGE free list holding the packet</span>
<span class="cm"> *	@len: the actual packet length, excluding any SGE padding</span>
<span class="cm"> *</span>
<span class="cm"> *	Get the next packet from a free list and complete setup of the</span>
<span class="cm"> *	sk_buff.  If the packet is small we make a copy and recycle the</span>
<span class="cm"> *	original buffer, otherwise we use the original buffer itself.  If a</span>
<span class="cm"> *	positive drop threshold is supplied packets are dropped and their</span>
<span class="cm"> *	buffers recycled if (a) the number of remaining buffers is under the</span>
<span class="cm"> *	threshold and the packet is too big to copy, or (b) the packet should</span>
<span class="cm"> *	be copied but there is no memory for the copy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">get_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">freelQ</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">freelQ_ce</span> <span class="o">*</span><span class="n">ce</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">[</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">copybreak</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">use_orig_buf</span><span class="p">;</span>

		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* align IP header */</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
					    <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">),</span>
					    <span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">),</span>
					    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
					       <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">),</span>
					       <span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">),</span>
					       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">recycle_fl_buf</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">use_orig_buf:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">recycle_fl_buf</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">),</span>
			 <span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">),</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	unexpected_offload - handle an unexpected offload packet</span>
<span class="cm"> *	@adapter: the adapter</span>
<span class="cm"> *	@fl: the free list that received the packet</span>
<span class="cm"> *</span>
<span class="cm"> *	Called when we receive an unexpected offload packet (e.g., the TOE</span>
<span class="cm"> *	function is disabled or the card is a NIC).  Prints a message and</span>
<span class="cm"> *	recycles the buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unexpected_offload</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">freelQ</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">freelQ_ce</span> <span class="o">*</span><span class="n">ce</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">[</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">),</span>
			    <span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">),</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: unexpected offload packet, cmd %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">recycle_fl_buf</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * T1/T2 SGE limits the maximum DMA size per TX descriptor to</span>
<span class="cm"> * SGE_TX_DESC_MAX_PLEN (16KB). If the PAGE_SIZE is larger than 16KB, the</span>
<span class="cm"> * stack might send more than SGE_TX_DESC_MAX_PLEN in a contiguous manner.</span>
<span class="cm"> * Note that the *_large_page_tx_descs stuff will be optimized out when</span>
<span class="cm"> * PAGE_SIZE &lt;= SGE_TX_DESC_MAX_PLEN.</span>
<span class="cm"> *</span>
<span class="cm"> * compute_large_page_descs() computes how many additional descriptors are</span>
<span class="cm"> * required to break down the stack&#39;s request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">compute_large_page_tx_descs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&gt;</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfrags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nfrags</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
				<span class="n">len</span> <span class="o">-=</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write a cmdQ entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Since this function writes the &#39;flags&#39; field, it must not be used to</span>
<span class="cm"> * write the first cmdQ entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_tx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmdQ_e</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">);</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">mapping</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">len_gen</span> <span class="o">=</span> <span class="n">V_CMD_LEN</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_CMD_GEN1</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">F_CMD_DATAVALID</span> <span class="o">|</span> <span class="n">V_CMD_EOP</span><span class="p">(</span><span class="n">eop</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_CMD_GEN2</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See comment for previous function.</span>
<span class="cm"> *</span>
<span class="cm"> * write_tx_descs_large_page() writes additional SGE tx descriptors if</span>
<span class="cm"> * *desc_len exceeds HW&#39;s capability.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">write_large_page_tx_descs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">cmdQ_e</span> <span class="o">**</span><span class="n">e</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">cmdQ_ce</span> <span class="o">**</span><span class="n">ce</span><span class="p">,</span>
						     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">gen</span><span class="p">,</span>
						     <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">desc_mapping</span><span class="p">,</span>
						     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">desc_len</span><span class="p">,</span>
						     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfrags</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&gt;</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cmdQ_e</span> <span class="o">*</span><span class="n">e1</span> <span class="o">=</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cmdQ_ce</span> <span class="o">*</span><span class="n">ce1</span> <span class="o">=</span> <span class="o">*</span><span class="n">ce</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">desc_len</span> <span class="o">&gt;</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">desc_len</span> <span class="o">-=</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">;</span>
			<span class="n">write_tx_desc</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="o">*</span><span class="n">desc_mapping</span><span class="p">,</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">,</span>
				      <span class="o">*</span><span class="n">gen</span><span class="p">,</span> <span class="n">nfrags</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">desc_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ce1</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="n">ce1</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="o">*</span><span class="n">desc_mapping</span> <span class="o">+=</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">desc_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ce1</span><span class="o">++</span><span class="p">;</span>
				<span class="n">e1</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="o">*</span><span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">ce1</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">;</span>
					<span class="n">e1</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">e1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ce</span> <span class="o">=</span> <span class="n">ce1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pidx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write the command descriptors to transmit the given skb starting at</span>
<span class="cm"> * descriptor pidx with the given generation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_tx_descs</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">desc_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmdQ_e</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">e1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmdQ_ce</span> <span class="o">*</span><span class="n">ce</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">first_desc_len</span><span class="p">,</span> <span class="n">desc_len</span><span class="p">,</span>
	    <span class="n">nfrags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">e1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
	<span class="n">ce</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
				 <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>

	<span class="n">desc_mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
	<span class="n">desc_len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">F_CMD_DATAVALID</span> <span class="o">|</span> <span class="n">F_CMD_SOP</span> <span class="o">|</span>
	    <span class="n">V_CMD_EOP</span><span class="p">(</span><span class="n">nfrags</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">desc_len</span> <span class="o">&lt;=</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">)</span> <span class="o">|</span>
	    <span class="n">V_CMD_GEN2</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
	<span class="n">first_desc_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">desc_len</span> <span class="o">&lt;=</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">)</span> <span class="o">?</span>
	    <span class="n">desc_len</span> <span class="o">:</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">desc_mapping</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">desc_mapping</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">len_gen</span> <span class="o">=</span> <span class="n">V_CMD_LEN</span><span class="p">(</span><span class="n">first_desc_len</span><span class="p">)</span> <span class="o">|</span> <span class="n">V_CMD_GEN1</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
	<span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&gt;</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span> <span class="o">&amp;&amp;</span>
	    <span class="n">desc_len</span> <span class="o">&gt;</span> <span class="n">SGE_TX_DESC_MAX_PLEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc_mapping</span> <span class="o">+=</span> <span class="n">first_desc_len</span><span class="p">;</span>
		<span class="n">desc_len</span> <span class="o">-=</span> <span class="n">first_desc_len</span><span class="p">;</span>
		<span class="n">e1</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ce</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">e1</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
			<span class="n">ce</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pidx</span> <span class="o">=</span> <span class="n">write_large_page_tx_descs</span><span class="p">(</span><span class="n">pidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gen</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">desc_mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc_len</span><span class="p">,</span>
						 <span class="n">nfrags</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">desc_len</span><span class="p">))</span>
			<span class="n">write_tx_desc</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">desc_mapping</span><span class="p">,</span> <span class="n">desc_len</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span>
				      <span class="n">nfrags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
	<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nfrags</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">e1</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ce</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">gen</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">e1</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
			<span class="n">ce</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mapping</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">desc_mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
		<span class="n">desc_len</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>

		<span class="n">pidx</span> <span class="o">=</span> <span class="n">write_large_page_tx_descs</span><span class="p">(</span><span class="n">pidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gen</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">desc_mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc_len</span><span class="p">,</span>
						 <span class="n">nfrags</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">desc_len</span><span class="p">))</span>
			<span class="n">write_tx_desc</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">desc_mapping</span><span class="p">,</span> <span class="n">desc_len</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span>
				      <span class="n">nfrags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
		<span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ce</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean up completed Tx buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reclaim_completed_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reclaim</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cleaned</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reclaim</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;reclaim_completed_tx processed:%d cleaned:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">q</span><span class="o">-&gt;</span><span class="n">processed</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cleaned</span><span class="p">);</span>
		<span class="n">free_cmdQ_buffers</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">reclaim</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">cleaned</span> <span class="o">+=</span> <span class="n">reclaim</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from tasklet. Checks the scheduler for any</span>
<span class="cm"> * pending skbs that can be sent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">restart_sched</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">credits</span><span class="p">,</span> <span class="n">queued_skb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">reclaim_completed_tx</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

	<span class="n">credits</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;restart_sched credits=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">credits</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">sched_skb</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">credits</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">genbit</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	        <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">compute_large_page_tx_descs</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">genbit</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span><span class="p">;</span>
		<span class="n">pidx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">-=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">write_tx_descs</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">genbit</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	        <span class="n">credits</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">;</span>
		<span class="n">queued_skb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queued_skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">F_CMDQ0_ENABLE</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_DOORBELL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sge_rx - process an ingress ethernet packet</span>
<span class="cm"> *	@sge: the sge structure</span>
<span class="cm"> *	@fl: the free list that contains the packet buffer</span>
<span class="cm"> *	@len: the packet length</span>
<span class="cm"> *</span>
<span class="cm"> *	Process an ingress ethernet pakcet and deliver it to the stack.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sge_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="k">struct</span> <span class="n">freelQ</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpl_rx_pkt</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_port_stats</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">get_packet</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">rx_pkt_pad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_drops</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpl_rx_pkt</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">iff</span> <span class="o">&gt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">));</span>

	<span class="n">st</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">iff</span><span class="p">]);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">iff</span><span class="p">].</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">==</span> <span class="mh">0xffff</span> <span class="o">&amp;&amp;</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rx_cso_good</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">vlan_valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">vlan_xtract</span><span class="o">++</span><span class="p">;</span>
		<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">vlan</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns true if a command queue has enough available descriptors that</span>
<span class="cm"> * we can resume Tx operation after temporarily disabling its packet queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">enough_free_Tx_descs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cleaned</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">-</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when sufficient space has become available in the SGE command queues</span>
<span class="cm"> * after the Tx packet schedulers have been suspended to restart the Tx path.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">restart_tx_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enough_free_Tx_descs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">nd</span> <span class="o">=</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">if_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">stopped_tx_queues</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">netif_running</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cmdQ_restarted</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update_tx_info is called from the interrupt handler/NAPI to return cmdQ0</span>
<span class="cm"> * information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">update_tx_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pr0</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">cmdq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">cmdq</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">+=</span> <span class="n">pr0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">F_FL0_ENABLE</span> <span class="o">|</span> <span class="n">F_FL1_ENABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">freelQs_empty</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">F_FL0_ENABLE</span> <span class="o">|</span> <span class="n">F_FL1_ENABLE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_CMDQ0_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmdq</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmdq</span><span class="o">-&gt;</span><span class="n">cleaned</span> <span class="o">+</span> <span class="n">cmdq</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">!=</span> <span class="n">cmdq</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmdq</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmdq</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">F_CMDQ0_ENABLE</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_DOORBELL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_sched</span><span class="p">)</span>
			<span class="n">tasklet_hi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_sched</span><span class="o">-&gt;</span><span class="n">sched_tsk</span><span class="p">);</span>

		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">F_CMDQ0_ENABLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">stopped_tx_queues</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">restart_tx_queues</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process SGE responses, up to the supplied budget.  Returns the number of</span>
<span class="cm"> * responses processed.  A negative budget is effectively unlimited.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_responses</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">respQ</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">respQ_e</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmdq_processed</span><span class="p">[</span><span class="n">SGE_CMDQ_N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">done</span> <span class="o">&lt;</span> <span class="n">budget</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">GenerationBit</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Qsleeping</span><span class="p">;</span>

		<span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Cmdq0CreditReturn</span><span class="p">;</span>
		<span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Cmdq1CreditReturn</span><span class="p">;</span>

		<span class="cm">/* We batch updates to the TX side to avoid cacheline</span>
<span class="cm">		 * ping-pong of TX state information on MP where the sender</span>
<span class="cm">		 * might run on a different CPU than this function...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_CMDQ0_ENABLE</span><span class="p">)</span> <span class="o">||</span> <span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">update_tx_info</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">processed</span> <span class="o">+=</span> <span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">DataValid</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">freelQ</span> <span class="o">*</span><span class="n">fl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">FreelistQid</span><span class="p">];</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">Sop</span> <span class="o">||</span> <span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">Eop</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">Offload</span><span class="p">))</span>
				<span class="n">unexpected_offload</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">sge_rx</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">BufferLength</span><span class="p">);</span>

			<span class="o">++</span><span class="n">done</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Note: this depends on each packet consuming a</span>
<span class="cm">			 * single free-list buffer; cf. the BUG above.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">==</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
				<span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">prefetch</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">[</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">].</span><span class="n">skb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">--</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">&lt;</span>
				     <span class="n">fl</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">SGE_FREEL_REFILL_THRESH</span><span class="p">))</span>
				<span class="n">refill_free_list</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">pure_rsps</span><span class="o">++</span><span class="p">;</span>

		<span class="n">e</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">&gt;</span> <span class="n">SGE_RESPQ_REPLENISH_THRES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_RSPQUEUECREDIT</span><span class="p">);</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">update_tx_info</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">processed</span> <span class="o">+=</span> <span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">responses_pending</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">respQ</span> <span class="o">*</span><span class="n">Q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">respQ_e</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">Q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">GenerationBit</span> <span class="o">==</span> <span class="n">Q</span><span class="o">-&gt;</span><span class="n">genbit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A simpler version of process_responses() that handles only pure (i.e.,</span>
<span class="cm"> * non data-carrying) responses.  Such respones are too light-weight to justify</span>
<span class="cm"> * calling a softirq when using NAPI, so we handle them specially in hard</span>
<span class="cm"> * interrupt context.  The function is called with a pointer to a response,</span>
<span class="cm"> * which the caller must ensure is a valid pure response.  Returns 1 if it</span>
<span class="cm"> * encounters a valid data-carrying response, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_pure_responses</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">respQ</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">respQ_e</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">freelQ</span> <span class="o">*</span><span class="n">fl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">FreelistQid</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmdq_processed</span><span class="p">[</span><span class="n">SGE_CMDQ_N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

	<span class="n">prefetch</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">centries</span><span class="p">[</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">cidx</span><span class="p">].</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">DataValid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Qsleeping</span><span class="p">;</span>

		<span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Cmdq0CreditReturn</span><span class="p">;</span>
		<span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Cmdq1CreditReturn</span><span class="p">;</span>

		<span class="n">e</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">cidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">&gt;</span> <span class="n">SGE_RESPQ_REPLENISH_THRES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_RSPQUEUECREDIT</span><span class="p">);</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">pure_rsps</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">GenerationBit</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">DataValid</span><span class="p">);</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">update_tx_info</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">processed</span> <span class="o">+=</span> <span class="n">cmdq_processed</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">GenerationBit</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handler for new data events when using NAPI.  This does not need any locking</span>
<span class="cm"> * or protection from interrupts as data interrupts are off at this point and</span>
<span class="cm"> * other adapter interrupts do not interfere.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">t1_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">adapter</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">work_done</span> <span class="o">=</span> <span class="n">process_responses</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">cidx</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_SLEEPING</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">t1_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">handled</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">responses_pending</span><span class="p">(</span><span class="n">adapter</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">F_PL_INTR_SGE_DATA</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_PL_CAUSE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">process_pure_responses</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
				<span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* no data, no NAPI needed */</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">respQ</span><span class="p">.</span><span class="n">cidx</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_SLEEPING</span><span class="p">);</span>
				<span class="cm">/* undo schedule_prep */</span>
				<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">async_lock</span><span class="p">);</span>
	<span class="n">handled</span> <span class="o">=</span> <span class="n">t1_slow_intr_handler</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">async_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handled</span><span class="p">)</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">unhandled_irqs</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enqueues the sk_buff onto the cmdQ[qid] and has hardware fetch it.</span>
<span class="cm"> *</span>
<span class="cm"> * The code figures out how many entries the sk_buff will require in the</span>
<span class="cm"> * cmdQ and updates the cmdQ data structure with the state once the enqueue</span>
<span class="cm"> * has complete. Then, it doesn&#39;t access the global structure anymore, but</span>
<span class="cm"> * uses the corresponding fields on the stack. In conjunction with a spinlock</span>
<span class="cm"> * around that code, we can make the function reentrant without holding the</span>
<span class="cm"> * lock when we actually enqueue (which might be expensive, especially on</span>
<span class="cm"> * architectures with IO MMUs).</span>
<span class="cm"> *</span>
<span class="cm"> * This runs with softirqs disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">t1_sge_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="n">qid</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">credits</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">genbit</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">use_sched_skb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_LOCKED</span><span class="p">;</span>

	<span class="n">reclaim_completed_tx</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

	<span class="n">pidx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">;</span>
	<span class="n">credits</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">+=</span> <span class="n">compute_large_page_tx_descs</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Ethernet packet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">credits</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">stopped_tx_queues</span><span class="p">);</span>
			<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cmdQ_full</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Tx ring full while queue awake!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">credits</span> <span class="o">-</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">stop_thres</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">stopped_tx_queues</span><span class="p">);</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cmdQ_full</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* T204 cmdQ0 skbs that are destined for a certain port have to go</span>
<span class="cm">	 * through the scheduler.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_sched</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">qid</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">use_sched:</span>
		<span class="n">use_sched_skb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Note that the scheduler might return a different skb than</span>
<span class="cm">		 * the one passed in.</span>
<span class="cm">		 */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">sched_skb</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">credits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pidx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">compute_large_page_tx_descs</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">genbit</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span><span class="p">;</span>
	<span class="n">pidx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">pidx</span> <span class="o">-=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">genbit</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">write_tx_descs</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">genbit</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We always ring the doorbell for cmdQ1.  For cmdQ0, we only ring</span>
<span class="cm">	 * the doorbell if the Q is asleep. There is a natural race, where</span>
<span class="cm">	 * the hardware is going to sleep just after we checked, however,</span>
<span class="cm">	 * then the interrupt handler will detect the outstanding TX packet</span>
<span class="cm">	 * and ring the doorbell for us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qid</span><span class="p">)</span>
		<span class="n">doorbell_pio</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">F_CMDQ1_ENABLE</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">CMDQ_STAT_LAST_PKT_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">F_CMDQ0_ENABLE</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_DOORBELL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_sched_skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">credits</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">;</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">use_sched</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MK_ETH_TYPE_MSS(type, mss) (((mss) &amp; 0x3FFF) | ((type) &lt;&lt; 14))</span>

<span class="cm">/*</span>
<span class="cm"> *	eth_hdr_len - return the length of an Ethernet header</span>
<span class="cm"> *	@data: pointer to the start of the Ethernet header</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns the length of an Ethernet header, including optional VLAN tag.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">eth_hdr_len</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">h_proto</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">)</span> <span class="o">?</span> <span class="n">VLAN_ETH_HLEN</span> <span class="o">:</span> <span class="n">ETH_HLEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Adds the CPL header to the sk_buff and passes it to t1_sge_tx.</span>
<span class="cm"> */</span>
<span class="n">netdev_tx_t</span> <span class="nf">t1_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge_port_stats</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span><span class="p">]);</span>
	<span class="k">struct</span> <span class="n">cpl_tx_pkt</span> <span class="o">*</span><span class="n">cpl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">orig_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_CPL5</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">send</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are using a non-standard hard_header_len.</span>
<span class="cm">	 * Allocate more header room in the rare cases it is not big enough.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span> <span class="o">-</span> <span class="n">ETH_HLEN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_realloc_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpl_tx_pkt_lso</span><span class="p">));</span>
		<span class="o">++</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">tx_need_hdrroom</span><span class="p">;</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">orig_skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">eth_type</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cpl_tx_pkt_lso</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>

		<span class="o">++</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">tx_tso</span><span class="p">;</span>

		<span class="n">eth_type</span> <span class="o">=</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="n">ETH_HLEN</span> <span class="o">?</span>
			<span class="n">CPL_ETH_II</span> <span class="o">:</span> <span class="n">CPL_ETH_II_VLAN</span><span class="p">;</span>

		<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpl_tx_pkt_lso</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">CPL_TX_PKT_LSO</span><span class="p">;</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">ip_csum_dis</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">l4_csum_dis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">ip_hdr_words</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">;</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">tcp_hdr_words</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">doff</span><span class="p">;</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">eth_type_mss</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">MK_ETH_TYPE_MSS</span><span class="p">(</span><span class="n">eth_type</span><span class="p">,</span>
							  <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">));</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
		<span class="n">cpl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpl_tx_pkt</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Packets shorter than ETH_HLEN can break the MAC, drop them</span>
<span class="cm">		 * early.  Also, we may get oversized packets because some</span>
<span class="cm">		 * parts of the kernel don&#39;t handle our unusual hard_header_len</span>
<span class="cm">		 * right, drop those too.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ETH_HLEN</span> <span class="o">||</span>
			     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">eth_hdr_len</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: packet size %d hdr %d mtu%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">eth_hdr_len</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_checksum_help</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: unable to do udp checksum</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Hmmm, assuming to catch the gratious arp... and we&#39;ll use</span>
<span class="cm">		 * it to flush out stuck espi packets...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_skb</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span><span class="p">])))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_ARP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">arp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ar_op</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REQUEST</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_skb</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
				<span class="cm">/* We want to re-use this skb later. We</span>
<span class="cm">				 * simply bump the reference count and it</span>
<span class="cm">				 * will not be freed...</span>
<span class="cm">				 */</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">cpl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpl_tx_pkt</span> <span class="o">*</span><span class="p">)</span><span class="n">__skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cpl</span><span class="p">));</span>
		<span class="n">cpl</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">CPL_TX_PKT</span><span class="p">;</span>
		<span class="n">cpl</span><span class="o">-&gt;</span><span class="n">ip_csum_dis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* SW calculates IP csum */</span>
		<span class="n">cpl</span><span class="o">-&gt;</span><span class="n">l4_csum_dis</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* the length field isn&#39;t used so don&#39;t bother setting it */</span>

		<span class="n">st</span><span class="o">-&gt;</span><span class="n">tx_cso</span> <span class="o">+=</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cpl</span><span class="o">-&gt;</span><span class="n">iff</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpl</span><span class="o">-&gt;</span><span class="n">vlan_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cpl</span><span class="o">-&gt;</span><span class="n">vlan</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">vlan_insert</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cpl</span><span class="o">-&gt;</span><span class="n">vlan_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">send:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">t1_sge_tx</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">adapter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* If transmit busy, and we reallocated skb&#39;s due to headroom limit,</span>
<span class="cm">	 * then silently discard to avoid leak.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">NETDEV_TX_OK</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span> <span class="o">!=</span> <span class="n">orig_skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback for the Tx buffer reclaim timer.  Runs with softirqs disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sge_tx_reclaim_cb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SGE_CMDQ_N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cmdQ</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">cmdQ</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">reclaim_completed_tx</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">)</span> <span class="p">{</span>    <span class="cm">/* flush pending credits */</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">F_CMDQ0_ENABLE</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_DOORBELL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">TX_RECLAIM_PERIOD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Propagate changes of the SGE coalescing parameters to the HW.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">t1_sge_set_coalesce_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_params</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">fixed_intrtimer</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span> <span class="o">*</span>
		<span class="n">core_ticks_per_usec</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">fixed_intrtimer</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_INTRTIMER</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocates both RX and TX resources and configures the SGE. However,</span>
<span class="cm"> * the hardware is not enabled yet.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">t1_sge_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sge_params</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_rx_resources</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_tx_resources</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_rx_resources</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">configure_sge</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that we have sized the free lists calculate the payload</span>
<span class="cm">	 * capacity of the large buffers.  Other parts of the driver use</span>
<span class="cm">	 * this to set the max offload coalescing size so that RX packets</span>
<span class="cm">	 * do not overflow our large buffers.</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">large_buf_capacity</span> <span class="o">=</span> <span class="n">jumbo_payload_capacity</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disables the DMA engine.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t1_sge_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_CONTROL</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_CONTROL</span><span class="p">);</span> <span class="cm">/* flush */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_T2</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">))</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timer</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_sched</span><span class="p">)</span>
		<span class="n">tx_sched_stop</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NPORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_skb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enables the DMA engine.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">t1_sge_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">refill_free_list</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">refill_free_list</span><span class="p">(</span><span class="n">sge</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">freelQ</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">sge_control</span><span class="p">,</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_CONTROL</span><span class="p">);</span>
	<span class="n">doorbell_pio</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">F_FL0_ENABLE</span> <span class="o">|</span> <span class="n">F_FL1_ENABLE</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">A_SG_CONTROL</span><span class="p">);</span> <span class="cm">/* flush */</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">TX_RECLAIM_PERIOD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_T2</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback for the T2 ESPI &#39;stuck packet feature&#39; workaorund</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">espibug_workaround_t204</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nports</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seop</span><span class="p">[</span><span class="n">MAX_NPORTS</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">open_device_map</span> <span class="o">&amp;</span> <span class="n">PORT_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t1_espi_get_mon_t204</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">seop</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_skb</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">seop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="p">((</span><span class="n">seop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">skb</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
						    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpl_tx_pkt</span><span class="p">),</span>
							       <span class="n">ch_mac_addr</span><span class="p">,</span>
							       <span class="n">ETH_ALEN</span><span class="p">);</span>
				<span class="n">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
							       <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">10</span><span class="p">,</span>
							       <span class="n">ch_mac_addr</span><span class="p">,</span>
							       <span class="n">ETH_ALEN</span><span class="p">);</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* bump the reference count to avoid freeing of</span>
<span class="cm">			 * the skb once the DMA has completed.</span>
<span class="cm">			 */</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">t1_sge_tx</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">adapter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">espibug_workaround</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
	        <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_skb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	        <span class="n">u32</span> <span class="n">seop</span> <span class="o">=</span> <span class="n">t1_espi_get_mon</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mh">0x930</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	        <span class="k">if</span> <span class="p">((</span><span class="n">seop</span> <span class="o">&amp;</span> <span class="mh">0xfff0fff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xfff</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
	                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	                        <span class="n">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
						     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpl_tx_pkt</span><span class="p">),</span>
							       <span class="n">ch_mac_addr</span><span class="p">,</span>
							       <span class="n">ETH_ALEN</span><span class="p">);</span>
	                        <span class="n">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
							       <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">10</span><span class="p">,</span>
							       <span class="n">ch_mac_addr</span><span class="p">,</span>
							       <span class="n">ETH_ALEN</span><span class="p">);</span>
	                        <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	                <span class="p">}</span>

	                <span class="cm">/* bump the reference count to avoid freeing of the</span>
<span class="cm">	                 * skb once the DMA has completed.</span>
<span class="cm">	                 */</span>
	                <span class="n">skb</span> <span class="o">=</span> <span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	                <span class="n">t1_sge_tx</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">adapter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dev</span><span class="p">);</span>
	        <span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Creates a t1_sge structure and returns suggested resource parameters.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span> <span class="n">__devinit</span> <span class="nf">t1_sge_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sge_params</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sge</span> <span class="o">*</span><span class="n">sge</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sge</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sge</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">rx_pkt_pad</span> <span class="o">=</span> <span class="n">t1_is_T1B</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">jumbo_fl</span> <span class="o">=</span> <span class="n">t1_is_T1B</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_port</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sge_port_stats</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">nomem_port</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">);</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sge</span><span class="p">;</span>
	<span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_reclaim_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">sge_tx_reclaim_cb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_T2</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timer</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_sched_init</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>
			<span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">espibug_workaround_t204</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">espibug_workaround</span><span class="p">;</span>
		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

		<span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timeout</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* for T204, every 10ms */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">nports</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">sge</span><span class="o">-&gt;</span><span class="n">espibug_timeout</span> <span class="o">=</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">100</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">p</span><span class="o">-&gt;</span><span class="n">cmdQ_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SGE_CMDQ0_E_N</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">cmdQ_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">SGE_CMDQ1_E_N</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">freelQ_size</span><span class="p">[</span><span class="o">!</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">jumbo_fl</span><span class="p">]</span> <span class="o">=</span> <span class="n">SGE_FREEL_SIZE</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">freelQ_size</span><span class="p">[</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">jumbo_fl</span><span class="p">]</span> <span class="o">=</span> <span class="n">SGE_JUMBO_FREEL_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">tx_sched</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">board_info</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">board</span> <span class="o">==</span> <span class="n">CHBT_BOARD_CHT204</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">rx_coalesce_usecs</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">coalesce_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sample_interval_usecs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sge</span><span class="p">;</span>
<span class="nl">nomem_port:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_percpu</span><span class="p">(</span><span class="n">sge</span><span class="o">-&gt;</span><span class="n">port_stats</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="o">--</span><span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sge</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
